(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./Container", "./Utils/Constants", "../Utils/NumberUtils", "../Utils/Utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Loader = void 0;
    const Container_1 = require("./Container");
    const Constants_1 = require("./Utils/Constants");
    const NumberUtils_1 = require("../Utils/NumberUtils");
    const Utils_1 = require("../Utils/Utils");
    function fetchError(statusCode) {
        console.error(`tsParticles - Error ${statusCode} while retrieving config file`);
    }
    async function getDataFromUrl(jsonUrl, index) {
        const url = (0, Utils_1.itemFromSingleOrMultiple)(jsonUrl, index);
        if (!url) {
            return;
        }
        const response = await fetch(url);
        if (response.ok) {
            return response.json();
        }
        fetchError(response.status);
    }
    class Loader {
        constructor(engine) {
            this._engine = engine;
        }
        load(tagId, options, index) {
            const params = { index, remote: false };
            if (typeof tagId === "string") {
                params.tagId = tagId;
            }
            else {
                params.options = tagId;
            }
            if (typeof options === "number") {
                params.index = options;
            }
            else {
                params.options = options !== null && options !== void 0 ? options : params.options;
            }
            return this.loadOptions(params);
        }
        async loadJSON(tagId, jsonUrl, index) {
            let url, id;
            if (typeof jsonUrl === "number" || jsonUrl === undefined) {
                url = tagId;
            }
            else {
                id = tagId;
                url = jsonUrl;
            }
            return this.loadRemoteOptions({ tagId: id, url, index, remote: true });
        }
        async loadOptions(params) {
            var _a, _b, _c;
            const tagId = (_a = params.tagId) !== null && _a !== void 0 ? _a : `tsparticles${Math.floor((0, NumberUtils_1.getRandom)() * 10000)}`, { index, url: jsonUrl, remote } = params, options = remote ? await getDataFromUrl(jsonUrl, index) : params.options;
            let domContainer = (_b = params.element) !== null && _b !== void 0 ? _b : document.getElementById(tagId);
            if (!domContainer) {
                domContainer = document.createElement("div");
                domContainer.id = tagId;
                (_c = document.querySelector("body")) === null || _c === void 0 ? void 0 : _c.append(domContainer);
            }
            const currentOptions = (0, Utils_1.itemFromSingleOrMultiple)(options, index), dom = this._engine.dom(), oldIndex = dom.findIndex((v) => v.id === tagId);
            if (oldIndex >= 0) {
                const old = this._engine.domItem(oldIndex);
                if (old && !old.destroyed) {
                    old.destroy();
                    dom.splice(oldIndex, 1);
                }
            }
            let canvasEl;
            if (domContainer.tagName.toLowerCase() === "canvas") {
                canvasEl = domContainer;
                canvasEl.dataset[Constants_1.generatedAttribute] = "false";
            }
            else {
                const existingCanvases = domContainer.getElementsByTagName("canvas");
                if (existingCanvases.length) {
                    canvasEl = existingCanvases[0];
                    canvasEl.dataset[Constants_1.generatedAttribute] = "false";
                }
                else {
                    canvasEl = document.createElement("canvas");
                    canvasEl.dataset[Constants_1.generatedAttribute] = "true";
                    domContainer.appendChild(canvasEl);
                }
            }
            if (!canvasEl.style.width) {
                canvasEl.style.width = "100%";
            }
            if (!canvasEl.style.height) {
                canvasEl.style.height = "100%";
            }
            const newItem = new Container_1.Container(this._engine, tagId, currentOptions);
            if (oldIndex >= 0) {
                dom.splice(oldIndex, 0, newItem);
            }
            else {
                dom.push(newItem);
            }
            newItem.canvas.loadCanvas(canvasEl);
            await newItem.start();
            return newItem;
        }
        async loadRemoteOptions(params) {
            return this.loadOptions(params);
        }
        async set(id, domContainer, options, index) {
            const params = { index, remote: false };
            if (typeof id === "string") {
                params.tagId = id;
            }
            else {
                params.element = id;
            }
            if (domContainer instanceof HTMLElement) {
                params.element = domContainer;
            }
            else {
                params.options = domContainer;
            }
            if (typeof options === "number") {
                params.index = options;
            }
            else {
                params.options = options !== null && options !== void 0 ? options : params.options;
            }
            return this.loadOptions(params);
        }
        async setJSON(id, domContainer, jsonUrl, index) {
            let url, newId, newIndex, element;
            if (id instanceof HTMLElement) {
                element = id;
                url = domContainer;
                newIndex = jsonUrl;
            }
            else {
                newId = id;
                element = domContainer;
                url = jsonUrl;
                newIndex = index;
            }
            return this.loadRemoteOptions({ tagId: newId, url, index: newIndex, element, remote: true });
        }
    }
    exports.Loader = Loader;
});
