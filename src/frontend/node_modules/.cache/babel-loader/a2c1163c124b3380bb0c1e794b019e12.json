{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _declaration = require('./declaration');\n\nvar _declaration2 = _interopRequireDefault(_declaration);\n\nvar _tokenize = require('./tokenize');\n\nvar _tokenize2 = _interopRequireDefault(_tokenize);\n\nvar _comment = require('./comment');\n\nvar _comment2 = _interopRequireDefault(_comment);\n\nvar _atRule = require('./at-rule');\n\nvar _atRule2 = _interopRequireDefault(_atRule);\n\nvar _root = require('./root');\n\nvar _root2 = _interopRequireDefault(_root);\n\nvar _rule = require('./rule');\n\nvar _rule2 = _interopRequireDefault(_rule);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Parser = function () {\n  function Parser(input) {\n    _classCallCheck(this, Parser);\n\n    this.input = input;\n    this.root = new _root2.default();\n    this.current = this.root;\n    this.spaces = '';\n    this.semicolon = false;\n    this.createTokenizer();\n    this.root.source = {\n      input: input,\n      start: {\n        line: 1,\n        column: 1\n      }\n    };\n  }\n\n  Parser.prototype.createTokenizer = function createTokenizer() {\n    this.tokenizer = (0, _tokenize2.default)(this.input);\n  };\n\n  Parser.prototype.parse = function parse() {\n    var token = void 0;\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1];\n          break;\n\n        case ';':\n          this.freeSemicolon(token);\n          break;\n\n        case '}':\n          this.end(token);\n          break;\n\n        case 'comment':\n          this.comment(token);\n          break;\n\n        case 'at-word':\n          this.atrule(token);\n          break;\n\n        case '{':\n          this.emptyRule(token);\n          break;\n\n        default:\n          this.other(token);\n          break;\n      }\n    }\n\n    this.endFile();\n  };\n\n  Parser.prototype.comment = function comment(token) {\n    var node = new _comment2.default();\n    this.init(node, token[2], token[3]);\n    node.source.end = {\n      line: token[4],\n      column: token[5]\n    };\n    var text = token[1].slice(2, -2);\n\n    if (/^\\s*$/.test(text)) {\n      node.text = '';\n      node.raws.left = text;\n      node.raws.right = '';\n    } else {\n      var match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n      node.text = match[2];\n      node.raws.left = match[1];\n      node.raws.right = match[3];\n    }\n  };\n\n  Parser.prototype.emptyRule = function emptyRule(token) {\n    var node = new _rule2.default();\n    this.init(node, token[2], token[3]);\n    node.selector = '';\n    node.raws.between = '';\n    this.current = node;\n  };\n\n  Parser.prototype.other = function other(start) {\n    var end = false;\n    var type = null;\n    var colon = false;\n    var bracket = null;\n    var brackets = [];\n    var tokens = [];\n    var token = start;\n\n    while (token) {\n      type = token[0];\n      tokens.push(token);\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token;\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens);\n            return;\n          } else {\n            break;\n          }\n        } else if (type === '{') {\n          this.rule(tokens);\n          return;\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop());\n          end = true;\n          break;\n        } else if (type === ':') {\n          colon = true;\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n        if (brackets.length === 0) bracket = null;\n      }\n\n      token = this.tokenizer.nextToken();\n    }\n\n    if (this.tokenizer.endOfFile()) end = true;\n    if (brackets.length > 0) this.unclosedBracket(bracket);\n\n    if (end && colon) {\n      while (tokens.length) {\n        token = tokens[tokens.length - 1][0];\n        if (token !== 'space' && token !== 'comment') break;\n        this.tokenizer.back(tokens.pop());\n      }\n\n      this.decl(tokens);\n      return;\n    } else {\n      this.unknownWord(tokens);\n    }\n  };\n\n  Parser.prototype.rule = function rule(tokens) {\n    tokens.pop();\n    var node = new _rule2.default();\n    this.init(node, tokens[0][2], tokens[0][3]);\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n    this.raw(node, 'selector', tokens);\n    this.current = node;\n  };\n\n  Parser.prototype.decl = function decl(tokens) {\n    var node = new _declaration2.default();\n    this.init(node);\n    var last = tokens[tokens.length - 1];\n\n    if (last[0] === ';') {\n      this.semicolon = true;\n      tokens.pop();\n    }\n\n    if (last[4]) {\n      node.source.end = {\n        line: last[4],\n        column: last[5]\n      };\n    } else {\n      node.source.end = {\n        line: last[2],\n        column: last[3]\n      };\n    }\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens);\n      node.raws.before += tokens.shift()[1];\n    }\n\n    node.source.start = {\n      line: tokens[0][2],\n      column: tokens[0][3]\n    };\n    node.prop = '';\n\n    while (tokens.length) {\n      var type = tokens[0][0];\n\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break;\n      }\n\n      node.prop += tokens.shift()[1];\n    }\n\n    node.raws.between = '';\n    var token = void 0;\n\n    while (tokens.length) {\n      token = tokens.shift();\n\n      if (token[0] === ':') {\n        node.raws.between += token[1];\n        break;\n      } else {\n        node.raws.between += token[1];\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0];\n      node.prop = node.prop.slice(1);\n    }\n\n    node.raws.between += this.spacesAndCommentsFromStart(tokens);\n    this.precheckMissedSemicolon(tokens);\n\n    for (var i = tokens.length - 1; i > 0; i--) {\n      token = tokens[i];\n\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true;\n        var string = this.stringFrom(tokens, i);\n        string = this.spacesFromEnd(tokens) + string;\n        if (string !== ' !important') node.raws.important = string;\n        break;\n      } else if (token[1].toLowerCase() === 'important') {\n        var cache = tokens.slice(0);\n        var str = '';\n\n        for (var j = i; j > 0; j--) {\n          var _type = cache[j][0];\n\n          if (str.trim().indexOf('!') === 0 && _type !== 'space') {\n            break;\n          }\n\n          str = cache.pop()[1] + str;\n        }\n\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true;\n          node.raws.important = str;\n          tokens = cache;\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break;\n      }\n    }\n\n    this.raw(node, 'value', tokens);\n    if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);\n  };\n\n  Parser.prototype.atrule = function atrule(token) {\n    var node = new _atRule2.default();\n    node.name = token[1].slice(1);\n\n    if (node.name === '') {\n      this.unnamedAtrule(node, token);\n    }\n\n    this.init(node, token[2], token[3]);\n    var prev = void 0;\n    var shift = void 0;\n    var last = false;\n    var open = false;\n    var params = [];\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n\n      if (token[0] === ';') {\n        node.source.end = {\n          line: token[2],\n          column: token[3]\n        };\n        this.semicolon = true;\n        break;\n      } else if (token[0] === '{') {\n        open = true;\n        break;\n      } else if (token[0] === '}') {\n        if (params.length > 0) {\n          shift = params.length - 1;\n          prev = params[shift];\n\n          while (prev && prev[0] === 'space') {\n            prev = params[--shift];\n          }\n\n          if (prev) {\n            node.source.end = {\n              line: prev[4],\n              column: prev[5]\n            };\n          }\n        }\n\n        this.end(token);\n        break;\n      } else {\n        params.push(token);\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true;\n        break;\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params);\n\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params);\n      this.raw(node, 'params', params);\n\n      if (last) {\n        token = params[params.length - 1];\n        node.source.end = {\n          line: token[4],\n          column: token[5]\n        };\n        this.spaces = node.raws.between;\n        node.raws.between = '';\n      }\n    } else {\n      node.raws.afterName = '';\n      node.params = '';\n    }\n\n    if (open) {\n      node.nodes = [];\n      this.current = node;\n    }\n  };\n\n  Parser.prototype.end = function end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.semicolon = false;\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    this.spaces = '';\n\n    if (this.current.parent) {\n      this.current.source.end = {\n        line: token[2],\n        column: token[3]\n      };\n      this.current = this.current.parent;\n    } else {\n      this.unexpectedClose(token);\n    }\n  };\n\n  Parser.prototype.endFile = function endFile() {\n    if (this.current.parent) this.unclosedBlock();\n\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n  };\n\n  Parser.prototype.freeSemicolon = function freeSemicolon(token) {\n    this.spaces += token[1];\n\n    if (this.current.nodes) {\n      var prev = this.current.nodes[this.current.nodes.length - 1];\n\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces;\n        this.spaces = '';\n      }\n    }\n  }; // Helpers\n\n\n  Parser.prototype.init = function init(node, line, column) {\n    this.current.push(node);\n    node.source = {\n      start: {\n        line: line,\n        column: column\n      },\n      input: this.input\n    };\n    node.raws.before = this.spaces;\n    this.spaces = '';\n    if (node.type !== 'comment') this.semicolon = false;\n  };\n\n  Parser.prototype.raw = function raw(node, prop, tokens) {\n    var token = void 0,\n        type = void 0;\n    var length = tokens.length;\n    var value = '';\n    var clean = true;\n    var next = void 0,\n        prev = void 0;\n    var pattern = /^([.|#])?([\\w])+/i;\n\n    for (var i = 0; i < length; i += 1) {\n      token = tokens[i];\n      type = token[0];\n\n      if (type === 'comment' && node.type === 'rule') {\n        prev = tokens[i - 1];\n        next = tokens[i + 1];\n\n        if (prev[0] !== 'space' && next[0] !== 'space' && pattern.test(prev[1]) && pattern.test(next[1])) {\n          value += token[1];\n        } else {\n          clean = false;\n        }\n\n        continue;\n      }\n\n      if (type === 'comment' || type === 'space' && i === length - 1) {\n        clean = false;\n      } else {\n        value += token[1];\n      }\n    }\n\n    if (!clean) {\n      var raw = tokens.reduce(function (all, i) {\n        return all + i[1];\n      }, '');\n      node.raws[prop] = {\n        value: value,\n        raw: raw\n      };\n    }\n\n    node[prop] = value;\n  };\n\n  Parser.prototype.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n    var lastTokenType = void 0;\n    var spaces = '';\n\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n\n    return spaces;\n  };\n\n  Parser.prototype.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n    var next = void 0;\n    var spaces = '';\n\n    while (tokens.length) {\n      next = tokens[0][0];\n      if (next !== 'space' && next !== 'comment') break;\n      spaces += tokens.shift()[1];\n    }\n\n    return spaces;\n  };\n\n  Parser.prototype.spacesFromEnd = function spacesFromEnd(tokens) {\n    var lastTokenType = void 0;\n    var spaces = '';\n\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n\n    return spaces;\n  };\n\n  Parser.prototype.stringFrom = function stringFrom(tokens, from) {\n    var result = '';\n\n    for (var i = from; i < tokens.length; i++) {\n      result += tokens[i][1];\n    }\n\n    tokens.splice(from, tokens.length - from);\n    return result;\n  };\n\n  Parser.prototype.colon = function colon(tokens) {\n    var brackets = 0;\n    var token = void 0,\n        type = void 0,\n        prev = void 0;\n\n    for (var i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n      type = token[0];\n\n      if (type === '(') {\n        brackets += 1;\n      } else if (type === ')') {\n        brackets -= 1;\n      } else if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token);\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue;\n        } else {\n          return i;\n        }\n      }\n\n      prev = token;\n    }\n\n    return false;\n  }; // Errors\n\n\n  Parser.prototype.unclosedBracket = function unclosedBracket(bracket) {\n    throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);\n  };\n\n  Parser.prototype.unknownWord = function unknownWord(tokens) {\n    throw this.input.error('Unknown word', tokens[0][2], tokens[0][3]);\n  };\n\n  Parser.prototype.unexpectedClose = function unexpectedClose(token) {\n    throw this.input.error('Unexpected }', token[2], token[3]);\n  };\n\n  Parser.prototype.unclosedBlock = function unclosedBlock() {\n    var pos = this.current.source.start;\n    throw this.input.error('Unclosed block', pos.line, pos.column);\n  };\n\n  Parser.prototype.doubleColon = function doubleColon(token) {\n    throw this.input.error('Double colon', token[2], token[3]);\n  };\n\n  Parser.prototype.unnamedAtrule = function unnamedAtrule(node, token) {\n    throw this.input.error('At-rule without name', token[2], token[3]);\n  };\n\n  Parser.prototype.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {\n    // Hook for Safe Parser\n    tokens;\n  };\n\n  Parser.prototype.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n    var colon = this.colon(tokens);\n    if (colon === false) return;\n    var founded = 0;\n    var token = void 0;\n\n    for (var j = colon - 1; j >= 0; j--) {\n      token = tokens[j];\n\n      if (token[0] !== 'space') {\n        founded += 1;\n        if (founded === 2) break;\n      }\n    }\n\n    throw this.input.error('Missed semicolon', token[2], token[3]);\n  };\n\n  return Parser;\n}();\n\nexports.default = Parser;\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["Parser","input","_classCallCheck","root","Root","current","spaces","semicolon","createTokenizer","source","start","line","column","tokenizer","parse","token","endOfFile","nextToken","freeSemicolon","end","comment","atrule","emptyRule","other","endFile","node","Comment","init","text","slice","test","raws","left","right","match","Rule","selector","between","type","colon","bracket","brackets","tokens","push","length","decl","rule","back","pop","unclosedBracket","unknownWord","spacesAndCommentsFromEnd","raw","Declaration","last","before","shift","prop","spacesAndCommentsFromStart","precheckMissedSemicolon","i","toLowerCase","important","string","stringFrom","spacesFromEnd","cache","str","j","trim","indexOf","value","checkMissedSemicolon","AtRule","name","unnamedAtrule","prev","open","params","afterName","nodes","after","parent","unexpectedClose","unclosedBlock","ownSemicolon","clean","next","pattern","reduce","all","lastTokenType","from","result","splice","doubleColon","error","pos","founded"],"sources":["parser.es6"],"sourcesContent":["import Declaration from './declaration';\nimport tokenizer   from './tokenize';\nimport Comment     from './comment';\nimport AtRule      from './at-rule';\nimport Root        from './root';\nimport Rule        from './rule';\n\nexport default class Parser {\n\n    constructor(input) {\n        this.input = input;\n\n        this.root      = new Root();\n        this.current   = this.root;\n        this.spaces    = '';\n        this.semicolon = false;\n\n        this.createTokenizer();\n        this.root.source = { input, start: { line: 1, column: 1 } };\n    }\n\n    createTokenizer() {\n        this.tokenizer = tokenizer(this.input);\n    }\n\n    parse() {\n        let token;\n        while ( !this.tokenizer.endOfFile() ) {\n            token = this.tokenizer.nextToken();\n\n            switch ( token[0] ) {\n\n            case 'space':\n                this.spaces += token[1];\n                break;\n\n            case ';':\n                this.freeSemicolon(token);\n                break;\n\n            case '}':\n                this.end(token);\n                break;\n\n            case 'comment':\n                this.comment(token);\n                break;\n\n            case 'at-word':\n                this.atrule(token);\n                break;\n\n            case '{':\n                this.emptyRule(token);\n                break;\n\n            default:\n                this.other(token);\n                break;\n            }\n        }\n        this.endFile();\n    }\n\n    comment(token) {\n        let node = new Comment();\n        this.init(node, token[2], token[3]);\n        node.source.end = { line: token[4], column: token[5] };\n\n        let text = token[1].slice(2, -2);\n        if ( /^\\s*$/.test(text) ) {\n            node.text       = '';\n            node.raws.left  = text;\n            node.raws.right = '';\n        } else {\n            let match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n            node.text       = match[2];\n            node.raws.left  = match[1];\n            node.raws.right = match[3];\n        }\n    }\n\n    emptyRule(token) {\n        let node = new Rule();\n        this.init(node, token[2], token[3]);\n        node.selector = '';\n        node.raws.between = '';\n        this.current = node;\n    }\n\n    other(start) {\n        let end      = false;\n        let type     = null;\n        let colon    = false;\n        let bracket  = null;\n        let brackets = [];\n\n        let tokens = [];\n        let token = start;\n        while ( token ) {\n            type = token[0];\n            tokens.push(token);\n\n            if ( type === '(' || type === '[' ) {\n                if ( !bracket ) bracket = token;\n                brackets.push(type === '(' ? ')' : ']');\n\n            } else if ( brackets.length === 0 ) {\n                if ( type === ';' ) {\n                    if ( colon ) {\n                        this.decl(tokens);\n                        return;\n                    } else {\n                        break;\n                    }\n\n                } else if ( type === '{' ) {\n                    this.rule(tokens);\n                    return;\n\n                } else if ( type === '}' ) {\n                    this.tokenizer.back(tokens.pop());\n                    end = true;\n                    break;\n\n                } else if ( type === ':' ) {\n                    colon = true;\n                }\n\n            } else if ( type === brackets[brackets.length - 1] ) {\n                brackets.pop();\n                if ( brackets.length === 0 ) bracket = null;\n            }\n\n            token = this.tokenizer.nextToken();\n        }\n\n        if ( this.tokenizer.endOfFile() ) end = true;\n        if ( brackets.length > 0 ) this.unclosedBracket(bracket);\n\n        if ( end && colon ) {\n            while ( tokens.length ) {\n                token = tokens[tokens.length - 1][0];\n                if ( token !== 'space' && token !== 'comment' ) break;\n                this.tokenizer.back(tokens.pop());\n            }\n            this.decl(tokens);\n            return;\n        } else {\n            this.unknownWord(tokens);\n        }\n    }\n\n    rule(tokens) {\n        tokens.pop();\n\n        let node = new Rule();\n        this.init(node, tokens[0][2], tokens[0][3]);\n\n        node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n        this.raw(node, 'selector', tokens);\n        this.current = node;\n    }\n\n    decl(tokens) {\n        let node = new Declaration();\n        this.init(node);\n\n        let last = tokens[tokens.length - 1];\n        if ( last[0] === ';' ) {\n            this.semicolon = true;\n            tokens.pop();\n        }\n        if ( last[4] ) {\n            node.source.end = { line: last[4], column: last[5] };\n        } else {\n            node.source.end = { line: last[2], column: last[3] };\n        }\n\n        while ( tokens[0][0] !== 'word' ) {\n            if ( tokens.length === 1 ) this.unknownWord(tokens);\n            node.raws.before += tokens.shift()[1];\n        }\n        node.source.start = { line: tokens[0][2], column: tokens[0][3] };\n\n        node.prop = '';\n        while ( tokens.length ) {\n            let type = tokens[0][0];\n            if ( type === ':' || type === 'space' || type === 'comment' ) {\n                break;\n            }\n            node.prop += tokens.shift()[1];\n        }\n\n        node.raws.between = '';\n\n        let token;\n        while ( tokens.length ) {\n            token = tokens.shift();\n\n            if ( token[0] === ':' ) {\n                node.raws.between += token[1];\n                break;\n            } else {\n                node.raws.between += token[1];\n            }\n        }\n\n        if ( node.prop[0] === '_' || node.prop[0] === '*' ) {\n            node.raws.before += node.prop[0];\n            node.prop = node.prop.slice(1);\n        }\n        node.raws.between += this.spacesAndCommentsFromStart(tokens);\n        this.precheckMissedSemicolon(tokens);\n\n        for ( let i = tokens.length - 1; i > 0; i-- ) {\n            token = tokens[i];\n            if ( token[1].toLowerCase() === '!important' ) {\n                node.important = true;\n                let string = this.stringFrom(tokens, i);\n                string = this.spacesFromEnd(tokens) + string;\n                if ( string !== ' !important' ) node.raws.important = string;\n                break;\n\n            } else if (token[1].toLowerCase() === 'important') {\n                let cache = tokens.slice(0);\n                let str   = '';\n                for ( let j = i; j > 0; j-- ) {\n                    let type = cache[j][0];\n                    if ( str.trim().indexOf('!') === 0 && type !== 'space' ) {\n                        break;\n                    }\n                    str = cache.pop()[1] + str;\n                }\n                if ( str.trim().indexOf('!') === 0 ) {\n                    node.important = true;\n                    node.raws.important = str;\n                    tokens = cache;\n                }\n            }\n\n            if ( token[0] !== 'space' && token[0] !== 'comment' ) {\n                break;\n            }\n        }\n\n        this.raw(node, 'value', tokens);\n\n        if ( node.value.indexOf(':') !== -1 ) this.checkMissedSemicolon(tokens);\n    }\n\n    atrule(token) {\n        let node  = new AtRule();\n        node.name = token[1].slice(1);\n        if ( node.name === '' ) {\n            this.unnamedAtrule(node, token);\n        }\n        this.init(node, token[2], token[3]);\n\n        let prev;\n        let shift;\n        let last   = false;\n        let open   = false;\n        let params = [];\n\n        while ( !this.tokenizer.endOfFile() ) {\n            token = this.tokenizer.nextToken();\n\n            if ( token[0] === ';' ) {\n                node.source.end = { line: token[2], column: token[3] };\n                this.semicolon = true;\n                break;\n            } else if ( token[0] === '{' ) {\n                open = true;\n                break;\n            } else if ( token[0] === '}') {\n                if ( params.length > 0 ) {\n                    shift = params.length - 1;\n                    prev = params[shift];\n                    while ( prev && prev[0] === 'space' ) {\n                        prev = params[--shift];\n                    }\n                    if ( prev ) {\n                        node.source.end = { line: prev[4], column: prev[5] };\n                    }\n                }\n                this.end(token);\n                break;\n            } else {\n                params.push(token);\n            }\n\n            if ( this.tokenizer.endOfFile() ) {\n                last = true;\n                break;\n            }\n        }\n\n        node.raws.between = this.spacesAndCommentsFromEnd(params);\n        if ( params.length ) {\n            node.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node, 'params', params);\n            if ( last ) {\n                token = params[params.length - 1];\n                node.source.end   = { line: token[4], column: token[5] };\n                this.spaces       = node.raws.between;\n                node.raws.between = '';\n            }\n        } else {\n            node.raws.afterName = '';\n            node.params         = '';\n        }\n\n        if ( open ) {\n            node.nodes   = [];\n            this.current = node;\n        }\n    }\n\n    end(token) {\n        if ( this.current.nodes && this.current.nodes.length ) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.semicolon = false;\n\n        this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n        this.spaces = '';\n\n        if ( this.current.parent ) {\n            this.current.source.end = { line: token[2], column: token[3] };\n            this.current = this.current.parent;\n        } else {\n            this.unexpectedClose(token);\n        }\n    }\n\n    endFile() {\n        if ( this.current.parent ) this.unclosedBlock();\n        if ( this.current.nodes && this.current.nodes.length ) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    }\n\n    freeSemicolon(token) {\n        this.spaces += token[1];\n        if ( this.current.nodes ) {\n            let prev = this.current.nodes[this.current.nodes.length - 1];\n            if ( prev && prev.type === 'rule' && !prev.raws.ownSemicolon ) {\n                prev.raws.ownSemicolon = this.spaces;\n                this.spaces = '';\n            }\n        }\n    }\n\n    // Helpers\n\n    init(node, line, column) {\n        this.current.push(node);\n\n        node.source = { start: { line, column }, input: this.input };\n        node.raws.before = this.spaces;\n        this.spaces = '';\n        if ( node.type !== 'comment' ) this.semicolon = false;\n    }\n\n    raw(node, prop, tokens) {\n        let token, type;\n        let length = tokens.length;\n        let value  = '';\n        let clean  = true;\n        let next, prev;\n        const pattern = /^([.|#])?([\\w])+/i;\n\n        for ( let i = 0; i < length; i += 1 ) {\n            token = tokens[i];\n            type  = token[0];\n\n            if ( type === 'comment' && node.type === 'rule' ) {\n                prev = tokens[i - 1];\n                next = tokens[i + 1];\n\n                if (\n                    prev[0] !== 'space' &&\n                    next[0] !== 'space' &&\n                    pattern.test(prev[1]) &&\n                    pattern.test(next[1])\n                ) {\n                    value += token[1];\n                } else {\n                    clean = false;\n                }\n\n                continue;\n            }\n\n            if ( type === 'comment' || type === 'space' && i === length - 1 ) {\n                clean = false;\n            } else {\n                value += token[1];\n            }\n        }\n        if ( !clean ) {\n            let raw = tokens.reduce( (all, i) => all + i[1], '');\n            node.raws[prop] = { value, raw };\n        }\n        node[prop] = value;\n    }\n\n    spacesAndCommentsFromEnd(tokens) {\n        let lastTokenType;\n        let spaces = '';\n        while ( tokens.length ) {\n            lastTokenType = tokens[tokens.length - 1][0];\n            if ( lastTokenType !== 'space' &&\n                lastTokenType !== 'comment' ) break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    }\n\n    spacesAndCommentsFromStart(tokens) {\n        let next;\n        let spaces = '';\n        while ( tokens.length ) {\n            next = tokens[0][0];\n            if ( next !== 'space' && next !== 'comment' ) break;\n            spaces += tokens.shift()[1];\n        }\n        return spaces;\n    }\n\n    spacesFromEnd(tokens) {\n        let lastTokenType;\n        let spaces = '';\n        while ( tokens.length ) {\n            lastTokenType = tokens[tokens.length - 1][0];\n            if ( lastTokenType !== 'space' ) break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    }\n\n    stringFrom(tokens, from) {\n        let result = '';\n        for ( let i = from; i < tokens.length; i++ ) {\n            result += tokens[i][1];\n        }\n        tokens.splice(from, tokens.length - from);\n        return result;\n    }\n\n    colon(tokens) {\n        let brackets = 0;\n        let token, type, prev;\n        for ( let i = 0; i < tokens.length; i++ ) {\n            token = tokens[i];\n            type  = token[0];\n\n            if ( type === '(' ) {\n                brackets += 1;\n            } else if ( type === ')' ) {\n                brackets -= 1;\n            } else if ( brackets === 0 && type === ':' ) {\n                if ( !prev ) {\n                    this.doubleColon(token);\n                } else if ( prev[0] === 'word' && prev[1] === 'progid' ) {\n                    continue;\n                } else {\n                    return i;\n                }\n            }\n\n            prev = token;\n        }\n        return false;\n    }\n\n    // Errors\n\n    unclosedBracket(bracket) {\n        throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);\n    }\n\n    unknownWord(tokens) {\n        throw this.input.error('Unknown word', tokens[0][2], tokens[0][3]);\n    }\n\n    unexpectedClose(token) {\n        throw this.input.error('Unexpected }', token[2], token[3]);\n    }\n\n    unclosedBlock() {\n        let pos = this.current.source.start;\n        throw this.input.error('Unclosed block', pos.line, pos.column);\n    }\n\n    doubleColon(token) {\n        throw this.input.error('Double colon', token[2], token[3]);\n    }\n\n    unnamedAtrule(node, token) {\n        throw this.input.error('At-rule without name', token[2], token[3]);\n    }\n\n    precheckMissedSemicolon(tokens) {\n        // Hook for Safe Parser\n        tokens;\n    }\n\n    checkMissedSemicolon(tokens) {\n        let colon = this.colon(tokens);\n        if ( colon === false ) return;\n\n        let founded = 0;\n        let token;\n        for ( let j = colon - 1; j >= 0; j-- ) {\n            token = tokens[j];\n            if ( token[0] !== 'space' ) {\n                founded += 1;\n                if ( founded === 2 ) break;\n            }\n        }\n        throw this.input.error('Missed semicolon', token[2], token[3]);\n    }\n\n}\n"]},"metadata":{},"sourceType":"module"}