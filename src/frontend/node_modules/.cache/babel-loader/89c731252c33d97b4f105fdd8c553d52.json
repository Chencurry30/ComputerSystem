{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _declaration = require('./declaration');\n\nvar _declaration2 = _interopRequireDefault(_declaration);\n\nvar _comment = require('./comment');\n\nvar _comment2 = _interopRequireDefault(_comment);\n\nvar _node = require('./node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction cleanSource(nodes) {\n  return nodes.map(function (i) {\n    if (i.nodes) i.nodes = cleanSource(i.nodes);\n    delete i.source;\n    return i;\n  });\n}\n/**\n * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes\n * inherit some common methods to help work with their children.\n *\n * Note that all containers can store any content. If you write a rule inside\n * a rule, PostCSS will parse it.\n *\n * @extends Node\n * @abstract\n */\n\n\nvar Container = function (_Node) {\n  _inherits(Container, _Node);\n\n  function Container() {\n    _classCallCheck(this, Container);\n\n    return _possibleConstructorReturn(this, _Node.apply(this, arguments));\n  }\n\n  Container.prototype.push = function push(child) {\n    child.parent = this;\n    this.nodes.push(child);\n    return this;\n  };\n  /**\n   * Iterates through the container’s immediate children,\n   * calling `callback` for each child.\n   *\n   * Returning `false` in the callback will break iteration.\n   *\n   * This method only iterates through the container’s immediate children.\n   * If you need to recursively iterate through all the container’s descendant\n   * nodes, use {@link Container#walk}.\n   *\n   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe\n   * if you are mutating the array of child nodes during iteration.\n   * PostCSS will adjust the current index to match the mutations.\n   *\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * const root = postcss.parse('a { color: black; z-index: 1 }');\n   * const rule = root.first;\n   *\n   * for ( let decl of rule.nodes ) {\n   *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n   *     // Cycle will be infinite, because cloneBefore moves the current node\n   *     // to the next index\n   * }\n   *\n   * rule.each(decl => {\n   *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n   *     // Will be executed only for color and z-index\n   * });\n   */\n\n\n  Container.prototype.each = function each(callback) {\n    if (!this.lastEach) this.lastEach = 0;\n    if (!this.indexes) this.indexes = {};\n    this.lastEach += 1;\n    var id = this.lastEach;\n    this.indexes[id] = 0;\n    if (!this.nodes) return undefined;\n    var index = void 0,\n        result = void 0;\n\n    while (this.indexes[id] < this.nodes.length) {\n      index = this.indexes[id];\n      result = callback(this.nodes[index], index);\n      if (result === false) break;\n      this.indexes[id] += 1;\n    }\n\n    delete this.indexes[id];\n    return result;\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each node.\n   *\n   * Like container.each(), this method is safe to use\n   * if you are mutating arrays during iteration.\n   *\n   * If you only need to iterate through the container’s immediate children,\n   * use {@link Container#each}.\n   *\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walk(node => {\n   *   // Traverses all descendant nodes.\n   * });\n   */\n\n\n  Container.prototype.walk = function walk(callback) {\n    return this.each(function (child, i) {\n      var result = callback(child, i);\n\n      if (result !== false && child.walk) {\n        result = child.walk(callback);\n      }\n\n      return result;\n    });\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each declaration node.\n   *\n   * If you pass a filter, iteration will only happen over declarations\n   * with matching properties.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [prop]   - string or regular expression\n   *                                   to filter declarations by property name\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walkDecls(decl => {\n   *   checkPropertySupport(decl.prop);\n   * });\n   *\n   * root.walkDecls('border-radius', decl => {\n   *   decl.remove();\n   * });\n   *\n   * root.walkDecls(/^background/, decl => {\n   *   decl.value = takeFirstColorFromGradient(decl.value);\n   * });\n   */\n\n\n  Container.prototype.walkDecls = function walkDecls(prop, callback) {\n    if (!callback) {\n      callback = prop;\n      return this.walk(function (child, i) {\n        if (child.type === 'decl') {\n          return callback(child, i);\n        }\n      });\n    } else if (prop instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'decl' && prop.test(child.prop)) {\n          return callback(child, i);\n        }\n      });\n    } else {\n      return this.walk(function (child, i) {\n        if (child.type === 'decl' && child.prop === prop) {\n          return callback(child, i);\n        }\n      });\n    }\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each rule node.\n   *\n   * If you pass a filter, iteration will only happen over rules\n   * with matching selectors.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [selector] - string or regular expression\n   *                                     to filter rules by selector\n   * @param {childIterator} callback   - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * const selectors = [];\n   * root.walkRules(rule => {\n   *   selectors.push(rule.selector);\n   * });\n   * console.log(`Your CSS uses ${selectors.length} selectors`);\n   */\n\n\n  Container.prototype.walkRules = function walkRules(selector, callback) {\n    if (!callback) {\n      callback = selector;\n      return this.walk(function (child, i) {\n        if (child.type === 'rule') {\n          return callback(child, i);\n        }\n      });\n    } else if (selector instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'rule' && selector.test(child.selector)) {\n          return callback(child, i);\n        }\n      });\n    } else {\n      return this.walk(function (child, i) {\n        if (child.type === 'rule' && child.selector === selector) {\n          return callback(child, i);\n        }\n      });\n    }\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each at-rule node.\n   *\n   * If you pass a filter, iteration will only happen over at-rules\n   * that have matching names.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [name]   - string or regular expression\n   *                                   to filter at-rules by name\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walkAtRules(rule => {\n   *   if ( isOld(rule.name) ) rule.remove();\n   * });\n   *\n   * let first = false;\n   * root.walkAtRules('charset', rule => {\n   *   if ( !first ) {\n   *     first = true;\n   *   } else {\n   *     rule.remove();\n   *   }\n   * });\n   */\n\n\n  Container.prototype.walkAtRules = function walkAtRules(name, callback) {\n    if (!callback) {\n      callback = name;\n      return this.walk(function (child, i) {\n        if (child.type === 'atrule') {\n          return callback(child, i);\n        }\n      });\n    } else if (name instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'atrule' && name.test(child.name)) {\n          return callback(child, i);\n        }\n      });\n    } else {\n      return this.walk(function (child, i) {\n        if (child.type === 'atrule' && child.name === name) {\n          return callback(child, i);\n        }\n      });\n    }\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each comment node.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walkComments(comment => {\n   *   comment.remove();\n   * });\n   */\n\n\n  Container.prototype.walkComments = function walkComments(callback) {\n    return this.walk(function (child, i) {\n      if (child.type === 'comment') {\n        return callback(child, i);\n      }\n    });\n  };\n  /**\n   * Inserts new nodes to the end of the container.\n   *\n   * @param {...(Node|object|string|Node[])} children - new nodes\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n   * rule.append(decl1, decl2);\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n   * root.append({ selector: 'a' });                       // rule\n   * rule.append({ prop: 'color', value: 'black' });       // declaration\n   * rule.append({ text: 'Comment' })                      // comment\n   *\n   * root.append('a {}');\n   * root.first.append('color: black; z-index: 1');\n   */\n\n\n  Container.prototype.append = function append() {\n    for (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {\n      children[_key] = arguments[_key];\n    }\n\n    for (var _iterator = children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var child = _ref;\n      var nodes = this.normalize(child, this.last);\n\n      for (var _iterator2 = nodes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var node = _ref2;\n        this.nodes.push(node);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Inserts new nodes to the start of the container.\n   *\n   * @param {...(Node|object|string|Node[])} children - new nodes\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n   * rule.prepend(decl1, decl2);\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n   * root.append({ selector: 'a' });                       // rule\n   * rule.append({ prop: 'color', value: 'black' });       // declaration\n   * rule.append({ text: 'Comment' })                      // comment\n   *\n   * root.append('a {}');\n   * root.first.append('color: black; z-index: 1');\n   */\n\n\n  Container.prototype.prepend = function prepend() {\n    for (var _len2 = arguments.length, children = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      children[_key2] = arguments[_key2];\n    }\n\n    children = children.reverse();\n\n    for (var _iterator3 = children, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var child = _ref3;\n      var nodes = this.normalize(child, this.first, 'prepend').reverse();\n\n      for (var _iterator4 = nodes, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n        var _ref4;\n\n        if (_isArray4) {\n          if (_i4 >= _iterator4.length) break;\n          _ref4 = _iterator4[_i4++];\n        } else {\n          _i4 = _iterator4.next();\n          if (_i4.done) break;\n          _ref4 = _i4.value;\n        }\n\n        var node = _ref4;\n        this.nodes.unshift(node);\n      }\n\n      for (var id in this.indexes) {\n        this.indexes[id] = this.indexes[id] + nodes.length;\n      }\n    }\n\n    return this;\n  };\n\n  Container.prototype.cleanRaws = function cleanRaws(keepBetween) {\n    _Node.prototype.cleanRaws.call(this, keepBetween);\n\n    if (this.nodes) {\n      for (var _iterator5 = this.nodes, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n        var _ref5;\n\n        if (_isArray5) {\n          if (_i5 >= _iterator5.length) break;\n          _ref5 = _iterator5[_i5++];\n        } else {\n          _i5 = _iterator5.next();\n          if (_i5.done) break;\n          _ref5 = _i5.value;\n        }\n\n        var node = _ref5;\n        node.cleanRaws(keepBetween);\n      }\n    }\n  };\n  /**\n   * Insert new node before old node within the container.\n   *\n   * @param {Node|number} exist             - child or child’s index.\n   * @param {Node|object|string|Node[]} add - new node\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }));\n   */\n\n\n  Container.prototype.insertBefore = function insertBefore(exist, add) {\n    exist = this.index(exist);\n    var type = exist === 0 ? 'prepend' : false;\n    var nodes = this.normalize(add, this.nodes[exist], type).reverse();\n\n    for (var _iterator6 = nodes, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n      var _ref6;\n\n      if (_isArray6) {\n        if (_i6 >= _iterator6.length) break;\n        _ref6 = _iterator6[_i6++];\n      } else {\n        _i6 = _iterator6.next();\n        if (_i6.done) break;\n        _ref6 = _i6.value;\n      }\n\n      var node = _ref6;\n      this.nodes.splice(exist, 0, node);\n    }\n\n    var index = void 0;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (exist <= index) {\n        this.indexes[id] = index + nodes.length;\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Insert new node after old node within the container.\n   *\n   * @param {Node|number} exist             - child or child’s index\n   * @param {Node|object|string|Node[]} add - new node\n   *\n   * @return {Node} this node for methods chain\n   */\n\n\n  Container.prototype.insertAfter = function insertAfter(exist, add) {\n    exist = this.index(exist);\n    var nodes = this.normalize(add, this.nodes[exist]).reverse();\n\n    for (var _iterator7 = nodes, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {\n      var _ref7;\n\n      if (_isArray7) {\n        if (_i7 >= _iterator7.length) break;\n        _ref7 = _iterator7[_i7++];\n      } else {\n        _i7 = _iterator7.next();\n        if (_i7.done) break;\n        _ref7 = _i7.value;\n      }\n\n      var node = _ref7;\n      this.nodes.splice(exist + 1, 0, node);\n    }\n\n    var index = void 0;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (exist < index) {\n        this.indexes[id] = index + nodes.length;\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Removes node from the container and cleans the parent properties\n   * from the node and its children.\n   *\n   * @param {Node|number} child - child or child’s index\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * rule.nodes.length  //=> 5\n   * rule.removeChild(decl);\n   * rule.nodes.length  //=> 4\n   * decl.parent        //=> undefined\n   */\n\n\n  Container.prototype.removeChild = function removeChild(child) {\n    child = this.index(child);\n    this.nodes[child].parent = undefined;\n    this.nodes.splice(child, 1);\n    var index = void 0;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (index >= child) {\n        this.indexes[id] = index - 1;\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Removes all children from the container\n   * and cleans their parent properties.\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * rule.removeAll();\n   * rule.nodes.length //=> 0\n   */\n\n\n  Container.prototype.removeAll = function removeAll() {\n    for (var _iterator8 = this.nodes, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {\n      var _ref8;\n\n      if (_isArray8) {\n        if (_i8 >= _iterator8.length) break;\n        _ref8 = _iterator8[_i8++];\n      } else {\n        _i8 = _iterator8.next();\n        if (_i8.done) break;\n        _ref8 = _i8.value;\n      }\n\n      var node = _ref8;\n      node.parent = undefined;\n    }\n\n    this.nodes = [];\n    return this;\n  };\n  /**\n   * Passes all declaration values within the container that match pattern\n   * through callback, replacing those values with the returned result\n   * of callback.\n   *\n   * This method is useful if you are using a custom unit or function\n   * and need to iterate through all values.\n   *\n   * @param {string|RegExp} pattern      - replace pattern\n   * @param {object} opts                - options to speed up the search\n   * @param {string|string[]} opts.props - an array of property names\n   * @param {string} opts.fast           - string that’s used\n   *                                       to narrow down values and speed up\n                                           the regexp search\n   * @param {function|string} callback   - string to replace pattern\n   *                                       or callback that returns a new\n   *                                       value.\n   *                                       The callback will receive\n   *                                       the same arguments as those\n   *                                       passed to a function parameter\n   *                                       of `String#replace`.\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * root.replaceValues(/\\d+rem/, { fast: 'rem' }, string => {\n   *   return 15 * parseInt(string) + 'px';\n   * });\n   */\n\n\n  Container.prototype.replaceValues = function replaceValues(pattern, opts, callback) {\n    if (!callback) {\n      callback = opts;\n      opts = {};\n    }\n\n    this.walkDecls(function (decl) {\n      if (opts.props && opts.props.indexOf(decl.prop) === -1) return;\n      if (opts.fast && decl.value.indexOf(opts.fast) === -1) return;\n      decl.value = decl.value.replace(pattern, callback);\n    });\n    return this;\n  };\n  /**\n   * Returns `true` if callback returns `true`\n   * for all of the container’s children.\n   *\n   * @param {childCondition} condition - iterator returns true or false.\n   *\n   * @return {boolean} is every child pass condition\n   *\n   * @example\n   * const noPrefixes = rule.every(i => i.prop[0] !== '-');\n   */\n\n\n  Container.prototype.every = function every(condition) {\n    return this.nodes.every(condition);\n  };\n  /**\n   * Returns `true` if callback returns `true` for (at least) one\n   * of the container’s children.\n   *\n   * @param {childCondition} condition - iterator returns true or false.\n   *\n   * @return {boolean} is some child pass condition\n   *\n   * @example\n   * const hasPrefix = rule.some(i => i.prop[0] === '-');\n   */\n\n\n  Container.prototype.some = function some(condition) {\n    return this.nodes.some(condition);\n  };\n  /**\n   * Returns a `child`’s index within the {@link Container#nodes} array.\n   *\n   * @param {Node} child - child of the current container.\n   *\n   * @return {number} child index\n   *\n   * @example\n   * rule.index( rule.nodes[2] ) //=> 2\n   */\n\n\n  Container.prototype.index = function index(child) {\n    if (typeof child === 'number') {\n      return child;\n    } else {\n      return this.nodes.indexOf(child);\n    }\n  };\n  /**\n   * The container’s first child.\n   *\n   * @type {Node}\n   *\n   * @example\n   * rule.first == rules.nodes[0];\n   */\n\n\n  Container.prototype.normalize = function normalize(nodes, sample) {\n    var _this2 = this;\n\n    if (typeof nodes === 'string') {\n      var parse = require('./parse');\n\n      nodes = cleanSource(parse(nodes).nodes);\n    } else if (Array.isArray(nodes)) {\n      nodes = nodes.slice(0);\n\n      for (var _iterator9 = nodes, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {\n        var _ref9;\n\n        if (_isArray9) {\n          if (_i9 >= _iterator9.length) break;\n          _ref9 = _iterator9[_i9++];\n        } else {\n          _i9 = _iterator9.next();\n          if (_i9.done) break;\n          _ref9 = _i9.value;\n        }\n\n        var i = _ref9;\n        if (i.parent) i.parent.removeChild(i, 'ignore');\n      }\n    } else if (nodes.type === 'root') {\n      nodes = nodes.nodes.slice(0);\n\n      for (var _iterator10 = nodes, _isArray10 = Array.isArray(_iterator10), _i11 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {\n        var _ref10;\n\n        if (_isArray10) {\n          if (_i11 >= _iterator10.length) break;\n          _ref10 = _iterator10[_i11++];\n        } else {\n          _i11 = _iterator10.next();\n          if (_i11.done) break;\n          _ref10 = _i11.value;\n        }\n\n        var _i10 = _ref10;\n        if (_i10.parent) _i10.parent.removeChild(_i10, 'ignore');\n      }\n    } else if (nodes.type) {\n      nodes = [nodes];\n    } else if (nodes.prop) {\n      if (typeof nodes.value === 'undefined') {\n        throw new Error('Value field is missed in node creation');\n      } else if (typeof nodes.value !== 'string') {\n        nodes.value = String(nodes.value);\n      }\n\n      nodes = [new _declaration2.default(nodes)];\n    } else if (nodes.selector) {\n      var Rule = require('./rule');\n\n      nodes = [new Rule(nodes)];\n    } else if (nodes.name) {\n      var AtRule = require('./at-rule');\n\n      nodes = [new AtRule(nodes)];\n    } else if (nodes.text) {\n      nodes = [new _comment2.default(nodes)];\n    } else {\n      throw new Error('Unknown node type in node creation');\n    }\n\n    var processed = nodes.map(function (i) {\n      if (typeof i.before !== 'function') i = _this2.rebuild(i);\n      if (i.parent) i.parent.removeChild(i);\n\n      if (typeof i.raws.before === 'undefined') {\n        if (sample && typeof sample.raws.before !== 'undefined') {\n          i.raws.before = sample.raws.before.replace(/[^\\s]/g, '');\n        }\n      }\n\n      i.parent = _this2;\n      return i;\n    });\n    return processed;\n  };\n\n  Container.prototype.rebuild = function rebuild(node, parent) {\n    var _this3 = this;\n\n    var fix = void 0;\n\n    if (node.type === 'root') {\n      var Root = require('./root');\n\n      fix = new Root();\n    } else if (node.type === 'atrule') {\n      var AtRule = require('./at-rule');\n\n      fix = new AtRule();\n    } else if (node.type === 'rule') {\n      var Rule = require('./rule');\n\n      fix = new Rule();\n    } else if (node.type === 'decl') {\n      fix = new _declaration2.default();\n    } else if (node.type === 'comment') {\n      fix = new _comment2.default();\n    }\n\n    for (var i in node) {\n      if (i === 'nodes') {\n        fix.nodes = node.nodes.map(function (j) {\n          return _this3.rebuild(j, fix);\n        });\n      } else if (i === 'parent' && parent) {\n        fix.parent = parent;\n      } else if (node.hasOwnProperty(i)) {\n        fix[i] = node[i];\n      }\n    }\n\n    return fix;\n  };\n  /**\n   * @memberof Container#\n   * @member {Node[]} nodes - an array containing the container’s children\n   *\n   * @example\n   * const root = postcss.parse('a { color: black }');\n   * root.nodes.length           //=> 1\n   * root.nodes[0].selector      //=> 'a'\n   * root.nodes[0].nodes[0].prop //=> 'color'\n   */\n\n\n  _createClass(Container, [{\n    key: 'first',\n    get: function get() {\n      if (!this.nodes) return undefined;\n      return this.nodes[0];\n    }\n    /**\n     * The container’s last child.\n     *\n     * @type {Node}\n     *\n     * @example\n     * rule.last == rule.nodes[rule.nodes.length - 1];\n     */\n\n  }, {\n    key: 'last',\n    get: function get() {\n      if (!this.nodes) return undefined;\n      return this.nodes[this.nodes.length - 1];\n    }\n  }]);\n\n  return Container;\n}(_node2.default);\n\nexports.default = Container;\n/**\n * @callback childCondition\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @param {Node[]} nodes - all container children\n * @return {boolean}\n */\n\n/**\n * @callback childIterator\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @return {false|undefined} returning `false` will break iteration\n */\n\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["cleanSource","nodes","map","i","source","Container","push","child","parent","each","callback","lastEach","indexes","id","undefined","index","result","length","walk","walkDecls","prop","type","RegExp","test","walkRules","selector","walkAtRules","name","walkComments","append","children","arguments","_ref","_i","normalize","last","_ref2","_i2","node","prepend","reverse","_ref3","_i3","first","_ref4","_i4","unshift","cleanRaws","keepBetween","_Node","_ref5","_i5","insertBefore","exist","add","_ref6","_i6","splice","insertAfter","_ref7","_i7","removeChild","removeAll","_ref8","_i8","replaceValues","pattern","opts","props","indexOf","decl","fast","value","replace","every","condition","some","sample","parse","require","Array","isArray","slice","_ref9","_i9","_ref10","_i11","Error","String","Declaration","Rule","AtRule","text","Comment","processed","before","_this2","rebuild","raws","fix","Root","_this3","j","hasOwnProperty","Node"],"sources":["container.es6"],"sourcesContent":["import Declaration from './declaration';\nimport Comment     from './comment';\nimport Node        from './node';\n\nfunction cleanSource(nodes) {\n    return nodes.map( i => {\n        if ( i.nodes ) i.nodes = cleanSource(i.nodes);\n        delete i.source;\n        return i;\n    });\n}\n\n/**\n * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes\n * inherit some common methods to help work with their children.\n *\n * Note that all containers can store any content. If you write a rule inside\n * a rule, PostCSS will parse it.\n *\n * @extends Node\n * @abstract\n */\nclass Container extends Node {\n\n    push(child) {\n        child.parent = this;\n        this.nodes.push(child);\n        return this;\n    }\n\n    /**\n     * Iterates through the container’s immediate children,\n     * calling `callback` for each child.\n     *\n     * Returning `false` in the callback will break iteration.\n     *\n     * This method only iterates through the container’s immediate children.\n     * If you need to recursively iterate through all the container’s descendant\n     * nodes, use {@link Container#walk}.\n     *\n     * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe\n     * if you are mutating the array of child nodes during iteration.\n     * PostCSS will adjust the current index to match the mutations.\n     *\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * const root = postcss.parse('a { color: black; z-index: 1 }');\n     * const rule = root.first;\n     *\n     * for ( let decl of rule.nodes ) {\n     *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n     *     // Cycle will be infinite, because cloneBefore moves the current node\n     *     // to the next index\n     * }\n     *\n     * rule.each(decl => {\n     *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n     *     // Will be executed only for color and z-index\n     * });\n     */\n    each(callback) {\n        if ( !this.lastEach ) this.lastEach = 0;\n        if ( !this.indexes ) this.indexes = { };\n\n        this.lastEach += 1;\n        let id = this.lastEach;\n        this.indexes[id] = 0;\n\n        if ( !this.nodes ) return undefined;\n\n        let index, result;\n        while ( this.indexes[id] < this.nodes.length ) {\n            index  = this.indexes[id];\n            result = callback(this.nodes[index], index);\n            if ( result === false ) break;\n\n            this.indexes[id] += 1;\n        }\n\n        delete this.indexes[id];\n\n        return result;\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each node.\n     *\n     * Like container.each(), this method is safe to use\n     * if you are mutating arrays during iteration.\n     *\n     * If you only need to iterate through the container’s immediate children,\n     * use {@link Container#each}.\n     *\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walk(node => {\n     *   // Traverses all descendant nodes.\n     * });\n     */\n    walk(callback) {\n        return this.each( (child, i) => {\n            let result = callback(child, i);\n            if ( result !== false && child.walk ) {\n                result = child.walk(callback);\n            }\n            return result;\n        });\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each declaration node.\n     *\n     * If you pass a filter, iteration will only happen over declarations\n     * with matching properties.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {string|RegExp} [prop]   - string or regular expression\n     *                                   to filter declarations by property name\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walkDecls(decl => {\n     *   checkPropertySupport(decl.prop);\n     * });\n     *\n     * root.walkDecls('border-radius', decl => {\n     *   decl.remove();\n     * });\n     *\n     * root.walkDecls(/^background/, decl => {\n     *   decl.value = takeFirstColorFromGradient(decl.value);\n     * });\n     */\n    walkDecls(prop, callback) {\n        if ( !callback ) {\n            callback = prop;\n            return this.walk( (child, i) => {\n                if ( child.type === 'decl' ) {\n                    return callback(child, i);\n                }\n            });\n        } else if ( prop instanceof RegExp ) {\n            return this.walk( (child, i) => {\n                if ( child.type === 'decl' && prop.test(child.prop) ) {\n                    return callback(child, i);\n                }\n            });\n        } else {\n            return this.walk( (child, i) => {\n                if ( child.type === 'decl' && child.prop === prop ) {\n                    return callback(child, i);\n                }\n            });\n        }\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each rule node.\n     *\n     * If you pass a filter, iteration will only happen over rules\n     * with matching selectors.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {string|RegExp} [selector] - string or regular expression\n     *                                     to filter rules by selector\n     * @param {childIterator} callback   - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * const selectors = [];\n     * root.walkRules(rule => {\n     *   selectors.push(rule.selector);\n     * });\n     * console.log(`Your CSS uses ${selectors.length} selectors`);\n     */\n    walkRules(selector, callback) {\n        if ( !callback ) {\n            callback = selector;\n\n            return this.walk( (child, i) => {\n                if ( child.type === 'rule' ) {\n                    return callback(child, i);\n                }\n            });\n        } else if ( selector instanceof RegExp ) {\n            return this.walk( (child, i) => {\n                if ( child.type === 'rule' && selector.test(child.selector) ) {\n                    return callback(child, i);\n                }\n            });\n        } else {\n            return this.walk( (child, i) => {\n                if ( child.type === 'rule' && child.selector === selector ) {\n                    return callback(child, i);\n                }\n            });\n        }\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each at-rule node.\n     *\n     * If you pass a filter, iteration will only happen over at-rules\n     * that have matching names.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {string|RegExp} [name]   - string or regular expression\n     *                                   to filter at-rules by name\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walkAtRules(rule => {\n     *   if ( isOld(rule.name) ) rule.remove();\n     * });\n     *\n     * let first = false;\n     * root.walkAtRules('charset', rule => {\n     *   if ( !first ) {\n     *     first = true;\n     *   } else {\n     *     rule.remove();\n     *   }\n     * });\n     */\n    walkAtRules(name, callback) {\n        if ( !callback ) {\n            callback = name;\n            return this.walk( (child, i) => {\n                if ( child.type === 'atrule' ) {\n                    return callback(child, i);\n                }\n            });\n        } else if ( name instanceof RegExp ) {\n            return this.walk( (child, i) => {\n                if ( child.type === 'atrule' && name.test(child.name) ) {\n                    return callback(child, i);\n                }\n            });\n        } else {\n            return this.walk( (child, i) => {\n                if ( child.type === 'atrule' && child.name === name ) {\n                    return callback(child, i);\n                }\n            });\n        }\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each comment node.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walkComments(comment => {\n     *   comment.remove();\n     * });\n     */\n    walkComments(callback) {\n        return this.walk( (child, i) => {\n            if ( child.type === 'comment' ) {\n                return callback(child, i);\n            }\n        });\n    }\n\n    /**\n     * Inserts new nodes to the end of the container.\n     *\n     * @param {...(Node|object|string|Node[])} children - new nodes\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n     * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n     * rule.append(decl1, decl2);\n     *\n     * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n     * root.append({ selector: 'a' });                       // rule\n     * rule.append({ prop: 'color', value: 'black' });       // declaration\n     * rule.append({ text: 'Comment' })                      // comment\n     *\n     * root.append('a {}');\n     * root.first.append('color: black; z-index: 1');\n     */\n    append(...children) {\n        for ( let child of children ) {\n            let nodes = this.normalize(child, this.last);\n            for ( let node of nodes ) this.nodes.push(node);\n        }\n        return this;\n    }\n\n    /**\n     * Inserts new nodes to the start of the container.\n     *\n     * @param {...(Node|object|string|Node[])} children - new nodes\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n     * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n     * rule.prepend(decl1, decl2);\n     *\n     * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n     * root.append({ selector: 'a' });                       // rule\n     * rule.append({ prop: 'color', value: 'black' });       // declaration\n     * rule.append({ text: 'Comment' })                      // comment\n     *\n     * root.append('a {}');\n     * root.first.append('color: black; z-index: 1');\n     */\n    prepend(...children) {\n        children = children.reverse();\n        for ( let child of children ) {\n            let nodes = this.normalize(child, this.first, 'prepend').reverse();\n            for ( let node of nodes ) this.nodes.unshift(node);\n            for ( let id in this.indexes ) {\n                this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n        }\n        return this;\n    }\n\n    cleanRaws(keepBetween) {\n        super.cleanRaws(keepBetween);\n        if ( this.nodes ) {\n            for ( let node of this.nodes ) node.cleanRaws(keepBetween);\n        }\n    }\n\n    /**\n     * Insert new node before old node within the container.\n     *\n     * @param {Node|number} exist             - child or child’s index.\n     * @param {Node|object|string|Node[]} add - new node\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }));\n     */\n    insertBefore(exist, add) {\n        exist = this.index(exist);\n\n        let type  = exist === 0 ? 'prepend' : false;\n        let nodes = this.normalize(add, this.nodes[exist], type).reverse();\n        for ( let node of nodes ) this.nodes.splice(exist, 0, node);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( exist <= index ) {\n                this.indexes[id] = index + nodes.length;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Insert new node after old node within the container.\n     *\n     * @param {Node|number} exist             - child or child’s index\n     * @param {Node|object|string|Node[]} add - new node\n     *\n     * @return {Node} this node for methods chain\n     */\n    insertAfter(exist, add) {\n        exist = this.index(exist);\n\n        let nodes = this.normalize(add, this.nodes[exist]).reverse();\n        for ( let node of nodes ) this.nodes.splice(exist + 1, 0, node);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( exist < index ) {\n                this.indexes[id] = index + nodes.length;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes node from the container and cleans the parent properties\n     * from the node and its children.\n     *\n     * @param {Node|number} child - child or child’s index\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * rule.nodes.length  //=> 5\n     * rule.removeChild(decl);\n     * rule.nodes.length  //=> 4\n     * decl.parent        //=> undefined\n     */\n    removeChild(child) {\n        child = this.index(child);\n        this.nodes[child].parent = undefined;\n        this.nodes.splice(child, 1);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( index >= child ) {\n                this.indexes[id] = index - 1;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes all children from the container\n     * and cleans their parent properties.\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * rule.removeAll();\n     * rule.nodes.length //=> 0\n     */\n    removeAll() {\n        for ( let node of this.nodes ) node.parent = undefined;\n        this.nodes = [];\n        return this;\n    }\n\n    /**\n     * Passes all declaration values within the container that match pattern\n     * through callback, replacing those values with the returned result\n     * of callback.\n     *\n     * This method is useful if you are using a custom unit or function\n     * and need to iterate through all values.\n     *\n     * @param {string|RegExp} pattern      - replace pattern\n     * @param {object} opts                - options to speed up the search\n     * @param {string|string[]} opts.props - an array of property names\n     * @param {string} opts.fast           - string that’s used\n     *                                       to narrow down values and speed up\n                                             the regexp search\n     * @param {function|string} callback   - string to replace pattern\n     *                                       or callback that returns a new\n     *                                       value.\n     *                                       The callback will receive\n     *                                       the same arguments as those\n     *                                       passed to a function parameter\n     *                                       of `String#replace`.\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * root.replaceValues(/\\d+rem/, { fast: 'rem' }, string => {\n     *   return 15 * parseInt(string) + 'px';\n     * });\n     */\n    replaceValues(pattern, opts, callback) {\n        if ( !callback ) {\n            callback = opts;\n            opts = { };\n        }\n\n        this.walkDecls( decl => {\n            if ( opts.props && opts.props.indexOf(decl.prop) === -1 ) return;\n            if ( opts.fast  && decl.value.indexOf(opts.fast) === -1 ) return;\n\n            decl.value = decl.value.replace(pattern, callback);\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns `true` if callback returns `true`\n     * for all of the container’s children.\n     *\n     * @param {childCondition} condition - iterator returns true or false.\n     *\n     * @return {boolean} is every child pass condition\n     *\n     * @example\n     * const noPrefixes = rule.every(i => i.prop[0] !== '-');\n     */\n    every(condition) {\n        return this.nodes.every(condition);\n    }\n\n    /**\n     * Returns `true` if callback returns `true` for (at least) one\n     * of the container’s children.\n     *\n     * @param {childCondition} condition - iterator returns true or false.\n     *\n     * @return {boolean} is some child pass condition\n     *\n     * @example\n     * const hasPrefix = rule.some(i => i.prop[0] === '-');\n     */\n    some(condition) {\n        return this.nodes.some(condition);\n    }\n\n    /**\n     * Returns a `child`’s index within the {@link Container#nodes} array.\n     *\n     * @param {Node} child - child of the current container.\n     *\n     * @return {number} child index\n     *\n     * @example\n     * rule.index( rule.nodes[2] ) //=> 2\n     */\n    index(child) {\n        if ( typeof child === 'number' ) {\n            return child;\n        } else {\n            return this.nodes.indexOf(child);\n        }\n    }\n\n    /**\n     * The container’s first child.\n     *\n     * @type {Node}\n     *\n     * @example\n     * rule.first == rules.nodes[0];\n     */\n    get first() {\n        if ( !this.nodes ) return undefined;\n        return this.nodes[0];\n    }\n\n    /**\n     * The container’s last child.\n     *\n     * @type {Node}\n     *\n     * @example\n     * rule.last == rule.nodes[rule.nodes.length - 1];\n     */\n    get last() {\n        if ( !this.nodes ) return undefined;\n        return this.nodes[this.nodes.length - 1];\n    }\n\n    normalize(nodes, sample) {\n        if ( typeof nodes === 'string' ) {\n            let parse = require('./parse');\n            nodes = cleanSource(parse(nodes).nodes);\n        } else if ( Array.isArray(nodes) ) {\n            nodes = nodes.slice(0);\n            for ( let i of nodes ) {\n                if ( i.parent ) i.parent.removeChild(i, 'ignore');\n            }\n        } else if ( nodes.type === 'root' ) {\n            nodes = nodes.nodes.slice(0);\n            for ( let i of nodes ) {\n                if ( i.parent ) i.parent.removeChild(i, 'ignore');\n            }\n        } else if ( nodes.type ) {\n            nodes = [nodes];\n        } else if ( nodes.prop ) {\n            if ( typeof nodes.value === 'undefined' ) {\n                throw new Error('Value field is missed in node creation');\n            } else if ( typeof nodes.value !== 'string' ) {\n                nodes.value = String(nodes.value);\n            }\n            nodes = [new Declaration(nodes)];\n        } else if ( nodes.selector ) {\n            let Rule = require('./rule');\n            nodes = [new Rule(nodes)];\n        } else if ( nodes.name ) {\n            let AtRule = require('./at-rule');\n            nodes = [new AtRule(nodes)];\n        } else if ( nodes.text ) {\n            nodes = [new Comment(nodes)];\n        } else {\n            throw new Error('Unknown node type in node creation');\n        }\n\n        let processed = nodes.map( i => {\n            if ( typeof i.before !== 'function' ) i = this.rebuild(i);\n\n            if ( i.parent ) i.parent.removeChild(i);\n            if ( typeof i.raws.before === 'undefined' ) {\n                if ( sample && typeof sample.raws.before !== 'undefined' ) {\n                    i.raws.before = sample.raws.before.replace(/[^\\s]/g, '');\n                }\n            }\n            i.parent = this;\n            return i;\n        });\n\n        return processed;\n    }\n\n    rebuild(node, parent) {\n        let fix;\n        if ( node.type === 'root' ) {\n            let Root = require('./root');\n            fix = new Root();\n        } else if ( node.type === 'atrule' ) {\n            let AtRule = require('./at-rule');\n            fix = new AtRule();\n        } else if ( node.type === 'rule' ) {\n            let Rule = require('./rule');\n            fix = new Rule();\n        } else if ( node.type === 'decl' ) {\n            fix = new Declaration();\n        } else if ( node.type === 'comment' ) {\n            fix = new Comment();\n        }\n\n        for ( let i in node ) {\n            if ( i === 'nodes' ) {\n                fix.nodes = node.nodes.map( j => this.rebuild(j, fix) );\n            } else if ( i === 'parent' && parent ) {\n                fix.parent = parent;\n            } else if ( node.hasOwnProperty(i) ) {\n                fix[i] = node[i];\n            }\n        }\n\n        return fix;\n    }\n\n    /**\n     * @memberof Container#\n     * @member {Node[]} nodes - an array containing the container’s children\n     *\n     * @example\n     * const root = postcss.parse('a { color: black }');\n     * root.nodes.length           //=> 1\n     * root.nodes[0].selector      //=> 'a'\n     * root.nodes[0].nodes[0].prop //=> 'color'\n     */\n\n}\n\nexport default Container;\n\n\n/**\n * @callback childCondition\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @param {Node[]} nodes - all container children\n * @return {boolean}\n */\n\n/**\n * @callback childIterator\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @return {false|undefined} returning `false` will break iteration\n */\n"]},"metadata":{},"sourceType":"module"}