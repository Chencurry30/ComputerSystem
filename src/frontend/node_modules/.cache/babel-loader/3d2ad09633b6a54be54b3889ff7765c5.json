{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { hex2b64 } from \"./lib/jsbn/base64\";\nimport { Hex } from \"./lib/asn1js/hex\";\nimport { Base64 } from \"./lib/asn1js/base64\";\nimport { ASN1 } from \"./lib/asn1js/asn1\";\nimport { RSAKey } from \"./lib/jsbn/rsa\";\nimport { parseBigInt } from \"./lib/jsbn/jsbn\";\nimport { KJUR } from \"./lib/jsrsasign/asn1-1.0\";\n/**\n * Create a new JSEncryptRSAKey that extends Tom Wu's RSA key object.\n * This object is just a decorator for parsing the key parameter\n * @param {string|Object} key - The key in string format, or an object containing\n * the parameters needed to build a RSAKey object.\n * @constructor\n */\n\nvar JSEncryptRSAKey =\n/** @class */\nfunction (_super) {\n  __extends(JSEncryptRSAKey, _super);\n\n  function JSEncryptRSAKey(key) {\n    var _this = _super.call(this) || this; // Call the super constructor.\n    //  RSAKey.call(this);\n    // If a key key was provided.\n\n\n    if (key) {\n      // If this is a string...\n      if (typeof key === \"string\") {\n        _this.parseKey(key);\n      } else if (JSEncryptRSAKey.hasPrivateKeyProperty(key) || JSEncryptRSAKey.hasPublicKeyProperty(key)) {\n        // Set the values for the key.\n        _this.parsePropertiesFrom(key);\n      }\n    }\n\n    return _this;\n  }\n  /**\n   * Method to parse a pem encoded string containing both a public or private key.\n   * The method will translate the pem encoded string in a der encoded string and\n   * will parse private key and public key parameters. This method accepts public key\n   * in the rsaencryption pkcs #1 format (oid: 1.2.840.113549.1.1.1).\n   *\n   * @todo Check how many rsa formats use the same format of pkcs #1.\n   *\n   * The format is defined as:\n   * PublicKeyInfo ::= SEQUENCE {\n   *   algorithm       AlgorithmIdentifier,\n   *   PublicKey       BIT STRING\n   * }\n   * Where AlgorithmIdentifier is:\n   * AlgorithmIdentifier ::= SEQUENCE {\n   *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm\n   *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)\n   * }\n   * and PublicKey is a SEQUENCE encapsulated in a BIT STRING\n   * RSAPublicKey ::= SEQUENCE {\n   *   modulus           INTEGER,  -- n\n   *   publicExponent    INTEGER   -- e\n   * }\n   * it's possible to examine the structure of the keys obtained from openssl using\n   * an asn.1 dumper as the one used here to parse the components: http://lapo.it/asn1js/\n   * @argument {string} pem the pem encoded string, can include the BEGIN/END header/footer\n   * @private\n   */\n\n\n  JSEncryptRSAKey.prototype.parseKey = function (pem) {\n    try {\n      var modulus = 0;\n      var public_exponent = 0;\n      var reHex = /^\\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\\s*)+$/;\n      var der = reHex.test(pem) ? Hex.decode(pem) : Base64.unarmor(pem);\n      var asn1 = ASN1.decode(der); // Fixes a bug with OpenSSL 1.0+ private keys\n\n      if (asn1.sub.length === 3) {\n        asn1 = asn1.sub[2].sub[0];\n      }\n\n      if (asn1.sub.length === 9) {\n        // Parse the private key.\n        modulus = asn1.sub[1].getHexStringValue(); // bigint\n\n        this.n = parseBigInt(modulus, 16);\n        public_exponent = asn1.sub[2].getHexStringValue(); // int\n\n        this.e = parseInt(public_exponent, 16);\n        var private_exponent = asn1.sub[3].getHexStringValue(); // bigint\n\n        this.d = parseBigInt(private_exponent, 16);\n        var prime1 = asn1.sub[4].getHexStringValue(); // bigint\n\n        this.p = parseBigInt(prime1, 16);\n        var prime2 = asn1.sub[5].getHexStringValue(); // bigint\n\n        this.q = parseBigInt(prime2, 16);\n        var exponent1 = asn1.sub[6].getHexStringValue(); // bigint\n\n        this.dmp1 = parseBigInt(exponent1, 16);\n        var exponent2 = asn1.sub[7].getHexStringValue(); // bigint\n\n        this.dmq1 = parseBigInt(exponent2, 16);\n        var coefficient = asn1.sub[8].getHexStringValue(); // bigint\n\n        this.coeff = parseBigInt(coefficient, 16);\n      } else if (asn1.sub.length === 2) {\n        // Parse the public key.\n        var bit_string = asn1.sub[1];\n        var sequence = bit_string.sub[0];\n        modulus = sequence.sub[0].getHexStringValue();\n        this.n = parseBigInt(modulus, 16);\n        public_exponent = sequence.sub[1].getHexStringValue();\n        this.e = parseInt(public_exponent, 16);\n      } else {\n        return false;\n      }\n\n      return true;\n    } catch (ex) {\n      return false;\n    }\n  };\n  /**\n   * Translate rsa parameters in a hex encoded string representing the rsa key.\n   *\n   * The translation follow the ASN.1 notation :\n   * RSAPrivateKey ::= SEQUENCE {\n   *   version           Version,\n   *   modulus           INTEGER,  -- n\n   *   publicExponent    INTEGER,  -- e\n   *   privateExponent   INTEGER,  -- d\n   *   prime1            INTEGER,  -- p\n   *   prime2            INTEGER,  -- q\n   *   exponent1         INTEGER,  -- d mod (p1)\n   *   exponent2         INTEGER,  -- d mod (q-1)\n   *   coefficient       INTEGER,  -- (inverse of q) mod p\n   * }\n   * @returns {string}  DER Encoded String representing the rsa private key\n   * @private\n   */\n\n\n  JSEncryptRSAKey.prototype.getPrivateBaseKey = function () {\n    var options = {\n      array: [new KJUR.asn1.DERInteger({\n        int: 0\n      }), new KJUR.asn1.DERInteger({\n        bigint: this.n\n      }), new KJUR.asn1.DERInteger({\n        int: this.e\n      }), new KJUR.asn1.DERInteger({\n        bigint: this.d\n      }), new KJUR.asn1.DERInteger({\n        bigint: this.p\n      }), new KJUR.asn1.DERInteger({\n        bigint: this.q\n      }), new KJUR.asn1.DERInteger({\n        bigint: this.dmp1\n      }), new KJUR.asn1.DERInteger({\n        bigint: this.dmq1\n      }), new KJUR.asn1.DERInteger({\n        bigint: this.coeff\n      })]\n    };\n    var seq = new KJUR.asn1.DERSequence(options);\n    return seq.getEncodedHex();\n  };\n  /**\n   * base64 (pem) encoded version of the DER encoded representation\n   * @returns {string} pem encoded representation without header and footer\n   * @public\n   */\n\n\n  JSEncryptRSAKey.prototype.getPrivateBaseKeyB64 = function () {\n    return hex2b64(this.getPrivateBaseKey());\n  };\n  /**\n   * Translate rsa parameters in a hex encoded string representing the rsa public key.\n   * The representation follow the ASN.1 notation :\n   * PublicKeyInfo ::= SEQUENCE {\n   *   algorithm       AlgorithmIdentifier,\n   *   PublicKey       BIT STRING\n   * }\n   * Where AlgorithmIdentifier is:\n   * AlgorithmIdentifier ::= SEQUENCE {\n   *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm\n   *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)\n   * }\n   * and PublicKey is a SEQUENCE encapsulated in a BIT STRING\n   * RSAPublicKey ::= SEQUENCE {\n   *   modulus           INTEGER,  -- n\n   *   publicExponent    INTEGER   -- e\n   * }\n   * @returns {string} DER Encoded String representing the rsa public key\n   * @private\n   */\n\n\n  JSEncryptRSAKey.prototype.getPublicBaseKey = function () {\n    var first_sequence = new KJUR.asn1.DERSequence({\n      array: [new KJUR.asn1.DERObjectIdentifier({\n        oid: \"1.2.840.113549.1.1.1\"\n      }), new KJUR.asn1.DERNull()]\n    });\n    var second_sequence = new KJUR.asn1.DERSequence({\n      array: [new KJUR.asn1.DERInteger({\n        bigint: this.n\n      }), new KJUR.asn1.DERInteger({\n        int: this.e\n      })]\n    });\n    var bit_string = new KJUR.asn1.DERBitString({\n      hex: \"00\" + second_sequence.getEncodedHex()\n    });\n    var seq = new KJUR.asn1.DERSequence({\n      array: [first_sequence, bit_string]\n    });\n    return seq.getEncodedHex();\n  };\n  /**\n   * base64 (pem) encoded version of the DER encoded representation\n   * @returns {string} pem encoded representation without header and footer\n   * @public\n   */\n\n\n  JSEncryptRSAKey.prototype.getPublicBaseKeyB64 = function () {\n    return hex2b64(this.getPublicBaseKey());\n  };\n  /**\n   * wrap the string in block of width chars. The default value for rsa keys is 64\n   * characters.\n   * @param {string} str the pem encoded string without header and footer\n   * @param {Number} [width=64] - the length the string has to be wrapped at\n   * @returns {string}\n   * @private\n   */\n\n\n  JSEncryptRSAKey.wordwrap = function (str, width) {\n    width = width || 64;\n\n    if (!str) {\n      return str;\n    }\n\n    var regex = \"(.{1,\" + width + \"})( +|$\\n?)|(.{1,\" + width + \"})\";\n    return str.match(RegExp(regex, \"g\")).join(\"\\n\");\n  };\n  /**\n   * Retrieve the pem encoded private key\n   * @returns {string} the pem encoded private key with header/footer\n   * @public\n   */\n\n\n  JSEncryptRSAKey.prototype.getPrivateKey = function () {\n    var key = \"-----BEGIN RSA PRIVATE KEY-----\\n\";\n    key += JSEncryptRSAKey.wordwrap(this.getPrivateBaseKeyB64()) + \"\\n\";\n    key += \"-----END RSA PRIVATE KEY-----\";\n    return key;\n  };\n  /**\n   * Retrieve the pem encoded public key\n   * @returns {string} the pem encoded public key with header/footer\n   * @public\n   */\n\n\n  JSEncryptRSAKey.prototype.getPublicKey = function () {\n    var key = \"-----BEGIN PUBLIC KEY-----\\n\";\n    key += JSEncryptRSAKey.wordwrap(this.getPublicBaseKeyB64()) + \"\\n\";\n    key += \"-----END PUBLIC KEY-----\";\n    return key;\n  };\n  /**\n   * Check if the object contains the necessary parameters to populate the rsa modulus\n   * and public exponent parameters.\n   * @param {Object} [obj={}] - An object that may contain the two public key\n   * parameters\n   * @returns {boolean} true if the object contains both the modulus and the public exponent\n   * properties (n and e)\n   * @todo check for types of n and e. N should be a parseable bigInt object, E should\n   * be a parseable integer number\n   * @private\n   */\n\n\n  JSEncryptRSAKey.hasPublicKeyProperty = function (obj) {\n    obj = obj || {};\n    return obj.hasOwnProperty(\"n\") && obj.hasOwnProperty(\"e\");\n  };\n  /**\n   * Check if the object contains ALL the parameters of an RSA key.\n   * @param {Object} [obj={}] - An object that may contain nine rsa key\n   * parameters\n   * @returns {boolean} true if the object contains all the parameters needed\n   * @todo check for types of the parameters all the parameters but the public exponent\n   * should be parseable bigint objects, the public exponent should be a parseable integer number\n   * @private\n   */\n\n\n  JSEncryptRSAKey.hasPrivateKeyProperty = function (obj) {\n    obj = obj || {};\n    return obj.hasOwnProperty(\"n\") && obj.hasOwnProperty(\"e\") && obj.hasOwnProperty(\"d\") && obj.hasOwnProperty(\"p\") && obj.hasOwnProperty(\"q\") && obj.hasOwnProperty(\"dmp1\") && obj.hasOwnProperty(\"dmq1\") && obj.hasOwnProperty(\"coeff\");\n  };\n  /**\n   * Parse the properties of obj in the current rsa object. Obj should AT LEAST\n   * include the modulus and public exponent (n, e) parameters.\n   * @param {Object} obj - the object containing rsa parameters\n   * @private\n   */\n\n\n  JSEncryptRSAKey.prototype.parsePropertiesFrom = function (obj) {\n    this.n = obj.n;\n    this.e = obj.e;\n\n    if (obj.hasOwnProperty(\"d\")) {\n      this.d = obj.d;\n      this.p = obj.p;\n      this.q = obj.q;\n      this.dmp1 = obj.dmp1;\n      this.dmq1 = obj.dmq1;\n      this.coeff = obj.coeff;\n    }\n  };\n\n  return JSEncryptRSAKey;\n}(RSAKey);\n\nexport { JSEncryptRSAKey };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","hex2b64","Hex","Base64","ASN1","RSAKey","parseBigInt","KJUR","JSEncryptRSAKey","_super","key","_this","parseKey","hasPrivateKeyProperty","hasPublicKeyProperty","parsePropertiesFrom","pem","modulus","public_exponent","reHex","der","test","decode","unarmor","asn1","sub","length","getHexStringValue","n","e","parseInt","private_exponent","prime1","prime2","q","exponent1","dmp1","exponent2","dmq1","coefficient","coeff","bit_string","sequence","ex","getPrivateBaseKey","options","array","DERInteger","int","bigint","seq","DERSequence","getEncodedHex","getPrivateBaseKeyB64","getPublicBaseKey","first_sequence","DERObjectIdentifier","oid","DERNull","second_sequence","DERBitString","hex","getPublicBaseKeyB64","wordwrap","str","width","regex","match","RegExp","join","getPrivateKey","getPublicKey","obj"],"sources":["/Users/liguoqiang/Desktop/code/computer-system/src/frontend/node_modules/jsencrypt/lib/JSEncryptRSAKey.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { hex2b64 } from \"./lib/jsbn/base64\";\nimport { Hex } from \"./lib/asn1js/hex\";\nimport { Base64 } from \"./lib/asn1js/base64\";\nimport { ASN1 } from \"./lib/asn1js/asn1\";\nimport { RSAKey } from \"./lib/jsbn/rsa\";\nimport { parseBigInt } from \"./lib/jsbn/jsbn\";\nimport { KJUR } from \"./lib/jsrsasign/asn1-1.0\";\n/**\n * Create a new JSEncryptRSAKey that extends Tom Wu's RSA key object.\n * This object is just a decorator for parsing the key parameter\n * @param {string|Object} key - The key in string format, or an object containing\n * the parameters needed to build a RSAKey object.\n * @constructor\n */\nvar JSEncryptRSAKey = /** @class */ (function (_super) {\n    __extends(JSEncryptRSAKey, _super);\n    function JSEncryptRSAKey(key) {\n        var _this = _super.call(this) || this;\n        // Call the super constructor.\n        //  RSAKey.call(this);\n        // If a key key was provided.\n        if (key) {\n            // If this is a string...\n            if (typeof key === \"string\") {\n                _this.parseKey(key);\n            }\n            else if (JSEncryptRSAKey.hasPrivateKeyProperty(key) ||\n                JSEncryptRSAKey.hasPublicKeyProperty(key)) {\n                // Set the values for the key.\n                _this.parsePropertiesFrom(key);\n            }\n        }\n        return _this;\n    }\n    /**\n     * Method to parse a pem encoded string containing both a public or private key.\n     * The method will translate the pem encoded string in a der encoded string and\n     * will parse private key and public key parameters. This method accepts public key\n     * in the rsaencryption pkcs #1 format (oid: 1.2.840.113549.1.1.1).\n     *\n     * @todo Check how many rsa formats use the same format of pkcs #1.\n     *\n     * The format is defined as:\n     * PublicKeyInfo ::= SEQUENCE {\n     *   algorithm       AlgorithmIdentifier,\n     *   PublicKey       BIT STRING\n     * }\n     * Where AlgorithmIdentifier is:\n     * AlgorithmIdentifier ::= SEQUENCE {\n     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm\n     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)\n     * }\n     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING\n     * RSAPublicKey ::= SEQUENCE {\n     *   modulus           INTEGER,  -- n\n     *   publicExponent    INTEGER   -- e\n     * }\n     * it's possible to examine the structure of the keys obtained from openssl using\n     * an asn.1 dumper as the one used here to parse the components: http://lapo.it/asn1js/\n     * @argument {string} pem the pem encoded string, can include the BEGIN/END header/footer\n     * @private\n     */\n    JSEncryptRSAKey.prototype.parseKey = function (pem) {\n        try {\n            var modulus = 0;\n            var public_exponent = 0;\n            var reHex = /^\\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\\s*)+$/;\n            var der = reHex.test(pem) ? Hex.decode(pem) : Base64.unarmor(pem);\n            var asn1 = ASN1.decode(der);\n            // Fixes a bug with OpenSSL 1.0+ private keys\n            if (asn1.sub.length === 3) {\n                asn1 = asn1.sub[2].sub[0];\n            }\n            if (asn1.sub.length === 9) {\n                // Parse the private key.\n                modulus = asn1.sub[1].getHexStringValue(); // bigint\n                this.n = parseBigInt(modulus, 16);\n                public_exponent = asn1.sub[2].getHexStringValue(); // int\n                this.e = parseInt(public_exponent, 16);\n                var private_exponent = asn1.sub[3].getHexStringValue(); // bigint\n                this.d = parseBigInt(private_exponent, 16);\n                var prime1 = asn1.sub[4].getHexStringValue(); // bigint\n                this.p = parseBigInt(prime1, 16);\n                var prime2 = asn1.sub[5].getHexStringValue(); // bigint\n                this.q = parseBigInt(prime2, 16);\n                var exponent1 = asn1.sub[6].getHexStringValue(); // bigint\n                this.dmp1 = parseBigInt(exponent1, 16);\n                var exponent2 = asn1.sub[7].getHexStringValue(); // bigint\n                this.dmq1 = parseBigInt(exponent2, 16);\n                var coefficient = asn1.sub[8].getHexStringValue(); // bigint\n                this.coeff = parseBigInt(coefficient, 16);\n            }\n            else if (asn1.sub.length === 2) {\n                // Parse the public key.\n                var bit_string = asn1.sub[1];\n                var sequence = bit_string.sub[0];\n                modulus = sequence.sub[0].getHexStringValue();\n                this.n = parseBigInt(modulus, 16);\n                public_exponent = sequence.sub[1].getHexStringValue();\n                this.e = parseInt(public_exponent, 16);\n            }\n            else {\n                return false;\n            }\n            return true;\n        }\n        catch (ex) {\n            return false;\n        }\n    };\n    /**\n     * Translate rsa parameters in a hex encoded string representing the rsa key.\n     *\n     * The translation follow the ASN.1 notation :\n     * RSAPrivateKey ::= SEQUENCE {\n     *   version           Version,\n     *   modulus           INTEGER,  -- n\n     *   publicExponent    INTEGER,  -- e\n     *   privateExponent   INTEGER,  -- d\n     *   prime1            INTEGER,  -- p\n     *   prime2            INTEGER,  -- q\n     *   exponent1         INTEGER,  -- d mod (p1)\n     *   exponent2         INTEGER,  -- d mod (q-1)\n     *   coefficient       INTEGER,  -- (inverse of q) mod p\n     * }\n     * @returns {string}  DER Encoded String representing the rsa private key\n     * @private\n     */\n    JSEncryptRSAKey.prototype.getPrivateBaseKey = function () {\n        var options = {\n            array: [\n                new KJUR.asn1.DERInteger({ int: 0 }),\n                new KJUR.asn1.DERInteger({ bigint: this.n }),\n                new KJUR.asn1.DERInteger({ int: this.e }),\n                new KJUR.asn1.DERInteger({ bigint: this.d }),\n                new KJUR.asn1.DERInteger({ bigint: this.p }),\n                new KJUR.asn1.DERInteger({ bigint: this.q }),\n                new KJUR.asn1.DERInteger({ bigint: this.dmp1 }),\n                new KJUR.asn1.DERInteger({ bigint: this.dmq1 }),\n                new KJUR.asn1.DERInteger({ bigint: this.coeff })\n            ]\n        };\n        var seq = new KJUR.asn1.DERSequence(options);\n        return seq.getEncodedHex();\n    };\n    /**\n     * base64 (pem) encoded version of the DER encoded representation\n     * @returns {string} pem encoded representation without header and footer\n     * @public\n     */\n    JSEncryptRSAKey.prototype.getPrivateBaseKeyB64 = function () {\n        return hex2b64(this.getPrivateBaseKey());\n    };\n    /**\n     * Translate rsa parameters in a hex encoded string representing the rsa public key.\n     * The representation follow the ASN.1 notation :\n     * PublicKeyInfo ::= SEQUENCE {\n     *   algorithm       AlgorithmIdentifier,\n     *   PublicKey       BIT STRING\n     * }\n     * Where AlgorithmIdentifier is:\n     * AlgorithmIdentifier ::= SEQUENCE {\n     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm\n     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)\n     * }\n     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING\n     * RSAPublicKey ::= SEQUENCE {\n     *   modulus           INTEGER,  -- n\n     *   publicExponent    INTEGER   -- e\n     * }\n     * @returns {string} DER Encoded String representing the rsa public key\n     * @private\n     */\n    JSEncryptRSAKey.prototype.getPublicBaseKey = function () {\n        var first_sequence = new KJUR.asn1.DERSequence({\n            array: [\n                new KJUR.asn1.DERObjectIdentifier({ oid: \"1.2.840.113549.1.1.1\" }),\n                new KJUR.asn1.DERNull()\n            ]\n        });\n        var second_sequence = new KJUR.asn1.DERSequence({\n            array: [\n                new KJUR.asn1.DERInteger({ bigint: this.n }),\n                new KJUR.asn1.DERInteger({ int: this.e })\n            ]\n        });\n        var bit_string = new KJUR.asn1.DERBitString({\n            hex: \"00\" + second_sequence.getEncodedHex()\n        });\n        var seq = new KJUR.asn1.DERSequence({\n            array: [\n                first_sequence,\n                bit_string\n            ]\n        });\n        return seq.getEncodedHex();\n    };\n    /**\n     * base64 (pem) encoded version of the DER encoded representation\n     * @returns {string} pem encoded representation without header and footer\n     * @public\n     */\n    JSEncryptRSAKey.prototype.getPublicBaseKeyB64 = function () {\n        return hex2b64(this.getPublicBaseKey());\n    };\n    /**\n     * wrap the string in block of width chars. The default value for rsa keys is 64\n     * characters.\n     * @param {string} str the pem encoded string without header and footer\n     * @param {Number} [width=64] - the length the string has to be wrapped at\n     * @returns {string}\n     * @private\n     */\n    JSEncryptRSAKey.wordwrap = function (str, width) {\n        width = width || 64;\n        if (!str) {\n            return str;\n        }\n        var regex = \"(.{1,\" + width + \"})( +|$\\n?)|(.{1,\" + width + \"})\";\n        return str.match(RegExp(regex, \"g\")).join(\"\\n\");\n    };\n    /**\n     * Retrieve the pem encoded private key\n     * @returns {string} the pem encoded private key with header/footer\n     * @public\n     */\n    JSEncryptRSAKey.prototype.getPrivateKey = function () {\n        var key = \"-----BEGIN RSA PRIVATE KEY-----\\n\";\n        key += JSEncryptRSAKey.wordwrap(this.getPrivateBaseKeyB64()) + \"\\n\";\n        key += \"-----END RSA PRIVATE KEY-----\";\n        return key;\n    };\n    /**\n     * Retrieve the pem encoded public key\n     * @returns {string} the pem encoded public key with header/footer\n     * @public\n     */\n    JSEncryptRSAKey.prototype.getPublicKey = function () {\n        var key = \"-----BEGIN PUBLIC KEY-----\\n\";\n        key += JSEncryptRSAKey.wordwrap(this.getPublicBaseKeyB64()) + \"\\n\";\n        key += \"-----END PUBLIC KEY-----\";\n        return key;\n    };\n    /**\n     * Check if the object contains the necessary parameters to populate the rsa modulus\n     * and public exponent parameters.\n     * @param {Object} [obj={}] - An object that may contain the two public key\n     * parameters\n     * @returns {boolean} true if the object contains both the modulus and the public exponent\n     * properties (n and e)\n     * @todo check for types of n and e. N should be a parseable bigInt object, E should\n     * be a parseable integer number\n     * @private\n     */\n    JSEncryptRSAKey.hasPublicKeyProperty = function (obj) {\n        obj = obj || {};\n        return (obj.hasOwnProperty(\"n\") &&\n            obj.hasOwnProperty(\"e\"));\n    };\n    /**\n     * Check if the object contains ALL the parameters of an RSA key.\n     * @param {Object} [obj={}] - An object that may contain nine rsa key\n     * parameters\n     * @returns {boolean} true if the object contains all the parameters needed\n     * @todo check for types of the parameters all the parameters but the public exponent\n     * should be parseable bigint objects, the public exponent should be a parseable integer number\n     * @private\n     */\n    JSEncryptRSAKey.hasPrivateKeyProperty = function (obj) {\n        obj = obj || {};\n        return (obj.hasOwnProperty(\"n\") &&\n            obj.hasOwnProperty(\"e\") &&\n            obj.hasOwnProperty(\"d\") &&\n            obj.hasOwnProperty(\"p\") &&\n            obj.hasOwnProperty(\"q\") &&\n            obj.hasOwnProperty(\"dmp1\") &&\n            obj.hasOwnProperty(\"dmq1\") &&\n            obj.hasOwnProperty(\"coeff\"));\n    };\n    /**\n     * Parse the properties of obj in the current rsa object. Obj should AT LEAST\n     * include the modulus and public exponent (n, e) parameters.\n     * @param {Object} obj - the object containing rsa parameters\n     * @private\n     */\n    JSEncryptRSAKey.prototype.parsePropertiesFrom = function (obj) {\n        this.n = obj.n;\n        this.e = obj.e;\n        if (obj.hasOwnProperty(\"d\")) {\n            this.d = obj.d;\n            this.p = obj.p;\n            this.q = obj.q;\n            this.dmp1 = obj.dmp1;\n            this.dmq1 = obj.dmq1;\n            this.coeff = obj.coeff;\n        }\n    };\n    return JSEncryptRSAKey;\n}(RSAKey));\nexport { JSEncryptRSAKey };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}