{"ast":null,"code":"\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar OldSelector = function () {\n  function OldSelector(selector, prefix) {\n    _classCallCheck(this, OldSelector);\n\n    this.prefix = prefix;\n    this.prefixed = selector.prefixed(this.prefix);\n    this.regexp = selector.regexp(this.prefix);\n    this.prefixeds = selector.possible().map(function (x) {\n      return [selector.prefixed(x), selector.regexp(x)];\n    });\n    this.unprefixed = selector.name;\n    this.nameRegexp = selector.regexp();\n  }\n  /**\n   * Is rule a hack without unprefixed version bottom\n   */\n\n\n  OldSelector.prototype.isHack = function isHack(rule) {\n    var index = rule.parent.index(rule) + 1;\n    var rules = rule.parent.nodes;\n\n    while (index < rules.length) {\n      var before = rules[index].selector;\n\n      if (!before) {\n        return true;\n      }\n\n      if (before.indexOf(this.unprefixed) !== -1 && before.match(this.nameRegexp)) {\n        return false;\n      }\n\n      var some = false;\n\n      for (var _iterator = this.prefixeds, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref2 = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref2 = _i.value;\n        }\n\n        var _ref = _ref2;\n        var string = _ref[0];\n        var regexp = _ref[1];\n\n        if (before.indexOf(string) !== -1 && before.match(regexp)) {\n          some = true;\n          break;\n        }\n      }\n\n      if (!some) {\n        return true;\n      }\n\n      index += 1;\n    }\n\n    return true;\n  };\n  /**\n   * Does rule contain an unnecessary prefixed selector\n   */\n\n\n  OldSelector.prototype.check = function check(rule) {\n    if (rule.selector.indexOf(this.prefixed) === -1) {\n      return false;\n    }\n\n    if (!rule.selector.match(this.regexp)) {\n      return false;\n    }\n\n    if (this.isHack(rule)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  return OldSelector;\n}();\n\nmodule.exports = OldSelector;","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","OldSelector","selector","prefix","prefixed","regexp","prefixeds","possible","map","x","unprefixed","name","nameRegexp","prototype","isHack","rule","index","parent","rules","nodes","length","before","indexOf","match","some","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref2","next","done","value","_ref","string","check","module","exports"],"sources":["C:/Users/Administrator/Desktop/code/computer-system/src/frontend/node_modules/autoprefixer/lib/old-selector.js"],"sourcesContent":["\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar OldSelector = function () {\n    function OldSelector(selector, prefix) {\n        _classCallCheck(this, OldSelector);\n\n        this.prefix = prefix;\n        this.prefixed = selector.prefixed(this.prefix);\n        this.regexp = selector.regexp(this.prefix);\n\n        this.prefixeds = selector.possible().map(function (x) {\n            return [selector.prefixed(x), selector.regexp(x)];\n        });\n\n        this.unprefixed = selector.name;\n        this.nameRegexp = selector.regexp();\n    }\n\n    /**\n     * Is rule a hack without unprefixed version bottom\n     */\n\n\n    OldSelector.prototype.isHack = function isHack(rule) {\n        var index = rule.parent.index(rule) + 1;\n        var rules = rule.parent.nodes;\n\n        while (index < rules.length) {\n            var before = rules[index].selector;\n            if (!before) {\n                return true;\n            }\n\n            if (before.indexOf(this.unprefixed) !== -1 && before.match(this.nameRegexp)) {\n                return false;\n            }\n\n            var some = false;\n            for (var _iterator = this.prefixeds, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n                var _ref2;\n\n                if (_isArray) {\n                    if (_i >= _iterator.length) break;\n                    _ref2 = _iterator[_i++];\n                } else {\n                    _i = _iterator.next();\n                    if (_i.done) break;\n                    _ref2 = _i.value;\n                }\n\n                var _ref = _ref2;\n                var string = _ref[0];\n                var regexp = _ref[1];\n\n                if (before.indexOf(string) !== -1 && before.match(regexp)) {\n                    some = true;\n                    break;\n                }\n            }\n\n            if (!some) {\n                return true;\n            }\n\n            index += 1;\n        }\n\n        return true;\n    };\n\n    /**\n     * Does rule contain an unnecessary prefixed selector\n     */\n\n\n    OldSelector.prototype.check = function check(rule) {\n        if (rule.selector.indexOf(this.prefixed) === -1) {\n            return false;\n        }\n        if (!rule.selector.match(this.regexp)) {\n            return false;\n        }\n        if (this.isHack(rule)) {\n            return false;\n        }\n        return true;\n    };\n\n    return OldSelector;\n}();\n\nmodule.exports = OldSelector;"],"mappings":"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"},"metadata":{},"sourceType":"module"}