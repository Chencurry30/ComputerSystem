{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar defaultRaw = {\n  colon: ': ',\n  indent: '    ',\n  beforeDecl: '\\n',\n  beforeRule: '\\n',\n  beforeOpen: ' ',\n  beforeClose: '\\n',\n  beforeComment: '\\n',\n  after: '\\n',\n  emptyBody: '',\n  commentLeft: ' ',\n  commentRight: ' '\n};\n\nfunction capitalize(str) {\n  return str[0].toUpperCase() + str.slice(1);\n}\n\nvar Stringifier = function () {\n  function Stringifier(builder) {\n    _classCallCheck(this, Stringifier);\n\n    this.builder = builder;\n  }\n\n  Stringifier.prototype.stringify = function stringify(node, semicolon) {\n    this[node.type](node, semicolon);\n  };\n\n  Stringifier.prototype.root = function root(node) {\n    this.body(node);\n    if (node.raws.after) this.builder(node.raws.after);\n  };\n\n  Stringifier.prototype.comment = function comment(node) {\n    var left = this.raw(node, 'left', 'commentLeft');\n    var right = this.raw(node, 'right', 'commentRight');\n    this.builder('/*' + left + node.text + right + '*/', node);\n  };\n\n  Stringifier.prototype.decl = function decl(node, semicolon) {\n    var between = this.raw(node, 'between', 'colon');\n    var string = node.prop + between + this.rawValue(node, 'value');\n\n    if (node.important) {\n      string += node.raws.important || ' !important';\n    }\n\n    if (semicolon) string += ';';\n    this.builder(string, node);\n  };\n\n  Stringifier.prototype.rule = function rule(node) {\n    this.block(node, this.rawValue(node, 'selector'));\n\n    if (node.raws.ownSemicolon) {\n      this.builder(node.raws.ownSemicolon, node, 'end');\n    }\n  };\n\n  Stringifier.prototype.atrule = function atrule(node, semicolon) {\n    var name = '@' + node.name;\n    var params = node.params ? this.rawValue(node, 'params') : '';\n\n    if (typeof node.raws.afterName !== 'undefined') {\n      name += node.raws.afterName;\n    } else if (params) {\n      name += ' ';\n    }\n\n    if (node.nodes) {\n      this.block(node, name + params);\n    } else {\n      var end = (node.raws.between || '') + (semicolon ? ';' : '');\n      this.builder(name + params + end, node);\n    }\n  };\n\n  Stringifier.prototype.body = function body(node) {\n    var last = node.nodes.length - 1;\n\n    while (last > 0) {\n      if (node.nodes[last].type !== 'comment') break;\n      last -= 1;\n    }\n\n    var semicolon = this.raw(node, 'semicolon');\n\n    for (var i = 0; i < node.nodes.length; i++) {\n      var child = node.nodes[i];\n      var before = this.raw(child, 'before');\n      if (before) this.builder(before);\n      this.stringify(child, last !== i || semicolon);\n    }\n  };\n\n  Stringifier.prototype.block = function block(node, start) {\n    var between = this.raw(node, 'between', 'beforeOpen');\n    this.builder(start + between + '{', node, 'start');\n    var after = void 0;\n\n    if (node.nodes && node.nodes.length) {\n      this.body(node);\n      after = this.raw(node, 'after');\n    } else {\n      after = this.raw(node, 'after', 'emptyBody');\n    }\n\n    if (after) this.builder(after);\n    this.builder('}', node, 'end');\n  };\n\n  Stringifier.prototype.raw = function raw(node, own, detect) {\n    var value = void 0;\n    if (!detect) detect = own; // Already had\n\n    if (own) {\n      value = node.raws[own];\n      if (typeof value !== 'undefined') return value;\n    }\n\n    var parent = node.parent; // Hack for first rule in CSS\n\n    if (detect === 'before') {\n      if (!parent || parent.type === 'root' && parent.first === node) {\n        return '';\n      }\n    } // Floating child without parent\n\n\n    if (!parent) return defaultRaw[detect]; // Detect style by other nodes\n\n    var root = node.root();\n    if (!root.rawCache) root.rawCache = {};\n\n    if (typeof root.rawCache[detect] !== 'undefined') {\n      return root.rawCache[detect];\n    }\n\n    if (detect === 'before' || detect === 'after') {\n      return this.beforeAfter(node, detect);\n    } else {\n      var method = 'raw' + capitalize(detect);\n\n      if (this[method]) {\n        value = this[method](root, node);\n      } else {\n        root.walk(function (i) {\n          value = i.raws[own];\n          if (typeof value !== 'undefined') return false;\n        });\n      }\n    }\n\n    if (typeof value === 'undefined') value = defaultRaw[detect];\n    root.rawCache[detect] = value;\n    return value;\n  };\n\n  Stringifier.prototype.rawSemicolon = function rawSemicolon(root) {\n    var value = void 0;\n    root.walk(function (i) {\n      if (i.nodes && i.nodes.length && i.last.type === 'decl') {\n        value = i.raws.semicolon;\n        if (typeof value !== 'undefined') return false;\n      }\n    });\n    return value;\n  };\n\n  Stringifier.prototype.rawEmptyBody = function rawEmptyBody(root) {\n    var value = void 0;\n    root.walk(function (i) {\n      if (i.nodes && i.nodes.length === 0) {\n        value = i.raws.after;\n        if (typeof value !== 'undefined') return false;\n      }\n    });\n    return value;\n  };\n\n  Stringifier.prototype.rawIndent = function rawIndent(root) {\n    if (root.raws.indent) return root.raws.indent;\n    var value = void 0;\n    root.walk(function (i) {\n      var p = i.parent;\n\n      if (p && p !== root && p.parent && p.parent === root) {\n        if (typeof i.raws.before !== 'undefined') {\n          var parts = i.raws.before.split('\\n');\n          value = parts[parts.length - 1];\n          value = value.replace(/[^\\s]/g, '');\n          return false;\n        }\n      }\n    });\n    return value;\n  };\n\n  Stringifier.prototype.rawBeforeComment = function rawBeforeComment(root, node) {\n    var value = void 0;\n    root.walkComments(function (i) {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before;\n\n        if (value.indexOf('\\n') !== -1) {\n          value = value.replace(/[^\\n]+$/, '');\n        }\n\n        return false;\n      }\n    });\n\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeDecl');\n    } else if (value) {\n      value = value.replace(/[^\\s]/g, '');\n    }\n\n    return value;\n  };\n\n  Stringifier.prototype.rawBeforeDecl = function rawBeforeDecl(root, node) {\n    var value = void 0;\n    root.walkDecls(function (i) {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before;\n\n        if (value.indexOf('\\n') !== -1) {\n          value = value.replace(/[^\\n]+$/, '');\n        }\n\n        return false;\n      }\n    });\n\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeRule');\n    } else if (value) {\n      value = value.replace(/[^\\s]/g, '');\n    }\n\n    return value;\n  };\n\n  Stringifier.prototype.rawBeforeRule = function rawBeforeRule(root) {\n    var value = void 0;\n    root.walk(function (i) {\n      if (i.nodes && (i.parent !== root || root.first !== i)) {\n        if (typeof i.raws.before !== 'undefined') {\n          value = i.raws.before;\n\n          if (value.indexOf('\\n') !== -1) {\n            value = value.replace(/[^\\n]+$/, '');\n          }\n\n          return false;\n        }\n      }\n    });\n    if (value) value = value.replace(/[^\\s]/g, '');\n    return value;\n  };\n\n  Stringifier.prototype.rawBeforeClose = function rawBeforeClose(root) {\n    var value = void 0;\n    root.walk(function (i) {\n      if (i.nodes && i.nodes.length > 0) {\n        if (typeof i.raws.after !== 'undefined') {\n          value = i.raws.after;\n\n          if (value.indexOf('\\n') !== -1) {\n            value = value.replace(/[^\\n]+$/, '');\n          }\n\n          return false;\n        }\n      }\n    });\n    if (value) value = value.replace(/[^\\s]/g, '');\n    return value;\n  };\n\n  Stringifier.prototype.rawBeforeOpen = function rawBeforeOpen(root) {\n    var value = void 0;\n    root.walk(function (i) {\n      if (i.type !== 'decl') {\n        value = i.raws.between;\n        if (typeof value !== 'undefined') return false;\n      }\n    });\n    return value;\n  };\n\n  Stringifier.prototype.rawColon = function rawColon(root) {\n    var value = void 0;\n    root.walkDecls(function (i) {\n      if (typeof i.raws.between !== 'undefined') {\n        value = i.raws.between.replace(/[^\\s:]/g, '');\n        return false;\n      }\n    });\n    return value;\n  };\n\n  Stringifier.prototype.beforeAfter = function beforeAfter(node, detect) {\n    var value = void 0;\n\n    if (node.type === 'decl') {\n      value = this.raw(node, null, 'beforeDecl');\n    } else if (node.type === 'comment') {\n      value = this.raw(node, null, 'beforeComment');\n    } else if (detect === 'before') {\n      value = this.raw(node, null, 'beforeRule');\n    } else {\n      value = this.raw(node, null, 'beforeClose');\n    }\n\n    var buf = node.parent;\n    var depth = 0;\n\n    while (buf && buf.type !== 'root') {\n      depth += 1;\n      buf = buf.parent;\n    }\n\n    if (value.indexOf('\\n') !== -1) {\n      var indent = this.raw(node, null, 'indent');\n\n      if (indent.length) {\n        for (var step = 0; step < depth; step++) {\n          value += indent;\n        }\n      }\n    }\n\n    return value;\n  };\n\n  Stringifier.prototype.rawValue = function rawValue(node, prop) {\n    var value = node[prop];\n    var raw = node.raws[prop];\n\n    if (raw && raw.value === value) {\n      return raw.raw;\n    } else {\n      return value;\n    }\n  };\n\n  return Stringifier;\n}();\n\nexports.default = Stringifier;\nmodule.exports = exports['default'];","map":{"version":3,"mappings":";;;;;;;;;;AAAA,IAAMA,aAAa;EACfC,OAAe,IADA;EAEfC,QAAe,MAFA;EAGfC,YAAe,IAHA;EAIfC,YAAe,IAJA;EAKfC,YAAe,GALA;EAMfC,aAAe,IANA;EAOfC,eAAe,IAPA;EAQfC,OAAe,IARA;EASfC,WAAe,EATA;EAUfC,aAAe,GAVA;EAWfC,cAAe;AAXA,CAAnB;;AAcA,SAASC,UAAT,CAAoBC,GAApB,EAAyB;EACrB,OAAOA,IAAI,CAAJA,EAAOC,WAAPD,KAAuBA,IAAIE,KAAJF,CAAU,CAAVA,CAA9B;AACH;;IAEKG,W;EAEF,qBAAYC,OAAZ,EAAqB;IAAAC;;IACjB,KAAKD,OAAL,GAAeA,OAAf;EACH;;wBAEDE,Y,mBAAUC,I,EAAMC,S,EAAW;IACvB,KAAKD,KAAKE,IAAV,EAAgBF,IAAhB,EAAsBC,SAAtB;;;wBAGJE,O,cAAKH,I,EAAM;IACP,KAAKI,IAAL,CAAUJ,IAAV;IACA,IAAKA,KAAKK,IAALL,CAAUZ,KAAf,EAAuB,KAAKS,OAAL,CAAaG,KAAKK,IAALL,CAAUZ,KAAvB;;;wBAG3BkB,U,iBAAQN,I,EAAM;IACV,IAAIO,OAAQ,KAAKC,GAAL,CAASR,IAAT,EAAe,MAAf,EAAwB,aAAxB,CAAZ;IACA,IAAIS,QAAQ,KAAKD,GAAL,CAASR,IAAT,EAAe,OAAf,EAAwB,cAAxB,CAAZ;IACA,KAAKH,OAAL,CAAa,OAAOU,IAAP,GAAcP,KAAKU,IAAnB,GAA0BD,KAA1B,GAAkC,IAA/C,EAAqDT,IAArD;;;wBAGJW,O,cAAKX,I,EAAMC,S,EAAW;IAClB,IAAIW,UAAU,KAAKJ,GAAL,CAASR,IAAT,EAAe,SAAf,EAA0B,OAA1B,CAAd;IACA,IAAIa,SAAUb,KAAKc,IAALd,GAAYY,OAAZZ,GAAsB,KAAKe,QAAL,CAAcf,IAAd,EAAoB,OAApB,CAApC;;IAEA,IAAKA,KAAKgB,SAAV,EAAsB;MAClBH,UAAUb,KAAKK,IAALL,CAAUgB,SAAVhB,IAAuB,aAAjCa;IACH;;IAED,IAAKZ,SAAL,EAAiBY,UAAU,GAAVA;IACjB,KAAKhB,OAAL,CAAagB,MAAb,EAAqBb,IAArB;;;wBAGJiB,O,cAAKjB,I,EAAM;IACP,KAAKkB,KAAL,CAAWlB,IAAX,EAAiB,KAAKe,QAAL,CAAcf,IAAd,EAAoB,UAApB,CAAjB;;IACA,IAAKA,KAAKK,IAALL,CAAUmB,YAAf,EAA8B;MAC1B,KAAKtB,OAAL,CAAaG,KAAKK,IAALL,CAAUmB,YAAvB,EAAqCnB,IAArC,EAA2C,KAA3C;IACH;;;wBAGLoB,S,gBAAOpB,I,EAAMC,S,EAAW;IACpB,IAAIoB,OAAS,MAAMrB,KAAKqB,IAAxB;IACA,IAAIC,SAAStB,KAAKsB,MAALtB,GAAc,KAAKe,QAAL,CAAcf,IAAd,EAAoB,QAApB,CAAdA,GAA8C,EAA3D;;IAEA,IAAK,OAAOA,KAAKK,IAALL,CAAUuB,SAAjB,KAA+B,WAApC,EAAkD;MAC9CF,QAAQrB,KAAKK,IAALL,CAAUuB,SAAlBF;IADJ,OAEO,IAAKC,MAAL,EAAc;MACjBD,QAAQ,GAARA;IACH;;IAED,IAAKrB,KAAKwB,KAAV,EAAkB;MACd,KAAKN,KAAL,CAAWlB,IAAX,EAAiBqB,OAAOC,MAAxB;IADJ,OAEO;MACH,IAAIG,MAAM,CAACzB,KAAKK,IAALL,CAAUY,OAAVZ,IAAqB,EAAtB,KAA6BC,YAAY,GAAZA,GAAkB,EAA/C,CAAV;MACA,KAAKJ,OAAL,CAAawB,OAAOC,MAAPD,GAAgBI,GAA7B,EAAkCzB,IAAlC;IACH;;;wBAGLI,O,cAAKJ,I,EAAM;IACP,IAAI0B,OAAO1B,KAAKwB,KAALxB,CAAW2B,MAAX3B,GAAoB,CAA/B;;IACA,OAAQ0B,OAAO,CAAf,EAAmB;MACf,IAAK1B,KAAKwB,KAALxB,CAAW0B,IAAX1B,EAAiBE,IAAjBF,KAA0B,SAA/B,EAA2C;MAC3C0B,QAAQ,CAARA;IACH;;IAED,IAAIzB,YAAY,KAAKO,GAAL,CAASR,IAAT,EAAe,WAAf,CAAhB;;IACA,KAAM,IAAI4B,IAAI,CAAd,EAAiBA,IAAI5B,KAAKwB,KAALxB,CAAW2B,MAAhC,EAAwCC,GAAxC,EAA8C;MAC1C,IAAIC,QAAS7B,KAAKwB,KAALxB,CAAW4B,CAAX5B,CAAb;MACA,IAAI8B,SAAS,KAAKtB,GAAL,CAASqB,KAAT,EAAgB,QAAhB,CAAb;MACA,IAAKC,MAAL,EAAc,KAAKjC,OAAL,CAAaiC,MAAb;MACd,KAAK/B,SAAL,CAAe8B,KAAf,EAAsBH,SAASE,CAATF,IAAczB,SAApC;IACH;;;wBAGLiB,Q,eAAMlB,I,EAAM+B,K,EAAO;IACf,IAAInB,UAAU,KAAKJ,GAAL,CAASR,IAAT,EAAe,SAAf,EAA0B,YAA1B,CAAd;IACA,KAAKH,OAAL,CAAakC,QAAQnB,OAARmB,GAAkB,GAA/B,EAAoC/B,IAApC,EAA0C,OAA1C;IAEA,IAAIZ,cAAJ;;IACA,IAAKY,KAAKwB,KAALxB,IAAcA,KAAKwB,KAALxB,CAAW2B,MAA9B,EAAuC;MACnC,KAAKvB,IAAL,CAAUJ,IAAV;MACAZ,QAAQ,KAAKoB,GAAL,CAASR,IAAT,EAAe,OAAf,CAARZ;IAFJ,OAGO;MACHA,QAAQ,KAAKoB,GAAL,CAASR,IAAT,EAAe,OAAf,EAAwB,WAAxB,CAARZ;IACH;;IAED,IAAKA,KAAL,EAAa,KAAKS,OAAL,CAAaT,KAAb;IACb,KAAKS,OAAL,CAAa,GAAb,EAAkBG,IAAlB,EAAwB,KAAxB;;;wBAGJQ,M,aAAIR,I,EAAMgC,G,EAAKC,M,EAAQ;IACnB,IAAIC,cAAJ;IACA,IAAK,CAACD,MAAN,EAAeA,SAASD,GAATC,CAFI,CAInB;;IACA,IAAKD,GAAL,EAAW;MACPE,QAAQlC,KAAKK,IAALL,CAAUgC,GAAVhC,CAARkC;MACA,IAAK,OAAOA,KAAP,KAAiB,WAAtB,EAAoC,OAAOA,KAAP;IACvC;;IAED,IAAIC,SAASnC,KAAKmC,MAAlB,CAVmB,CAYnB;;IACA,IAAKF,WAAW,QAAhB,EAA2B;MACvB,IAAK,CAACE,MAAD,IAAWA,OAAOjC,IAAPiC,KAAgB,MAAhBA,IAA0BA,OAAOC,KAAPD,KAAiBnC,IAA3D,EAAkE;QAC9D,OAAO,EAAP;MACH;IACJ,CAjBkB,CAmBnB;;;IACA,IAAK,CAACmC,MAAN,EAAe,OAAOvD,WAAWqD,MAAXrD,CAAP,CApBI,CAsBnB;;IACA,IAAIuB,OAAOH,KAAKG,IAALH,EAAX;IACA,IAAK,CAACG,KAAKkC,QAAX,EAAsBlC,KAAKkC,QAALlC,GAAgB,EAAhBA;;IACtB,IAAK,OAAOA,KAAKkC,QAALlC,CAAc8B,MAAd9B,CAAP,KAAiC,WAAtC,EAAoD;MAChD,OAAOA,KAAKkC,QAALlC,CAAc8B,MAAd9B,CAAP;IACH;;IAED,IAAK8B,WAAW,QAAXA,IAAuBA,WAAW,OAAvC,EAAiD;MAC7C,OAAO,KAAKK,WAAL,CAAiBtC,IAAjB,EAAuBiC,MAAvB,CAAP;IADJ,OAEO;MACH,IAAIM,SAAS,QAAQ/C,WAAWyC,MAAXzC,CAArB;;MACA,IAAK,KAAK+C,MAAL,CAAL,EAAoB;QAChBL,QAAQ,KAAKK,MAAL,EAAapC,IAAb,EAAmBH,IAAnB,CAARkC;MADJ,OAEO;QACH/B,KAAKqC,IAALrC,CAAW,aAAK;UACZ+B,QAAQN,EAAEvB,IAAFuB,CAAOI,GAAPJ,CAARM;UACA,IAAK,OAAOA,KAAP,KAAiB,WAAtB,EAAoC,OAAO,KAAP;QAFxC;MAIH;IACJ;;IAED,IAAK,OAAOA,KAAP,KAAiB,WAAtB,EAAoCA,QAAQtD,WAAWqD,MAAXrD,CAARsD;IAEpC/B,KAAKkC,QAALlC,CAAc8B,MAAd9B,IAAwB+B,KAAxB/B;IACA,OAAO+B,KAAP;;;wBAGJO,e,sBAAatC,I,EAAM;IACf,IAAI+B,cAAJ;IACA/B,KAAKqC,IAALrC,CAAW,aAAK;MACZ,IAAKyB,EAAEJ,KAAFI,IAAWA,EAAEJ,KAAFI,CAAQD,MAAnBC,IAA6BA,EAAEF,IAAFE,CAAO1B,IAAP0B,KAAgB,MAAlD,EAA2D;QACvDM,QAAQN,EAAEvB,IAAFuB,CAAO3B,SAAfiC;QACA,IAAK,OAAOA,KAAP,KAAiB,WAAtB,EAAoC,OAAO,KAAP;MACvC;IAJL;IAMA,OAAOA,KAAP;;;wBAGJQ,e,sBAAavC,I,EAAM;IACf,IAAI+B,cAAJ;IACA/B,KAAKqC,IAALrC,CAAW,aAAK;MACZ,IAAKyB,EAAEJ,KAAFI,IAAWA,EAAEJ,KAAFI,CAAQD,MAARC,KAAmB,CAAnC,EAAuC;QACnCM,QAAQN,EAAEvB,IAAFuB,CAAOxC,KAAf8C;QACA,IAAK,OAAOA,KAAP,KAAiB,WAAtB,EAAoC,OAAO,KAAP;MACvC;IAJL;IAMA,OAAOA,KAAP;;;wBAGJS,Y,mBAAUxC,I,EAAM;IACZ,IAAKA,KAAKE,IAALF,CAAUrB,MAAf,EAAwB,OAAOqB,KAAKE,IAALF,CAAUrB,MAAjB;IACxB,IAAIoD,cAAJ;IACA/B,KAAKqC,IAALrC,CAAW,aAAK;MACZ,IAAIyC,IAAIhB,EAAEO,MAAV;;MACA,IAAKS,KAAKA,MAAMzC,IAAXyC,IAAmBA,EAAET,MAArBS,IAA+BA,EAAET,MAAFS,KAAazC,IAAjD,EAAwD;QACpD,IAAK,OAAOyB,EAAEvB,IAAFuB,CAAOE,MAAd,KAAyB,WAA9B,EAA4C;UACxC,IAAIe,QAAQjB,EAAEvB,IAAFuB,CAAOE,MAAPF,CAAckB,KAAdlB,CAAoB,IAApBA,CAAZ;UACAM,QAAQW,MAAMA,MAAMlB,MAANkB,GAAe,CAArBA,CAARX;UACAA,QAAQA,MAAMa,OAANb,CAAc,QAAdA,EAAwB,EAAxBA,CAARA;UACA,OAAO,KAAP;QACH;MACJ;IATL;IAWA,OAAOA,KAAP;;;wBAGJc,mB,0BAAiB7C,I,EAAMH,I,EAAM;IACzB,IAAIkC,cAAJ;IACA/B,KAAK8C,YAAL9C,CAAmB,aAAK;MACpB,IAAK,OAAOyB,EAAEvB,IAAFuB,CAAOE,MAAd,KAAyB,WAA9B,EAA4C;QACxCI,QAAQN,EAAEvB,IAAFuB,CAAOE,MAAfI;;QACA,IAAKA,MAAMgB,OAANhB,CAAc,IAAdA,MAAwB,CAAC,CAA9B,EAAkC;UAC9BA,QAAQA,MAAMa,OAANb,CAAc,SAAdA,EAAyB,EAAzBA,CAARA;QACH;;QACD,OAAO,KAAP;MACH;IAPL;;IASA,IAAK,OAAOA,KAAP,KAAiB,WAAtB,EAAoC;MAChCA,QAAQ,KAAK1B,GAAL,CAASR,IAAT,EAAe,IAAf,EAAqB,YAArB,CAARkC;IADJ,OAEO,IAAKA,KAAL,EAAa;MAChBA,QAAQA,MAAMa,OAANb,CAAc,QAAdA,EAAwB,EAAxBA,CAARA;IACH;;IACD,OAAOA,KAAP;;;wBAGJiB,gB,uBAAchD,I,EAAMH,I,EAAM;IACtB,IAAIkC,cAAJ;IACA/B,KAAKiD,SAALjD,CAAgB,aAAK;MACjB,IAAK,OAAOyB,EAAEvB,IAAFuB,CAAOE,MAAd,KAAyB,WAA9B,EAA4C;QACxCI,QAAQN,EAAEvB,IAAFuB,CAAOE,MAAfI;;QACA,IAAKA,MAAMgB,OAANhB,CAAc,IAAdA,MAAwB,CAAC,CAA9B,EAAkC;UAC9BA,QAAQA,MAAMa,OAANb,CAAc,SAAdA,EAAyB,EAAzBA,CAARA;QACH;;QACD,OAAO,KAAP;MACH;IAPL;;IASA,IAAK,OAAOA,KAAP,KAAiB,WAAtB,EAAoC;MAChCA,QAAQ,KAAK1B,GAAL,CAASR,IAAT,EAAe,IAAf,EAAqB,YAArB,CAARkC;IADJ,OAEO,IAAKA,KAAL,EAAa;MAChBA,QAAQA,MAAMa,OAANb,CAAc,QAAdA,EAAwB,EAAxBA,CAARA;IACH;;IACD,OAAOA,KAAP;;;wBAGJmB,gB,uBAAclD,I,EAAM;IAChB,IAAI+B,cAAJ;IACA/B,KAAKqC,IAALrC,CAAW,aAAK;MACZ,IAAKyB,EAAEJ,KAAFI,KAAYA,EAAEO,MAAFP,KAAazB,IAAbyB,IAAqBzB,KAAKiC,KAALjC,KAAeyB,CAAhDA,CAAL,EAA0D;QACtD,IAAK,OAAOA,EAAEvB,IAAFuB,CAAOE,MAAd,KAAyB,WAA9B,EAA4C;UACxCI,QAAQN,EAAEvB,IAAFuB,CAAOE,MAAfI;;UACA,IAAKA,MAAMgB,OAANhB,CAAc,IAAdA,MAAwB,CAAC,CAA9B,EAAkC;YAC9BA,QAAQA,MAAMa,OAANb,CAAc,SAAdA,EAAyB,EAAzBA,CAARA;UACH;;UACD,OAAO,KAAP;QACH;MACJ;IATL;IAWA,IAAKA,KAAL,EAAaA,QAAQA,MAAMa,OAANb,CAAc,QAAdA,EAAwB,EAAxBA,CAARA;IACb,OAAOA,KAAP;;;wBAGJoB,iB,wBAAenD,I,EAAM;IACjB,IAAI+B,cAAJ;IACA/B,KAAKqC,IAALrC,CAAW,aAAK;MACZ,IAAKyB,EAAEJ,KAAFI,IAAWA,EAAEJ,KAAFI,CAAQD,MAARC,GAAiB,CAAjC,EAAqC;QACjC,IAAK,OAAOA,EAAEvB,IAAFuB,CAAOxC,KAAd,KAAwB,WAA7B,EAA2C;UACvC8C,QAAQN,EAAEvB,IAAFuB,CAAOxC,KAAf8C;;UACA,IAAKA,MAAMgB,OAANhB,CAAc,IAAdA,MAAwB,CAAC,CAA9B,EAAkC;YAC9BA,QAAQA,MAAMa,OAANb,CAAc,SAAdA,EAAyB,EAAzBA,CAARA;UACH;;UACD,OAAO,KAAP;QACH;MACJ;IATL;IAWA,IAAKA,KAAL,EAAaA,QAAQA,MAAMa,OAANb,CAAc,QAAdA,EAAwB,EAAxBA,CAARA;IACb,OAAOA,KAAP;;;wBAGJqB,gB,uBAAcpD,I,EAAM;IAChB,IAAI+B,cAAJ;IACA/B,KAAKqC,IAALrC,CAAW,aAAK;MACZ,IAAKyB,EAAE1B,IAAF0B,KAAW,MAAhB,EAAyB;QACrBM,QAAQN,EAAEvB,IAAFuB,CAAOhB,OAAfsB;QACA,IAAK,OAAOA,KAAP,KAAiB,WAAtB,EAAoC,OAAO,KAAP;MACvC;IAJL;IAMA,OAAOA,KAAP;;;wBAGJsB,W,kBAASrD,I,EAAM;IACX,IAAI+B,cAAJ;IACA/B,KAAKiD,SAALjD,CAAgB,aAAK;MACjB,IAAK,OAAOyB,EAAEvB,IAAFuB,CAAOhB,OAAd,KAA0B,WAA/B,EAA6C;QACzCsB,QAAQN,EAAEvB,IAAFuB,CAAOhB,OAAPgB,CAAemB,OAAfnB,CAAuB,SAAvBA,EAAkC,EAAlCA,CAARM;QACA,OAAO,KAAP;MACH;IAJL;IAMA,OAAOA,KAAP;;;wBAGJI,c,qBAAYtC,I,EAAMiC,M,EAAQ;IACtB,IAAIC,cAAJ;;IACA,IAAKlC,KAAKE,IAALF,KAAc,MAAnB,EAA4B;MACxBkC,QAAQ,KAAK1B,GAAL,CAASR,IAAT,EAAe,IAAf,EAAqB,YAArB,CAARkC;IADJ,OAEO,IAAKlC,KAAKE,IAALF,KAAc,SAAnB,EAA+B;MAClCkC,QAAQ,KAAK1B,GAAL,CAASR,IAAT,EAAe,IAAf,EAAqB,eAArB,CAARkC;IADG,OAEA,IAAKD,WAAW,QAAhB,EAA2B;MAC9BC,QAAQ,KAAK1B,GAAL,CAASR,IAAT,EAAe,IAAf,EAAqB,YAArB,CAARkC;IADG,OAEA;MACHA,QAAQ,KAAK1B,GAAL,CAASR,IAAT,EAAe,IAAf,EAAqB,aAArB,CAARkC;IACH;;IAED,IAAIuB,MAAQzD,KAAKmC,MAAjB;IACA,IAAIuB,QAAQ,CAAZ;;IACA,OAAQD,OAAOA,IAAIvD,IAAJuD,KAAa,MAA5B,EAAqC;MACjCC,SAAS,CAATA;MACAD,MAAMA,IAAItB,MAAVsB;IACH;;IAED,IAAKvB,MAAMgB,OAANhB,CAAc,IAAdA,MAAwB,CAAC,CAA9B,EAAkC;MAC9B,IAAIpD,SAAS,KAAK0B,GAAL,CAASR,IAAT,EAAe,IAAf,EAAqB,QAArB,CAAb;;MACA,IAAKlB,OAAO6C,MAAZ,EAAqB;QACjB,KAAM,IAAIgC,OAAO,CAAjB,EAAoBA,OAAOD,KAA3B,EAAkCC,MAAlC;UAA2CzB,SAASpD,MAAToD;QAA3C;MACH;IACJ;;IAED,OAAOA,KAAP;;;wBAGJnB,W,kBAASf,I,EAAMc,I,EAAM;IACjB,IAAIoB,QAAQlC,KAAKc,IAALd,CAAZ;IACA,IAAIQ,MAAQR,KAAKK,IAALL,CAAUc,IAAVd,CAAZ;;IACA,IAAKQ,OAAOA,IAAI0B,KAAJ1B,KAAc0B,KAA1B,EAAkC;MAC9B,OAAO1B,IAAIA,GAAX;IADJ,OAEO;MACH,OAAO0B,KAAP;IACH;;;;;;kBAKMtC","names":["defaultRaw","colon","indent","beforeDecl","beforeRule","beforeOpen","beforeClose","beforeComment","after","emptyBody","commentLeft","commentRight","capitalize","str","toUpperCase","slice","Stringifier","builder","_classCallCheck","stringify","node","semicolon","type","root","body","raws","comment","left","raw","right","text","decl","between","string","prop","rawValue","important","rule","block","ownSemicolon","atrule","name","params","afterName","nodes","end","last","length","i","child","before","start","own","detect","value","parent","first","rawCache","beforeAfter","method","walk","rawSemicolon","rawEmptyBody","rawIndent","p","parts","split","replace","rawBeforeComment","walkComments","indexOf","rawBeforeDecl","walkDecls","rawBeforeRule","rawBeforeClose","rawBeforeOpen","rawColon","buf","depth","step"],"sources":["stringifier.es6"],"sourcesContent":["const defaultRaw = {\n    colon:         ': ',\n    indent:        '    ',\n    beforeDecl:    '\\n',\n    beforeRule:    '\\n',\n    beforeOpen:    ' ',\n    beforeClose:   '\\n',\n    beforeComment: '\\n',\n    after:         '\\n',\n    emptyBody:     '',\n    commentLeft:   ' ',\n    commentRight:  ' '\n};\n\nfunction capitalize(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\n\nclass Stringifier {\n\n    constructor(builder) {\n        this.builder = builder;\n    }\n\n    stringify(node, semicolon) {\n        this[node.type](node, semicolon);\n    }\n\n    root(node) {\n        this.body(node);\n        if ( node.raws.after ) this.builder(node.raws.after);\n    }\n\n    comment(node) {\n        let left  = this.raw(node, 'left',  'commentLeft');\n        let right = this.raw(node, 'right', 'commentRight');\n        this.builder('/*' + left + node.text + right + '*/', node);\n    }\n\n    decl(node, semicolon) {\n        let between = this.raw(node, 'between', 'colon');\n        let string  = node.prop + between + this.rawValue(node, 'value');\n\n        if ( node.important ) {\n            string += node.raws.important || ' !important';\n        }\n\n        if ( semicolon ) string += ';';\n        this.builder(string, node);\n    }\n\n    rule(node) {\n        this.block(node, this.rawValue(node, 'selector'));\n        if ( node.raws.ownSemicolon ) {\n            this.builder(node.raws.ownSemicolon, node, 'end');\n        }\n    }\n\n    atrule(node, semicolon) {\n        let name   = '@' + node.name;\n        let params = node.params ? this.rawValue(node, 'params') : '';\n\n        if ( typeof node.raws.afterName !== 'undefined' ) {\n            name += node.raws.afterName;\n        } else if ( params ) {\n            name += ' ';\n        }\n\n        if ( node.nodes ) {\n            this.block(node, name + params);\n        } else {\n            let end = (node.raws.between || '') + (semicolon ? ';' : '');\n            this.builder(name + params + end, node);\n        }\n    }\n\n    body(node) {\n        let last = node.nodes.length - 1;\n        while ( last > 0 ) {\n            if ( node.nodes[last].type !== 'comment' ) break;\n            last -= 1;\n        }\n\n        let semicolon = this.raw(node, 'semicolon');\n        for ( let i = 0; i < node.nodes.length; i++ ) {\n            let child  = node.nodes[i];\n            let before = this.raw(child, 'before');\n            if ( before ) this.builder(before);\n            this.stringify(child, last !== i || semicolon);\n        }\n    }\n\n    block(node, start) {\n        let between = this.raw(node, 'between', 'beforeOpen');\n        this.builder(start + between + '{', node, 'start');\n\n        let after;\n        if ( node.nodes && node.nodes.length ) {\n            this.body(node);\n            after = this.raw(node, 'after');\n        } else {\n            after = this.raw(node, 'after', 'emptyBody');\n        }\n\n        if ( after ) this.builder(after);\n        this.builder('}', node, 'end');\n    }\n\n    raw(node, own, detect) {\n        let value;\n        if ( !detect ) detect = own;\n\n        // Already had\n        if ( own ) {\n            value = node.raws[own];\n            if ( typeof value !== 'undefined' ) return value;\n        }\n\n        let parent = node.parent;\n\n        // Hack for first rule in CSS\n        if ( detect === 'before' ) {\n            if ( !parent || parent.type === 'root' && parent.first === node ) {\n                return '';\n            }\n        }\n\n        // Floating child without parent\n        if ( !parent ) return defaultRaw[detect];\n\n        // Detect style by other nodes\n        let root = node.root();\n        if ( !root.rawCache ) root.rawCache = { };\n        if ( typeof root.rawCache[detect] !== 'undefined' ) {\n            return root.rawCache[detect];\n        }\n\n        if ( detect === 'before' || detect === 'after' ) {\n            return this.beforeAfter(node, detect);\n        } else {\n            let method = 'raw' + capitalize(detect);\n            if ( this[method] ) {\n                value = this[method](root, node);\n            } else {\n                root.walk( i => {\n                    value = i.raws[own];\n                    if ( typeof value !== 'undefined' ) return false;\n                });\n            }\n        }\n\n        if ( typeof value === 'undefined' ) value = defaultRaw[detect];\n\n        root.rawCache[detect] = value;\n        return value;\n    }\n\n    rawSemicolon(root) {\n        let value;\n        root.walk( i => {\n            if ( i.nodes && i.nodes.length && i.last.type === 'decl' ) {\n                value = i.raws.semicolon;\n                if ( typeof value !== 'undefined' ) return false;\n            }\n        });\n        return value;\n    }\n\n    rawEmptyBody(root) {\n        let value;\n        root.walk( i => {\n            if ( i.nodes && i.nodes.length === 0 ) {\n                value = i.raws.after;\n                if ( typeof value !== 'undefined' ) return false;\n            }\n        });\n        return value;\n    }\n\n    rawIndent(root) {\n        if ( root.raws.indent ) return root.raws.indent;\n        let value;\n        root.walk( i => {\n            let p = i.parent;\n            if ( p && p !== root && p.parent && p.parent === root ) {\n                if ( typeof i.raws.before !== 'undefined' ) {\n                    let parts = i.raws.before.split('\\n');\n                    value = parts[parts.length - 1];\n                    value = value.replace(/[^\\s]/g, '');\n                    return false;\n                }\n            }\n        });\n        return value;\n    }\n\n    rawBeforeComment(root, node) {\n        let value;\n        root.walkComments( i => {\n            if ( typeof i.raws.before !== 'undefined' ) {\n                value = i.raws.before;\n                if ( value.indexOf('\\n') !== -1 ) {\n                    value = value.replace(/[^\\n]+$/, '');\n                }\n                return false;\n            }\n        });\n        if ( typeof value === 'undefined' ) {\n            value = this.raw(node, null, 'beforeDecl');\n        } else if ( value ) {\n            value = value.replace(/[^\\s]/g, '');\n        }\n        return value;\n    }\n\n    rawBeforeDecl(root, node) {\n        let value;\n        root.walkDecls( i => {\n            if ( typeof i.raws.before !== 'undefined' ) {\n                value = i.raws.before;\n                if ( value.indexOf('\\n') !== -1 ) {\n                    value = value.replace(/[^\\n]+$/, '');\n                }\n                return false;\n            }\n        });\n        if ( typeof value === 'undefined' ) {\n            value = this.raw(node, null, 'beforeRule');\n        } else if ( value ) {\n            value = value.replace(/[^\\s]/g, '');\n        }\n        return value;\n    }\n\n    rawBeforeRule(root) {\n        let value;\n        root.walk( i => {\n            if ( i.nodes && (i.parent !== root || root.first !== i) ) {\n                if ( typeof i.raws.before !== 'undefined' ) {\n                    value = i.raws.before;\n                    if ( value.indexOf('\\n') !== -1 ) {\n                        value = value.replace(/[^\\n]+$/, '');\n                    }\n                    return false;\n                }\n            }\n        });\n        if ( value ) value = value.replace(/[^\\s]/g, '');\n        return value;\n    }\n\n    rawBeforeClose(root) {\n        let value;\n        root.walk( i => {\n            if ( i.nodes && i.nodes.length > 0 ) {\n                if ( typeof i.raws.after !== 'undefined' ) {\n                    value = i.raws.after;\n                    if ( value.indexOf('\\n') !== -1 ) {\n                        value = value.replace(/[^\\n]+$/, '');\n                    }\n                    return false;\n                }\n            }\n        });\n        if ( value ) value = value.replace(/[^\\s]/g, '');\n        return value;\n    }\n\n    rawBeforeOpen(root) {\n        let value;\n        root.walk( i => {\n            if ( i.type !== 'decl' ) {\n                value = i.raws.between;\n                if ( typeof value !== 'undefined' ) return false;\n            }\n        });\n        return value;\n    }\n\n    rawColon(root) {\n        let value;\n        root.walkDecls( i => {\n            if ( typeof i.raws.between !== 'undefined' ) {\n                value = i.raws.between.replace(/[^\\s:]/g, '');\n                return false;\n            }\n        });\n        return value;\n    }\n\n    beforeAfter(node, detect) {\n        let value;\n        if ( node.type === 'decl' ) {\n            value = this.raw(node, null, 'beforeDecl');\n        } else if ( node.type === 'comment' ) {\n            value = this.raw(node, null, 'beforeComment');\n        } else if ( detect === 'before' ) {\n            value = this.raw(node, null, 'beforeRule');\n        } else {\n            value = this.raw(node, null, 'beforeClose');\n        }\n\n        let buf   = node.parent;\n        let depth = 0;\n        while ( buf && buf.type !== 'root' ) {\n            depth += 1;\n            buf = buf.parent;\n        }\n\n        if ( value.indexOf('\\n') !== -1 ) {\n            let indent = this.raw(node, null, 'indent');\n            if ( indent.length ) {\n                for ( let step = 0; step < depth; step++ ) value += indent;\n            }\n        }\n\n        return value;\n    }\n\n    rawValue(node, prop) {\n        let value = node[prop];\n        let raw   = node.raws[prop];\n        if ( raw && raw.value === value ) {\n            return raw.raw;\n        } else {\n            return value;\n        }\n    }\n\n}\n\nexport default Stringifier;\n"]},"metadata":{},"sourceType":"module"}