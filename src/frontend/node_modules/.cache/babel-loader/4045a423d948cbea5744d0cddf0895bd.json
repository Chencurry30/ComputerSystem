{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _sourceMap = require('source-map');\n\nvar _sourceMap2 = _interopRequireDefault(_sourceMap);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar MapGenerator = function () {\n  function MapGenerator(stringify, root, opts) {\n    _classCallCheck(this, MapGenerator);\n\n    this.stringify = stringify;\n    this.mapOpts = opts.map || {};\n    this.root = root;\n    this.opts = opts;\n  }\n\n  MapGenerator.prototype.isMap = function isMap() {\n    if (typeof this.opts.map !== 'undefined') {\n      return !!this.opts.map;\n    } else {\n      return this.previous().length > 0;\n    }\n  };\n\n  MapGenerator.prototype.previous = function previous() {\n    var _this = this;\n\n    if (!this.previousMaps) {\n      this.previousMaps = [];\n      this.root.walk(function (node) {\n        if (node.source && node.source.input.map) {\n          var map = node.source.input.map;\n\n          if (_this.previousMaps.indexOf(map) === -1) {\n            _this.previousMaps.push(map);\n          }\n        }\n      });\n    }\n\n    return this.previousMaps;\n  };\n\n  MapGenerator.prototype.isInline = function isInline() {\n    if (typeof this.mapOpts.inline !== 'undefined') {\n      return this.mapOpts.inline;\n    }\n\n    var annotation = this.mapOpts.annotation;\n\n    if (typeof annotation !== 'undefined' && annotation !== true) {\n      return false;\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(function (i) {\n        return i.inline;\n      });\n    } else {\n      return true;\n    }\n  };\n\n  MapGenerator.prototype.isSourcesContent = function isSourcesContent() {\n    if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n      return this.mapOpts.sourcesContent;\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(function (i) {\n        return i.withContent();\n      });\n    } else {\n      return true;\n    }\n  };\n\n  MapGenerator.prototype.clearAnnotation = function clearAnnotation() {\n    if (this.mapOpts.annotation === false) return;\n    var node = void 0;\n\n    for (var i = this.root.nodes.length - 1; i >= 0; i--) {\n      node = this.root.nodes[i];\n      if (node.type !== 'comment') continue;\n\n      if (node.text.indexOf('# sourceMappingURL=') === 0) {\n        this.root.removeChild(i);\n      }\n    }\n  };\n\n  MapGenerator.prototype.setSourcesContent = function setSourcesContent() {\n    var _this2 = this;\n\n    var already = {};\n    this.root.walk(function (node) {\n      if (node.source) {\n        var from = node.source.input.from;\n\n        if (from && !already[from]) {\n          already[from] = true;\n\n          var relative = _this2.relative(from);\n\n          _this2.map.setSourceContent(relative, node.source.input.css);\n        }\n      }\n    });\n  };\n\n  MapGenerator.prototype.applyPrevMaps = function applyPrevMaps() {\n    for (var _iterator = this.previous(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var prev = _ref;\n      var from = this.relative(prev.file);\n\n      var root = prev.root || _path2.default.dirname(prev.file);\n\n      var map = void 0;\n\n      if (this.mapOpts.sourcesContent === false) {\n        map = new _sourceMap2.default.SourceMapConsumer(prev.text);\n\n        if (map.sourcesContent) {\n          map.sourcesContent = map.sourcesContent.map(function () {\n            return null;\n          });\n        }\n      } else {\n        map = prev.consumer();\n      }\n\n      this.map.applySourceMap(map, from, this.relative(root));\n    }\n  };\n\n  MapGenerator.prototype.isAnnotation = function isAnnotation() {\n    if (this.isInline()) {\n      return true;\n    } else if (typeof this.mapOpts.annotation !== 'undefined') {\n      return this.mapOpts.annotation;\n    } else if (this.previous().length) {\n      return this.previous().some(function (i) {\n        return i.annotation;\n      });\n    } else {\n      return true;\n    }\n  };\n\n  MapGenerator.prototype.toBase64 = function toBase64(str) {\n    if (Buffer) {\n      if (Buffer.from && Buffer.from !== Uint8Array.from) {\n        return Buffer.from(str).toString('base64');\n      } else {\n        return new Buffer(str).toString('base64');\n      }\n    } else {\n      return window.btoa(unescape(encodeURIComponent(str)));\n    }\n  };\n\n  MapGenerator.prototype.addAnnotation = function addAnnotation() {\n    var content = void 0;\n\n    if (this.isInline()) {\n      content = 'data:application/json;base64,' + this.toBase64(this.map.toString());\n    } else if (typeof this.mapOpts.annotation === 'string') {\n      content = this.mapOpts.annotation;\n    } else {\n      content = this.outputFile() + '.map';\n    }\n\n    var eol = '\\n';\n    if (this.css.indexOf('\\r\\n') !== -1) eol = '\\r\\n';\n    this.css += eol + '/*# sourceMappingURL=' + content + ' */';\n  };\n\n  MapGenerator.prototype.outputFile = function outputFile() {\n    if (this.opts.to) {\n      return this.relative(this.opts.to);\n    } else if (this.opts.from) {\n      return this.relative(this.opts.from);\n    } else {\n      return 'to.css';\n    }\n  };\n\n  MapGenerator.prototype.generateMap = function generateMap() {\n    this.generateString();\n    if (this.isSourcesContent()) this.setSourcesContent();\n    if (this.previous().length > 0) this.applyPrevMaps();\n    if (this.isAnnotation()) this.addAnnotation();\n\n    if (this.isInline()) {\n      return [this.css];\n    } else {\n      return [this.css, this.map];\n    }\n  };\n\n  MapGenerator.prototype.relative = function relative(file) {\n    if (file.indexOf('<') === 0) return file;\n    if (/^\\w+:\\/\\//.test(file)) return file;\n    var from = this.opts.to ? _path2.default.dirname(this.opts.to) : '.';\n\n    if (typeof this.mapOpts.annotation === 'string') {\n      from = _path2.default.dirname(_path2.default.resolve(from, this.mapOpts.annotation));\n    }\n\n    file = _path2.default.relative(from, file);\n\n    if (_path2.default.sep === '\\\\') {\n      return file.replace(/\\\\/g, '/');\n    } else {\n      return file;\n    }\n  };\n\n  MapGenerator.prototype.sourcePath = function sourcePath(node) {\n    if (this.mapOpts.from) {\n      return this.mapOpts.from;\n    } else {\n      return this.relative(node.source.input.from);\n    }\n  };\n\n  MapGenerator.prototype.generateString = function generateString() {\n    var _this3 = this;\n\n    this.css = '';\n    this.map = new _sourceMap2.default.SourceMapGenerator({\n      file: this.outputFile()\n    });\n    var line = 1;\n    var column = 1;\n    var lines = void 0,\n        last = void 0;\n    this.stringify(this.root, function (str, node, type) {\n      _this3.css += str;\n\n      if (node && type !== 'end') {\n        if (node.source && node.source.start) {\n          _this3.map.addMapping({\n            source: _this3.sourcePath(node),\n            generated: {\n              line: line,\n              column: column - 1\n            },\n            original: {\n              line: node.source.start.line,\n              column: node.source.start.column - 1\n            }\n          });\n        } else {\n          _this3.map.addMapping({\n            source: '<no source>',\n            original: {\n              line: 1,\n              column: 0\n            },\n            generated: {\n              line: line,\n              column: column - 1\n            }\n          });\n        }\n      }\n\n      lines = str.match(/\\n/g);\n\n      if (lines) {\n        line += lines.length;\n        last = str.lastIndexOf('\\n');\n        column = str.length - last;\n      } else {\n        column += str.length;\n      }\n\n      if (node && type !== 'start') {\n        if (node.source && node.source.end) {\n          _this3.map.addMapping({\n            source: _this3.sourcePath(node),\n            generated: {\n              line: line,\n              column: column - 1\n            },\n            original: {\n              line: node.source.end.line,\n              column: node.source.end.column\n            }\n          });\n        } else {\n          _this3.map.addMapping({\n            source: '<no source>',\n            original: {\n              line: 1,\n              column: 0\n            },\n            generated: {\n              line: line,\n              column: column - 1\n            }\n          });\n        }\n      }\n    });\n  };\n\n  MapGenerator.prototype.generate = function generate() {\n    this.clearAnnotation();\n\n    if (this.isMap()) {\n      return this.generateMap();\n    } else {\n      var result = '';\n      this.stringify(this.root, function (i) {\n        result += i;\n      });\n      return [result];\n    }\n  };\n\n  return MapGenerator;\n}();\n\nexports.default = MapGenerator;\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["MapGenerator","stringify","root","opts","_classCallCheck","mapOpts","map","isMap","previous","length","previousMaps","walk","node","source","input","_this","indexOf","push","isInline","inline","annotation","some","i","isSourcesContent","sourcesContent","withContent","clearAnnotation","nodes","type","text","removeChild","setSourcesContent","already","from","relative","_this2","setSourceContent","css","applyPrevMaps","_ref","_i","prev","file","path","dirname","mozilla","SourceMapConsumer","consumer","applySourceMap","isAnnotation","toBase64","str","Buffer","Uint8Array","toString","window","btoa","unescape","encodeURIComponent","addAnnotation","content","outputFile","eol","to","generateMap","generateString","test","resolve","sep","replace","sourcePath","SourceMapGenerator","line","column","lines","last","_this3","start","addMapping","generated","original","match","lastIndexOf","end","generate","result"],"sources":["map-generator.es6"],"sourcesContent":["import mozilla from 'source-map';\nimport path    from 'path';\n\nexport default class MapGenerator {\n\n    constructor(stringify, root, opts) {\n        this.stringify = stringify;\n        this.mapOpts   = opts.map || { };\n        this.root      = root;\n        this.opts      = opts;\n    }\n\n    isMap() {\n        if ( typeof this.opts.map !== 'undefined' ) {\n            return !!this.opts.map;\n        } else {\n            return this.previous().length > 0;\n        }\n    }\n\n    previous() {\n        if ( !this.previousMaps ) {\n            this.previousMaps = [];\n            this.root.walk( node => {\n                if ( node.source && node.source.input.map ) {\n                    let map = node.source.input.map;\n                    if ( this.previousMaps.indexOf(map) === -1 ) {\n                        this.previousMaps.push(map);\n                    }\n                }\n            });\n        }\n\n        return this.previousMaps;\n    }\n\n    isInline() {\n        if ( typeof this.mapOpts.inline !== 'undefined' ) {\n            return this.mapOpts.inline;\n        }\n\n        let annotation = this.mapOpts.annotation;\n        if ( typeof annotation !== 'undefined' && annotation !== true ) {\n            return false;\n        }\n\n        if ( this.previous().length ) {\n            return this.previous().some( i => i.inline );\n        } else {\n            return true;\n        }\n    }\n\n    isSourcesContent() {\n        if ( typeof this.mapOpts.sourcesContent !== 'undefined' ) {\n            return this.mapOpts.sourcesContent;\n        }\n        if ( this.previous().length ) {\n            return this.previous().some( i => i.withContent() );\n        } else {\n            return true;\n        }\n    }\n\n    clearAnnotation() {\n        if ( this.mapOpts.annotation === false ) return;\n\n        let node;\n        for ( let i = this.root.nodes.length - 1; i >= 0; i-- ) {\n            node = this.root.nodes[i];\n            if ( node.type !== 'comment' ) continue;\n            if ( node.text.indexOf('# sourceMappingURL=') === 0 ) {\n                this.root.removeChild(i);\n            }\n        }\n    }\n\n    setSourcesContent() {\n        let already = { };\n        this.root.walk( node => {\n            if ( node.source ) {\n                let from = node.source.input.from;\n                if ( from && !already[from] ) {\n                    already[from] = true;\n                    let relative = this.relative(from);\n                    this.map.setSourceContent(relative, node.source.input.css);\n                }\n            }\n        });\n    }\n\n    applyPrevMaps() {\n        for ( let prev of this.previous() ) {\n            let from = this.relative(prev.file);\n            let root = prev.root || path.dirname(prev.file);\n            let map;\n\n            if ( this.mapOpts.sourcesContent === false ) {\n                map = new mozilla.SourceMapConsumer(prev.text);\n                if ( map.sourcesContent ) {\n                    map.sourcesContent = map.sourcesContent.map( () => null );\n                }\n            } else {\n                map = prev.consumer();\n            }\n\n            this.map.applySourceMap(map, from, this.relative(root));\n        }\n    }\n\n    isAnnotation() {\n        if ( this.isInline() ) {\n            return true;\n        } else if ( typeof this.mapOpts.annotation !== 'undefined' ) {\n            return this.mapOpts.annotation;\n        } else if ( this.previous().length ) {\n            return this.previous().some( i => i.annotation );\n        } else {\n            return true;\n        }\n    }\n\n    toBase64(str) {\n        if ( Buffer ) {\n            if ( Buffer.from && Buffer.from !== Uint8Array.from ) {\n                return Buffer.from(str).toString('base64');\n            } else {\n                return new Buffer(str).toString('base64');\n            }\n        } else {\n            return window.btoa(unescape(encodeURIComponent(str)));\n        }\n    }\n\n    addAnnotation() {\n        let content;\n\n        if ( this.isInline() ) {\n\n            content = 'data:application/json;base64,' +\n                this.toBase64(this.map.toString());\n\n        } else if ( typeof this.mapOpts.annotation === 'string' ) {\n            content = this.mapOpts.annotation;\n\n        } else {\n            content = this.outputFile() + '.map';\n        }\n\n        let eol   = '\\n';\n        if ( this.css.indexOf('\\r\\n') !== -1 ) eol = '\\r\\n';\n\n        this.css += eol + '/*# sourceMappingURL=' + content + ' */';\n    }\n\n    outputFile() {\n        if ( this.opts.to ) {\n            return this.relative(this.opts.to);\n        } else if ( this.opts.from ) {\n            return this.relative(this.opts.from);\n        } else {\n            return 'to.css';\n        }\n    }\n\n    generateMap() {\n        this.generateString();\n        if ( this.isSourcesContent() )    this.setSourcesContent();\n        if ( this.previous().length > 0 ) this.applyPrevMaps();\n        if ( this.isAnnotation() )        this.addAnnotation();\n\n        if ( this.isInline() ) {\n            return [this.css];\n        } else {\n            return [this.css, this.map];\n        }\n    }\n\n    relative(file) {\n        if ( file.indexOf('<') === 0 ) return file;\n        if ( /^\\w+:\\/\\//.test(file) ) return file;\n\n        let from = this.opts.to ? path.dirname(this.opts.to) : '.';\n\n        if ( typeof this.mapOpts.annotation === 'string' ) {\n            from = path.dirname( path.resolve(from, this.mapOpts.annotation) );\n        }\n\n        file = path.relative(from, file);\n        if ( path.sep === '\\\\' ) {\n            return file.replace(/\\\\/g, '/');\n        } else {\n            return file;\n        }\n    }\n\n    sourcePath(node) {\n        if ( this.mapOpts.from ) {\n            return this.mapOpts.from;\n        } else {\n            return this.relative(node.source.input.from);\n        }\n    }\n\n    generateString() {\n        this.css = '';\n        this.map = new mozilla.SourceMapGenerator({ file: this.outputFile() });\n\n        let line   = 1;\n        let column = 1;\n\n        let lines, last;\n        this.stringify(this.root, (str, node, type) => {\n            this.css += str;\n\n            if ( node && type !== 'end' ) {\n                if ( node.source && node.source.start ) {\n                    this.map.addMapping({\n                        source:    this.sourcePath(node),\n                        generated: { line, column: column - 1 },\n                        original:  {\n                            line:   node.source.start.line,\n                            column: node.source.start.column - 1\n                        }\n                    });\n                } else {\n                    this.map.addMapping({\n                        source:    '<no source>',\n                        original:  { line: 1, column: 0 },\n                        generated: { line, column: column - 1 }\n                    });\n                }\n            }\n\n            lines = str.match(/\\n/g);\n            if ( lines ) {\n                line  += lines.length;\n                last   = str.lastIndexOf('\\n');\n                column = str.length - last;\n            } else {\n                column += str.length;\n            }\n\n            if ( node && type !== 'start' ) {\n                if ( node.source && node.source.end ) {\n                    this.map.addMapping({\n                        source:    this.sourcePath(node),\n                        generated: { line, column: column - 1 },\n                        original:  {\n                            line:   node.source.end.line,\n                            column: node.source.end.column\n                        }\n                    });\n                } else {\n                    this.map.addMapping({\n                        source:    '<no source>',\n                        original:  { line: 1, column: 0 },\n                        generated: { line, column: column - 1 }\n                    });\n                }\n            }\n        });\n    }\n\n    generate() {\n        this.clearAnnotation();\n\n        if ( this.isMap() ) {\n            return this.generateMap();\n        } else {\n            let result = '';\n            this.stringify(this.root, i => {\n                result += i;\n            });\n            return [result];\n        }\n    }\n\n}\n"]},"metadata":{},"sourceType":"module"}