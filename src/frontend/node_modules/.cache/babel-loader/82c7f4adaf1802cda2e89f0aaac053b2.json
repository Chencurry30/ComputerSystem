{"ast":null,"code":"// Random number generator - requires a PRNG backend, e.g. prng4.js\nimport { prng_newstate, rng_psize } from \"./prng4\";\nvar rng_state;\nvar rng_pool = null;\nvar rng_pptr; // Initialize the pool with junk if needed.\n\nif (rng_pool == null) {\n  rng_pool = [];\n  rng_pptr = 0;\n  var t = void 0;\n\n  if (window.crypto && window.crypto.getRandomValues) {\n    // Extract entropy (2048 bits) from RNG if available\n    var z = new Uint32Array(256);\n    window.crypto.getRandomValues(z);\n\n    for (t = 0; t < z.length; ++t) {\n      rng_pool[rng_pptr++] = z[t] & 255;\n    }\n  } // Use mouse events for entropy, if we do not have enough entropy by the time\n  // we need it, entropy will be generated by Math.random.\n\n\n  var count = 0;\n\n  var onMouseMoveListener_1 = function (ev) {\n    count = count || 0;\n\n    if (count >= 256 || rng_pptr >= rng_psize) {\n      if (window.removeEventListener) {\n        window.removeEventListener(\"mousemove\", onMouseMoveListener_1, false);\n      } else if (window.detachEvent) {\n        window.detachEvent(\"onmousemove\", onMouseMoveListener_1);\n      }\n\n      return;\n    }\n\n    try {\n      var mouseCoordinates = ev.x + ev.y;\n      rng_pool[rng_pptr++] = mouseCoordinates & 255;\n      count += 1;\n    } catch (e) {// Sometimes Firefox will deny permission to access event properties for some reason. Ignore.\n    }\n  };\n\n  if (window.addEventListener) {\n    window.addEventListener(\"mousemove\", onMouseMoveListener_1, false);\n  } else if (window.attachEvent) {\n    window.attachEvent(\"onmousemove\", onMouseMoveListener_1);\n  }\n}\n\nfunction rng_get_byte() {\n  if (rng_state == null) {\n    rng_state = prng_newstate(); // At this point, we may not have collected enough entropy.  If not, fall back to Math.random\n\n    while (rng_pptr < rng_psize) {\n      var random = Math.floor(65536 * Math.random());\n      rng_pool[rng_pptr++] = random & 255;\n    }\n\n    rng_state.init(rng_pool);\n\n    for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {\n      rng_pool[rng_pptr] = 0;\n    }\n\n    rng_pptr = 0;\n  } // TODO: allow reseeding after first request\n\n\n  return rng_state.next();\n}\n\nvar SecureRandom =\n/** @class */\nfunction () {\n  function SecureRandom() {}\n\n  SecureRandom.prototype.nextBytes = function (ba) {\n    for (var i = 0; i < ba.length; ++i) {\n      ba[i] = rng_get_byte();\n    }\n  };\n\n  return SecureRandom;\n}();\n\nexport { SecureRandom };","map":{"version":3,"names":["prng_newstate","rng_psize","rng_state","rng_pool","rng_pptr","t","window","crypto","getRandomValues","z","Uint32Array","length","count","onMouseMoveListener_1","ev","removeEventListener","detachEvent","mouseCoordinates","x","y","e","addEventListener","attachEvent","rng_get_byte","random","Math","floor","init","next","SecureRandom","prototype","nextBytes","ba","i"],"sources":["C:/Users/3HENRY/Desktop/web2/computer-system/src/frontend/node_modules/jsencrypt/lib/lib/jsbn/rng.js"],"sourcesContent":["// Random number generator - requires a PRNG backend, e.g. prng4.js\nimport { prng_newstate, rng_psize } from \"./prng4\";\nvar rng_state;\nvar rng_pool = null;\nvar rng_pptr;\n// Initialize the pool with junk if needed.\nif (rng_pool == null) {\n    rng_pool = [];\n    rng_pptr = 0;\n    var t = void 0;\n    if (window.crypto && window.crypto.getRandomValues) {\n        // Extract entropy (2048 bits) from RNG if available\n        var z = new Uint32Array(256);\n        window.crypto.getRandomValues(z);\n        for (t = 0; t < z.length; ++t) {\n            rng_pool[rng_pptr++] = z[t] & 255;\n        }\n    }\n    // Use mouse events for entropy, if we do not have enough entropy by the time\n    // we need it, entropy will be generated by Math.random.\n    var count = 0;\n    var onMouseMoveListener_1 = function (ev) {\n        count = count || 0;\n        if (count >= 256 || rng_pptr >= rng_psize) {\n            if (window.removeEventListener) {\n                window.removeEventListener(\"mousemove\", onMouseMoveListener_1, false);\n            }\n            else if (window.detachEvent) {\n                window.detachEvent(\"onmousemove\", onMouseMoveListener_1);\n            }\n            return;\n        }\n        try {\n            var mouseCoordinates = ev.x + ev.y;\n            rng_pool[rng_pptr++] = mouseCoordinates & 255;\n            count += 1;\n        }\n        catch (e) {\n            // Sometimes Firefox will deny permission to access event properties for some reason. Ignore.\n        }\n    };\n    if (window.addEventListener) {\n        window.addEventListener(\"mousemove\", onMouseMoveListener_1, false);\n    }\n    else if (window.attachEvent) {\n        window.attachEvent(\"onmousemove\", onMouseMoveListener_1);\n    }\n}\nfunction rng_get_byte() {\n    if (rng_state == null) {\n        rng_state = prng_newstate();\n        // At this point, we may not have collected enough entropy.  If not, fall back to Math.random\n        while (rng_pptr < rng_psize) {\n            var random = Math.floor(65536 * Math.random());\n            rng_pool[rng_pptr++] = random & 255;\n        }\n        rng_state.init(rng_pool);\n        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {\n            rng_pool[rng_pptr] = 0;\n        }\n        rng_pptr = 0;\n    }\n    // TODO: allow reseeding after first request\n    return rng_state.next();\n}\nvar SecureRandom = /** @class */ (function () {\n    function SecureRandom() {\n    }\n    SecureRandom.prototype.nextBytes = function (ba) {\n        for (var i = 0; i < ba.length; ++i) {\n            ba[i] = rng_get_byte();\n        }\n    };\n    return SecureRandom;\n}());\nexport { SecureRandom };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}