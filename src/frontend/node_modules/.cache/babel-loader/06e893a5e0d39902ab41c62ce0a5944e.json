{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _mapGenerator = require('./map-generator');\n\nvar _mapGenerator2 = _interopRequireDefault(_mapGenerator);\n\nvar _stringify2 = require('./stringify');\n\nvar _stringify3 = _interopRequireDefault(_stringify2);\n\nvar _warnOnce = require('./warn-once');\n\nvar _warnOnce2 = _interopRequireDefault(_warnOnce);\n\nvar _result = require('./result');\n\nvar _result2 = _interopRequireDefault(_result);\n\nvar _parse = require('./parse');\n\nvar _parse2 = _interopRequireDefault(_parse);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction isPromise(obj) {\n  return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.then === 'function';\n}\n/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([cssnext]).process(css);\n */\n\n\nvar LazyResult = function () {\n  function LazyResult(processor, css, opts) {\n    _classCallCheck(this, LazyResult);\n\n    this.stringified = false;\n    this.processed = false;\n    var root = void 0;\n\n    if ((typeof css === 'undefined' ? 'undefined' : _typeof(css)) === 'object' && css !== null && css.type === 'root') {\n      root = css;\n    } else if (css instanceof LazyResult || css instanceof _result2.default) {\n      root = css.root;\n\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = {};\n        if (!opts.map.inline) opts.map.inline = false;\n        opts.map.prev = css.map;\n      }\n    } else {\n      var parser = _parse2.default;\n      if (opts.syntax) parser = opts.syntax.parse;\n      if (opts.parser) parser = opts.parser;\n      if (parser.parse) parser = parser.parse;\n\n      try {\n        root = parser(css, opts);\n      } catch (error) {\n        this.error = error;\n      }\n    }\n\n    this.result = new _result2.default(processor, root, opts);\n  }\n  /**\n   * Returns a {@link Processor} instance, which will be used\n   * for CSS transformations.\n   * @type {Processor}\n   */\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and calls {@link Result#warnings()}.\n   *\n   * @return {Warning[]} warnings from plugins\n   */\n\n\n  LazyResult.prototype.warnings = function warnings() {\n    return this.sync().warnings();\n  };\n  /**\n   * Alias for the {@link LazyResult#css} property.\n   *\n   * @example\n   * lazy + '' === lazy.css;\n   *\n   * @return {string} output CSS\n   */\n\n\n  LazyResult.prototype.toString = function toString() {\n    return this.css;\n  };\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls `onFulfilled` with a Result instance. If a plugin throws\n   * an error, the `onRejected` callback will be executed.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFulfilled} onFulfilled - callback will be executed\n   *                                    when all plugins will finish work\n   * @param {onRejected}  onRejected  - callback will be executed on any error\n   *\n   * @return {Promise} Promise API to make queue\n   *\n   * @example\n   * postcss([cssnext]).process(css, { from: cssPath }).then(result => {\n   *   console.log(result.css);\n   * });\n   */\n\n\n  LazyResult.prototype.then = function then(onFulfilled, onRejected) {\n    if (!('from' in this.opts)) {\n      (0, _warnOnce2.default)('Without `from` option PostCSS could generate wrong ' + 'source map and will not find Browserslist config. ' + 'Set it to CSS file path or to `undefined` to prevent ' + 'this warning.');\n    }\n\n    return this.async().then(onFulfilled, onRejected);\n  };\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onRejected for each error thrown in any plugin.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onRejected} onRejected - callback will be executed on any error\n   *\n   * @return {Promise} Promise API to make queue\n   *\n   * @example\n   * postcss([cssnext]).process(css).then(result => {\n   *   console.log(result.css);\n   * }).catch(error => {\n   *   console.error(error);\n   * });\n   */\n\n\n  LazyResult.prototype.catch = function _catch(onRejected) {\n    return this.async().catch(onRejected);\n  };\n\n  LazyResult.prototype.handleError = function handleError(error, plugin) {\n    try {\n      this.error = error;\n\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin;\n        error.setMessage();\n      } else if (plugin.postcssVersion) {\n        var pluginName = plugin.postcssPlugin;\n        var pluginVer = plugin.postcssVersion;\n        var runtimeVer = this.result.processor.version;\n        var a = pluginVer.split('.');\n        var b = runtimeVer.split('.');\n\n        if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n          console.error('Unknown error from PostCSS plugin. ' + 'Your current PostCSS version ' + 'is ' + runtimeVer + ', but ' + pluginName + ' ' + 'uses ' + pluginVer + '. Perhaps this is ' + 'the source of the error below.');\n        }\n      }\n    } catch (err) {\n      if (console && console.error) console.error(err);\n    }\n  };\n\n  LazyResult.prototype.asyncTick = function asyncTick(resolve, reject) {\n    var _this = this;\n\n    if (this.plugin >= this.processor.plugins.length) {\n      this.processed = true;\n      return resolve();\n    }\n\n    try {\n      var plugin = this.processor.plugins[this.plugin];\n      var promise = this.run(plugin);\n      this.plugin += 1;\n\n      if (isPromise(promise)) {\n        promise.then(function () {\n          _this.asyncTick(resolve, reject);\n        }).catch(function (error) {\n          _this.handleError(error, plugin);\n\n          _this.processed = true;\n          reject(error);\n        });\n      } else {\n        this.asyncTick(resolve, reject);\n      }\n    } catch (error) {\n      this.processed = true;\n      reject(error);\n    }\n  };\n\n  LazyResult.prototype.async = function async() {\n    var _this2 = this;\n\n    if (this.processed) {\n      return new Promise(function (resolve, reject) {\n        if (_this2.error) {\n          reject(_this2.error);\n        } else {\n          resolve(_this2.stringify());\n        }\n      });\n    }\n\n    if (this.processing) {\n      return this.processing;\n    }\n\n    this.processing = new Promise(function (resolve, reject) {\n      if (_this2.error) return reject(_this2.error);\n      _this2.plugin = 0;\n\n      _this2.asyncTick(resolve, reject);\n    }).then(function () {\n      _this2.processed = true;\n      return _this2.stringify();\n    });\n    return this.processing;\n  };\n\n  LazyResult.prototype.sync = function sync() {\n    if (this.processed) return this.result;\n    this.processed = true;\n\n    if (this.processing) {\n      throw new Error('Use process(css).then(cb) to work with async plugins');\n    }\n\n    if (this.error) throw this.error;\n\n    for (var _iterator = this.result.processor.plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var plugin = _ref;\n      var promise = this.run(plugin);\n\n      if (isPromise(promise)) {\n        throw new Error('Use process(css).then(cb) to work with async plugins');\n      }\n    }\n\n    return this.result;\n  };\n\n  LazyResult.prototype.run = function run(plugin) {\n    this.result.lastPlugin = plugin;\n\n    try {\n      return plugin(this.result.root, this.result);\n    } catch (error) {\n      this.handleError(error, plugin);\n      throw error;\n    }\n  };\n\n  LazyResult.prototype.stringify = function stringify() {\n    if (this.stringified) return this.result;\n    this.stringified = true;\n    this.sync();\n    var opts = this.result.opts;\n    var str = _stringify3.default;\n    if (opts.syntax) str = opts.syntax.stringify;\n    if (opts.stringifier) str = opts.stringifier;\n    if (str.stringify) str = str.stringify;\n    var map = new _mapGenerator2.default(str, this.result.root, this.result.opts);\n    var data = map.generate();\n    this.result.css = data[0];\n    this.result.map = data[1];\n    return this.result;\n  };\n\n  _createClass(LazyResult, [{\n    key: 'processor',\n    get: function get() {\n      return this.result.processor;\n    }\n    /**\n     * Options from the {@link Processor#process} call.\n     * @type {processOptions}\n     */\n\n  }, {\n    key: 'opts',\n    get: function get() {\n      return this.result.opts;\n    }\n    /**\n     * Processes input CSS through synchronous plugins, converts `Root`\n     * to a CSS string and returns {@link Result#css}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#css\n     */\n\n  }, {\n    key: 'css',\n    get: function get() {\n      return this.stringify().css;\n    }\n    /**\n     * An alias for the `css` property. Use it with syntaxes\n     * that generate non-CSS output.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#content\n     */\n\n  }, {\n    key: 'content',\n    get: function get() {\n      return this.stringify().content;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#map}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {SourceMapGenerator}\n     * @see Result#map\n     */\n\n  }, {\n    key: 'map',\n    get: function get() {\n      return this.stringify().map;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#root}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Root}\n     * @see Result#root\n     */\n\n  }, {\n    key: 'root',\n    get: function get() {\n      return this.sync().root;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#messages}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Message[]}\n     * @see Result#messages\n     */\n\n  }, {\n    key: 'messages',\n    get: function get() {\n      return this.sync().messages;\n    }\n  }]);\n\n  return LazyResult;\n}();\n\nexports.default = LazyResult;\n/**\n * @callback onFulfilled\n * @param {Result} result\n */\n\n/**\n * @callback onRejected\n * @param {Error} error\n */\n\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["isPromise","obj","then","LazyResult","processor","css","opts","_classCallCheck","stringified","processed","root","type","Result","map","inline","prev","parser","parse","syntax","error","result","warnings","sync","toString","onFulfilled","onRejected","async","catch","handleError","plugin","name","postcssPlugin","setMessage","postcssVersion","pluginName","pluginVer","runtimeVer","version","a","split","b","parseInt","console","err","asyncTick","resolve","reject","plugins","length","promise","run","_this","Promise","_this2","stringify","processing","Error","_ref","_i","lastPlugin","str","stringifier","MapGenerator","data","generate","content","messages"],"sources":["lazy-result.es6"],"sourcesContent":["import MapGenerator from './map-generator';\nimport stringify    from './stringify';\nimport warnOnce     from './warn-once';\nimport Result       from './result';\nimport parse        from './parse';\n\nfunction isPromise(obj) {\n    return typeof obj === 'object' && typeof obj.then === 'function';\n}\n\n/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([cssnext]).process(css);\n */\nclass LazyResult {\n\n    constructor(processor, css, opts) {\n        this.stringified = false;\n        this.processed   = false;\n\n        let root;\n        if ( typeof css === 'object' && css !== null && css.type === 'root' ) {\n            root = css;\n        } else if ( css instanceof LazyResult || css instanceof Result ) {\n            root = css.root;\n            if ( css.map ) {\n                if ( typeof opts.map === 'undefined' ) opts.map = { };\n                if ( !opts.map.inline ) opts.map.inline = false;\n                opts.map.prev = css.map;\n            }\n        } else {\n            let parser = parse;\n            if ( opts.syntax )  parser = opts.syntax.parse;\n            if ( opts.parser )  parser = opts.parser;\n            if ( parser.parse ) parser = parser.parse;\n\n            try {\n                root = parser(css, opts);\n            } catch (error) {\n                this.error = error;\n            }\n        }\n\n        this.result = new Result(processor, root, opts);\n    }\n\n    /**\n     * Returns a {@link Processor} instance, which will be used\n     * for CSS transformations.\n     * @type {Processor}\n     */\n    get processor() {\n        return this.result.processor;\n    }\n\n    /**\n     * Options from the {@link Processor#process} call.\n     * @type {processOptions}\n     */\n    get opts() {\n        return this.result.opts;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins, converts `Root`\n     * to a CSS string and returns {@link Result#css}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#css\n     */\n    get css() {\n        return this.stringify().css;\n    }\n\n    /**\n     * An alias for the `css` property. Use it with syntaxes\n     * that generate non-CSS output.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#content\n     */\n    get content() {\n        return this.stringify().content;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#map}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {SourceMapGenerator}\n     * @see Result#map\n     */\n    get map() {\n        return this.stringify().map;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#root}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Root}\n     * @see Result#root\n     */\n    get root() {\n        return this.sync().root;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#messages}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Message[]}\n     * @see Result#messages\n     */\n    get messages() {\n        return this.sync().messages;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and calls {@link Result#warnings()}.\n     *\n     * @return {Warning[]} warnings from plugins\n     */\n    warnings() {\n        return this.sync().warnings();\n    }\n\n    /**\n     * Alias for the {@link LazyResult#css} property.\n     *\n     * @example\n     * lazy + '' === lazy.css;\n     *\n     * @return {string} output CSS\n     */\n    toString() {\n        return this.css;\n    }\n\n    /**\n     * Processes input CSS through synchronous and asynchronous plugins\n     * and calls `onFulfilled` with a Result instance. If a plugin throws\n     * an error, the `onRejected` callback will be executed.\n     *\n     * It implements standard Promise API.\n     *\n     * @param {onFulfilled} onFulfilled - callback will be executed\n     *                                    when all plugins will finish work\n     * @param {onRejected}  onRejected  - callback will be executed on any error\n     *\n     * @return {Promise} Promise API to make queue\n     *\n     * @example\n     * postcss([cssnext]).process(css, { from: cssPath }).then(result => {\n     *   console.log(result.css);\n     * });\n     */\n    then(onFulfilled, onRejected) {\n        if (!('from' in this.opts)) {\n            warnOnce(\n                'Without `from` option PostCSS could generate wrong ' +\n                'source map and will not find Browserslist config. ' +\n                'Set it to CSS file path or to `undefined` to prevent ' +\n                'this warning.'\n            );\n        }\n        return this.async().then(onFulfilled, onRejected);\n    }\n\n    /**\n     * Processes input CSS through synchronous and asynchronous plugins\n     * and calls onRejected for each error thrown in any plugin.\n     *\n     * It implements standard Promise API.\n     *\n     * @param {onRejected} onRejected - callback will be executed on any error\n     *\n     * @return {Promise} Promise API to make queue\n     *\n     * @example\n     * postcss([cssnext]).process(css).then(result => {\n     *   console.log(result.css);\n     * }).catch(error => {\n     *   console.error(error);\n     * });\n     */\n    catch(onRejected) {\n        return this.async().catch(onRejected);\n    }\n\n    handleError(error, plugin) {\n        try {\n            this.error = error;\n            if ( error.name === 'CssSyntaxError' && !error.plugin ) {\n                error.plugin = plugin.postcssPlugin;\n                error.setMessage();\n            } else if ( plugin.postcssVersion ) {\n                let pluginName = plugin.postcssPlugin;\n                let pluginVer  = plugin.postcssVersion;\n                let runtimeVer = this.result.processor.version;\n                let a = pluginVer.split('.');\n                let b = runtimeVer.split('.');\n\n                if ( a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1]) ) {\n                    console.error(\n                        'Unknown error from PostCSS plugin. ' +\n                        'Your current PostCSS version ' +\n                        'is ' + runtimeVer + ', but ' + pluginName + ' ' +\n                        'uses ' + pluginVer + '. Perhaps this is ' +\n                        'the source of the error below.');\n                }\n            }\n        } catch (err) {\n            if ( console && console.error ) console.error(err);\n        }\n    }\n\n    asyncTick(resolve, reject) {\n        if ( this.plugin >= this.processor.plugins.length ) {\n            this.processed = true;\n            return resolve();\n        }\n\n        try {\n            let plugin  = this.processor.plugins[this.plugin];\n            let promise = this.run(plugin);\n            this.plugin += 1;\n\n            if ( isPromise(promise) ) {\n                promise.then( () => {\n                    this.asyncTick(resolve, reject);\n                }).catch( error => {\n                    this.handleError(error, plugin);\n                    this.processed = true;\n                    reject(error);\n                });\n            } else {\n                this.asyncTick(resolve, reject);\n            }\n\n        } catch (error) {\n            this.processed = true;\n            reject(error);\n        }\n    }\n\n    async() {\n        if ( this.processed ) {\n            return new Promise( (resolve, reject) => {\n                if ( this.error ) {\n                    reject(this.error);\n                } else {\n                    resolve(this.stringify());\n                }\n            });\n        }\n        if ( this.processing ) {\n            return this.processing;\n        }\n\n        this.processing = new Promise( (resolve, reject) => {\n            if ( this.error ) return reject(this.error);\n            this.plugin = 0;\n            this.asyncTick(resolve, reject);\n        }).then( () => {\n            this.processed = true;\n            return this.stringify();\n        });\n\n        return this.processing;\n    }\n\n    sync() {\n        if ( this.processed ) return this.result;\n        this.processed = true;\n\n        if ( this.processing ) {\n            throw new Error(\n                'Use process(css).then(cb) to work with async plugins');\n        }\n\n        if ( this.error ) throw this.error;\n\n        for ( let plugin of this.result.processor.plugins ) {\n            let promise = this.run(plugin);\n            if ( isPromise(promise) ) {\n                throw new Error(\n                    'Use process(css).then(cb) to work with async plugins');\n            }\n        }\n\n        return this.result;\n    }\n\n    run(plugin) {\n        this.result.lastPlugin = plugin;\n\n        try {\n            return plugin(this.result.root, this.result);\n        } catch (error) {\n            this.handleError(error, plugin);\n            throw error;\n        }\n    }\n\n    stringify() {\n        if ( this.stringified ) return this.result;\n        this.stringified = true;\n\n        this.sync();\n\n        let opts = this.result.opts;\n        let str  = stringify;\n        if ( opts.syntax )      str = opts.syntax.stringify;\n        if ( opts.stringifier ) str = opts.stringifier;\n        if ( str.stringify )    str = str.stringify;\n\n        let map  = new MapGenerator(str, this.result.root, this.result.opts);\n        let data = map.generate();\n        this.result.css = data[0];\n        this.result.map = data[1];\n\n        return this.result;\n    }\n\n}\n\nexport default LazyResult;\n\n/**\n * @callback onFulfilled\n * @param {Result} result\n */\n\n/**\n * @callback onRejected\n * @param {Error} error\n */\n"]},"metadata":{},"sourceType":"module"}