(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.VueVideoPlayer = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
 /**
 *
 * Vue-Video-Player
 * Adapted from Videojs (https://github.com/videojs/video.js)
 *
 */

window.videojs = require('video.js')
videojs = videojs.default || videojs
var playerComponent = require('./src/player.vue')
playerComponent = playerComponent.default || playerComponent

var videoPlayer = {
  videojs: videojs,
  videoPlayer: playerComponent,
  install: function(Vue) {
    Vue.component(playerComponent.name, playerComponent)
  }
}

module.exports = videoPlayer

},{"./src/player.vue":55,"video.js":48}],2:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":4}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;

},{"../../modules/_core":9,"../../modules/es6.object.assign":39}],5:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],6:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":22}],7:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":32,"./_to-iobject":34,"./_to-length":35}],8:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],9:[function(require,module,exports){
var core = module.exports = { version: '2.5.0' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],10:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":5}],11:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],12:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":16}],13:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":17,"./_is-object":22}],14:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],15:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":9,"./_ctx":10,"./_global":17,"./_hide":19}],16:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],17:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],18:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],19:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":12,"./_object-dp":24,"./_property-desc":29}],20:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":12,"./_dom-create":13,"./_fails":16}],21:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":8}],22:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],23:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":16,"./_iobject":21,"./_object-gops":25,"./_object-keys":27,"./_object-pie":28,"./_to-object":36}],24:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":6,"./_descriptors":12,"./_ie8-dom-define":20,"./_to-primitive":37}],25:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],26:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":7,"./_has":18,"./_shared-key":30,"./_to-iobject":34}],27:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":14,"./_object-keys-internal":26}],28:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],29:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],30:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":31,"./_uid":38}],31:[function(require,module,exports){
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

},{"./_global":17}],32:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":33}],33:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],34:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":11,"./_iobject":21}],35:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":33}],36:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":11}],37:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":22}],38:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],39:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":15,"./_object-assign":23}],40:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":43}],41:[function(require,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

var doccy;

if (typeof document !== 'undefined') {
    doccy = document;
} else {
    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }
}

module.exports = doccy;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"min-document":3}],42:[function(require,module,exports){
(function (global){
var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],43:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],44:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":40,"trim":46}],45:[function(require,module,exports){
module.exports = SafeParseTuple

function SafeParseTuple(obj, reviver) {
    var json
    var error = null

    try {
        json = JSON.parse(obj, reviver)
    } catch (err) {
        error = err
    }

    return [error, json]
}

},{}],46:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],47:[function(require,module,exports){
function clean (s) {
  return s.replace(/\n\r?\s*/g, '')
}


module.exports = function tsml (sa) {
  var s = ''
    , i = 0

  for (; i < arguments.length; i++)
    s += clean(sa[i]) + (arguments[i + 1] || '')

  return s
}
},{}],48:[function(require,module,exports){
/**
 * @license
 * Video.js 6.2.5 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/master/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>
 */

'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var window = _interopDefault(require('global/window'));
var document = _interopDefault(require('global/document'));
var tsml = _interopDefault(require('tsml'));
var safeParseTuple = _interopDefault(require('safe-json-parse/tuple'));
var xhr = _interopDefault(require('xhr'));
var vtt = _interopDefault(require('videojs-vtt.js'));

var version = "6.2.5";

/**
 * @file browser.js
 * @module browser
 */
var USER_AGENT = window.navigator && window.navigator.userAgent || '';
var webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;

/*
 * Device is an iPhone
 *
 * @type {Boolean}
 * @constant
 * @private
 */
var IS_IPAD = /iPad/i.test(USER_AGENT);

// The Facebook app's UIWebView identifies as both an iPhone and iPad, so
// to identify iPhones, we need to exclude iPads.
// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/
var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
var IS_IPOD = /iPod/i.test(USER_AGENT);
var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;

var IOS_VERSION = function () {
  var match = USER_AGENT.match(/OS (\d+)_/i);

  if (match && match[1]) {
    return match[1];
  }
  return null;
}();

var IS_ANDROID = /Android/i.test(USER_AGENT);
var ANDROID_VERSION = function () {
  // This matches Android Major.Minor.Patch versions
  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
  var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);

  if (!match) {
    return null;
  }

  var major = match[1] && parseFloat(match[1]);
  var minor = match[2] && parseFloat(match[2]);

  if (major && minor) {
    return parseFloat(match[1] + '.' + match[2]);
  } else if (major) {
    return major;
  }
  return null;
}();

// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser
var IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;
var IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;

var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
var IS_EDGE = /Edge/i.test(USER_AGENT);
var IS_CHROME = !IS_EDGE && /Chrome/i.test(USER_AGENT);
var CHROME_VERSION = function () {
  var match = USER_AGENT.match(/Chrome\/(\d+)/);

  if (match && match[1]) {
    return parseFloat(match[1]);
  }
  return null;
}();
var IS_IE8 = /MSIE\s8\.0/.test(USER_AGENT);
var IE_VERSION = function () {
  var result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
  var version = result && parseFloat(result[1]);

  if (!version && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
    // IE 11 has a different user agent string than other IE versions
    version = 11.0;
  }

  return version;
}();

var IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
var IS_ANY_SAFARI = IS_SAFARI || IS_IOS;

var TOUCH_ENABLED = isReal() && ('ontouchstart' in window || window.DocumentTouch && window.document instanceof window.DocumentTouch);

var BACKGROUND_SIZE_SUPPORTED = isReal() && 'backgroundSize' in window.document.createElement('video').style;

var browser = (Object.freeze || Object)({
	IS_IPAD: IS_IPAD,
	IS_IPHONE: IS_IPHONE,
	IS_IPOD: IS_IPOD,
	IS_IOS: IS_IOS,
	IOS_VERSION: IOS_VERSION,
	IS_ANDROID: IS_ANDROID,
	ANDROID_VERSION: ANDROID_VERSION,
	IS_OLD_ANDROID: IS_OLD_ANDROID,
	IS_NATIVE_ANDROID: IS_NATIVE_ANDROID,
	IS_FIREFOX: IS_FIREFOX,
	IS_EDGE: IS_EDGE,
	IS_CHROME: IS_CHROME,
	CHROME_VERSION: CHROME_VERSION,
	IS_IE8: IS_IE8,
	IE_VERSION: IE_VERSION,
	IS_SAFARI: IS_SAFARI,
	IS_ANY_SAFARI: IS_ANY_SAFARI,
	TOUCH_ENABLED: TOUCH_ENABLED,
	BACKGROUND_SIZE_SUPPORTED: BACKGROUND_SIZE_SUPPORTED
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};











var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};











var taggedTemplateLiteralLoose = function (strings, raw) {
  strings.raw = raw;
  return strings;
};

/**
 * @file obj.js
 * @module obj
 */

/**
 * @callback obj:EachCallback
 *
 * @param {Mixed} value
 *        The current key for the object that is being iterated over.
 *
 * @param {string} key
 *        The current key-value for object that is being iterated over
 */

/**
 * @callback obj:ReduceCallback
 *
 * @param {Mixed} accum
 *        The value that is accumulating over the reduce loop.
 *
 * @param {Mixed} value
 *        The current key for the object that is being iterated over.
 *
 * @param {string} key
 *        The current key-value for object that is being iterated over
 *
 * @return {Mixed}
 *         The new accumulated value.
 */
var toString = Object.prototype.toString;

/**
 * Get the keys of an Object
 *
 * @param {Object}
 *        The Object to get the keys from
 *
 * @return {string[]}
 *         An array of the keys from the object. Returns an empty array if the
 *         object passed in was invalid or had no keys.
 *
 * @private
 */
var keys = function keys(object) {
  return isObject(object) ? Object.keys(object) : [];
};

/**
 * Array-like iteration for objects.
 *
 * @param {Object} object
 *        The object to iterate over
 *
 * @param {obj:EachCallback} fn
 *        The callback function which is called for each key in the object.
 */
function each(object, fn) {
  keys(object).forEach(function (key) {
    return fn(object[key], key);
  });
}

/**
 * Array-like reduce for objects.
 *
 * @param {Object} object
 *        The Object that you want to reduce.
 *
 * @param {Function} fn
 *         A callback function which is called for each key in the object. It
 *         receives the accumulated value and the per-iteration value and key
 *         as arguments.
 *
 * @param {Mixed} [initial = 0]
 *        Starting value
 *
 * @return {Mixed}
 *         The final accumulated value.
 */
function reduce(object, fn) {
  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  return keys(object).reduce(function (accum, key) {
    return fn(accum, object[key], key);
  }, initial);
}

/**
 * Object.assign-style object shallow merge/extend.
 *
 * @param  {Object} target
 * @param  {Object} ...sources
 * @return {Object}
 */
function assign(target) {
  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  if (Object.assign) {
    return Object.assign.apply(Object, [target].concat(sources));
  }

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    each(source, function (value, key) {
      target[key] = value;
    });
  });

  return target;
}

/**
 * Returns whether a value is an object of any kind - including DOM nodes,
 * arrays, regular expressions, etc. Not functions, though.
 *
 * This avoids the gotcha where using `typeof` on a `null` value
 * results in `'object'`.
 *
 * @param  {Object} value
 * @return {Boolean}
 */
function isObject(value) {
  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
}

/**
 * Returns whether an object appears to be a "plain" object - that is, a
 * direct instance of `Object`.
 *
 * @param  {Object} value
 * @return {Boolean}
 */
function isPlain(value) {
  return isObject(value) && toString.call(value) === '[object Object]' && value.constructor === Object;
}

/**
 * @file log.js
 * @module log
 */
var log = void 0;

// This is the private tracking variable for logging level.
var level = 'all';

// This is the private tracking variable for the logging history.
var history = [];

/**
 * Log messages to the console and history based on the type of message
 *
 * @private
 * @param  {string} type
 *         The name of the console method to use.
 *
 * @param  {Array} args
 *         The arguments to be passed to the matching console method.
 *
 * @param  {boolean} [stringify]
 *         By default, only old IEs should get console argument stringification,
 *         but this is exposed as a parameter to facilitate testing.
 */
var logByType = function logByType(type, args) {
  var stringify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !!IE_VERSION && IE_VERSION < 11;

  var lvl = log.levels[level];
  var lvlRegExp = new RegExp('^(' + lvl + ')$');

  if (type !== 'log') {

    // Add the type to the front of the message when it's not "log".
    args.unshift(type.toUpperCase() + ':');
  }

  // Add a clone of the args at this point to history.
  if (history) {
    history.push([].concat(args));
  }

  // Add console prefix after adding to history.
  args.unshift('VIDEOJS:');

  // If there's no console then don't try to output messages, but they will
  // still be stored in history.
  //
  // Was setting these once outside of this function, but containing them
  // in the function makes it easier to test cases where console doesn't exist
  // when the module is executed.
  var fn = window.console && window.console[type];

  // Bail out if there's no console or if this type is not allowed by the
  // current logging level.
  if (!fn || !lvl || !lvlRegExp.test(type)) {
    return;
  }

  // IEs previous to 11 log objects uselessly as "[object Object]"; so, JSONify
  // objects and arrays for those less-capable browsers.
  if (stringify) {
    args = args.map(function (a) {
      if (isObject(a) || Array.isArray(a)) {
        try {
          return JSON.stringify(a);
        } catch (x) {
          return String(a);
        }
      }

      // Cast to string before joining, so we get null and undefined explicitly
      // included in output (as we would in a modern console).
      return String(a);
    }).join(' ');
  }

  // Old IE versions do not allow .apply() for console methods (they are
  // reported as objects rather than functions).
  if (!fn.apply) {
    fn(args);
  } else {
    fn[Array.isArray(args) ? 'apply' : 'call'](window.console, args);
  }
};

/**
 * Logs plain debug messages. Similar to `console.log`.
 *
 * @class
 * @param    {Mixed[]} args
 *           One or more messages or objects that should be logged.
 */
log = function log() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  logByType('log', args);
};

/**
 * Enumeration of available logging levels, where the keys are the level names
 * and the values are `|`-separated strings containing logging methods allowed
 * in that logging level. These strings are used to create a regular expression
 * matching the function name being called.
 *
 * Levels provided by video.js are:
 *
 * - `off`: Matches no calls. Any value that can be cast to `false` will have
 *   this effect. The most restrictive.
 * - `all` (default): Matches only Video.js-provided functions (`log`,
 *   `log.warn`, and `log.error`).
 * - `warn`: Matches `log.warn` and `log.error` calls.
 * - `error`: Matches only `log.error` calls.
 *
 * @type {Object}
 */
log.levels = {
  all: 'log|warn|error',
  error: 'error',
  off: '',
  warn: 'warn|error',
  DEFAULT: level
};

/**
 * Get or set the current logging level. If a string matching a key from
 * {@link log.levels} is provided, acts as a setter. Regardless of argument,
 * returns the current logging level.
 *
 * @param  {string} [lvl]
 *         Pass to set a new logging level.
 *
 * @return {string}
 *         The current logging level.
 */
log.level = function (lvl) {
  if (typeof lvl === 'string') {
    if (!log.levels.hasOwnProperty(lvl)) {
      throw new Error('"' + lvl + '" in not a valid log level');
    }
    level = lvl;
  }
  return level;
};

/**
 * Returns an array containing everything that has been logged to the history.
 *
 * This array is a shallow clone of the internal history record. However, its
 * contents are _not_ cloned; so, mutating objects inside this array will
 * mutate them in history.
 *
 * @return {Array}
 */
log.history = function () {
  return history ? [].concat(history) : [];
};

/**
 * Clears the internal history tracking, but does not prevent further history
 * tracking.
 */
log.history.clear = function () {
  if (history) {
    history.length = 0;
  }
};

/**
 * Disable history tracking if it is currently enabled.
 */
log.history.disable = function () {
  if (history !== null) {
    history.length = 0;
    history = null;
  }
};

/**
 * Enable history tracking if it is currently disabled.
 */
log.history.enable = function () {
  if (history === null) {
    history = [];
  }
};

/**
 * Logs error messages. Similar to `console.error`.
 *
 * @param {Mixed[]} args
 *        One or more messages or objects that should be logged as an error
 */
log.error = function () {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return logByType('error', args);
};

/**
 * Logs warning messages. Similar to `console.warn`.
 *
 * @param {Mixed[]} args
 *        One or more messages or objects that should be logged as a warning.
 */
log.warn = function () {
  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return logByType('warn', args);
};

var log$1 = log;

/**
 * @file computed-style.js
 * @module computed-style
 */
/**
 * A safe getComputedStyle with an IE8 fallback.
 *
 * This is needed because in Firefox, if the player is loaded in an iframe with
 * `display:none`, then `getComputedStyle` returns `null`, so, we do a null-check to
 * make sure  that the player doesn't break in these cases.
 *
 * @param {Element} el
 *        The element you want the computed style of
 *
 * @param {string} prop
 *        The property name you want
 *
 * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397
 *
 * @static
 * @const
 */
function computedStyle(el, prop) {
  if (!el || !prop) {
    return '';
  }

  if (typeof window.getComputedStyle === 'function') {
    var cs = window.getComputedStyle(el);

    return cs ? cs[prop] : '';
  }

  return el.currentStyle[prop] || '';
}

var _templateObject = taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);

/**
 * @file dom.js
 * @module dom
 */
/**
 * Detect if a value is a string with any non-whitespace characters.
 *
 * @param {string} str
 *        The string to check
 *
 * @return {boolean}
 *         - True if the string is non-blank
 *         - False otherwise
 *
 */
function isNonBlankString(str) {
  return typeof str === 'string' && /\S/.test(str);
}

/**
 * Throws an error if the passed string has whitespace. This is used by
 * class methods to be relatively consistent with the classList API.
 *
 * @param {string} str
 *         The string to check for whitespace.
 *
 * @throws {Error}
 *         Throws an error if there is whitespace in the string.
 *
 */
function throwIfWhitespace(str) {
  if (/\s/.test(str)) {
    throw new Error('class has illegal whitespace characters');
  }
}

/**
 * Produce a regular expression for matching a className within an elements className.
 *
 * @param {string} className
 *         The className to generate the RegExp for.
 *
 * @return {RegExp}
 *         The RegExp that will check for a specific `className` in an elements
 *         className.
 */
function classRegExp(className) {
  return new RegExp('(^|\\s)' + className + '($|\\s)');
}

/**
 * Whether the current DOM interface appears to be real.
 *
 * @return {Boolean}
 */
function isReal() {
  return (

    // Both document and window will never be undefined thanks to `global`.
    document === window.document &&

    // In IE < 9, DOM methods return "object" as their type, so all we can
    // confidently check is that it exists.
    typeof document.createElement !== 'undefined'
  );
}

/**
 * Determines, via duck typing, whether or not a value is a DOM element.
 *
 * @param {Mixed} value
 *        The thing to check
 *
 * @return {boolean}
 *         - True if it is a DOM element
 *         - False otherwise
 */
function isEl(value) {
  return isObject(value) && value.nodeType === 1;
}

/**
 * Creates functions to query the DOM using a given method.
 *
 * @param {string} method
 *         The method to create the query with.
 *
 * @return {Function}
 *         The query method
 */
function createQuerier(method) {
  return function (selector, context) {
    if (!isNonBlankString(selector)) {
      return document[method](null);
    }
    if (isNonBlankString(context)) {
      context = document.querySelector(context);
    }

    var ctx = isEl(context) ? context : document;

    return ctx[method] && ctx[method](selector);
  };
}

/**
 * Creates an element and applies properties.
 *
 * @param {string} [tagName='div']
 *         Name of tag to be created.
 *
 * @param {Object} [properties={}]
 *         Element properties to be applied.
 *
 * @param {Object} [attributes={}]
 *         Element attributes to be applied.
 *
 * @param {String|Element|TextNode|Array|Function} [content]
 *         Contents for the element (see: {@link dom:normalizeContent})
 *
 * @return {Element}
 *         The element that was created.
 */
function createEl() {
  var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';
  var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var content = arguments[3];

  var el = document.createElement(tagName);

  Object.getOwnPropertyNames(properties).forEach(function (propName) {
    var val = properties[propName];

    // See #2176
    // We originally were accepting both properties and attributes in the
    // same object, but that doesn't work so well.
    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {
      log$1.warn(tsml(_templateObject, propName, val));
      el.setAttribute(propName, val);

      // Handle textContent since it's not supported everywhere and we have a
      // method for it.
    } else if (propName === 'textContent') {
      textContent(el, val);
    } else {
      el[propName] = val;
    }
  });

  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
    el.setAttribute(attrName, attributes[attrName]);
  });

  if (content) {
    appendContent(el, content);
  }

  return el;
}

/**
 * Injects text into an element, replacing any existing contents entirely.
 *
 * @param {Element} el
 *        The element to add text content into
 *
 * @param {string} text
 *        The text content to add.
 *
 * @return {Element}
 *         The element with added text content.
 */
function textContent(el, text) {
  if (typeof el.textContent === 'undefined') {
    el.innerText = text;
  } else {
    el.textContent = text;
  }
  return el;
}

/**
 * Insert an element as the first child node of another
 *
 * @param {Element} child
 *        Element to insert
 *
 * @param {Element} parent
 *        Element to insert child into
 */
function prependTo(child, parent) {
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
}

/**
 * Check if an element has a CSS class
 *
 * @param {Element} element
 *        Element to check
 *
 * @param {string} classToCheck
 *        Class name to check for
 *
 * @return {boolean}
 *         - True if the element had the class
 *         - False otherwise.
 *
 * @throws {Error}
 *         Throws an error if `classToCheck` has white space.
 */
function hasClass(element, classToCheck) {
  throwIfWhitespace(classToCheck);
  if (element.classList) {
    return element.classList.contains(classToCheck);
  }
  return classRegExp(classToCheck).test(element.className);
}

/**
 * Add a CSS class name to an element
 *
 * @param {Element} element
 *        Element to add class name to.
 *
 * @param {string} classToAdd
 *        Class name to add.
 *
 * @return {Element}
 *         The dom element with the added class name.
 */
function addClass(element, classToAdd) {
  if (element.classList) {
    element.classList.add(classToAdd);

    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it
    // in the case of classList not being supported.
  } else if (!hasClass(element, classToAdd)) {
    element.className = (element.className + ' ' + classToAdd).trim();
  }

  return element;
}

/**
 * Remove a CSS class name from an element
 *
 * @param {Element} element
 *        Element to remove a class name from.
 *
 * @param {string} classToRemove
 *        Class name to remove
 *
 * @return {Element}
 *         The dom element with class name removed.
 */
function removeClass(element, classToRemove) {
  if (element.classList) {
    element.classList.remove(classToRemove);
  } else {
    throwIfWhitespace(classToRemove);
    element.className = element.className.split(/\s+/).filter(function (c) {
      return c !== classToRemove;
    }).join(' ');
  }

  return element;
}

/**
 * The callback definition for toggleElClass.
 *
 * @callback Dom~PredicateCallback
 * @param {Element} element
 *        The DOM element of the Component.
 *
 * @param {string} classToToggle
 *        The `className` that wants to be toggled
 *
 * @return {boolean|undefined}
 *         - If true the `classToToggle` will get added to `element`.
 *         - If false the `classToToggle` will get removed from `element`.
 *         - If undefined this callback will be ignored
 */

/**
 * Adds or removes a CSS class name on an element depending on an optional
 * condition or the presence/absence of the class name.
 *
 * @param {Element} element
 *        The element to toggle a class name on.
 *
 * @param {string} classToToggle
 *        The class that should be toggled
 *
 * @param {boolean|PredicateCallback} [predicate]
 *        See the return value for {@link Dom~PredicateCallback}
 *
 * @return {Element}
 *         The element with a class that has been toggled.
 */
function toggleClass(element, classToToggle, predicate) {

  // This CANNOT use `classList` internally because IE does not support the
  // second parameter to the `classList.toggle()` method! Which is fine because
  // `classList` will be used by the add/remove functions.
  var has = hasClass(element, classToToggle);

  if (typeof predicate === 'function') {
    predicate = predicate(element, classToToggle);
  }

  if (typeof predicate !== 'boolean') {
    predicate = !has;
  }

  // If the necessary class operation matches the current state of the
  // element, no action is required.
  if (predicate === has) {
    return;
  }

  if (predicate) {
    addClass(element, classToToggle);
  } else {
    removeClass(element, classToToggle);
  }

  return element;
}

/**
 * Apply attributes to an HTML element.
 *
 * @param {Element} el
 *        Element to add attributes to.
 *
 * @param {Object} [attributes]
 *        Attributes to be applied.
 */
function setAttributes(el, attributes) {
  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
    var attrValue = attributes[attrName];

    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
      el.removeAttribute(attrName);
    } else {
      el.setAttribute(attrName, attrValue === true ? '' : attrValue);
    }
  });
}

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 *
 * @param {Element} tag
 *        Element from which to get tag attributes.
 *
 * @return {Object}
 *         All attributes of the element.
 */
function getAttributes(tag) {
  var obj = {};

  // known boolean attributes
  // we can check for matching boolean properties, but older browsers
  // won't know about HTML5 boolean attributes that we still read from
  var knownBooleans = ',' + 'autoplay,controls,loop,muted,default' + ',';

  if (tag && tag.attributes && tag.attributes.length > 0) {
    var attrs = tag.attributes;

    for (var i = attrs.length - 1; i >= 0; i--) {
      var attrName = attrs[i].name;
      var attrVal = attrs[i].value;

      // check for known booleans
      // the matching element property will return a value for typeof
      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {
        // the value of an included boolean attribute is typically an empty
        // string ('') which would equal false if we just check for a false value.
        // we also don't want support bad code like autoplay='false'
        attrVal = attrVal !== null ? true : false;
      }

      obj[attrName] = attrVal;
    }
  }

  return obj;
}

/**
 * Get the value of an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to get the value of
 *
 * @return {string}
 *         value of the attribute
 */
function getAttribute(el, attribute) {
  return el.getAttribute(attribute);
}

/**
 * Set the value of an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to set
 *
 * @param {string} value
 *        Value to set the attribute to
 */
function setAttribute(el, attribute, value) {
  el.setAttribute(attribute, value);
}

/**
 * Remove an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to remove
 */
function removeAttribute(el, attribute) {
  el.removeAttribute(attribute);
}

/**
 * Attempt to block the ability to select text while dragging controls
 */
function blockTextSelection() {
  document.body.focus();
  document.onselectstart = function () {
    return false;
  };
}

/**
 * Turn off text selection blocking
 */
function unblockTextSelection() {
  document.onselectstart = function () {
    return true;
  };
}

/**
 * Identical to the native `getBoundingClientRect` function, but ensures that
 * the method is supported at all (it is in all browsers we claim to support)
 * and that the element is in the DOM before continuing.
 *
 * This wrapper function also shims properties which are not provided by some
 * older browsers (namely, IE8).
 *
 * Additionally, some browsers do not support adding properties to a
 * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard
 * properties (except `x` and `y` which are not widely supported). This helps
 * avoid implementations where keys are non-enumerable.
 *
 * @param  {Element} el
 *         Element whose `ClientRect` we want to calculate.
 *
 * @return {Object|undefined}
 *         Always returns a plain
 */
function getBoundingClientRect(el) {
  if (el && el.getBoundingClientRect && el.parentNode) {
    var rect = el.getBoundingClientRect();
    var result = {};

    ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(function (k) {
      if (rect[k] !== undefined) {
        result[k] = rect[k];
      }
    });

    if (!result.height) {
      result.height = parseFloat(computedStyle(el, 'height'));
    }

    if (!result.width) {
      result.width = parseFloat(computedStyle(el, 'width'));
    }

    return result;
  }
}

/**
 * The postion of a DOM element on the page.
 *
 * @typedef {Object} module:dom~Position
 *
 * @property {number} left
 *           Pixels to the left
 *
 * @property {number} top
 *           Pixels on top
 */

/**
 * Offset Left.
 * getBoundingClientRect technique from
 * John Resig
 *
 * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/
 *
 * @param {Element} el
 *        Element from which to get offset
 *
 * @return {module:dom~Position}
 *         The position of the element that was passed in.
 */
function findPosition(el) {
  var box = void 0;

  if (el.getBoundingClientRect && el.parentNode) {
    box = el.getBoundingClientRect();
  }

  if (!box) {
    return {
      left: 0,
      top: 0
    };
  }

  var docEl = document.documentElement;
  var body = document.body;

  var clientLeft = docEl.clientLeft || body.clientLeft || 0;
  var scrollLeft = window.pageXOffset || body.scrollLeft;
  var left = box.left + scrollLeft - clientLeft;

  var clientTop = docEl.clientTop || body.clientTop || 0;
  var scrollTop = window.pageYOffset || body.scrollTop;
  var top = box.top + scrollTop - clientTop;

  // Android sometimes returns slightly off decimal values, so need to round
  return {
    left: Math.round(left),
    top: Math.round(top)
  };
}

/**
 * x and y coordinates for a dom element or mouse pointer
 *
 * @typedef {Object} Dom~Coordinates
 *
 * @property {number} x
 *           x coordinate in pixels
 *
 * @property {number} y
 *           y coordinate in pixels
 */

/**
 * Get pointer position in element
 * Returns an object with x and y coordinates.
 * The base on the coordinates are the bottom left of the element.
 *
 * @param {Element} el
 *        Element on which to get the pointer position on
 *
 * @param {EventTarget~Event} event
 *        Event object
 *
 * @return {Dom~Coordinates}
 *         A Coordinates object corresponding to the mouse position.
 *
 */
function getPointerPosition(el, event) {
  var position = {};
  var box = findPosition(el);
  var boxW = el.offsetWidth;
  var boxH = el.offsetHeight;

  var boxY = box.top;
  var boxX = box.left;
  var pageY = event.pageY;
  var pageX = event.pageX;

  if (event.changedTouches) {
    pageX = event.changedTouches[0].pageX;
    pageY = event.changedTouches[0].pageY;
  }

  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));
  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));

  return position;
}

/**
 * Determines, via duck typing, whether or not a value is a text node.
 *
 * @param {Mixed} value
 *        Check if this value is a text node.
 *
 * @return {boolean}
 *         - True if it is a text node
 *         - False otherwise
 */
function isTextNode(value) {
  return isObject(value) && value.nodeType === 3;
}

/**
 * Empties the contents of an element.
 *
 * @param {Element} el
 *        The element to empty children from
 *
 * @return {Element}
 *         The element with no children
 */
function emptyEl(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
  return el;
}

/**
 * Normalizes content for eventual insertion into the DOM.
 *
 * This allows a wide range of content definition methods, but protects
 * from falling into the trap of simply writing to `innerHTML`, which is
 * an XSS concern.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        - String: Normalized into a text node.
 *        - Element/TextNode: Passed through.
 *        - Array: A one-dimensional array of strings, elements, nodes, or functions
 *          (which return single strings, elements, or nodes).
 *        - Function: If the sole argument, is expected to produce a string, element,
 *          node, or array as defined above.
 *
 * @return {Array}
 *         All of the content that was passed in normalized.
 */
function normalizeContent(content) {

  // First, invoke content if it is a function. If it produces an array,
  // that needs to happen before normalization.
  if (typeof content === 'function') {
    content = content();
  }

  // Next up, normalize to an array, so one or many items can be normalized,
  // filtered, and returned.
  return (Array.isArray(content) ? content : [content]).map(function (value) {

    // First, invoke value if it is a function to produce a new value,
    // which will be subsequently normalized to a Node of some kind.
    if (typeof value === 'function') {
      value = value();
    }

    if (isEl(value) || isTextNode(value)) {
      return value;
    }

    if (typeof value === 'string' && /\S/.test(value)) {
      return document.createTextNode(value);
    }
  }).filter(function (value) {
    return value;
  });
}

/**
 * Normalizes and appends content to an element.
 *
 * @param {Element} el
 *        Element to append normalized content to.
 *
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        See the `content` argument of {@link dom:normalizeContent}
 *
 * @return {Element}
 *         The element with appended normalized content.
 */
function appendContent(el, content) {
  normalizeContent(content).forEach(function (node) {
    return el.appendChild(node);
  });
  return el;
}

/**
 * Normalizes and inserts content into an element; this is identical to
 * `appendContent()`, except it empties the element first.
 *
 * @param {Element} el
 *        Element to insert normalized content into.
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        See the `content` argument of {@link dom:normalizeContent}
 *
 * @return {Element}
 *         The element with inserted normalized content.
 *
 */
function insertContent(el, content) {
  return appendContent(emptyEl(el), content);
}

/**
 * Finds a single DOM element matching `selector` within the optional
 * `context` of another DOM element (defaulting to `document`).
 *
 * @param {string} selector
 *        A valid CSS selector, which will be passed to `querySelector`.
 *
 * @param {Element|String} [context=document]
 *        A DOM element within which to query. Can also be a selector
 *        string in which case the first matching element will be used
 *        as context. If missing (or no element matches selector), falls
 *        back to `document`.
 *
 * @return {Element|null}
 *         The element that was found or null.
 */
var $ = createQuerier('querySelector');

/**
 * Finds a all DOM elements matching `selector` within the optional
 * `context` of another DOM element (defaulting to `document`).
 *
 * @param {string} selector
 *           A valid CSS selector, which will be passed to `querySelectorAll`.
 *
 * @param {Element|String} [context=document]
 *           A DOM element within which to query. Can also be a selector
 *           string in which case the first matching element will be used
 *           as context. If missing (or no element matches selector), falls
 *           back to `document`.
 *
 * @return {NodeList}
 *         A element list of elements that were found. Will be empty if none were found.
 *
 */
var $$ = createQuerier('querySelectorAll');



var Dom = (Object.freeze || Object)({
	isReal: isReal,
	isEl: isEl,
	createEl: createEl,
	textContent: textContent,
	prependTo: prependTo,
	hasClass: hasClass,
	addClass: addClass,
	removeClass: removeClass,
	toggleClass: toggleClass,
	setAttributes: setAttributes,
	getAttributes: getAttributes,
	getAttribute: getAttribute,
	setAttribute: setAttribute,
	removeAttribute: removeAttribute,
	blockTextSelection: blockTextSelection,
	unblockTextSelection: unblockTextSelection,
	getBoundingClientRect: getBoundingClientRect,
	findPosition: findPosition,
	getPointerPosition: getPointerPosition,
	isTextNode: isTextNode,
	emptyEl: emptyEl,
	normalizeContent: normalizeContent,
	appendContent: appendContent,
	insertContent: insertContent,
	$: $,
	$$: $$
});

/**
 * @file guid.js
 * @module guid
 */

/**
 * Unique ID for an element or function
 * @type {Number}
 */
var _guid = 1;

/**
 * Get a unique auto-incrementing ID by number that has not been returned before.
 *
 * @return {number}
 *         A new unique ID.
 */
function newGUID() {
  return _guid++;
}

/**
 * @file dom-data.js
 * @module dom-data
 */
/**
 * Element Data Store.
 *
 * Allows for binding data to an element without putting it directly on the
 * element. Ex. Event listeners are stored here.
 * (also from jsninja.com, slightly modified and updated for closure compiler)
 *
 * @type {Object}
 * @private
 */
var elData = {};

/*
 * Unique attribute name to store an element's guid in
 *
 * @type {String}
 * @constant
 * @private
 */
var elIdAttr = 'vdata' + new Date().getTime();

/**
 * Returns the cache object where data for an element is stored
 *
 * @param {Element} el
 *        Element to store data for.
 *
 * @return {Object}
 *         The cache object for that el that was passed in.
 */
function getData(el) {
  var id = el[elIdAttr];

  if (!id) {
    id = el[elIdAttr] = newGUID();
  }

  if (!elData[id]) {
    elData[id] = {};
  }

  return elData[id];
}

/**
 * Returns whether or not an element has cached data
 *
 * @param {Element} el
 *        Check if this element has cached data.
 *
 * @return {boolean}
 *         - True if the DOM element has cached data.
 *         - False otherwise.
 */
function hasData(el) {
  var id = el[elIdAttr];

  if (!id) {
    return false;
  }

  return !!Object.getOwnPropertyNames(elData[id]).length;
}

/**
 * Delete data for the element from the cache and the guid attr from getElementById
 *
 * @param {Element} el
 *        Remove cached data for this element.
 */
function removeData(el) {
  var id = el[elIdAttr];

  if (!id) {
    return;
  }

  // Remove all stored data
  delete elData[id];

  // Remove the elIdAttr property from the DOM node
  try {
    delete el[elIdAttr];
  } catch (e) {
    if (el.removeAttribute) {
      el.removeAttribute(elIdAttr);
    } else {
      // IE doesn't appear to support removeAttribute on the document element
      el[elIdAttr] = null;
    }
  }
}

/**
 * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
 * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
 * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
 * robust as jquery's, so there's probably some differences.
 *
 * @module events
 */

/**
 * Clean up the listener cache and dispatchers
 *
 * @param {Element|Object} elem
 *        Element to clean up
 *
 * @param {string} type
 *        Type of event to clean up
 */
function _cleanUpEvents(elem, type) {
  var data = getData(elem);

  // Remove the events of a particular type if there are none left
  if (data.handlers[type].length === 0) {
    delete data.handlers[type];
    // data.handlers[type] = null;
    // Setting to null was causing an error with data.handlers

    // Remove the meta-handler from the element
    if (elem.removeEventListener) {
      elem.removeEventListener(type, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + type, data.dispatcher);
    }
  }

  // Remove the events object if there are no types left
  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;
  }

  // Finally remove the element data if there is no data left
  if (Object.getOwnPropertyNames(data).length === 0) {
    removeData(elem);
  }
}

/**
 * Loops through an array of event types and calls the requested method for each type.
 *
 * @param {Function} fn
 *        The event method we want to use.
 *
 * @param {Element|Object} elem
 *        Element or object to bind listeners to
 *
 * @param {string} type
 *        Type of event to bind to.
 *
 * @param {EventTarget~EventListener} callback
 *        Event listener.
 */
function _handleMultipleEvents(fn, elem, types, callback) {
  types.forEach(function (type) {
    // Call the event method for each one of the types
    fn(elem, type, callback);
  });
}

/**
 * Fix a native event to have standard property values
 *
 * @param {Object} event
 *        Event object to fix.
 *
 * @return {Object}
 *         Fixed event object.
 */
function fixEvent(event) {

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  }

  // Test if fixing up is needed
  // Used to check if !event.stopPropagation instead of isPropagationStopped
  // But native events return true for stopPropagation, but don't have
  // other expected methods like isPropagationStopped. Seems to be a problem
  // with the Javascript Ninja code. So we're just overriding all events now.
  if (!event || !event.isPropagationStopped) {
    var old = event || window.event;

    event = {};
    // Clone the old object so that we can modify the values event = {};
    // IE8 Doesn't like when you mess with native event properties
    // Firefox returns false for event.hasOwnProperty('type') and other props
    //  which makes copying more difficult.
    // TODO: Probably best to create a whitelist of event props
    for (var key in old) {
      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
      // and webkitMovementX/Y
      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {
        // Chrome 32+ warns if you try to copy deprecated returnValue, but
        // we still want to if preventDefault isn't supported (IE8).
        if (!(key === 'returnValue' && old.preventDefault)) {
          event[key] = old[key];
        }
      }
    }

    // The event occurred on this element
    if (!event.target) {
      event.target = event.srcElement || document;
    }

    // Handle which other element the event is related to
    if (!event.relatedTarget) {
      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
    }

    // Stop the default browser action
    event.preventDefault = function () {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event.returnValue = false;
      old.returnValue = false;
      event.defaultPrevented = true;
    };

    event.defaultPrevented = false;

    // Stop the event from bubbling
    event.stopPropagation = function () {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event.cancelBubble = true;
      old.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };

    event.isPropagationStopped = returnFalse;

    // Stop the event from bubbling and executing other handlers
    event.stopImmediatePropagation = function () {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };

    event.isImmediatePropagationStopped = returnFalse;

    // Handle mouse position
    if (event.clientX !== null && event.clientX !== undefined) {
      var doc = document.documentElement;
      var body = document.body;

      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // Handle key presses
    event.which = event.charCode || event.keyCode;

    // Fix button for mouse clicks:
    // 0 == left; 1 == middle; 2 == right
    if (event.button !== null && event.button !== undefined) {

      // The following is disabled because it does not pass videojs-standard
      // and... yikes.
      /* eslint-disable */
      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
      /* eslint-enable */
    }
  }

  // Returns fixed-up instance
  return event;
}

/**
 * Whether passive event listeners are supported
 */
var _supportsPassive = false;

(function () {
  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function get() {
        _supportsPassive = true;
      }
    });

    window.addEventListener('test', null, opts);
  } catch (e) {
    // disregard
  }
})();

/**
 * Touch events Chrome expects to be passive
 */
var passiveEvents = ['touchstart', 'touchmove'];

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 *
 * @param {Element|Object} elem
 *        Element or object to bind listeners to
 *
 * @param {string|string[]} type
 *        Type of event to bind to.
 *
 * @param {EventTarget~EventListener} fn
 *        Event listener.
 */
function on(elem, type, fn) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(on, elem, type, fn);
  }

  var data = getData(elem);

  // We need a place to store all our handler data
  if (!data.handlers) {
    data.handlers = {};
  }

  if (!data.handlers[type]) {
    data.handlers[type] = [];
  }

  if (!fn.guid) {
    fn.guid = newGUID();
  }

  data.handlers[type].push(fn);

  if (!data.dispatcher) {
    data.disabled = false;

    data.dispatcher = function (event, hash) {

      if (data.disabled) {
        return;
      }

      event = fixEvent(event);

      var handlers = data.handlers[event.type];

      if (handlers) {
        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
        var handlersCopy = handlers.slice(0);

        for (var m = 0, n = handlersCopy.length; m < n; m++) {
          if (event.isImmediatePropagationStopped()) {
            break;
          } else {
            try {
              handlersCopy[m].call(elem, event, hash);
            } catch (e) {
              log$1.error(e);
            }
          }
        }
      }
    };
  }

  if (data.handlers[type].length === 1) {
    if (elem.addEventListener) {
      var options = false;

      if (_supportsPassive && passiveEvents.indexOf(type) > -1) {
        options = { passive: true };
      }
      elem.addEventListener(type, data.dispatcher, options);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + type, data.dispatcher);
    }
  }
}

/**
 * Removes event listeners from an element
 *
 * @param {Element|Object} elem
 *        Object to remove listeners from.
 *
 * @param {string|string[]} [type]
 *        Type of listener to remove. Don't include to remove all events from element.
 *
 * @param {EventTarget~EventListener} [fn]
 *        Specific listener to remove. Don't include to remove listeners for an event
 *        type.
 */
function off(elem, type, fn) {
  // Don't want to add a cache object through getElData if not needed
  if (!hasData(elem)) {
    return;
  }

  var data = getData(elem);

  // If no events exist, nothing to unbind
  if (!data.handlers) {
    return;
  }

  if (Array.isArray(type)) {
    return _handleMultipleEvents(off, elem, type, fn);
  }

  // Utility function
  var removeType = function removeType(t) {
    data.handlers[t] = [];
    _cleanUpEvents(elem, t);
  };

  // Are we removing all bound events?
  if (!type) {
    for (var t in data.handlers) {
      removeType(t);
    }
    return;
  }

  var handlers = data.handlers[type];

  // If no handlers exist, nothing to unbind
  if (!handlers) {
    return;
  }

  // If no listener was provided, remove all listeners for type
  if (!fn) {
    removeType(type);
    return;
  }

  // We're only removing a single handler
  if (fn.guid) {
    for (var n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn.guid) {
        handlers.splice(n--, 1);
      }
    }
  }

  _cleanUpEvents(elem, type);
}

/**
 * Trigger an event for an element
 *
 * @param {Element|Object} elem
 *        Element to trigger an event on
 *
 * @param {EventTarget~Event|string} event
 *        A string (the type) or an event object with a type attribute
 *
 * @param {Object} [hash]
 *        data hash to pass along with the event
 *
 * @return {boolean|undefined}
 *         - Returns the opposite of `defaultPrevented` if default was prevented
 *         - Otherwise returns undefined
 */
function trigger(elem, event, hash) {
  // Fetches element data and a reference to the parent (for bubbling).
  // Don't want to add a data object to cache for every parent,
  // so checking hasElData first.
  var elemData = hasData(elem) ? getData(elem) : {};
  var parent = elem.parentNode || elem.ownerDocument;
  // type = event.type || event,
  // handler;

  // If an event name was passed as a string, creates an event out of it
  if (typeof event === 'string') {
    event = { type: event, target: elem };
  }
  // Normalizes the event properties.
  event = fixEvent(event);

  // If the passed element has a dispatcher, executes the established handlers.
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event, hash);
  }

  // Unless explicitly stopped or the event does not bubble (e.g. media events)
  // recursively calls this function to bubble the event up the DOM.
  if (parent && !event.isPropagationStopped() && event.bubbles === true) {
    trigger.call(null, parent, event, hash);

    // If at the top of the DOM, triggers the default action unless disabled.
  } else if (!parent && !event.defaultPrevented) {
    var targetData = getData(event.target);

    // Checks if the target has a default action for this event.
    if (event.target[event.type]) {
      // Temporarily disables event dispatching on the target as we have already executed the handler.
      targetData.disabled = true;
      // Executes the default action.
      if (typeof event.target[event.type] === 'function') {
        event.target[event.type]();
      }
      // Re-enables event dispatching.
      targetData.disabled = false;
    }
  }

  // Inform the triggerer if the default was prevented by returning false
  return !event.defaultPrevented;
}

/**
 * Trigger a listener only once for an event
 *
 * @param {Element|Object} elem
 *        Element or object to bind to.
 *
 * @param {string|string[]} type
 *        Name/type of event
 *
 * @param {Event~EventListener} fn
 *        Event Listener function
 */
function one(elem, type, fn) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(one, elem, type, fn);
  }
  var func = function func() {
    off(elem, type, func);
    fn.apply(this, arguments);
  };

  // copy the guid to the new function so it can removed using the original function's ID
  func.guid = fn.guid = fn.guid || newGUID();
  on(elem, type, func);
}

var Events = (Object.freeze || Object)({
	fixEvent: fixEvent,
	on: on,
	off: off,
	trigger: trigger,
	one: one
});

/**
 * @file setup.js - Functions for setting up a player without
 * user interaction based on the data-setup `attribute` of the video tag.
 *
 * @module setup
 */
var _windowLoaded = false;
var videojs$2 = void 0;

/**
 * Set up any tags that have a data-setup `attribute` when the player is started.
 */
var autoSetup = function autoSetup() {

  // Protect against breakage in non-browser environments.
  if (!isReal()) {
    return;
  }

  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*
  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));
  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));
  // var mediaEls = vids.concat(audios);

  // Because IE8 doesn't support calling slice on a node list, we need to loop
  // through each list of elements to build up a new, combined list of elements.
  var vids = document.getElementsByTagName('video');
  var audios = document.getElementsByTagName('audio');
  var mediaEls = [];

  if (vids && vids.length > 0) {
    for (var i = 0, e = vids.length; i < e; i++) {
      mediaEls.push(vids[i]);
    }
  }

  if (audios && audios.length > 0) {
    for (var _i = 0, _e = audios.length; _i < _e; _i++) {
      mediaEls.push(audios[_i]);
    }
  }

  // Check if any media elements exist
  if (mediaEls && mediaEls.length > 0) {

    for (var _i2 = 0, _e2 = mediaEls.length; _i2 < _e2; _i2++) {
      var mediaEl = mediaEls[_i2];

      // Check if element exists, has getAttribute func.
      // IE seems to consider typeof el.getAttribute == 'object' instead of
      // 'function' like expected, at least when loading the player immediately.
      if (mediaEl && mediaEl.getAttribute) {

        // Make sure this player hasn't already been set up.
        if (mediaEl.player === undefined) {
          var options = mediaEl.getAttribute('data-setup');

          // Check if data-setup attr exists.
          // We only auto-setup if they've added the data-setup attr.
          if (options !== null) {
            // Create new video.js instance.
            videojs$2(mediaEl);
          }
        }

        // If getAttribute isn't defined, we need to wait for the DOM.
      } else {
        autoSetupTimeout(1);
        break;
      }
    }

    // No videos were found, so keep looping unless page is finished loading.
  } else if (!_windowLoaded) {
    autoSetupTimeout(1);
  }
};

/**
 * Wait until the page is loaded before running autoSetup. This will be called in
 * autoSetup if `hasLoaded` returns false.
 *
 * @param {number} wait
 *        How long to wait in ms
 *
 * @param {module:videojs} [vjs]
 *        The videojs library function
 */
function autoSetupTimeout(wait, vjs) {
  if (vjs) {
    videojs$2 = vjs;
  }

  window.setTimeout(autoSetup, wait);
}

if (isReal() && document.readyState === 'complete') {
  _windowLoaded = true;
} else {
  /**
   * Listen for the load event on window, and set _windowLoaded to true.
   *
   * @listens load
   */
  one(window, 'load', function () {
    _windowLoaded = true;
  });
}

/**
 * @file stylesheet.js
 * @module stylesheet
 */
/**
 * Create a DOM syle element given a className for it.
 *
 * @param {string} className
 *        The className to add to the created style element.
 *
 * @return {Element}
 *         The element that was created.
 */
var createStyleElement = function createStyleElement(className) {
  var style = document.createElement('style');

  style.className = className;

  return style;
};

/**
 * Add text to a DOM element.
 *
 * @param {Element} el
 *        The Element to add text content to.
 *
 * @param {string} content
 *        The text to add to the element.
 */
var setTextContent = function setTextContent(el, content) {
  if (el.styleSheet) {
    el.styleSheet.cssText = content;
  } else {
    el.textContent = content;
  }
};

/**
 * @file fn.js
 * @module fn
 */
/**
 * Bind (a.k.a proxy or Context). A simple method for changing the context of a function
 * It also stores a unique id on the function so it can be easily removed from events.
 *
 * @param {Mixed} context
 *        The object to bind as scope.
 *
 * @param {Function} fn
 *        The function to be bound to a scope.
 *
 * @param {number} [uid]
 *        An optional unique ID for the function to be set
 *
 * @return {Function}
 *         The new function that will be bound into the context given
 */
var bind = function bind(context, fn, uid) {
  // Make sure the function has a unique ID
  if (!fn.guid) {
    fn.guid = newGUID();
  }

  // Create the new function that changes the context
  var bound = function bound() {
    return fn.apply(context, arguments);
  };

  // Allow for the ability to individualize this function
  // Needed in the case where multiple objects might share the same prototype
  // IF both items add an event listener with the same function, then you try to remove just one
  // it will remove both because they both have the same guid.
  // when using this, you need to use the bind method when you remove the listener as well.
  // currently used in text tracks
  bound.guid = uid ? uid + '_' + fn.guid : fn.guid;

  return bound;
};

/**
 * Wraps the given function, `fn`, with a new function that only invokes `fn`
 * at most once per every `wait` milliseconds.
 *
 * @param  {Function} fn
 *         The function to be throttled.
 *
 * @param  {Number}   wait
 *         The number of milliseconds by which to throttle.
 *
 * @return {Function}
 */
var throttle = function throttle(fn, wait) {
  var last = Date.now();

  var throttled = function throttled() {
    var now = Date.now();

    if (now - last >= wait) {
      fn.apply(undefined, arguments);
      last = now;
    }
  };

  return throttled;
};

/**
 * @file src/js/event-target.js
 */
/**
 * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It
 * adds shorthand functions that wrap around lengthy functions. For example:
 * the `on` function is a wrapper around `addEventListener`.
 *
 * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}
 * @class EventTarget
 */
var EventTarget = function EventTarget() {};

/**
 * A Custom DOM event.
 *
 * @typedef {Object} EventTarget~Event
 * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}
 */

/**
 * All event listeners should follow the following format.
 *
 * @callback EventTarget~EventListener
 * @this {EventTarget}
 *
 * @param {EventTarget~Event} event
 *        the event that triggered this function
 *
 * @param {Object} [hash]
 *        hash of data sent during the event
 */

/**
 * An object containing event names as keys and booleans as values.
 *
 * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}
 *         will have extra functionality. See that function for more information.
 *
 * @property EventTarget.prototype.allowedEvents_
 * @private
 */
EventTarget.prototype.allowedEvents_ = {};

/**
 * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
 * function that will get called when an event with a certain name gets triggered.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to call with `EventTarget`s
 */
EventTarget.prototype.on = function (type, fn) {
  // Remove the addEventListener alias before calling Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;

  this.addEventListener = function () {};
  on(this, type, fn);
  this.addEventListener = ael;
};

/**
 * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#on}
 */
EventTarget.prototype.addEventListener = EventTarget.prototype.on;

/**
 * Removes an `event listener` for a specific event from an instance of `EventTarget`.
 * This makes it so that the `event listener` will no longer get called when the
 * named event happens.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to remove.
 */
EventTarget.prototype.off = function (type, fn) {
  off(this, type, fn);
};

/**
 * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#off}
 */
EventTarget.prototype.removeEventListener = EventTarget.prototype.off;

/**
 * This function will add an `event listener` that gets triggered only once. After the
 * first trigger it will get removed. This is like adding an `event listener`
 * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to be called once for each event name.
 */
EventTarget.prototype.one = function (type, fn) {
  // Remove the addEventListener alialing Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;

  this.addEventListener = function () {};
  one(this, type, fn);
  this.addEventListener = ael;
};

/**
 * This function causes an event to happen. This will then cause any `event listeners`
 * that are waiting for that event, to get called. If there are no `event listeners`
 * for an event then nothing will happen.
 *
 * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
 * Trigger will also call the `on` + `uppercaseEventName` function.
 *
 * Example:
 * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
 * `onClick` if it exists.
 *
 * @param {string|EventTarget~Event|Object} event
 *        The name of the event, an `Event`, or an object with a key of type set to
 *        an event name.
 */
EventTarget.prototype.trigger = function (event) {
  var type = event.type || event;

  if (typeof event === 'string') {
    event = { type: type };
  }
  event = fixEvent(event);

  if (this.allowedEvents_[type] && this['on' + type]) {
    this['on' + type](event);
  }

  trigger(this, event);
};

/**
 * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#trigger}
 */
EventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;

/**
 * @file mixins/evented.js
 * @module evented
 */
/**
 * Returns whether or not an object has had the evented mixin applied.
 *
 * @param  {Object} object
 *         An object to test.
 *
 * @return {boolean}
 *         Whether or not the object appears to be evented.
 */
var isEvented = function isEvented(object) {
  return object instanceof EventTarget || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(function (k) {
    return typeof object[k] === 'function';
  });
};

/**
 * Whether a value is a valid event type - non-empty string or array.
 *
 * @private
 * @param  {string|Array} type
 *         The type value to test.
 *
 * @return {boolean}
 *         Whether or not the type is a valid event type.
 */
var isValidEventType = function isValidEventType(type) {
  return (
    // The regex here verifies that the `type` contains at least one non-
    // whitespace character.
    typeof type === 'string' && /\S/.test(type) || Array.isArray(type) && !!type.length
  );
};

/**
 * Validates a value to determine if it is a valid event target. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the target does not appear to be a valid event target.
 *
 * @param  {Object} target
 *         The object to test.
 */
var validateTarget = function validateTarget(target) {
  if (!target.nodeName && !isEvented(target)) {
    throw new Error('Invalid target; must be a DOM node or evented object.');
  }
};

/**
 * Validates a value to determine if it is a valid event target. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the type does not appear to be a valid event type.
 *
 * @param  {string|Array} type
 *         The type to test.
 */
var validateEventType = function validateEventType(type) {
  if (!isValidEventType(type)) {
    throw new Error('Invalid event type; must be a non-empty string or array.');
  }
};

/**
 * Validates a value to determine if it is a valid listener. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the listener is not a function.
 *
 * @param  {Function} listener
 *         The listener to test.
 */
var validateListener = function validateListener(listener) {
  if (typeof listener !== 'function') {
    throw new Error('Invalid listener; must be a function.');
  }
};

/**
 * Takes an array of arguments given to `on()` or `one()`, validates them, and
 * normalizes them into an object.
 *
 * @private
 * @param  {Object} self
 *         The evented object on which `on()` or `one()` was called. This
 *         object will be bound as the `this` value for the listener.
 *
 * @param  {Array} args
 *         An array of arguments passed to `on()` or `one()`.
 *
 * @return {Object}
 *         An object containing useful values for `on()` or `one()` calls.
 */
var normalizeListenArgs = function normalizeListenArgs(self, args) {

  // If the number of arguments is less than 3, the target is always the
  // evented object itself.
  var isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;
  var target = void 0;
  var type = void 0;
  var listener = void 0;

  if (isTargetingSelf) {
    target = self.eventBusEl_;

    // Deal with cases where we got 3 arguments, but we are still listening to
    // the evented object itself.
    if (args.length >= 3) {
      args.shift();
    }

    type = args[0];
    listener = args[1];
  } else {
    target = args[0];
    type = args[1];
    listener = args[2];
  }

  validateTarget(target);
  validateEventType(type);
  validateListener(listener);

  listener = bind(self, listener);

  return { isTargetingSelf: isTargetingSelf, target: target, type: type, listener: listener };
};

/**
 * Adds the listener to the event type(s) on the target, normalizing for
 * the type of target.
 *
 * @private
 * @param  {Element|Object} target
 *         A DOM node or evented object.
 *
 * @param  {string} method
 *         The event binding method to use ("on" or "one").
 *
 * @param  {string|Array} type
 *         One or more event type(s).
 *
 * @param  {Function} listener
 *         A listener function.
 */
var listen = function listen(target, method, type, listener) {
  validateTarget(target);

  if (target.nodeName) {
    Events[method](target, type, listener);
  } else {
    target[method](type, listener);
  }
};

/**
 * Contains methods that provide event capabilites to an object which is passed
 * to {@link module:evented|evented}.
 *
 * @mixin EventedMixin
 */
var EventedMixin = {

  /**
   * Add a listener to an event (or events) on this object or another evented
   * object.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  on: function on$$1() {
    var _this = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _normalizeListenArgs = normalizeListenArgs(this, args),
        isTargetingSelf = _normalizeListenArgs.isTargetingSelf,
        target = _normalizeListenArgs.target,
        type = _normalizeListenArgs.type,
        listener = _normalizeListenArgs.listener;

    listen(target, 'on', type, listener);

    // If this object is listening to another evented object.
    if (!isTargetingSelf) {

      // If this object is disposed, remove the listener.
      var removeListenerOnDispose = function removeListenerOnDispose() {
        return _this.off(target, type, listener);
      };

      // Use the same function ID as the listener so we can remove it later it
      // using the ID of the original listener.
      removeListenerOnDispose.guid = listener.guid;

      // Add a listener to the target's dispose event as well. This ensures
      // that if the target is disposed BEFORE this object, we remove the
      // removal listener that was just added. Otherwise, we create a memory leak.
      var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose() {
        return _this.off('dispose', removeListenerOnDispose);
      };

      // Use the same function ID as the listener so we can remove it later
      // it using the ID of the original listener.
      removeRemoverOnTargetDispose.guid = listener.guid;

      listen(this, 'on', 'dispose', removeListenerOnDispose);
      listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);
    }
  },


  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will only be called once and then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  one: function one$$1() {
    var _this2 = this;

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var _normalizeListenArgs2 = normalizeListenArgs(this, args),
        isTargetingSelf = _normalizeListenArgs2.isTargetingSelf,
        target = _normalizeListenArgs2.target,
        type = _normalizeListenArgs2.type,
        listener = _normalizeListenArgs2.listener;

    // Targeting this evented object.


    if (isTargetingSelf) {
      listen(target, 'one', type, listener);

      // Targeting another evented object.
    } else {
      var wrapper = function wrapper() {
        for (var _len3 = arguments.length, largs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          largs[_key3] = arguments[_key3];
        }

        _this2.off(target, type, wrapper);
        listener.apply(null, largs);
      };

      // Use the same function ID as the listener so we can remove it later
      // it using the ID of the original listener.
      wrapper.guid = listener.guid;
      listen(target, 'one', type, wrapper);
    }
  },


  /**
   * Removes listener(s) from event(s) on an evented object.
   *
   * @param  {string|Array|Element|Object} [targetOrType]
   *         If this is a string or array, it represents the event type(s).
   *
   *         Another evented object can be passed here instead, in which case
   *         ALL 3 arguments are _required_.
   *
   * @param  {string|Array|Function} [typeOrListener]
   *         If the first argument was a string or array, this may be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function; otherwise, _all_ listeners bound to the
   *         event type(s) will be removed.
   */
  off: function off$$1(targetOrType, typeOrListener, listener) {

    // Targeting this evented object.
    if (!targetOrType || isValidEventType(targetOrType)) {
      off(this.eventBusEl_, targetOrType, typeOrListener);

      // Targeting another evented object.
    } else {
      var target = targetOrType;
      var type = typeOrListener;

      // Fail fast and in a meaningful way!
      validateTarget(target);
      validateEventType(type);
      validateListener(listener);

      // Ensure there's at least a guid, even if the function hasn't been used
      listener = bind(this, listener);

      // Remove the dispose listener on this evented object, which was given
      // the same guid as the event listener in on().
      this.off('dispose', listener);

      if (target.nodeName) {
        off(target, type, listener);
        off(target, 'dispose', listener);
      } else if (isEvented(target)) {
        target.off(type, listener);
        target.off('dispose', listener);
      }
    }
  },


  /**
   * Fire an event on this evented object, causing its listeners to be called.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash]
   *          An additional object to pass along to listeners.
   *
   * @returns {boolean}
   *          Whether or not the default behavior was prevented.
   */
  trigger: function trigger$$1(event, hash) {
    return trigger(this.eventBusEl_, event, hash);
  }
};

/**
 * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.
 *
 * @param  {Object} target
 *         The object to which to add event methods.
 *
 * @param  {Object} [options={}]
 *         Options for customizing the mixin behavior.
 *
 * @param  {String} [options.eventBusKey]
 *         By default, adds a `eventBusEl_` DOM element to the target object,
 *         which is used as an event bus. If the target object already has a
 *         DOM element that should be used, pass its key here.
 *
 * @return {Object}
 *         The target object.
 */
function evented(target) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var eventBusKey = options.eventBusKey;

  // Set or create the eventBusEl_.

  if (eventBusKey) {
    if (!target[eventBusKey].nodeName) {
      throw new Error('The eventBusKey "' + eventBusKey + '" does not refer to an element.');
    }
    target.eventBusEl_ = target[eventBusKey];
  } else {
    target.eventBusEl_ = createEl('span', { className: 'vjs-event-bus' });
  }

  assign(target, EventedMixin);

  // When any evented object is disposed, it removes all its listeners.
  target.on('dispose', function () {
    return target.off();
  });

  return target;
}

/**
 * @file mixins/stateful.js
 * @module stateful
 */
/**
 * Contains methods that provide statefulness to an object which is passed
 * to {@link module:stateful}.
 *
 * @mixin StatefulMixin
 */
var StatefulMixin = {

  /**
   * A hash containing arbitrary keys and values representing the state of
   * the object.
   *
   * @type {Object}
   */
  state: {},

  /**
   * Set the state of an object by mutating its
   * {@link module:stateful~StatefulMixin.state|state} object in place.
   *
   * @fires   module:stateful~StatefulMixin#statechanged
   * @param   {Object|Function} stateUpdates
   *          A new set of properties to shallow-merge into the plugin state.
   *          Can be a plain object or a function returning a plain object.
   *
   * @returns {Object|undefined}
   *          An object containing changes that occurred. If no changes
   *          occurred, returns `undefined`.
   */
  setState: function setState(stateUpdates) {
    var _this = this;

    // Support providing the `stateUpdates` state as a function.
    if (typeof stateUpdates === 'function') {
      stateUpdates = stateUpdates();
    }

    var changes = void 0;

    each(stateUpdates, function (value, key) {

      // Record the change if the value is different from what's in the
      // current state.
      if (_this.state[key] !== value) {
        changes = changes || {};
        changes[key] = {
          from: _this.state[key],
          to: value
        };
      }

      _this.state[key] = value;
    });

    // Only trigger "statechange" if there were changes AND we have a trigger
    // function. This allows us to not require that the target object be an
    // evented object.
    if (changes && isEvented(this)) {

      /**
       * An event triggered on an object that is both
       * {@link module:stateful|stateful} and {@link module:evented|evented}
       * indicating that its state has changed.
       *
       * @event    module:stateful~StatefulMixin#statechanged
       * @type     {Object}
       * @property {Object} changes
       *           A hash containing the properties that were changed and
       *           the values they were changed `from` and `to`.
       */
      this.trigger({
        changes: changes,
        type: 'statechanged'
      });
    }

    return changes;
  }
};

/**
 * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target
 * object.
 *
 * If the target object is {@link module:evented|evented} and has a
 * `handleStateChanged` method, that method will be automatically bound to the
 * `statechanged` event on itself.
 *
 * @param   {Object} target
 *          The object to be made stateful.
 *
 * @param   {Object} [defaultState]
 *          A default set of properties to populate the newly-stateful object's
 *          `state` property.
 *
 * @returns {Object}
 *          Returns the `target`.
 */
function stateful(target, defaultState) {
  assign(target, StatefulMixin);

  // This happens after the mixing-in because we need to replace the `state`
  // added in that step.
  target.state = assign({}, target.state, defaultState);

  // Auto-bind the `handleStateChanged` method of the target object if it exists.
  if (typeof target.handleStateChanged === 'function' && isEvented(target)) {
    target.on('statechanged', target.handleStateChanged);
  }

  return target;
}

/**
 * @file to-title-case.js
 * @module to-title-case
 */

/**
 * Uppercase the first letter of a string.
 *
 * @param {string} string
 *        String to be uppercased
 *
 * @return {string}
 *         The string with an uppercased first letter
 */
function toTitleCase(string) {
  if (typeof string !== 'string') {
    return string;
  }

  return string.charAt(0).toUpperCase() + string.slice(1);
}

/**
 * Compares the TitleCase versions of the two strings for equality.
 *
 * @param {string} str1
 *        The first string to compare
 *
 * @param {string} str2
 *        The second string to compare
 *
 * @return {boolean}
 *         Whether the TitleCase versions of the strings are equal
 */
function titleCaseEquals(str1, str2) {
  return toTitleCase(str1) === toTitleCase(str2);
}

/**
 * @file merge-options.js
 * @module merge-options
 */
/**
 * Deep-merge one or more options objects, recursively merging **only** plain
 * object properties.
 *
 * @param   {Object[]} sources
 *          One or more objects to merge into a new object.
 *
 * @returns {Object}
 *          A new object that is the merged result of all sources.
 */
function mergeOptions() {
  var result = {};

  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    each(source, function (value, key) {
      if (!isPlain(value)) {
        result[key] = value;
        return;
      }

      if (!isPlain(result[key])) {
        result[key] = {};
      }

      result[key] = mergeOptions(result[key], value);
    });
  });

  return result;
}

/**
 * Player Component - Base class for all UI objects
 *
 * @file component.js
 */
/**
 * Base class for all UI Components.
 * Components are UI objects which represent both a javascript object and an element
 * in the DOM. They can be children of other components, and can have
 * children themselves.
 *
 * Components can also use methods from {@link EventTarget}
 */

var Component = function () {

  /**
   * A callback that is called when a component is ready. Does not have any
   * paramters and any callback value will be ignored.
   *
   * @callback Component~ReadyCallback
   * @this Component
   */

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Object[]} [options.children]
   *        An array of children objects to intialize this component with. Children objects have
   *        a name property that will be used if more than one component of the same type needs to be
   *        added.
   *
   * @param {Component~ReadyCallback} [ready]
   *        Function that gets called when the `Component` is ready.
   */
  function Component(player, options, ready) {
    classCallCheck(this, Component);


    // The component might be the player itself and we can't pass `this` to super
    if (!player && this.play) {
      this.player_ = player = this; // eslint-disable-line
    } else {
      this.player_ = player;
    }

    // Make a copy of prototype.options_ to protect against overriding defaults
    this.options_ = mergeOptions({}, this.options_);

    // Updated options with supplied options
    options = this.options_ = mergeOptions(this.options_, options);

    // Get ID from options or options element if one is supplied
    this.id_ = options.id || options.el && options.el.id;

    // If there was no ID from the options, generate one
    if (!this.id_) {
      // Don't require the player ID function in the case of mock players
      var id = player && player.id && player.id() || 'no_player';

      this.id_ = id + '_component_' + newGUID();
    }

    this.name_ = options.name || null;

    // Create element if one wasn't provided in options
    if (options.el) {
      this.el_ = options.el;
    } else if (options.createEl !== false) {
      this.el_ = this.createEl();
    }

    // Make this an evented object and use `el_`, if available, as its event bus
    evented(this, { eventBusKey: this.el_ ? 'el_' : null });
    stateful(this, this.constructor.defaultState);

    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};

    // Add any child components in options
    if (options.initChildren !== false) {
      this.initChildren();
    }

    this.ready(ready);
    // Don't want to trigger ready here or it will before init is actually
    // finished for all children that run this constructor

    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }

  /**
   * Dispose of the `Component` and all child components.
   *
   * @fires Component#dispose
   */


  Component.prototype.dispose = function dispose() {

    /**
     * Triggered when a `Component` is disposed.
     *
     * @event Component#dispose
     * @type {EventTarget~Event}
     *
     * @property {boolean} [bubbles=false]
     *           set to false so that the close event does not
     *           bubble up
     */
    this.trigger({ type: 'dispose', bubbles: false });

    // Dispose all children.
    if (this.children_) {
      for (var i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i].dispose) {
          this.children_[i].dispose();
        }
      }
    }

    // Delete child references
    this.children_ = null;
    this.childIndex_ = null;
    this.childNameIndex_ = null;

    if (this.el_) {
      // Remove element from DOM
      if (this.el_.parentNode) {
        this.el_.parentNode.removeChild(this.el_);
      }

      removeData(this.el_);
      this.el_ = null;
    }
  };

  /**
   * Return the {@link Player} that the `Component` has attached to.
   *
   * @return {Player}
   *         The player that this `Component` has attached to.
   */


  Component.prototype.player = function player() {
    return this.player_;
  };

  /**
   * Deep merge of options objects with new options.
   * > Note: When both `obj` and `options` contain properties whose values are objects.
   *         The two properties get merged using {@link module:mergeOptions}
   *
   * @param {Object} obj
   *        The object that contains new options.
   *
   * @return {Object}
   *         A new object of `this.options_` and `obj` merged together.
   *
   * @deprecated since version 5
   */


  Component.prototype.options = function options(obj) {
    log$1.warn('this.options() has been deprecated and will be moved to the constructor in 6.0');

    if (!obj) {
      return this.options_;
    }

    this.options_ = mergeOptions(this.options_, obj);
    return this.options_;
  };

  /**
   * Get the `Component`s DOM element
   *
   * @return {Element}
   *         The DOM element for this `Component`.
   */


  Component.prototype.el = function el() {
    return this.el_;
  };

  /**
   * Create the `Component`s DOM element.
   *
   * @param {string} [tagName]
   *        Element's DOM node type. e.g. 'div'
   *
   * @param {Object} [properties]
   *        An object of properties that should be set.
   *
   * @param {Object} [attributes]
   *        An object of attributes that should be set.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Component.prototype.createEl = function createEl$$1(tagName, properties, attributes) {
    return createEl(tagName, properties, attributes);
  };

  /**
   * Localize a string given the string in english.
   *
   * If tokens are provided, it'll try and run a simple token replacement on the provided string.
   * The tokens it loooks for look like `{1}` with the index being 1-indexed into the tokens array.
   *
   * If a `defaultValue` is provided, it'll use that over `string`,
   * if a value isn't found in provided language files.
   * This is useful if you want to have a descriptive key for token replacement
   * but have a succinct localized string and not require `en.json` to be included.
   *
   * Currently, it is used for the progress bar timing.
   * ```js
   * {
   *   "progress bar timing: currentTime={1} duration={2}": "{1} of {2}"
   * }
   * ```
   * It is then used like so:
   * ```js
   * this.localize('progress bar timing: currentTime={1} duration{2}',
   *               [this.player_.currentTime(), this.player_.duration()],
   *               '{1} of {2}');
   * ```
   *
   * Which outputs something like: `01:23 of 24:56`.
   *
   *
   * @param {string} string
   *        The string to localize and the key to lookup in the language files.
   * @param {string[]} [tokens]
   *        If the current item has token replacements, provide the tokens here.
   * @param {string} [defaultValue]
   *        Defaults to `string`. Can be a default value to use for token replacement
   *        if the lookup key is needed to be separate.
   *
   * @return {string}
   *         The localized string or if no localization exists the english string.
   */


  Component.prototype.localize = function localize(string, tokens) {
    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : string;

    var code = this.player_.language && this.player_.language();
    var languages = this.player_.languages && this.player_.languages();
    var language = languages && languages[code];
    var primaryCode = code && code.split('-')[0];
    var primaryLang = languages && languages[primaryCode];

    var localizedString = defaultValue;

    if (language && language[string]) {
      localizedString = language[string];
    } else if (primaryLang && primaryLang[string]) {
      localizedString = primaryLang[string];
    }

    if (tokens) {
      localizedString = localizedString.replace(/\{(\d+)\}/g, function (match, index) {
        var value = tokens[index - 1];
        var ret = value;

        if (typeof value === 'undefined') {
          ret = match;
        }

        return ret;
      });
    }

    return localizedString;
  };

  /**
   * Return the `Component`s DOM element. This is where children get inserted.
   * This will usually be the the same as the element returned in {@link Component#el}.
   *
   * @return {Element}
   *         The content element for this `Component`.
   */


  Component.prototype.contentEl = function contentEl() {
    return this.contentEl_ || this.el_;
  };

  /**
   * Get this `Component`s ID
   *
   * @return {string}
   *         The id of this `Component`
   */


  Component.prototype.id = function id() {
    return this.id_;
  };

  /**
   * Get the `Component`s name. The name gets used to reference the `Component`
   * and is set during registration.
   *
   * @return {string}
   *         The name of this `Component`.
   */


  Component.prototype.name = function name() {
    return this.name_;
  };

  /**
   * Get an array of all child components
   *
   * @return {Array}
   *         The children
   */


  Component.prototype.children = function children() {
    return this.children_;
  };

  /**
   * Returns the child `Component` with the given `id`.
   *
   * @param {string} id
   *        The id of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `id` or undefined.
   */


  Component.prototype.getChildById = function getChildById(id) {
    return this.childIndex_[id];
  };

  /**
   * Returns the child `Component` with the given `name`.
   *
   * @param {string} name
   *        The name of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `name` or undefined.
   */


  Component.prototype.getChild = function getChild(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    return this.childNameIndex_[name];
  };

  /**
   * Add a child `Component` inside the current `Component`.
   *
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @param {number} [index=this.children_.length]
   *        The index to attempt to add a child into.
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   */


  Component.prototype.addChild = function addChild(child) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.children_.length;

    var component = void 0;
    var componentName = void 0;

    // If child is a string, create component with options
    if (typeof child === 'string') {
      componentName = toTitleCase(child);

      var componentClassName = options.componentClass || componentName;

      // Set name through options
      options.name = componentName;

      // Create a new object & element for this controls set
      // If there's no .player_, this is a player
      var ComponentClass = Component.getComponent(componentClassName);

      if (!ComponentClass) {
        throw new Error('Component ' + componentClassName + ' does not exist');
      }

      // data stored directly on the videojs object may be
      // misidentified as a component to retain
      // backwards-compatibility with 4.x. check to make sure the
      // component class can be instantiated.
      if (typeof ComponentClass !== 'function') {
        return null;
      }

      component = new ComponentClass(this.player_ || this, options);

      // child is a component instance
    } else {
      component = child;
    }

    this.children_.splice(index, 0, component);

    if (typeof component.id === 'function') {
      this.childIndex_[component.id()] = component;
    }

    // If a name wasn't used to create the component, check if we can use the
    // name function of the component
    componentName = componentName || component.name && toTitleCase(component.name());

    if (componentName) {
      this.childNameIndex_[componentName] = component;
    }

    // Add the UI object's element to the container div (box)
    // Having an element is not required
    if (typeof component.el === 'function' && component.el()) {
      var childNodes = this.contentEl().children;
      var refNode = childNodes[index] || null;

      this.contentEl().insertBefore(component.el(), refNode);
    }

    // Return so it can stored on parent object if desired.
    return component;
  };

  /**
   * Remove a child `Component` from this `Component`s list of children. Also removes
   * the child `Component`s element from this `Component`s element.
   *
   * @param {Component} component
   *        The child `Component` to remove.
   */


  Component.prototype.removeChild = function removeChild(component) {
    if (typeof component === 'string') {
      component = this.getChild(component);
    }

    if (!component || !this.children_) {
      return;
    }

    var childFound = false;

    for (var i = this.children_.length - 1; i >= 0; i--) {
      if (this.children_[i] === component) {
        childFound = true;
        this.children_.splice(i, 1);
        break;
      }
    }

    if (!childFound) {
      return;
    }

    this.childIndex_[component.id()] = null;
    this.childNameIndex_[component.name()] = null;

    var compEl = component.el();

    if (compEl && compEl.parentNode === this.contentEl()) {
      this.contentEl().removeChild(component.el());
    }
  };

  /**
   * Add and initialize default child `Component`s based upon options.
   */


  Component.prototype.initChildren = function initChildren() {
    var _this = this;

    var children = this.options_.children;

    if (children) {
      // `this` is `parent`
      var parentOptions = this.options_;

      var handleAdd = function handleAdd(child) {
        var name = child.name;
        var opts = child.opts;

        // Allow options for children to be set at the parent options
        // e.g. videojs(id, { controlBar: false });
        // instead of videojs(id, { children: { controlBar: false });
        if (parentOptions[name] !== undefined) {
          opts = parentOptions[name];
        }

        // Allow for disabling default components
        // e.g. options['children']['posterImage'] = false
        if (opts === false) {
          return;
        }

        // Allow options to be passed as a simple boolean if no configuration
        // is necessary.
        if (opts === true) {
          opts = {};
        }

        // We also want to pass the original player options
        // to each component as well so they don't need to
        // reach back into the player for options later.
        opts.playerOptions = _this.options_.playerOptions;

        // Create and add the child component.
        // Add a direct reference to the child by name on the parent instance.
        // If two of the same component are used, different names should be supplied
        // for each
        var newChild = _this.addChild(name, opts);

        if (newChild) {
          _this[name] = newChild;
        }
      };

      // Allow for an array of children details to passed in the options
      var workingChildren = void 0;
      var Tech = Component.getComponent('Tech');

      if (Array.isArray(children)) {
        workingChildren = children;
      } else {
        workingChildren = Object.keys(children);
      }

      workingChildren
      // children that are in this.options_ but also in workingChildren  would
      // give us extra children we do not want. So, we want to filter them out.
      .concat(Object.keys(this.options_).filter(function (child) {
        return !workingChildren.some(function (wchild) {
          if (typeof wchild === 'string') {
            return child === wchild;
          }
          return child === wchild.name;
        });
      })).map(function (child) {
        var name = void 0;
        var opts = void 0;

        if (typeof child === 'string') {
          name = child;
          opts = children[name] || _this.options_[name] || {};
        } else {
          name = child.name;
          opts = child;
        }

        return { name: name, opts: opts };
      }).filter(function (child) {
        // we have to make sure that child.name isn't in the techOrder since
        // techs are registerd as Components but can't aren't compatible
        // See https://github.com/videojs/video.js/issues/2772
        var c = Component.getComponent(child.opts.componentClass || toTitleCase(child.name));

        return c && !Tech.isTech(c);
      }).forEach(handleAdd);
    }
  };

  /**
   * Builds the default DOM class name. Should be overriden by sub-components.
   *
   * @return {string}
   *         The DOM class name for this object.
   *
   * @abstract
   */


  Component.prototype.buildCSSClass = function buildCSSClass() {
    // Child classes can include a function that does:
    // return 'CLASS NAME' + this._super();
    return '';
  };

  /**
   * Bind a listener to the component's ready state.
   * Different from event listeners in that if the ready event has already happened
   * it will trigger the function immediately.
   *
   * @return {Component}
   *         Returns itself; method can be chained.
   */


  Component.prototype.ready = function ready(fn) {
    var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (fn) {
      if (this.isReady_) {
        if (sync) {
          fn.call(this);
        } else {
          // Call the function asynchronously by default for consistency
          this.setTimeout(fn, 1);
        }
      } else {
        this.readyQueue_ = this.readyQueue_ || [];
        this.readyQueue_.push(fn);
      }
    }
  };

  /**
   * Trigger all the ready listeners for this `Component`.
   *
   * @fires Component#ready
   */


  Component.prototype.triggerReady = function triggerReady() {
    this.isReady_ = true;

    // Ensure ready is triggerd asynchronously
    this.setTimeout(function () {
      var readyQueue = this.readyQueue_;

      // Reset Ready Queue
      this.readyQueue_ = [];

      if (readyQueue && readyQueue.length > 0) {
        readyQueue.forEach(function (fn) {
          fn.call(this);
        }, this);
      }

      // Allow for using event listeners also
      /**
       * Triggered when a `Component` is ready.
       *
       * @event Component#ready
       * @type {EventTarget~Event}
       */
      this.trigger('ready');
    }, 1);
  };

  /**
   * Find a single DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelector`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {Element|null}
   *         the dom element that was found, or null
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */


  Component.prototype.$ = function $$$1(selector, context) {
    return $(selector, context || this.contentEl());
  };

  /**
   * Finds all DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelectorAll`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {NodeList}
   *         a list of dom elements that were found
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */


  Component.prototype.$$ = function $$$$1(selector, context) {
    return $$(selector, context || this.contentEl());
  };

  /**
   * Check if a component's element has a CSS class name.
   *
   * @param {string} classToCheck
   *        CSS class name to check.
   *
   * @return {boolean}
   *         - True if the `Component` has the class.
   *         - False if the `Component` does not have the class`
   */


  Component.prototype.hasClass = function hasClass$$1(classToCheck) {
    return hasClass(this.el_, classToCheck);
  };

  /**
   * Add a CSS class name to the `Component`s element.
   *
   * @param {string} classToAdd
   *        CSS class name to add
   */


  Component.prototype.addClass = function addClass$$1(classToAdd) {
    addClass(this.el_, classToAdd);
  };

  /**
   * Remove a CSS class name from the `Component`s element.
   *
   * @param {string} classToRemove
   *        CSS class name to remove
   */


  Component.prototype.removeClass = function removeClass$$1(classToRemove) {
    removeClass(this.el_, classToRemove);
  };

  /**
   * Add or remove a CSS class name from the component's element.
   * - `classToToggle` gets added when {@link Component#hasClass} would return false.
   * - `classToToggle` gets removed when {@link Component#hasClass} would return true.
   *
   * @param  {string} classToToggle
   *         The class to add or remove based on (@link Component#hasClass}
   *
   * @param  {boolean|Dom~predicate} [predicate]
   *         An {@link Dom~predicate} function or a boolean
   */


  Component.prototype.toggleClass = function toggleClass$$1(classToToggle, predicate) {
    toggleClass(this.el_, classToToggle, predicate);
  };

  /**
   * Show the `Component`s element if it is hidden by removing the
   * 'vjs-hidden' class name from it.
   */


  Component.prototype.show = function show() {
    this.removeClass('vjs-hidden');
  };

  /**
   * Hide the `Component`s element if it is currently showing by adding the
   * 'vjs-hidden` class name to it.
   */


  Component.prototype.hide = function hide() {
    this.addClass('vjs-hidden');
  };

  /**
   * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'
   * class name to it. Used during fadeIn/fadeOut.
   *
   * @private
   */


  Component.prototype.lockShowing = function lockShowing() {
    this.addClass('vjs-lock-showing');
  };

  /**
   * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'
   * class name from it. Used during fadeIn/fadeOut.
   *
   * @private
   */


  Component.prototype.unlockShowing = function unlockShowing() {
    this.removeClass('vjs-lock-showing');
  };

  /**
   * Get the value of an attribute on the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to get the value from.
   *
   * @return {string|null}
   *         - The value of the attribute that was asked for.
   *         - Can be an empty string on some browsers if the attribute does not exist
   *           or has no value
   *         - Most browsers will return null if the attibute does not exist or has
   *           no value.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}
   */


  Component.prototype.getAttribute = function getAttribute$$1(attribute) {
    return getAttribute(this.el_, attribute);
  };

  /**
   * Set the value of an attribute on the `Component`'s element
   *
   * @param {string} attribute
   *        Name of the attribute to set.
   *
   * @param {string} value
   *        Value to set the attribute to.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}
   */


  Component.prototype.setAttribute = function setAttribute$$1(attribute, value) {
    setAttribute(this.el_, attribute, value);
  };

  /**
   * Remove an attribute from the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to remove.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}
   */


  Component.prototype.removeAttribute = function removeAttribute$$1(attribute) {
    removeAttribute(this.el_, attribute);
  };

  /**
   * Get or set the width of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The width that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|string}
   *         The width when getting, zero if there is no width. Can be a string
   *           postpixed with '%' or 'px'.
   */


  Component.prototype.width = function width(num, skipListeners) {
    return this.dimension('width', num, skipListeners);
  };

  /**
   * Get or set the height of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The height that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|string}
   *         The width when getting, zero if there is no width. Can be a string
   *         postpixed with '%' or 'px'.
   */


  Component.prototype.height = function height(num, skipListeners) {
    return this.dimension('height', num, skipListeners);
  };

  /**
   * Set both the width and height of the `Component` element at the same time.
   *
   * @param  {number|string} width
   *         Width to set the `Component`s element to.
   *
   * @param  {number|string} height
   *         Height to set the `Component`s element to.
   */


  Component.prototype.dimensions = function dimensions(width, height) {
    // Skip componentresize listeners on width for optimization
    this.width(width, true);
    this.height(height);
  };

  /**
   * Get or set width or height of the `Component` element. This is the shared code
   * for the {@link Component#width} and {@link Component#height}.
   *
   * Things to know:
   * - If the width or height in an number this will return the number postfixed with 'px'.
   * - If the width/height is a percent this will return the percent postfixed with '%'
   * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function
   *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.
   *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}
   *   for more information
   * - If you want the computed style of the component, use {@link Component#currentWidth}
   *   and {@link {Component#currentHeight}
   *
   * @fires Component#componentresize
   *
   * @param {string} widthOrHeight
   8        'width' or 'height'
   *
   * @param  {number|string} [num]
   8         New dimension
   *
   * @param  {boolean} [skipListeners]
   *         Skip componentresize event trigger
   *
   * @return {number}
   *         The dimension when getting or 0 if unset
   */


  Component.prototype.dimension = function dimension(widthOrHeight, num, skipListeners) {
    if (num !== undefined) {
      // Set to zero if null or literally NaN (NaN !== NaN)
      if (num === null || num !== num) {
        num = 0;
      }

      // Check if using css width/height (% or px) and adjust
      if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {
        this.el_.style[widthOrHeight] = num;
      } else if (num === 'auto') {
        this.el_.style[widthOrHeight] = '';
      } else {
        this.el_.style[widthOrHeight] = num + 'px';
      }

      // skipListeners allows us to avoid triggering the resize event when setting both width and height
      if (!skipListeners) {
        /**
         * Triggered when a component is resized.
         *
         * @event Component#componentresize
         * @type {EventTarget~Event}
         */
        this.trigger('componentresize');
      }

      return;
    }

    // Not setting a value, so getting it
    // Make sure element exists
    if (!this.el_) {
      return 0;
    }

    // Get dimension value from style
    var val = this.el_.style[widthOrHeight];
    var pxIndex = val.indexOf('px');

    if (pxIndex !== -1) {
      // Return the pixel value with no 'px'
      return parseInt(val.slice(0, pxIndex), 10);
    }

    // No px so using % or no style was set, so falling back to offsetWidth/height
    // If component has display:none, offset will return 0
    // TODO: handle display:none and no dimension style using px
    return parseInt(this.el_['offset' + toTitleCase(widthOrHeight)], 10);
  };

  /**
   * Get the width or the height of the `Component` elements computed style. Uses
   * `window.getComputedStyle`.
   *
   * @param {string} widthOrHeight
   *        A string containing 'width' or 'height'. Whichever one you want to get.
   *
   * @return {number}
   *         The dimension that gets asked for or 0 if nothing was set
   *         for that dimension.
   */


  Component.prototype.currentDimension = function currentDimension(widthOrHeight) {
    var computedWidthOrHeight = 0;

    if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {
      throw new Error('currentDimension only accepts width or height value');
    }

    if (typeof window.getComputedStyle === 'function') {
      var computedStyle = window.getComputedStyle(this.el_);

      computedWidthOrHeight = computedStyle.getPropertyValue(widthOrHeight) || computedStyle[widthOrHeight];
    }

    // remove 'px' from variable and parse as integer
    computedWidthOrHeight = parseFloat(computedWidthOrHeight);

    // if the computed value is still 0, it's possible that the browser is lying
    // and we want to check the offset values.
    // This code also runs on IE8 and wherever getComputedStyle doesn't exist.
    if (computedWidthOrHeight === 0) {
      var rule = 'offset' + toTitleCase(widthOrHeight);

      computedWidthOrHeight = this.el_[rule];
    }

    return computedWidthOrHeight;
  };

  /**
   * An object that contains width and height values of the `Component`s
   * computed style. Uses `window.getComputedStyle`.
   *
   * @typedef {Object} Component~DimensionObject
   *
   * @property {number} width
   *           The width of the `Component`s computed style.
   *
   * @property {number} height
   *           The height of the `Component`s computed style.
   */

  /**
   * Get an object that contains width and height values of the `Component`s
   * computed style.
   *
   * @return {Component~DimensionObject}
   *         The dimensions of the components element
   */


  Component.prototype.currentDimensions = function currentDimensions() {
    return {
      width: this.currentDimension('width'),
      height: this.currentDimension('height')
    };
  };

  /**
   * Get the width of the `Component`s computed style. Uses `window.getComputedStyle`.
   *
   * @return {number} width
   *           The width of the `Component`s computed style.
   */


  Component.prototype.currentWidth = function currentWidth() {
    return this.currentDimension('width');
  };

  /**
   * Get the height of the `Component`s computed style. Uses `window.getComputedStyle`.
   *
   * @return {number} height
   *           The height of the `Component`s computed style.
   */


  Component.prototype.currentHeight = function currentHeight() {
    return this.currentDimension('height');
  };

  /**
   * Set the focus to this component
   */


  Component.prototype.focus = function focus() {
    this.el_.focus();
  };

  /**
   * Remove the focus from this component
   */


  Component.prototype.blur = function blur() {
    this.el_.blur();
  };

  /**
   * Emit a 'tap' events when touch event support gets detected. This gets used to
   * support toggling the controls through a tap on the video. They get enabled
   * because every sub-component would have extra overhead otherwise.
   *
   * @private
   * @fires Component#tap
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchleave
   * @listens Component#touchcancel
   * @listens Component#touchend
    */


  Component.prototype.emitTapEvents = function emitTapEvents() {
    // Track the start time so we can determine how long the touch lasted
    var touchStart = 0;
    var firstTouch = null;

    // Maximum movement allowed during a touch event to still be considered a tap
    // Other popular libs use anywhere from 2 (hammer.js) to 15,
    // so 10 seems like a nice, round number.
    var tapMovementThreshold = 10;

    // The maximum length a touch can be while still being considered a tap
    var touchTimeThreshold = 200;

    var couldBeTap = void 0;

    this.on('touchstart', function (event) {
      // If more than one finger, don't consider treating this as a click
      if (event.touches.length === 1) {
        // Copy pageX/pageY from the object
        firstTouch = {
          pageX: event.touches[0].pageX,
          pageY: event.touches[0].pageY
        };
        // Record start time so we can detect a tap vs. "touch and hold"
        touchStart = new Date().getTime();
        // Reset couldBeTap tracking
        couldBeTap = true;
      }
    });

    this.on('touchmove', function (event) {
      // If more than one finger, don't consider treating this as a click
      if (event.touches.length > 1) {
        couldBeTap = false;
      } else if (firstTouch) {
        // Some devices will throw touchmoves for all but the slightest of taps.
        // So, if we moved only a small distance, this could still be a tap
        var xdiff = event.touches[0].pageX - firstTouch.pageX;
        var ydiff = event.touches[0].pageY - firstTouch.pageY;
        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);

        if (touchDistance > tapMovementThreshold) {
          couldBeTap = false;
        }
      }
    });

    var noTap = function noTap() {
      couldBeTap = false;
    };

    // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
    this.on('touchleave', noTap);
    this.on('touchcancel', noTap);

    // When the touch ends, measure how long it took and trigger the appropriate
    // event
    this.on('touchend', function (event) {
      firstTouch = null;
      // Proceed only if the touchmove/leave/cancel event didn't happen
      if (couldBeTap === true) {
        // Measure how long the touch lasted
        var touchTime = new Date().getTime() - touchStart;

        // Make sure the touch was less than the threshold to be considered a tap
        if (touchTime < touchTimeThreshold) {
          // Don't let browser turn this into a click
          event.preventDefault();
          /**
           * Triggered when a `Component` is tapped.
           *
           * @event Component#tap
           * @type {EventTarget~Event}
           */
          this.trigger('tap');
          // It may be good to copy the touchend event object and change the
          // type to tap, if the other event properties aren't exact after
          // Events.fixEvent runs (e.g. event.target)
        }
      }
    });
  };

  /**
   * This function reports user activity whenever touch events happen. This can get
   * turned off by any sub-components that wants touch events to act another way.
   *
   * Report user touch activity when touch events occur. User activity gets used to
   * determine when controls should show/hide. It is simple when it comes to mouse
   * events, because any mouse event should show the controls. So we capture mouse
   * events that bubble up to the player and report activity when that happens.
   * With touch events it isn't as easy as `touchstart` and `touchend` toggle player
   * controls. So touch events can't help us at the player level either.
   *
   * User activity gets checked asynchronously. So what could happen is a tap event
   * on the video turns the controls off. Then the `touchend` event bubbles up to
   * the player. Which, if it reported user activity, would turn the controls right
   * back on. We also don't want to completely block touch events from bubbling up.
   * Furthermore a `touchmove` event and anything other than a tap, should not turn
   * controls back on.
   *
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchend
   * @listens Component#touchcancel
   */


  Component.prototype.enableTouchActivity = function enableTouchActivity() {
    // Don't continue if the root player doesn't support reporting user activity
    if (!this.player() || !this.player().reportUserActivity) {
      return;
    }

    // listener for reporting that the user is active
    var report = bind(this.player(), this.player().reportUserActivity);

    var touchHolding = void 0;

    this.on('touchstart', function () {
      report();
      // For as long as the they are touching the device or have their mouse down,
      // we consider them active even if they're not moving their finger or mouse.
      // So we want to continue to update that they are active
      this.clearInterval(touchHolding);
      // report at the same interval as activityCheck
      touchHolding = this.setInterval(report, 250);
    });

    var touchEnd = function touchEnd(event) {
      report();
      // stop the interval that maintains activity if the touch is holding
      this.clearInterval(touchHolding);
    };

    this.on('touchmove', report);
    this.on('touchend', touchEnd);
    this.on('touchcancel', touchEnd);
  };

  /**
   * A callback that has no parameters and is bound into `Component`s context.
   *
   * @callback Component~GenericCallback
   * @this Component
   */

  /**
   * Creates a function that runs after an `x` millisecond timeout. This function is a
   * wrapper around `window.setTimeout`. There are a few reasons to use this one
   * instead though:
   * 1. It gets cleared via  {@link Component#clearTimeout} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will gets turned into a {@link Component~GenericCallback}
   *
   * > Note: You can use `window.clearTimeout` on the id returned by this function. This
   *         will cause its dispose listener not to get cleaned up! Please use
   *         {@link Component#clearTimeout} or {@link Component#dispose}.
   *
   * @param {Component~GenericCallback} fn
   *        The function that will be run after `timeout`.
   *
   * @param {number} timeout
   *        Timeout in milliseconds to delay before executing the specified function.
   *
   * @return {number}
   *         Returns a timeout ID that gets used to identify the timeout. It can also
   *         get used in {@link Component#clearTimeout} to clear the timeout that
   *         was set.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}
   */


  Component.prototype.setTimeout = function setTimeout(fn, timeout) {
    fn = bind(this, fn);

    var timeoutId = window.setTimeout(fn, timeout);
    var disposeFn = function disposeFn() {
      this.clearTimeout(timeoutId);
    };

    disposeFn.guid = 'vjs-timeout-' + timeoutId;

    this.on('dispose', disposeFn);

    return timeoutId;
  };

  /**
   * Clears a timeout that gets created via `window.setTimeout` or
   * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}
   * use this function instead of `window.clearTimout`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} timeoutId
   *        The id of the timeout to clear. The return value of
   *        {@link Component#setTimeout} or `window.setTimeout`.
   *
   * @return {number}
   *         Returns the timeout id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}
   */


  Component.prototype.clearTimeout = function clearTimeout(timeoutId) {
    window.clearTimeout(timeoutId);

    var disposeFn = function disposeFn() {};

    disposeFn.guid = 'vjs-timeout-' + timeoutId;

    this.off('dispose', disposeFn);

    return timeoutId;
  };

  /**
   * Creates a function that gets run every `x` milliseconds. This function is a wrapper
   * around `window.setInterval`. There are a few reasons to use this one instead though.
   * 1. It gets cleared via  {@link Component#clearInterval} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will be a {@link Component~GenericCallback}
   *
   * @param {Component~GenericCallback} fn
   *        The function to run every `x` seconds.
   *
   * @param {number} interval
   *        Execute the specified function every `x` milliseconds.
   *
   * @return {number}
   *         Returns an id that can be used to identify the interval. It can also be be used in
   *         {@link Component#clearInterval} to clear the interval.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}
   */


  Component.prototype.setInterval = function setInterval(fn, interval) {
    fn = bind(this, fn);

    var intervalId = window.setInterval(fn, interval);

    var disposeFn = function disposeFn() {
      this.clearInterval(intervalId);
    };

    disposeFn.guid = 'vjs-interval-' + intervalId;

    this.on('dispose', disposeFn);

    return intervalId;
  };

  /**
   * Clears an interval that gets created via `window.setInterval` or
   * {@link Component#setInterval}. If you set an inteval via {@link Component#setInterval}
   * use this function instead of `window.clearInterval`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} intervalId
   *        The id of the interval to clear. The return value of
   *        {@link Component#setInterval} or `window.setInterval`.
   *
   * @return {number}
   *         Returns the interval id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}
   */


  Component.prototype.clearInterval = function clearInterval(intervalId) {
    window.clearInterval(intervalId);

    var disposeFn = function disposeFn() {};

    disposeFn.guid = 'vjs-interval-' + intervalId;

    this.off('dispose', disposeFn);

    return intervalId;
  };

  /**
   * Queues up a callback to be passed to requestAnimationFrame (rAF), but
   * with a few extra bonuses:
   *
   * - Supports browsers that do not support rAF by falling back to
   *   {@link Component#setTimeout}.
   *
   * - The callback is turned into a {@link Component~GenericCallback} (i.e.
   *   bound to the component).
   *
   * - Automatic cancellation of the rAF callback is handled if the component
   *   is disposed before it is called.
   *
   * @param  {Component~GenericCallback} fn
   *         A function that will be bound to this component and executed just
   *         before the browser's next repaint.
   *
   * @return {number}
   *         Returns an rAF ID that gets used to identify the timeout. It can
   *         also be used in {@link Component#cancelAnimationFrame} to cancel
   *         the animation frame callback.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}
   */


  Component.prototype.requestAnimationFrame = function requestAnimationFrame(fn) {
    var _this2 = this;

    if (this.supportsRaf_) {
      fn = bind(this, fn);

      var id = window.requestAnimationFrame(fn);
      var disposeFn = function disposeFn() {
        return _this2.cancelAnimationFrame(id);
      };

      disposeFn.guid = 'vjs-raf-' + id;
      this.on('dispose', disposeFn);

      return id;
    }

    // Fall back to using a timer.
    return this.setTimeout(fn, 1000 / 60);
  };

  /**
   * Cancels a queued callback passed to {@link Component#requestAnimationFrame}
   * (rAF).
   *
   * If you queue an rAF callback via {@link Component#requestAnimationFrame},
   * use this function instead of `window.cancelAnimationFrame`. If you don't,
   * your dispose listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} id
   *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.
   *
   * @return {number}
   *         Returns the rAF ID that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}
   */


  Component.prototype.cancelAnimationFrame = function cancelAnimationFrame(id) {
    if (this.supportsRaf_) {
      window.cancelAnimationFrame(id);

      var disposeFn = function disposeFn() {};

      disposeFn.guid = 'vjs-raf-' + id;

      this.off('dispose', disposeFn);

      return id;
    }

    // Fall back to using a timer.
    return this.clearTimeout(id);
  };

  /**
   * Register a `Component` with `videojs` given the name and the component.
   *
   * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s
   *         should be registered using {@link Tech.registerTech} or
   *         {@link videojs:videojs.registerTech}.
   *
   * > NOTE: This function can also be seen on videojs as
   *         {@link videojs:videojs.registerComponent}.
   *
   * @param {string} name
   *        The name of the `Component` to register.
   *
   * @param {Component} ComponentToRegister
   *        The `Component` class to register.
   *
   * @return {Component}
   *         The `Component` that was registered.
   */


  Component.registerComponent = function registerComponent(name, ComponentToRegister) {
    if (typeof name !== 'string' || !name) {
      throw new Error('Illegal component name, "' + name + '"; must be a non-empty string.');
    }

    var Tech = Component.getComponent('Tech');

    // We need to make sure this check is only done if Tech has been registered.
    var isTech = Tech && Tech.isTech(ComponentToRegister);
    var isComp = Component === ComponentToRegister || Component.prototype.isPrototypeOf(ComponentToRegister.prototype);

    if (isTech || !isComp) {
      var reason = void 0;

      if (isTech) {
        reason = 'techs must be registered using Tech.registerTech()';
      } else {
        reason = 'must be a Component subclass';
      }

      throw new Error('Illegal component, "' + name + '"; ' + reason + '.');
    }

    name = toTitleCase(name);

    if (!Component.components_) {
      Component.components_ = {};
    }

    var Player = Component.getComponent('Player');

    if (name === 'Player' && Player && Player.players) {
      var players = Player.players;
      var playerNames = Object.keys(players);

      // If we have players that were disposed, then their name will still be
      // in Players.players. So, we must loop through and verify that the value
      // for each item is not null. This allows registration of the Player component
      // after all players have been disposed or before any were created.
      if (players && playerNames.length > 0 && playerNames.map(function (pname) {
        return players[pname];
      }).every(Boolean)) {
        throw new Error('Can not register Player component after player has been created.');
      }
    }

    Component.components_[name] = ComponentToRegister;

    return ComponentToRegister;
  };

  /**
   * Get a `Component` based on the name it was registered with.
   *
   * @param {string} name
   *        The Name of the component to get.
   *
   * @return {Component}
   *         The `Component` that got registered under the given name.
   *
   * @deprecated In `videojs` 6 this will not return `Component`s that were not
   *             registered using {@link Component.registerComponent}. Currently we
   *             check the global `videojs` object for a `Component` name and
   *             return that if it exists.
   */


  Component.getComponent = function getComponent(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    if (Component.components_ && Component.components_[name]) {
      return Component.components_[name];
    }
  };

  return Component;
}();

/**
 * Whether or not this component supports `requestAnimationFrame`.
 *
 * This is exposed primarily for testing purposes.
 *
 * @private
 * @type {Boolean}
 */


Component.prototype.supportsRaf_ = typeof window.requestAnimationFrame === 'function' && typeof window.cancelAnimationFrame === 'function';

Component.registerComponent('Component', Component);

/**
 * @file time-ranges.js
 * @module time-ranges
 */

/**
 * Returns the time for the specified index at the start or end
 * of a TimeRange object.
 *
 * @function time-ranges:indexFunction
 *
 * @param {number} [index=0]
 *        The range number to return the time for.
 *
 * @return {number}
 *         The time that offset at the specified index.
 *
 * @depricated index must be set to a value, in the future this will throw an error.
 */

/**
 * An object that contains ranges of time for various reasons.
 *
 * @typedef {Object} TimeRange
 *
 * @property {number} length
 *           The number of time ranges represented by this Object
 *
 * @property {time-ranges:indexFunction} start
 *           Returns the time offset at which a specified time range begins.
 *
 * @property {time-ranges:indexFunction} end
 *           Returns the time offset at which a specified time range begins.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges
 */

/**
 * Check if any of the time ranges are over the maximum index.
 *
 * @param {string} fnName
 *        The function name to use for logging
 *
 * @param {number} index
 *        The index to check
 *
 * @param {number} maxIndex
 *        The maximum possible index
 *
 * @throws {Error} if the timeRanges provided are over the maxIndex
 */
function rangeCheck(fnName, index, maxIndex) {
  if (typeof index !== 'number' || index < 0 || index > maxIndex) {
    throw new Error('Failed to execute \'' + fnName + '\' on \'TimeRanges\': The index provided (' + index + ') is non-numeric or out of bounds (0-' + maxIndex + ').');
  }
}

/**
 * Check if any of the time ranges are over the maximum index.
 *
 * @param {string} fnName
 *        The function name to use for logging
 *
 * @param {string} valueIndex
 *        The proprety that should be used to get the time. should be 'start' or 'end'
 *
 * @param {Array} ranges
 *        An array of time ranges
 *
 * @param {Array} [rangeIndex=0]
 *        The index to start the search at
 *
 * @return {number}
 *         The time that offset at the specified index.
 *
 *
 * @depricated rangeIndex must be set to a value, in the future this will throw an error.
 * @throws {Error} if rangeIndex is more than the length of ranges
 */
function getRange(fnName, valueIndex, ranges, rangeIndex) {
  rangeCheck(fnName, rangeIndex, ranges.length - 1);
  return ranges[rangeIndex][valueIndex];
}

/**
 * Create a time range object givent ranges of time.
 *
 * @param {Array} [ranges]
 *        An array of time ranges.
 */
function createTimeRangesObj(ranges) {
  if (ranges === undefined || ranges.length === 0) {
    return {
      length: 0,
      start: function start() {
        throw new Error('This TimeRanges object is empty');
      },
      end: function end() {
        throw new Error('This TimeRanges object is empty');
      }
    };
  }
  return {
    length: ranges.length,
    start: getRange.bind(null, 'start', 0, ranges),
    end: getRange.bind(null, 'end', 1, ranges)
  };
}

/**
 * Should create a fake `TimeRange` object which mimics an HTML5 time range instance.
 *
 * @param {number|Array} start
 *        The start of a single range or an array of ranges
 *
 * @param {number} end
 *        The end of a single range.
 *
 * @private
 */
function createTimeRanges(start, end) {
  if (Array.isArray(start)) {
    return createTimeRangesObj(start);
  } else if (start === undefined || end === undefined) {
    return createTimeRangesObj();
  }
  return createTimeRangesObj([[start, end]]);
}

/**
 * @file buffer.js
 * @module buffer
 */
/**
 * Compute the percentage of the media that has been buffered.
 *
 * @param {TimeRange} buffered
 *        The current `TimeRange` object representing buffered time ranges
 *
 * @param {number} duration
 *        Total duration of the media
 *
 * @return {number}
 *         Percent buffered of the total duration in decimal form.
 */
function bufferedPercent(buffered, duration) {
  var bufferedDuration = 0;
  var start = void 0;
  var end = void 0;

  if (!duration) {
    return 0;
  }

  if (!buffered || !buffered.length) {
    buffered = createTimeRanges(0, 0);
  }

  for (var i = 0; i < buffered.length; i++) {
    start = buffered.start(i);
    end = buffered.end(i);

    // buffered end can be bigger than duration by a very small fraction
    if (end > duration) {
      end = duration;
    }

    bufferedDuration += end - start;
  }

  return bufferedDuration / duration;
}

/**
 * @file fullscreen-api.js
 * @module fullscreen-api
 * @private
 */
/**
 * Store the browser-specific methods for the fullscreen API.
 *
 * @type {Object}
 * @see [Specification]{@link https://fullscreen.spec.whatwg.org}
 * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}
 */
var FullscreenApi = {};

// browser API methods
var apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'],
// WebKit
['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Old WebKit (Safari 5.1)
['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Mozilla
['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'],
// Microsoft
['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];

var specApi = apiMap[0];
var browserApi = void 0;

// determine the supported set of functions
for (var i = 0; i < apiMap.length; i++) {
  // check for exitFullscreen function
  if (apiMap[i][1] in document) {
    browserApi = apiMap[i];
    break;
  }
}

// map the browser API names to the spec API names
if (browserApi) {
  for (var _i = 0; _i < browserApi.length; _i++) {
    FullscreenApi[specApi[_i]] = browserApi[_i];
  }
}

/**
 * @file media-error.js
 */
/**
 * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.
 *
 * @param {number|string|Object|MediaError} value
 *        This can be of multiple types:
 *        - number: should be a standard error code
 *        - string: an error message (the code will be 0)
 *        - Object: arbitrary properties
 *        - `MediaError` (native): used to populate a video.js `MediaError` object
 *        - `MediaError` (video.js): will return itself if it's already a
 *          video.js `MediaError` object.
 *
 * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}
 * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}
 *
 * @class MediaError
 */
function MediaError(value) {

  // Allow redundant calls to this constructor to avoid having `instanceof`
  // checks peppered around the code.
  if (value instanceof MediaError) {
    return value;
  }

  if (typeof value === 'number') {
    this.code = value;
  } else if (typeof value === 'string') {
    // default code is zero, so this is a custom error
    this.message = value;
  } else if (isObject(value)) {

    // We assign the `code` property manually because native `MediaError` objects
    // do not expose it as an own/enumerable property of the object.
    if (typeof value.code === 'number') {
      this.code = value.code;
    }

    assign(this, value);
  }

  if (!this.message) {
    this.message = MediaError.defaultMessages[this.code] || '';
  }
}

/**
 * The error code that refers two one of the defined `MediaError` types
 *
 * @type {Number}
 */
MediaError.prototype.code = 0;

/**
 * An optional message that to show with the error. Message is not part of the HTML5
 * video spec but allows for more informative custom errors.
 *
 * @type {String}
 */
MediaError.prototype.message = '';

/**
 * An optional status code that can be set by plugins to allow even more detail about
 * the error. For example a plugin might provide a specific HTTP status code and an
 * error message for that code. Then when the plugin gets that error this class will
 * know how to display an error message for it. This allows a custom message to show
 * up on the `Player` error overlay.
 *
 * @type {Array}
 */
MediaError.prototype.status = null;

/**
 * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the
 * specification listed under {@link MediaError} for more information.
 *
 * @enum {array}
 * @readonly
 * @property {string} 0 - MEDIA_ERR_CUSTOM
 * @property {string} 1 - MEDIA_ERR_CUSTOM
 * @property {string} 2 - MEDIA_ERR_ABORTED
 * @property {string} 3 - MEDIA_ERR_NETWORK
 * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED
 * @property {string} 5 - MEDIA_ERR_ENCRYPTED
 */
MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];

/**
 * The default `MediaError` messages based on the {@link MediaError.errorTypes}.
 *
 * @type {Array}
 * @constant
 */
MediaError.defaultMessages = {
  1: 'You aborted the media playback',
  2: 'A network error caused the media download to fail part-way.',
  3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',
  4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',
  5: 'The media is encrypted and we do not have the keys to decrypt it.'
};

// Add types as properties on MediaError
// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
for (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
  MediaError[MediaError.errorTypes[errNum]] = errNum;
  // values should be accessible on both the class and instance
  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
}

/**
 * @file text-track-list-converter.js Utilities for capturing text track state and
 * re-creating tracks based on a capture.
 *
 * @module text-track-list-converter
 */

/**
 * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that
 * represents the {@link TextTrack}'s state.
 *
 * @param {TextTrack} track
 *        The text track to query.
 *
 * @return {Object}
 *         A serializable javascript representation of the TextTrack.
 * @private
 */
var trackToJson_ = function trackToJson_(track) {
  var ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce(function (acc, prop, i) {

    if (track[prop]) {
      acc[prop] = track[prop];
    }

    return acc;
  }, {
    cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {
      return {
        startTime: cue.startTime,
        endTime: cue.endTime,
        text: cue.text,
        id: cue.id
      };
    })
  });

  return ret;
};

/**
 * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the
 * state of all {@link TextTrack}s currently configured. The return array is compatible with
 * {@link text-track-list-converter:jsonToTextTracks}.
 *
 * @param {Tech} tech
 *        The tech object to query
 *
 * @return {Array}
 *         A serializable javascript representation of the {@link Tech}s
 *         {@link TextTrackList}.
 */
var textTracksToJson = function textTracksToJson(tech) {

  var trackEls = tech.$$('track');

  var trackObjs = Array.prototype.map.call(trackEls, function (t) {
    return t.track;
  });
  var tracks = Array.prototype.map.call(trackEls, function (trackEl) {
    var json = trackToJson_(trackEl.track);

    if (trackEl.src) {
      json.src = trackEl.src;
    }
    return json;
  });

  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {
    return trackObjs.indexOf(track) === -1;
  }).map(trackToJson_));
};

/**
 * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript
 * object {@link TextTrack} representations.
 *
 * @param {Array} json
 *        An array of `TextTrack` representation objects, like those that would be
 *        produced by `textTracksToJson`.
 *
 * @param {Tech} tech
 *        The `Tech` to create the `TextTrack`s on.
 */
var jsonToTextTracks = function jsonToTextTracks(json, tech) {
  json.forEach(function (track) {
    var addedTrack = tech.addRemoteTextTrack(track).track;

    if (!track.src && track.cues) {
      track.cues.forEach(function (cue) {
        return addedTrack.addCue(cue);
      });
    }
  });

  return tech.textTracks();
};

var textTrackConverter = { textTracksToJson: textTracksToJson, jsonToTextTracks: jsonToTextTracks, trackToJson_: trackToJson_ };

/**
 * @file modal-dialog.js
 */
var MODAL_CLASS_NAME = 'vjs-modal-dialog';
var ESC = 27;

/**
 * The `ModalDialog` displays over the video and its controls, which blocks
 * interaction with the player until it is closed.
 *
 * Modal dialogs include a "Close" button and will close when that button
 * is activated - or when ESC is pressed anywhere.
 *
 * @extends Component
 */

var ModalDialog = function (_Component) {
  inherits(ModalDialog, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Mixed} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {string} [options.description]
   *        A text description for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.fillAlways=false]
   *        Normally, modals are automatically filled only the first time
   *        they open. This tells the modal to refresh its content
   *        every time it opens.
   *
   * @param {string} [options.label]
   *        A text label for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.temporary=true]
   *        If `true`, the modal can only be opened once; it will be
   *        disposed as soon as it's closed.
   *
   * @param {boolean} [options.uncloseable=false]
   *        If `true`, the user will not be able to close the modal
   *        through the UI in the normal ways. Programmatic closing is
   *        still possible.
   */
  function ModalDialog(player, options) {
    classCallCheck(this, ModalDialog);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;

    _this.closeable(!_this.options_.uncloseable);
    _this.content(_this.options_.content);

    // Make sure the contentEl is defined AFTER any children are initialized
    // because we only want the contents of the modal in the contentEl
    // (not the UI elements like the close button).
    _this.contentEl_ = createEl('div', {
      className: MODAL_CLASS_NAME + '-content'
    }, {
      role: 'document'
    });

    _this.descEl_ = createEl('p', {
      className: MODAL_CLASS_NAME + '-description vjs-control-text',
      id: _this.el().getAttribute('aria-describedby')
    });

    textContent(_this.descEl_, _this.description());
    _this.el_.appendChild(_this.descEl_);
    _this.el_.appendChild(_this.contentEl_);
    return _this;
  }

  /**
   * Create the `ModalDialog`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */


  ModalDialog.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildCSSClass(),
      tabIndex: -1
    }, {
      'aria-describedby': this.id() + '_description',
      'aria-hidden': 'true',
      'aria-label': this.label(),
      'role': 'dialog'
    });
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ModalDialog.prototype.buildCSSClass = function buildCSSClass() {
    return MODAL_CLASS_NAME + ' vjs-hidden ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Handles `keydown` events on the document, looking for ESC, which closes
   * the modal.
   *
   * @param {EventTarget~Event} e
   *        The keypress that triggered this event.
   *
   * @listens keydown
   */


  ModalDialog.prototype.handleKeyPress = function handleKeyPress(e) {
    if (e.which === ESC && this.closeable()) {
      this.close();
    }
  };

  /**
   * Returns the label string for this modal. Primarily used for accessibility.
   *
   * @return {string}
   *         the localized or raw label of this modal.
   */


  ModalDialog.prototype.label = function label() {
    return this.localize(this.options_.label || 'Modal Window');
  };

  /**
   * Returns the description string for this modal. Primarily used for
   * accessibility.
   *
   * @return {string}
   *         The localized or raw description of this modal.
   */


  ModalDialog.prototype.description = function description() {
    var desc = this.options_.description || this.localize('This is a modal window.');

    // Append a universal closeability message if the modal is closeable.
    if (this.closeable()) {
      desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');
    }

    return desc;
  };

  /**
   * Opens the modal.
   *
   * @fires ModalDialog#beforemodalopen
   * @fires ModalDialog#modalopen
   */


  ModalDialog.prototype.open = function open() {
    if (!this.opened_) {
      var player = this.player();

      /**
        * Fired just before a `ModalDialog` is opened.
        *
        * @event ModalDialog#beforemodalopen
        * @type {EventTarget~Event}
        */
      this.trigger('beforemodalopen');
      this.opened_ = true;

      // Fill content if the modal has never opened before and
      // never been filled.
      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
        this.fill();
      }

      // If the player was playing, pause it and take note of its previously
      // playing state.
      this.wasPlaying_ = !player.paused();

      if (this.options_.pauseOnOpen && this.wasPlaying_) {
        player.pause();
      }

      if (this.closeable()) {
        this.on(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));
      }

      player.controls(false);
      this.show();
      this.conditionalFocus_();
      this.el().setAttribute('aria-hidden', 'false');

      /**
        * Fired just after a `ModalDialog` is opened.
        *
        * @event ModalDialog#modalopen
        * @type {EventTarget~Event}
        */
      this.trigger('modalopen');
      this.hasBeenOpened_ = true;
    }
  };

  /**
   * If the `ModalDialog` is currently open or closed.
   *
   * @param  {boolean} [value]
   *         If given, it will open (`true`) or close (`false`) the modal.
   *
   * @return {boolean}
   *         the current open state of the modaldialog
   */


  ModalDialog.prototype.opened = function opened(value) {
    if (typeof value === 'boolean') {
      this[value ? 'open' : 'close']();
    }
    return this.opened_;
  };

  /**
   * Closes the modal, does nothing if the `ModalDialog` is
   * not open.
   *
   * @fires ModalDialog#beforemodalclose
   * @fires ModalDialog#modalclose
   */


  ModalDialog.prototype.close = function close() {
    if (!this.opened_) {
      return;
    }
    var player = this.player();

    /**
      * Fired just before a `ModalDialog` is closed.
      *
      * @event ModalDialog#beforemodalclose
      * @type {EventTarget~Event}
      */
    this.trigger('beforemodalclose');
    this.opened_ = false;

    if (this.wasPlaying_ && this.options_.pauseOnOpen) {
      player.play();
    }

    if (this.closeable()) {
      this.off(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));
    }

    player.controls(true);
    this.hide();
    this.el().setAttribute('aria-hidden', 'true');

    /**
      * Fired just after a `ModalDialog` is closed.
      *
      * @event ModalDialog#modalclose
      * @type {EventTarget~Event}
      */
    this.trigger('modalclose');
    this.conditionalBlur_();

    if (this.options_.temporary) {
      this.dispose();
    }
  };

  /**
   * Check to see if the `ModalDialog` is closeable via the UI.
   *
   * @param  {boolean} [value]
   *         If given as a boolean, it will set the `closeable` option.
   *
   * @return {boolean}
   *         Returns the final value of the closable option.
   */


  ModalDialog.prototype.closeable = function closeable(value) {
    if (typeof value === 'boolean') {
      var closeable = this.closeable_ = !!value;
      var close = this.getChild('closeButton');

      // If this is being made closeable and has no close button, add one.
      if (closeable && !close) {

        // The close button should be a child of the modal - not its
        // content element, so temporarily change the content element.
        var temp = this.contentEl_;

        this.contentEl_ = this.el_;
        close = this.addChild('closeButton', { controlText: 'Close Modal Dialog' });
        this.contentEl_ = temp;
        this.on(close, 'close', this.close);
      }

      // If this is being made uncloseable and has a close button, remove it.
      if (!closeable && close) {
        this.off(close, 'close', this.close);
        this.removeChild(close);
        close.dispose();
      }
    }
    return this.closeable_;
  };

  /**
   * Fill the modal's content element with the modal's "content" option.
   * The content element will be emptied before this change takes place.
   */


  ModalDialog.prototype.fill = function fill() {
    this.fillWith(this.content());
  };

  /**
   * Fill the modal's content element with arbitrary content.
   * The content element will be emptied before this change takes place.
   *
   * @fires ModalDialog#beforemodalfill
   * @fires ModalDialog#modalfill
   *
   * @param {Mixed} [content]
   *        The same rules apply to this as apply to the `content` option.
   */


  ModalDialog.prototype.fillWith = function fillWith(content) {
    var contentEl = this.contentEl();
    var parentEl = contentEl.parentNode;
    var nextSiblingEl = contentEl.nextSibling;

    /**
     * Fired just before a `ModalDialog` is filled with content.
     *
     * @event ModalDialog#beforemodalfill
     * @type {EventTarget~Event}
     */
    this.trigger('beforemodalfill');
    this.hasBeenFilled_ = true;

    // Detach the content element from the DOM before performing
    // manipulation to avoid modifying the live DOM multiple times.
    parentEl.removeChild(contentEl);
    this.empty();
    insertContent(contentEl, content);
    /**
     * Fired just after a `ModalDialog` is filled with content.
     *
     * @event ModalDialog#modalfill
     * @type {EventTarget~Event}
     */
    this.trigger('modalfill');

    // Re-inject the re-filled content element.
    if (nextSiblingEl) {
      parentEl.insertBefore(contentEl, nextSiblingEl);
    } else {
      parentEl.appendChild(contentEl);
    }

    // make sure that the close button is last in the dialog DOM
    var closeButton = this.getChild('closeButton');

    if (closeButton) {
      parentEl.appendChild(closeButton.el_);
    }
  };

  /**
   * Empties the content element. This happens anytime the modal is filled.
   *
   * @fires ModalDialog#beforemodalempty
   * @fires ModalDialog#modalempty
   */


  ModalDialog.prototype.empty = function empty() {
    /**
     * Fired just before a `ModalDialog` is emptied.
     *
     * @event ModalDialog#beforemodalempty
     * @type {EventTarget~Event}
     */
    this.trigger('beforemodalempty');
    emptyEl(this.contentEl());

    /**
     * Fired just after a `ModalDialog` is emptied.
     *
     * @event ModalDialog#modalempty
     * @type {EventTarget~Event}
     */
    this.trigger('modalempty');
  };

  /**
   * Gets or sets the modal content, which gets normalized before being
   * rendered into the DOM.
   *
   * This does not update the DOM or fill the modal, but it is called during
   * that process.
   *
   * @param  {Mixed} [value]
   *         If defined, sets the internal content value to be used on the
   *         next call(s) to `fill`. This value is normalized before being
   *         inserted. To "clear" the internal content value, pass `null`.
   *
   * @return {Mixed}
   *         The current content of the modal dialog
   */


  ModalDialog.prototype.content = function content(value) {
    if (typeof value !== 'undefined') {
      this.content_ = value;
    }
    return this.content_;
  };

  /**
   * conditionally focus the modal dialog if focus was previously on the player.
   *
   * @private
   */


  ModalDialog.prototype.conditionalFocus_ = function conditionalFocus_() {
    var activeEl = document.activeElement;
    var playerEl = this.player_.el_;

    this.previouslyActiveEl_ = null;

    if (playerEl.contains(activeEl) || playerEl === activeEl) {
      this.previouslyActiveEl_ = activeEl;

      this.focus();

      this.on(document, 'keydown', this.handleKeyDown);
    }
  };

  /**
   * conditionally blur the element and refocus the last focused element
   *
   * @private
   */


  ModalDialog.prototype.conditionalBlur_ = function conditionalBlur_() {
    if (this.previouslyActiveEl_) {
      this.previouslyActiveEl_.focus();
      this.previouslyActiveEl_ = null;
    }

    this.off(document, 'keydown', this.handleKeyDown);
  };

  /**
   * Keydown handler. Attached when modal is focused.
   *
   * @listens keydown
   */


  ModalDialog.prototype.handleKeyDown = function handleKeyDown(event) {
    // exit early if it isn't a tab key
    if (event.which !== 9) {
      return;
    }

    var focusableEls = this.focusableEls_();
    var activeEl = this.el_.querySelector(':focus');
    var focusIndex = void 0;

    for (var i = 0; i < focusableEls.length; i++) {
      if (activeEl === focusableEls[i]) {
        focusIndex = i;
        break;
      }
    }

    if (document.activeElement === this.el_) {
      focusIndex = 0;
    }

    if (event.shiftKey && focusIndex === 0) {
      focusableEls[focusableEls.length - 1].focus();
      event.preventDefault();
    } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {
      focusableEls[0].focus();
      event.preventDefault();
    }
  };

  /**
   * get all focusable elements
   *
   * @private
   */


  ModalDialog.prototype.focusableEls_ = function focusableEls_() {
    var allChildren = this.el_.querySelectorAll('*');

    return Array.prototype.filter.call(allChildren, function (child) {
      return (child instanceof window.HTMLAnchorElement || child instanceof window.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window.HTMLInputElement || child instanceof window.HTMLSelectElement || child instanceof window.HTMLTextAreaElement || child instanceof window.HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof window.HTMLIFrameElement || child instanceof window.HTMLObjectElement || child instanceof window.HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');
    });
  };

  return ModalDialog;
}(Component);

/**
 * Default options for `ModalDialog` default options.
 *
 * @type {Object}
 * @private
 */


ModalDialog.prototype.options_ = {
  pauseOnOpen: true,
  temporary: true
};

Component.registerComponent('ModalDialog', ModalDialog);

/**
 * @file track-list.js
 */
/**
 * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and
 * {@link VideoTrackList}
 *
 * @extends EventTarget
 */

var TrackList = function (_EventTarget) {
  inherits(TrackList, _EventTarget);

  /**
   * Create an instance of this class
   *
   * @param {Track[]} tracks
   *        A list of tracks to initialize the list with.
   *
   * @param {Object} [list]
   *        The child object with inheritance done manually for ie8.
   *
   * @abstract
   */
  function TrackList() {
    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var _ret;

    var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    classCallCheck(this, TrackList);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    if (!list) {
      list = _this; // eslint-disable-line
      if (IS_IE8) {
        list = document.createElement('custom');
        for (var prop in TrackList.prototype) {
          if (prop !== 'constructor') {
            list[prop] = TrackList.prototype[prop];
          }
        }
      }
    }

    list.tracks_ = [];

    /**
     * @memberof TrackList
     * @member {number} length
     *         The current number of `Track`s in the this Trackist.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.tracks_.length;
      }
    });

    for (var i = 0; i < tracks.length; i++) {
      list.addTrack(tracks[i]);
    }

    // must return the object, as for ie8 it will not be this
    // but a reference to a document object
    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link Track} to the `TrackList`
   *
   * @param {Track} track
   *        The audio, video, or text track to add to the list.
   *
   * @fires TrackList#addtrack
   */


  TrackList.prototype.addTrack = function addTrack(track) {
    var index = this.tracks_.length;

    if (!('' + index in this)) {
      Object.defineProperty(this, index, {
        get: function get$$1() {
          return this.tracks_[index];
        }
      });
    }

    // Do not add duplicate tracks
    if (this.tracks_.indexOf(track) === -1) {
      this.tracks_.push(track);
      /**
       * Triggered when a track is added to a track list.
       *
       * @event TrackList#addtrack
       * @type {EventTarget~Event}
       * @property {Track} track
       *           A reference to track that was added.
       */
      this.trigger({
        track: track,
        type: 'addtrack'
      });
    }
  };

  /**
   * Remove a {@link Track} from the `TrackList`
   *
   * @param {Track} rtrack
   *        The audio, video, or text track to remove from the list.
   *
   * @fires TrackList#removetrack
   */


  TrackList.prototype.removeTrack = function removeTrack(rtrack) {
    var track = void 0;

    for (var i = 0, l = this.length; i < l; i++) {
      if (this[i] === rtrack) {
        track = this[i];
        if (track.off) {
          track.off();
        }

        this.tracks_.splice(i, 1);

        break;
      }
    }

    if (!track) {
      return;
    }

    /**
     * Triggered when a track is removed from track list.
     *
     * @event TrackList#removetrack
     * @type {EventTarget~Event}
     * @property {Track} track
     *           A reference to track that was removed.
     */
    this.trigger({
      track: track,
      type: 'removetrack'
    });
  };

  /**
   * Get a Track from the TrackList by a tracks id
   *
   * @param {String} id - the id of the track to get
   * @method getTrackById
   * @return {Track}
   * @private
   */


  TrackList.prototype.getTrackById = function getTrackById(id) {
    var result = null;

    for (var i = 0, l = this.length; i < l; i++) {
      var track = this[i];

      if (track.id === id) {
        result = track;
        break;
      }
    }

    return result;
  };

  return TrackList;
}(EventTarget);

/**
 * Triggered when a different track is selected/enabled.
 *
 * @event TrackList#change
 * @type {EventTarget~Event}
 */

/**
 * Events that can be called with on + eventName. See {@link EventHandler}.
 *
 * @property {Object} TrackList#allowedEvents_
 * @private
 */


TrackList.prototype.allowedEvents_ = {
  change: 'change',
  addtrack: 'addtrack',
  removetrack: 'removetrack'
};

// emulate attribute EventHandler support to allow for feature detection
for (var event in TrackList.prototype.allowedEvents_) {
  TrackList.prototype['on' + event] = null;
}

/**
 * @file audio-track-list.js
 */
/**
 * Anywhere we call this function we diverge from the spec
 * as we only support one enabled audiotrack at a time
 *
 * @param {AudioTrackList} list
 *        list to work on
 *
 * @param {AudioTrack} track
 *        The track to skip
 *
 * @private
 */
var disableOthers = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    // another audio track is enabled, disable it
    list[i].enabled = false;
  }
};

/**
 * The current list of {@link AudioTrack} for a media file.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}
 * @extends TrackList
 */

var AudioTrackList = function (_TrackList) {
  inherits(AudioTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {AudioTrack[]} [tracks=[]]
   *        A list of `AudioTrack` to instantiate the list with.
   */
  function AudioTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, AudioTrackList);

    var list = void 0;

    // make sure only 1 track is enabled
    // sorted from last index to first index
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].enabled) {
        disableOthers(tracks, tracks[i]);
        break;
      }
    }

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in AudioTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = AudioTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    list.changing_ = false;

    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add an {@link AudioTrack} to the `AudioTrackList`.
   *
   * @param {AudioTrack} track
   *        The AudioTrack to add to the list
   *
   * @fires TrackList#addtrack
   */


  AudioTrackList.prototype.addTrack = function addTrack(track) {
    var _this2 = this;

    if (track.enabled) {
      disableOthers(this, track);
    }

    _TrackList.prototype.addTrack.call(this, track);
    // native tracks don't have this
    if (!track.addEventListener) {
      return;
    }

    /**
     * @listens AudioTrack#enabledchange
     * @fires TrackList#change
     */
    track.addEventListener('enabledchange', function () {
      // when we are disabling other tracks (since we don't support
      // more than one track at a time) we will set changing_
      // to true so that we don't trigger additional change events
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers(_this2, track);
      _this2.changing_ = false;
      _this2.trigger('change');
    });
  };

  return AudioTrackList;
}(TrackList);

/**
 * @file video-track-list.js
 */
/**
 * Un-select all other {@link VideoTrack}s that are selected.
 *
 * @param {VideoTrackList} list
 *        list to work on
 *
 * @param {VideoTrack} track
 *        The track to skip
 *
 * @private
 */
var disableOthers$1 = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    // another video track is enabled, disable it
    list[i].selected = false;
  }
};

/**
 * The current list of {@link VideoTrack} for a video.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}
 * @extends TrackList
 */

var VideoTrackList = function (_TrackList) {
  inherits(VideoTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {VideoTrack[]} [tracks=[]]
   *        A list of `VideoTrack` to instantiate the list with.
   */
  function VideoTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, VideoTrackList);

    var list = void 0;

    // make sure only 1 track is enabled
    // sorted from last index to first index
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].selected) {
        disableOthers$1(tracks, tracks[i]);
        break;
      }
    }

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in VideoTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = VideoTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    list.changing_ = false;

    /**
     * @member {number} VideoTrackList#selectedIndex
     *         The current index of the selected {@link VideoTrack`}.
     */
    Object.defineProperty(list, 'selectedIndex', {
      get: function get$$1() {
        for (var _i = 0; _i < this.length; _i++) {
          if (this[_i].selected) {
            return _i;
          }
        }
        return -1;
      },
      set: function set$$1() {}
    });

    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link VideoTrack} to the `VideoTrackList`.
   *
   * @param {VideoTrack} track
   *        The VideoTrack to add to the list
   *
   * @fires TrackList#addtrack
   */


  VideoTrackList.prototype.addTrack = function addTrack(track) {
    var _this2 = this;

    if (track.selected) {
      disableOthers$1(this, track);
    }

    _TrackList.prototype.addTrack.call(this, track);
    // native tracks don't have this
    if (!track.addEventListener) {
      return;
    }

    /**
     * @listens VideoTrack#selectedchange
     * @fires TrackList#change
     */
    track.addEventListener('selectedchange', function () {
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers$1(_this2, track);
      _this2.changing_ = false;
      _this2.trigger('change');
    });
  };

  return VideoTrackList;
}(TrackList);

/**
 * @file text-track-list.js
 */
/**
 * The current list of {@link TextTrack} for a media file.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}
 * @extends TrackList
 */

var TextTrackList = function (_TrackList) {
  inherits(TextTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {TextTrack[]} [tracks=[]]
   *        A list of `TextTrack` to instantiate the list with.
   */
  function TextTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, TextTrackList);

    var list = void 0;

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in TextTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = TextTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link TextTrack} to the `TextTrackList`
   *
   * @param {TextTrack} track
   *        The text track to add to the list.
   *
   * @fires TrackList#addtrack
   */


  TextTrackList.prototype.addTrack = function addTrack(track) {
    _TrackList.prototype.addTrack.call(this, track);

    /**
     * @listens TextTrack#modechange
     * @fires TrackList#change
     */
    track.addEventListener('modechange', bind(this, function () {
      this.trigger('change');
    }));

    var nonLanguageTextTrackKind = ['metadata', 'chapters'];

    if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {
      track.addEventListener('modechange', bind(this, function () {
        this.trigger('selectedlanguagechange');
      }));
    }
  };

  return TextTrackList;
}(TrackList);

/**
 * @file html-track-element-list.js
 */

/**
 * The current list of {@link HtmlTrackElement}s.
 */

var HtmlTrackElementList = function () {

  /**
   * Create an instance of this class.
   *
   * @param {HtmlTrackElement[]} [tracks=[]]
   *        A list of `HtmlTrackElement` to instantiate the list with.
   */
  function HtmlTrackElementList() {
    var trackElements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, HtmlTrackElementList);

    var list = this; // eslint-disable-line

    if (IS_IE8) {
      list = document.createElement('custom');

      for (var prop in HtmlTrackElementList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = HtmlTrackElementList.prototype[prop];
        }
      }
    }

    list.trackElements_ = [];

    /**
     * @memberof HtmlTrackElementList
     * @member {number} length
     *         The current number of `Track`s in the this Trackist.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.trackElements_.length;
      }
    });

    for (var i = 0, length = trackElements.length; i < length; i++) {
      list.addTrackElement_(trackElements[i]);
    }

    if (IS_IE8) {
      return list;
    }
  }

  /**
   * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to add to the list.
   *
   * @private
   */


  HtmlTrackElementList.prototype.addTrackElement_ = function addTrackElement_(trackElement) {
    var index = this.trackElements_.length;

    if (!('' + index in this)) {
      Object.defineProperty(this, index, {
        get: function get$$1() {
          return this.trackElements_[index];
        }
      });
    }

    // Do not add duplicate elements
    if (this.trackElements_.indexOf(trackElement) === -1) {
      this.trackElements_.push(trackElement);
    }
  };

  /**
   * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an
   * {@link TextTrack}.
   *
   * @param {TextTrack} track
   *        The track associated with a track element.
   *
   * @return {HtmlTrackElement|undefined}
   *         The track element that was found or undefined.
   *
   * @private
   */


  HtmlTrackElementList.prototype.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {
    var trackElement_ = void 0;

    for (var i = 0, length = this.trackElements_.length; i < length; i++) {
      if (track === this.trackElements_[i].track) {
        trackElement_ = this.trackElements_[i];

        break;
      }
    }

    return trackElement_;
  };

  /**
   * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to remove from the list.
   *
   * @private
   */


  HtmlTrackElementList.prototype.removeTrackElement_ = function removeTrackElement_(trackElement) {
    for (var i = 0, length = this.trackElements_.length; i < length; i++) {
      if (trackElement === this.trackElements_[i]) {
        this.trackElements_.splice(i, 1);

        break;
      }
    }
  };

  return HtmlTrackElementList;
}();

/**
 * @file text-track-cue-list.js
 */
/**
 * @typedef {Object} TextTrackCueList~TextTrackCue
 *
 * @property {string} id
 *           The unique id for this text track cue
 *
 * @property {number} startTime
 *           The start time for this text track cue
 *
 * @property {number} endTime
 *           The end time for this text track cue
 *
 * @property {boolean} pauseOnExit
 *           Pause when the end time is reached if true.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}
 */

/**
 * A List of TextTrackCues.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}
 */

var TextTrackCueList = function () {

  /**
   * Create an instance of this class..
   *
   * @param {Array} cues
   *        A list of cues to be initialized with
   */
  function TextTrackCueList(cues) {
    classCallCheck(this, TextTrackCueList);

    var list = this; // eslint-disable-line

    if (IS_IE8) {
      list = document.createElement('custom');

      for (var prop in TextTrackCueList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TextTrackCueList.prototype[prop];
        }
      }
    }

    TextTrackCueList.prototype.setCues_.call(list, cues);

    /**
     * @memberof TextTrackCueList
     * @member {number} length
     *         The current number of `TextTrackCue`s in the TextTrackCueList.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.length_;
      }
    });

    if (IS_IE8) {
      return list;
    }
  }

  /**
   * A setter for cues in this list. Creates getters
   * an an index for the cues.
   *
   * @param {Array} cues
   *        An array of cues to set
   *
   * @private
   */


  TextTrackCueList.prototype.setCues_ = function setCues_(cues) {
    var oldLength = this.length || 0;
    var i = 0;
    var l = cues.length;

    this.cues_ = cues;
    this.length_ = cues.length;

    var defineProp = function defineProp(index) {
      if (!('' + index in this)) {
        Object.defineProperty(this, '' + index, {
          get: function get$$1() {
            return this.cues_[index];
          }
        });
      }
    };

    if (oldLength < l) {
      i = oldLength;

      for (; i < l; i++) {
        defineProp.call(this, i);
      }
    }
  };

  /**
   * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.
   *
   * @param {string} id
   *        The id of the cue that should be searched for.
   *
   * @return {TextTrackCueList~TextTrackCue|null}
   *         A single cue or null if none was found.
   */


  TextTrackCueList.prototype.getCueById = function getCueById(id) {
    var result = null;

    for (var i = 0, l = this.length; i < l; i++) {
      var cue = this[i];

      if (cue.id === id) {
        result = cue;
        break;
      }
    }

    return result;
  };

  return TextTrackCueList;
}();

/**
 * @file track-kinds.js
 */

/**
 * All possible `VideoTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind
 * @typedef VideoTrack~Kind
 * @enum
 */
var VideoTrackKind = {
  alternative: 'alternative',
  captions: 'captions',
  main: 'main',
  sign: 'sign',
  subtitles: 'subtitles',
  commentary: 'commentary'
};

/**
 * All possible `AudioTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind
 * @typedef AudioTrack~Kind
 * @enum
 */
var AudioTrackKind = {
  'alternative': 'alternative',
  'descriptions': 'descriptions',
  'main': 'main',
  'main-desc': 'main-desc',
  'translation': 'translation',
  'commentary': 'commentary'
};

/**
 * All possible `TextTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind
 * @typedef TextTrack~Kind
 * @enum
 */
var TextTrackKind = {
  subtitles: 'subtitles',
  captions: 'captions',
  descriptions: 'descriptions',
  chapters: 'chapters',
  metadata: 'metadata'
};

/**
 * All possible `TextTrackMode`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode
 * @typedef TextTrack~Mode
 * @enum
 */
var TextTrackMode = {
  disabled: 'disabled',
  hidden: 'hidden',
  showing: 'showing'
};

/**
 * @file track.js
 */
/**
 * A Track class that contains all of the common functionality for {@link AudioTrack},
 * {@link VideoTrack}, and {@link TextTrack}.
 *
 * > Note: This class should not be used directly
 *
 * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}
 * @extends EventTarget
 * @abstract
 */

var Track = function (_EventTarget) {
  inherits(Track, _EventTarget);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid kind for the track type you are creating.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @abstract
   */
  function Track() {
    var _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Track);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    var track = _this; // eslint-disable-line

    if (IS_IE8) {
      track = document.createElement('custom');
      for (var prop in Track.prototype) {
        if (prop !== 'constructor') {
          track[prop] = Track.prototype[prop];
        }
      }
    }

    var trackProps = {
      id: options.id || 'vjs_track_' + newGUID(),
      kind: options.kind || '',
      label: options.label || '',
      language: options.language || ''
    };

    /**
     * @memberof Track
     * @member {string} id
     *         The id of this track. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} kind
     *         The kind of track that this is. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} label
     *         The label of this track. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} language
     *         The two letter language code for this track. Cannot be changed after
     *         creation.
     * @instance
     *
     * @readonly
     */

    var _loop = function _loop(key) {
      Object.defineProperty(track, key, {
        get: function get$$1() {
          return trackProps[key];
        },
        set: function set$$1() {}
      });
    };

    for (var key in trackProps) {
      _loop(key);
    }

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return Track;
}(EventTarget);

/**
 * @file url.js
 * @module url
 */
/**
 * @typedef {Object} url:URLObject
 *
 * @property {string} protocol
 *           The protocol of the url that was parsed.
 *
 * @property {string} hostname
 *           The hostname of the url that was parsed.
 *
 * @property {string} port
 *           The port of the url that was parsed.
 *
 * @property {string} pathname
 *           The pathname of the url that was parsed.
 *
 * @property {string} search
 *           The search query of the url that was parsed.
 *
 * @property {string} hash
 *           The hash of the url that was parsed.
 *
 * @property {string} host
 *           The host of the url that was parsed.
 */

/**
 * Resolve and parse the elements of a URL.
 *
 * @param  {String} url
 *         The url to parse
 *
 * @return {url:URLObject}
 *         An object of url details
 */
var parseUrl = function parseUrl(url) {
  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];

  // add the url to an anchor and let the browser parse the URL
  var a = document.createElement('a');

  a.href = url;

  // IE8 (and 9?) Fix
  // ie8 doesn't parse the URL correctly until the anchor is actually
  // added to the body, and an innerHTML is needed to trigger the parsing
  var addToBody = a.host === '' && a.protocol !== 'file:';
  var div = void 0;

  if (addToBody) {
    div = document.createElement('div');
    div.innerHTML = '<a href="' + url + '"></a>';
    a = div.firstChild;
    // prevent the div from affecting layout
    div.setAttribute('style', 'display:none; position:absolute;');
    document.body.appendChild(div);
  }

  // Copy the specific URL properties to a new object
  // This is also needed for IE8 because the anchor loses its
  // properties when it's removed from the dom
  var details = {};

  for (var i = 0; i < props.length; i++) {
    details[props[i]] = a[props[i]];
  }

  // IE9 adds the port to the host property unlike everyone else. If
  // a port identifier is added for standard ports, strip it.
  if (details.protocol === 'http:') {
    details.host = details.host.replace(/:80$/, '');
  }

  if (details.protocol === 'https:') {
    details.host = details.host.replace(/:443$/, '');
  }

  if (addToBody) {
    document.body.removeChild(div);
  }

  return details;
};

/**
 * Get absolute version of relative URL. Used to tell flash correct URL.
 *
 *
 * @param  {string} url
 *         URL to make absolute
 *
 * @return {string}
 *         Absolute URL
 *
 * @see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue
 */
var getAbsoluteURL = function getAbsoluteURL(url) {
  // Check if absolute URL
  if (!url.match(/^https?:\/\//)) {
    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.
    var div = document.createElement('div');

    div.innerHTML = '<a href="' + url + '">x</a>';
    url = div.firstChild.href;
  }

  return url;
};

/**
 * Returns the extension of the passed file name. It will return an empty string
 * if passed an invalid path.
 *
 * @param {string} path
 *        The fileName path like '/path/to/file.mp4'
 *
 * @returns {string}
 *          The extension in lower case or an empty string if no
 *          extension could be found.
 */
var getFileExtension = function getFileExtension(path) {
  if (typeof path === 'string') {
    var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/i;
    var pathParts = splitPathRe.exec(path);

    if (pathParts) {
      return pathParts.pop().toLowerCase();
    }
  }

  return '';
};

/**
 * Returns whether the url passed is a cross domain request or not.
 *
 * @param {string} url
 *        The url to check.
 *
 * @return {boolean}
 *         Whether it is a cross domain request or not.
 */
var isCrossOrigin = function isCrossOrigin(url) {
  var winLoc = window.location;
  var urlInfo = parseUrl(url);

  // IE8 protocol relative urls will return ':' for protocol
  var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;

  // Check if url is for another domain/origin
  // IE8 doesn't know location.origin, so we won't rely on it here
  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;

  return crossOrigin;
};

var Url = (Object.freeze || Object)({
	parseUrl: parseUrl,
	getAbsoluteURL: getAbsoluteURL,
	getFileExtension: getFileExtension,
	isCrossOrigin: isCrossOrigin
});

/**
 * @file text-track.js
 */
/**
 * Takes a webvtt file contents and parses it into cues
 *
 * @param {string} srcContent
 *        webVTT file contents
 *
 * @param {TextTrack} track
 *        TextTrack to add cues to. Cues come from the srcContent.
 *
 * @private
 */
var parseCues = function parseCues(srcContent, track) {
  var parser = new window.WebVTT.Parser(window, window.vttjs, window.WebVTT.StringDecoder());
  var errors = [];

  parser.oncue = function (cue) {
    track.addCue(cue);
  };

  parser.onparsingerror = function (error) {
    errors.push(error);
  };

  parser.onflush = function () {
    track.trigger({
      type: 'loadeddata',
      target: track
    });
  };

  parser.parse(srcContent);
  if (errors.length > 0) {
    if (window.console && window.console.groupCollapsed) {
      window.console.groupCollapsed('Text Track parsing errors for ' + track.src);
    }
    errors.forEach(function (error) {
      return log$1.error(error);
    });
    if (window.console && window.console.groupEnd) {
      window.console.groupEnd();
    }
  }

  parser.flush();
};

/**
 * Load a `TextTrack` from a specifed url.
 *
 * @param {string} src
 *        Url to load track from.
 *
 * @param {TextTrack} track
 *        Track to add cues to. Comes from the content at the end of `url`.
 *
 * @private
 */
var loadTrack = function loadTrack(src, track) {
  var opts = {
    uri: src
  };
  var crossOrigin = isCrossOrigin(src);

  if (crossOrigin) {
    opts.cors = crossOrigin;
  }

  xhr(opts, bind(this, function (err, response, responseBody) {
    if (err) {
      return log$1.error(err, response);
    }

    track.loaded_ = true;

    // Make sure that vttjs has loaded, otherwise, wait till it finished loading
    // NOTE: this is only used for the alt/video.novtt.js build
    if (typeof window.WebVTT !== 'function') {
      if (track.tech_) {
        var loadHandler = function loadHandler() {
          return parseCues(responseBody, track);
        };

        track.tech_.on('vttjsloaded', loadHandler);
        track.tech_.on('vttjserror', function () {
          log$1.error('vttjs failed to load, stopping trying to process ' + track.src);
          track.tech_.off('vttjsloaded', loadHandler);
        });
      }
    } else {
      parseCues(responseBody, track);
    }
  }));
};

/**
 * A representation of a single `TextTrack`.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}
 * @extends Track
 */

var TextTrack = function (_Track) {
  inherits(TextTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this TextTrack.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        vesion of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  function TextTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, TextTrack);

    if (!options.tech) {
      throw new Error('A tech was not provided.');
    }

    var settings = mergeOptions(options, {
      kind: TextTrackKind[options.kind] || 'subtitles',
      language: options.language || options.srclang || ''
    });
    var mode = TextTrackMode[settings.mode] || 'disabled';
    var default_ = settings['default'];

    if (settings.kind === 'metadata' || settings.kind === 'chapters') {
      mode = 'hidden';
    }
    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var tt = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);

    tt.tech_ = settings.tech;

    if (IS_IE8) {
      for (var prop in TextTrack.prototype) {
        if (prop !== 'constructor') {
          tt[prop] = TextTrack.prototype[prop];
        }
      }
    }

    tt.cues_ = [];
    tt.activeCues_ = [];

    var cues = new TextTrackCueList(tt.cues_);
    var activeCues = new TextTrackCueList(tt.activeCues_);
    var changed = false;
    var timeupdateHandler = bind(tt, function () {

      // Accessing this.activeCues for the side-effects of updating itself
      // due to it's nature as a getter function. Do not remove or cues will
      // stop updating!
      /* eslint-disable no-unused-expressions */
      this.activeCues;
      /* eslint-enable no-unused-expressions */
      if (changed) {
        this.trigger('cuechange');
        changed = false;
      }
    });

    if (mode !== 'disabled') {
      tt.tech_.ready(function () {
        tt.tech_.on('timeupdate', timeupdateHandler);
      }, true);
    }

    /**
     * @memberof TextTrack
     * @member {boolean} default
     *         If this track was set to be on or off by default. Cannot be changed after
     *         creation.
     * @instance
     *
     * @readonly
     */
    Object.defineProperty(tt, 'default', {
      get: function get$$1() {
        return default_;
      },
      set: function set$$1() {}
    });

    /**
     * @memberof TextTrack
     * @member {string} mode
     *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
     *         not be set if setting to an invalid mode.
     * @instance
     *
     * @fires TextTrack#modechange
     */
    Object.defineProperty(tt, 'mode', {
      get: function get$$1() {
        return mode;
      },
      set: function set$$1(newMode) {
        var _this2 = this;

        if (!TextTrackMode[newMode]) {
          return;
        }
        mode = newMode;
        if (mode === 'showing') {

          this.tech_.ready(function () {
            _this2.tech_.on('timeupdate', timeupdateHandler);
          }, true);
        }
        /**
         * An event that fires when mode changes on this track. This allows
         * the TextTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec!
         *
         * @event TextTrack#modechange
         * @type {EventTarget~Event}
         */
        this.trigger('modechange');
      }
    });

    /**
     * @memberof TextTrack
     * @member {TextTrackCueList} cues
     *         The text track cue list for this TextTrack.
     * @instance
     */
    Object.defineProperty(tt, 'cues', {
      get: function get$$1() {
        if (!this.loaded_) {
          return null;
        }

        return cues;
      },
      set: function set$$1() {}
    });

    /**
     * @memberof TextTrack
     * @member {TextTrackCueList} activeCues
     *         The list text track cues that are currently active for this TextTrack.
     * @instance
     */
    Object.defineProperty(tt, 'activeCues', {
      get: function get$$1() {
        if (!this.loaded_) {
          return null;
        }

        // nothing to do
        if (this.cues.length === 0) {
          return activeCues;
        }

        var ct = this.tech_.currentTime();
        var active = [];

        for (var i = 0, l = this.cues.length; i < l; i++) {
          var cue = this.cues[i];

          if (cue.startTime <= ct && cue.endTime >= ct) {
            active.push(cue);
          } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
            active.push(cue);
          }
        }

        changed = false;

        if (active.length !== this.activeCues_.length) {
          changed = true;
        } else {
          for (var _i = 0; _i < active.length; _i++) {
            if (this.activeCues_.indexOf(active[_i]) === -1) {
              changed = true;
            }
          }
        }

        this.activeCues_ = active;
        activeCues.setCues_(this.activeCues_);

        return activeCues;
      },
      set: function set$$1() {}
    });

    if (settings.src) {
      tt.src = settings.src;
      loadTrack(settings.src, tt);
    } else {
      tt.loaded_ = true;
    }

    return _ret = tt, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a cue to the internal list of cues.
   *
   * @param {TextTrack~Cue} cue
   *        The cue to add to our internal list
   */


  TextTrack.prototype.addCue = function addCue(originalCue) {
    var cue = originalCue;

    if (window.vttjs && !(originalCue instanceof window.vttjs.VTTCue)) {
      cue = new window.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);

      for (var prop in originalCue) {
        if (!(prop in cue)) {
          cue[prop] = originalCue[prop];
        }
      }

      // make sure that `id` is copied over
      cue.id = originalCue.id;
      cue.originalCue_ = originalCue;
    }

    var tracks = this.tech_.textTracks();

    for (var i = 0; i < tracks.length; i++) {
      if (tracks[i] !== this) {
        tracks[i].removeCue(cue);
      }
    }

    this.cues_.push(cue);
    this.cues.setCues_(this.cues_);
  };

  /**
   * Remove a cue from our internal list
   *
   * @param {TextTrack~Cue} removeCue
   *        The cue to remove from our internal list
   */


  TextTrack.prototype.removeCue = function removeCue(_removeCue) {
    var i = this.cues_.length;

    while (i--) {
      var cue = this.cues_[i];

      if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {
        this.cues_.splice(i, 1);
        this.cues.setCues_(this.cues_);
        break;
      }
    }
  };

  return TextTrack;
}(Track);

/**
 * cuechange - One or more cues in the track have become active or stopped being active.
 */


TextTrack.prototype.allowedEvents_ = {
  cuechange: 'cuechange'
};

/**
 * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}
 * only one `AudioTrack` in the list will be enabled at a time.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}
 * @extends Track
 */

var AudioTrack = function (_Track) {
  inherits(AudioTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {AudioTrack~Kind} [options.kind='']
   *        A valid audio track kind
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.enabled]
   *        If this track is the one that is currently playing. If this track is part of
   *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.
   */
  function AudioTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, AudioTrack);

    var settings = mergeOptions(options, {
      kind: AudioTrackKind[options.kind] || ''
    });
    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var track = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);
    var enabled = false;

    if (IS_IE8) {
      for (var prop in AudioTrack.prototype) {
        if (prop !== 'constructor') {
          track[prop] = AudioTrack.prototype[prop];
        }
      }
    }
    /**
     * @memberof AudioTrack
     * @member {boolean} enabled
     *         If this `AudioTrack` is enabled or not. When setting this will
     *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.
     * @instance
     *
     * @fires VideoTrack#selectedchange
     */
    Object.defineProperty(track, 'enabled', {
      get: function get$$1() {
        return enabled;
      },
      set: function set$$1(newEnabled) {
        // an invalid or unchanged value
        if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {
          return;
        }
        enabled = newEnabled;

        /**
         * An event that fires when enabled changes on this track. This allows
         * the AudioTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec! Native tracks will do
         *         this internally without an event.
         *
         * @event AudioTrack#enabledchange
         * @type {EventTarget~Event}
         */
        this.trigger('enabledchange');
      }
    });

    // if the user sets this track to selected then
    // set selected to that true value otherwise
    // we keep it false
    if (settings.enabled) {
      track.enabled = settings.enabled;
    }
    track.loaded_ = true;

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return AudioTrack;
}(Track);

/**
 * A representation of a single `VideoTrack`.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}
 * @extends Track
 */

var VideoTrack = function (_Track) {
  inherits(VideoTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid {@link VideoTrack~Kind}
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.selected]
   *        If this track is the one that is currently playing.
   */
  function VideoTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, VideoTrack);

    var settings = mergeOptions(options, {
      kind: VideoTrackKind[options.kind] || ''
    });

    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var track = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);
    var selected = false;

    if (IS_IE8) {
      for (var prop in VideoTrack.prototype) {
        if (prop !== 'constructor') {
          track[prop] = VideoTrack.prototype[prop];
        }
      }
    }

    /**
     * @memberof VideoTrack
     * @member {boolean} selected
     *         If this `VideoTrack` is selected or not. When setting this will
     *         fire {@link VideoTrack#selectedchange} if the state of selected changed.
     * @instance
     *
     * @fires VideoTrack#selectedchange
     */
    Object.defineProperty(track, 'selected', {
      get: function get$$1() {
        return selected;
      },
      set: function set$$1(newSelected) {
        // an invalid or unchanged value
        if (typeof newSelected !== 'boolean' || newSelected === selected) {
          return;
        }
        selected = newSelected;

        /**
         * An event that fires when selected changes on this track. This allows
         * the VideoTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec! Native tracks will do
         *         this internally without an event.
         *
         * @event VideoTrack#selectedchange
         * @type {EventTarget~Event}
         */
        this.trigger('selectedchange');
      }
    });

    // if the user sets this track to selected then
    // set selected to that true value otherwise
    // we keep it false
    if (settings.selected) {
      track.selected = settings.selected;
    }

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return VideoTrack;
}(Track);

/**
 * @file html-track-element.js
 */

/**
 * @memberof HTMLTrackElement
 * @typedef {HTMLTrackElement~ReadyState}
 * @enum {number}
 */
var NONE = 0;
var LOADING = 1;
var LOADED = 2;
var ERROR = 3;

/**
 * A single track represented in the DOM.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}
 * @extends EventTarget
 */

var HTMLTrackElement = function (_EventTarget) {
  inherits(HTMLTrackElement, _EventTarget);

  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this HTMLTrackElement.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        vesion of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  function HTMLTrackElement() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, HTMLTrackElement);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    var readyState = void 0;
    var trackElement = _this; // eslint-disable-line

    if (IS_IE8) {
      trackElement = document.createElement('custom');

      for (var prop in HTMLTrackElement.prototype) {
        if (prop !== 'constructor') {
          trackElement[prop] = HTMLTrackElement.prototype[prop];
        }
      }
    }

    var track = new TextTrack(options);

    trackElement.kind = track.kind;
    trackElement.src = track.src;
    trackElement.srclang = track.language;
    trackElement.label = track.label;
    trackElement['default'] = track['default'];

    /**
     * @memberof HTMLTrackElement
     * @member {HTMLTrackElement~ReadyState} readyState
     *         The current ready state of the track element.
     * @instance
     */
    Object.defineProperty(trackElement, 'readyState', {
      get: function get$$1() {
        return readyState;
      }
    });

    /**
     * @memberof HTMLTrackElement
     * @member {TextTrack} track
     *         The underlying TextTrack object.
     * @instance
     *
     */
    Object.defineProperty(trackElement, 'track', {
      get: function get$$1() {
        return track;
      }
    });

    readyState = NONE;

    /**
     * @listens TextTrack#loadeddata
     * @fires HTMLTrackElement#load
     */
    track.addEventListener('loadeddata', function () {
      readyState = LOADED;

      trackElement.trigger({
        type: 'load',
        target: trackElement
      });
    });

    if (IS_IE8) {
      var _ret;

      return _ret = trackElement, possibleConstructorReturn(_this, _ret);
    }
    return _this;
  }

  return HTMLTrackElement;
}(EventTarget);

HTMLTrackElement.prototype.allowedEvents_ = {
  load: 'load'
};

HTMLTrackElement.NONE = NONE;
HTMLTrackElement.LOADING = LOADING;
HTMLTrackElement.LOADED = LOADED;
HTMLTrackElement.ERROR = ERROR;

/*
 * This file contains all track properties that are used in
 * player.js, tech.js, html5.js and possibly other techs in the future.
 */

var NORMAL = {
  audio: {
    ListClass: AudioTrackList,
    TrackClass: AudioTrack,
    capitalName: 'Audio'
  },
  video: {
    ListClass: VideoTrackList,
    TrackClass: VideoTrack,
    capitalName: 'Video'
  },
  text: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: 'Text'
  }
};

Object.keys(NORMAL).forEach(function (type) {
  NORMAL[type].getterName = type + 'Tracks';
  NORMAL[type].privateName = type + 'Tracks_';
});

var REMOTE = {
  remoteText: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: 'RemoteText',
    getterName: 'remoteTextTracks',
    privateName: 'remoteTextTracks_'
  },
  remoteTextEl: {
    ListClass: HtmlTrackElementList,
    TrackClass: HTMLTrackElement,
    capitalName: 'RemoteTextTrackEls',
    getterName: 'remoteTextTrackEls',
    privateName: 'remoteTextTrackEls_'
  }
};

var ALL = mergeOptions(NORMAL, REMOTE);

REMOTE.names = Object.keys(REMOTE);
NORMAL.names = Object.keys(NORMAL);
ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);

/**
 * @file tech.js
 */

/**
 * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string
 * that just contains the src url alone.
 * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`
   * `var SourceString = 'http://example.com/some-video.mp4';`
 *
 * @typedef {Object|string} Tech~SourceObject
 *
 * @property {string} src
 *           The url to the source
 *
 * @property {string} type
 *           The mime type of the source
 */

/**
 * A function used by {@link Tech} to create a new {@link TextTrack}.
 *
 * @private
 *
 * @param {Tech} self
 *        An instance of the Tech class.
 *
 * @param {string} kind
 *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
 *
 * @param {string} [label]
 *        Label to identify the text track
 *
 * @param {string} [language]
 *        Two letter language abbreviation
 *
 * @param {Object} [options={}]
 *        An object with additional text track options
 *
 * @return {TextTrack}
 *          The text track that was created.
 */
function createTrackHelper(self, kind, label, language) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

  var tracks = self.textTracks();

  options.kind = kind;

  if (label) {
    options.label = label;
  }
  if (language) {
    options.language = language;
  }
  options.tech = self;

  var track = new ALL.text.TrackClass(options);

  tracks.addTrack(track);

  return track;
}

/**
 * This is the base class for media playback technology controllers, such as
 * {@link Flash} and {@link HTML5}
 *
 * @extends Component
 */

var Tech = function (_Component) {
  inherits(Tech, _Component);

  /**
   * Create an instance of this Tech.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} ready
   *        Callback function to call when the `HTML5` Tech is ready.
   */
  function Tech() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var ready = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
    classCallCheck(this, Tech);

    // we don't want the tech to report user activity automatically.
    // This is done manually in addControlsListeners
    options.reportTouchActivity = false;

    // keep track of whether the current source has played at all to
    // implement a very limited played()
    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));

    _this.hasStarted_ = false;
    _this.on('playing', function () {
      this.hasStarted_ = true;
    });
    _this.on('loadstart', function () {
      this.hasStarted_ = false;
    });

    ALL.names.forEach(function (name) {
      var props = ALL[name];

      if (options && options[props.getterName]) {
        _this[props.privateName] = options[props.getterName];
      }
    });

    // Manually track progress in cases where the browser/flash player doesn't report it.
    if (!_this.featuresProgressEvents) {
      _this.manualProgressOn();
    }

    // Manually track timeupdates in cases where the browser/flash player doesn't report it.
    if (!_this.featuresTimeupdateEvents) {
      _this.manualTimeUpdatesOn();
    }

    ['Text', 'Audio', 'Video'].forEach(function (track) {
      if (options['native' + track + 'Tracks'] === false) {
        _this['featuresNative' + track + 'Tracks'] = false;
      }
    });

    if (options.nativeCaptions === false || options.nativeTextTracks === false) {
      _this.featuresNativeTextTracks = false;
    } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
      _this.featuresNativeTextTracks = true;
    }

    if (!_this.featuresNativeTextTracks) {
      _this.emulateTextTracks();
    }

    _this.autoRemoteTextTracks_ = new ALL.text.ListClass();

    _this.initTrackListeners();

    // Turn on component tap events only if not using native controls
    if (!options.nativeControlsForTouch) {
      _this.emitTapEvents();
    }

    if (_this.constructor) {
      _this.name_ = _this.constructor.name || 'Unknown Tech';
    }
    return _this;
  }

  /* Fallbacks for unsupported event types
  ================================================================================ */

  /**
   * Polyfill the `progress` event for browsers that don't support it natively.
   *
   * @see {@link Tech#trackProgress}
   */


  Tech.prototype.manualProgressOn = function manualProgressOn() {
    this.on('durationchange', this.onDurationChange);

    this.manualProgress = true;

    // Trigger progress watching when a source begins loading
    this.one('ready', this.trackProgress);
  };

  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   */


  Tech.prototype.manualProgressOff = function manualProgressOff() {
    this.manualProgress = false;
    this.stopTrackingProgress();

    this.off('durationchange', this.onDurationChange);
  };

  /**
   * This is used to trigger a `progress` event when the buffered percent changes. It
   * sets an interval function that will be called every 500 milliseconds to check if the
   * buffer end percent has changed.
   *
   * > This function is called by {@link Tech#manualProgressOn}
   *
   * @param {EventTarget~Event} event
   *        The `ready` event that caused this to run.
   *
   * @listens Tech#ready
   * @fires Tech#progress
   */


  Tech.prototype.trackProgress = function trackProgress(event) {
    this.stopTrackingProgress();
    this.progressInterval = this.setInterval(bind(this, function () {
      // Don't trigger unless buffered amount is greater than last time

      var numBufferedPercent = this.bufferedPercent();

      if (this.bufferedPercent_ !== numBufferedPercent) {
        /**
         * See {@link Player#progress}
         *
         * @event Tech#progress
         * @type {EventTarget~Event}
         */
        this.trigger('progress');
      }

      this.bufferedPercent_ = numBufferedPercent;

      if (numBufferedPercent === 1) {
        this.stopTrackingProgress();
      }
    }), 500);
  };

  /**
   * Update our internal duration on a `durationchange` event by calling
   * {@link Tech#duration}.
   *
   * @param {EventTarget~Event} event
   *        The `durationchange` event that caused this to run.
   *
   * @listens Tech#durationchange
   */


  Tech.prototype.onDurationChange = function onDurationChange(event) {
    this.duration_ = this.duration();
  };

  /**
   * Get and create a `TimeRange` object for buffering.
   *
   * @return {TimeRange}
   *         The time range object that was created.
   */


  Tech.prototype.buffered = function buffered() {
    return createTimeRanges(0, 0);
  };

  /**
   * Get the percentage of the current video that is currently buffered.
   *
   * @return {number}
   *         A number from 0 to 1 that represents the decimal percentage of the
   *         video that is buffered.
   *
   */


  Tech.prototype.bufferedPercent = function bufferedPercent$$1() {
    return bufferedPercent(this.buffered(), this.duration_);
  };

  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   * Stop manually tracking progress events by clearing the interval that was set in
   * {@link Tech#trackProgress}.
   */


  Tech.prototype.stopTrackingProgress = function stopTrackingProgress() {
    this.clearInterval(this.progressInterval);
  };

  /**
   * Polyfill the `timeupdate` event for browsers that don't support it.
   *
   * @see {@link Tech#trackCurrentTime}
   */


  Tech.prototype.manualTimeUpdatesOn = function manualTimeUpdatesOn() {
    this.manualTimeUpdates = true;

    this.on('play', this.trackCurrentTime);
    this.on('pause', this.stopTrackingCurrentTime);
  };

  /**
   * Turn off the polyfill for `timeupdate` events that was created in
   * {@link Tech#manualTimeUpdatesOn}
   */


  Tech.prototype.manualTimeUpdatesOff = function manualTimeUpdatesOff() {
    this.manualTimeUpdates = false;
    this.stopTrackingCurrentTime();
    this.off('play', this.trackCurrentTime);
    this.off('pause', this.stopTrackingCurrentTime);
  };

  /**
   * Sets up an interval function to track current time and trigger `timeupdate` every
   * 250 milliseconds.
   *
   * @listens Tech#play
   * @triggers Tech#timeupdate
   */


  Tech.prototype.trackCurrentTime = function trackCurrentTime() {
    if (this.currentTimeInterval) {
      this.stopTrackingCurrentTime();
    }
    this.currentTimeInterval = this.setInterval(function () {
      /**
       * Triggered at an interval of 250ms to indicated that time is passing in the video.
       *
       * @event Tech#timeupdate
       * @type {EventTarget~Event}
       */
      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });

      // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
    }, 250);
  };

  /**
   * Stop the interval function created in {@link Tech#trackCurrentTime} so that the
   * `timeupdate` event is no longer triggered.
   *
   * @listens {Tech#pause}
   */


  Tech.prototype.stopTrackingCurrentTime = function stopTrackingCurrentTime() {
    this.clearInterval(this.currentTimeInterval);

    // #1002 - if the video ends right before the next timeupdate would happen,
    // the progress bar won't make it all the way to the end
    this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
  };

  /**
   * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},
   * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.
   *
   * @fires Component#dispose
   */


  Tech.prototype.dispose = function dispose() {

    // clear out all tracks because we can't reuse them between techs
    this.clearTracks(NORMAL.names);

    // Turn off any manual progress or timeupdate tracking
    if (this.manualProgress) {
      this.manualProgressOff();
    }

    if (this.manualTimeUpdates) {
      this.manualTimeUpdatesOff();
    }

    _Component.prototype.dispose.call(this);
  };

  /**
   * Clear out a single `TrackList` or an array of `TrackLists` given their names.
   *
   * > Note: Techs without source handlers should call this between sources for `video`
   *         & `audio` tracks. You don't want to use them between tracks!
   *
   * @param {string[]|string} types
   *        TrackList names to clear, valid names are `video`, `audio`, and
   *        `text`.
   */


  Tech.prototype.clearTracks = function clearTracks(types) {
    var _this2 = this;

    types = [].concat(types);
    // clear out all tracks because we can't reuse them between techs
    types.forEach(function (type) {
      var list = _this2[type + 'Tracks']() || [];
      var i = list.length;

      while (i--) {
        var track = list[i];

        if (type === 'text') {
          _this2.removeRemoteTextTrack(track);
        }
        list.removeTrack(track);
      }
    });
  };

  /**
   * Remove any TextTracks added via addRemoteTextTrack that are
   * flagged for automatic garbage collection
   */


  Tech.prototype.cleanupAutoTextTracks = function cleanupAutoTextTracks() {
    var list = this.autoRemoteTextTracks_ || [];
    var i = list.length;

    while (i--) {
      var track = list[i];

      this.removeRemoteTextTrack(track);
    }
  };

  /**
   * Reset the tech, which will removes all sources and reset the internal readyState.
   *
   * @abstract
   */


  Tech.prototype.reset = function reset() {};

  /**
   * Get or set an error on the Tech.
   *
   * @param {MediaError} [err]
   *        Error to set on the Tech
   *
   * @return {MediaError|null}
   *         The current error object on the tech, or null if there isn't one.
   */


  Tech.prototype.error = function error(err) {
    if (err !== undefined) {
      this.error_ = new MediaError(err);
      this.trigger('error');
    }
    return this.error_;
  };

  /**
   * Returns the `TimeRange`s that have been played through for the current source.
   *
   * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.
   *         It only checks wether the source has played at all or not.
   *
   * @return {TimeRange}
   *         - A single time range if this video has played
   *         - An empty set of ranges if not.
   */


  Tech.prototype.played = function played() {
    if (this.hasStarted_) {
      return createTimeRanges(0, 0);
    }
    return createTimeRanges();
  };

  /**
   * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was
   * previously called.
   *
   * @fires Tech#timeupdate
   */


  Tech.prototype.setCurrentTime = function setCurrentTime() {
    // improve the accuracy of manual timeupdates
    if (this.manualTimeUpdates) {
      /**
       * A manual `timeupdate` event.
       *
       * @event Tech#timeupdate
       * @type {EventTarget~Event}
       */
      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
    }
  };

  /**
   * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and
   * {@link TextTrackList} events.
   *
   * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.
   *
   * @fires Tech#audiotrackchange
   * @fires Tech#videotrackchange
   * @fires Tech#texttrackchange
   */


  Tech.prototype.initTrackListeners = function initTrackListeners() {
    var _this3 = this;

    /**
     * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}
     *
     * @event Tech#audiotrackchange
     * @type {EventTarget~Event}
     */

    /**
     * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}
     *
     * @event Tech#videotrackchange
     * @type {EventTarget~Event}
     */

    /**
     * Triggered when tracks are added or removed on the Tech {@link TextTrackList}
     *
     * @event Tech#texttrackchange
     * @type {EventTarget~Event}
     */
    NORMAL.names.forEach(function (name) {
      var props = NORMAL[name];
      var trackListChanges = function trackListChanges() {
        _this3.trigger(name + 'trackchange');
      };

      var tracks = _this3[props.getterName]();

      tracks.addEventListener('removetrack', trackListChanges);
      tracks.addEventListener('addtrack', trackListChanges);

      _this3.on('dispose', function () {
        tracks.removeEventListener('removetrack', trackListChanges);
        tracks.removeEventListener('addtrack', trackListChanges);
      });
    });
  };

  /**
   * Emulate TextTracks using vtt.js if necessary
   *
   * @fires Tech#vttjsloaded
   * @fires Tech#vttjserror
   */


  Tech.prototype.addWebVttScript_ = function addWebVttScript_() {
    var _this4 = this;

    if (window.WebVTT) {
      return;
    }

    // Initially, Tech.el_ is a child of a dummy-div wait until the Component system
    // signals that the Tech is ready at which point Tech.el_ is part of the DOM
    // before inserting the WebVTT script
    if (document.body.contains(this.el())) {

      // load via require if available and vtt.js script location was not passed in
      // as an option. novtt builds will turn the above require call into an empty object
      // which will cause this if check to always fail.
      if (!this.options_['vtt.js'] && isPlain(vtt) && Object.keys(vtt).length > 0) {
        this.trigger('vttjsloaded');
        return;
      }

      // load vtt.js via the script location option or the cdn of no location was
      // passed in
      var script = document.createElement('script');

      script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.12.4/vtt.min.js';
      script.onload = function () {
        /**
         * Fired when vtt.js is loaded.
         *
         * @event Tech#vttjsloaded
         * @type {EventTarget~Event}
         */
        _this4.trigger('vttjsloaded');
      };
      script.onerror = function () {
        /**
         * Fired when vtt.js was not loaded due to an error
         *
         * @event Tech#vttjsloaded
         * @type {EventTarget~Event}
         */
        _this4.trigger('vttjserror');
      };
      this.on('dispose', function () {
        script.onload = null;
        script.onerror = null;
      });
      // but have not loaded yet and we set it to true before the inject so that
      // we don't overwrite the injected window.WebVTT if it loads right away
      window.WebVTT = true;
      this.el().parentNode.appendChild(script);
    } else {
      this.ready(this.addWebVttScript_);
    }
  };

  /**
   * Emulate texttracks
   *
   */


  Tech.prototype.emulateTextTracks = function emulateTextTracks() {
    var _this5 = this;

    var tracks = this.textTracks();
    var remoteTracks = this.remoteTextTracks();
    var handleAddTrack = function handleAddTrack(e) {
      return tracks.addTrack(e.track);
    };
    var handleRemoveTrack = function handleRemoveTrack(e) {
      return tracks.removeTrack(e.track);
    };

    remoteTracks.on('addtrack', handleAddTrack);
    remoteTracks.on('removetrack', handleRemoveTrack);

    this.addWebVttScript_();

    var updateDisplay = function updateDisplay() {
      return _this5.trigger('texttrackchange');
    };

    var textTracksChanges = function textTracksChanges() {
      updateDisplay();

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        track.removeEventListener('cuechange', updateDisplay);
        if (track.mode === 'showing') {
          track.addEventListener('cuechange', updateDisplay);
        }
      }
    };

    textTracksChanges();
    tracks.addEventListener('change', textTracksChanges);
    tracks.addEventListener('addtrack', textTracksChanges);
    tracks.addEventListener('removetrack', textTracksChanges);

    this.on('dispose', function () {
      remoteTracks.off('addtrack', handleAddTrack);
      remoteTracks.off('removetrack', handleRemoveTrack);
      tracks.removeEventListener('change', textTracksChanges);
      tracks.removeEventListener('addtrack', textTracksChanges);
      tracks.removeEventListener('removetrack', textTracksChanges);

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        track.removeEventListener('cuechange', updateDisplay);
      }
    });
  };

  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */


  Tech.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (!kind) {
      throw new Error('TextTrack kind is required but was not provided');
    }

    return createTrackHelper(this, kind, label, language);
  };

  /**
   * Create an emulated TextTrack for use by addRemoteTextTrack
   *
   * This is intended to be overridden by classes that inherit from
   * Tech in order to create native or custom TextTracks.
   *
   * @param {Object} options
   *        The object should contain the options to initialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label].
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */


  Tech.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {
    var track = mergeOptions(options, {
      tech: this
    });

    return new REMOTE.remoteTextEl.TrackClass(track);
  };

  /**
   * Creates a remote text track object and returns an html track element.
   *
   * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.
   *
   * @param {Object} options
   *        See {@link Tech#createRemoteTextTrack} for more detailed properties.
   *
   * @param {boolean} [manualCleanup=true]
   *        - When false: the TextTrack will be automatically removed from the video
   *          element whenever the source changes
   *        - When True: The TextTrack will have to be cleaned up manually
   *
   * @return {HTMLTrackElement}
   *         An Html Track Element.
   *
   * @deprecated The default functionality for this function will be equivalent
   *             to "manualCleanup=false" in the future. The manualCleanup parameter will
   *             also be removed.
   */


  Tech.prototype.addRemoteTextTrack = function addRemoteTextTrack() {
    var _this6 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var manualCleanup = arguments[1];

    var htmlTrackElement = this.createRemoteTextTrack(options);

    if (manualCleanup !== true && manualCleanup !== false) {
      // deprecation warning
      log$1.warn('Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js');
      manualCleanup = true;
    }

    // store HTMLTrackElement and TextTrack to remote list
    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
    this.remoteTextTracks().addTrack(htmlTrackElement.track);

    if (manualCleanup !== true) {
      // create the TextTrackList if it doesn't exist
      this.ready(function () {
        return _this6.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);
      });
    }

    return htmlTrackElement;
  };

  /**
   * Remove a remote text track from the remote `TextTrackList`.
   *
   * @param {TextTrack} track
   *        `TextTrack` to remove from the `TextTrackList`
   */


  Tech.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);

    // remove HTMLTrackElement and TextTrack from remote list
    this.remoteTextTrackEls().removeTrackElement_(trackElement);
    this.remoteTextTracks().removeTrack(track);
    this.autoRemoteTextTracks_.removeTrack(track);
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   *
   * @abstract
   */


  Tech.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return {};
  };

  /**
   * A method to set a poster from a `Tech`.
   *
   * @abstract
   */


  Tech.prototype.setPoster = function setPoster() {};

  /**
   * A method to check for the presence of the 'playsinine' <video> attribute.
   *
   * @abstract
   */


  Tech.prototype.playsinline = function playsinline() {};

  /**
   * A method to set or unset the 'playsinine' <video> attribute.
   *
   * @abstract
   */


  Tech.prototype.setPlaysinline = function setPlaysinline() {};

  /*
   * Check if the tech can support the given mime-type.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param  {string} type
   *         The mimetype to check for support
   *
   * @return {string}
   *         'probably', 'maybe', or empty string
   *
   * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}
   *
   * @abstract
   */


  Tech.prototype.canPlayType = function canPlayType() {
    return '';
  };

  /**
   * Check if the type is supported by this tech.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param {string} type
   *        The media type to check
   * @return {string} Returns the native video element's response
   */


  Tech.canPlayType = function canPlayType() {
    return '';
  };

  /**
   * Check if the tech can support the given source
   * @param {Object} srcObj
   *        The source object
   * @param {Object} options
   *        The options passed to the tech
   * @return {string} 'probably', 'maybe', or '' (empty string)
   */


  Tech.canPlaySource = function canPlaySource(srcObj, options) {
    return Tech.canPlayType(srcObj.type);
  };

  /*
   * Return whether the argument is a Tech or not.
   * Can be passed either a Class like `Html5` or a instance like `player.tech_`
   *
   * @param {Object} component
   *        The item to check
   *
   * @return {boolean}
   *         Whether it is a tech or not
   *         - True if it is a tech
   *         - False if it is not
   */


  Tech.isTech = function isTech(component) {
    return component.prototype instanceof Tech || component instanceof Tech || component === Tech;
  };

  /**
   * Registers a `Tech` into a shared list for videojs.
   *
   * @param {string} name
   *        Name of the `Tech` to register.
   *
   * @param {Object} tech
   *        The `Tech` class to register.
   */


  Tech.registerTech = function registerTech(name, tech) {
    if (!Tech.techs_) {
      Tech.techs_ = {};
    }

    if (!Tech.isTech(tech)) {
      throw new Error('Tech ' + name + ' must be a Tech');
    }

    if (!Tech.canPlayType) {
      throw new Error('Techs must have a static canPlayType method on them');
    }
    if (!Tech.canPlaySource) {
      throw new Error('Techs must have a static canPlaySource method on them');
    }

    name = toTitleCase(name);

    Tech.techs_[name] = tech;
    if (name !== 'Tech') {
      // camel case the techName for use in techOrder
      Tech.defaultTechOrder_.push(name);
    }
    return tech;
  };

  /**
   * Get a `Tech` from the shared list by name.
   *
   * @param {string} name
   *        `camelCase` or `TitleCase` name of the Tech to get
   *
   * @return {Tech|undefined}
   *         The `Tech` or undefined if there was no tech with the name requsted.
   */


  Tech.getTech = function getTech(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    if (Tech.techs_ && Tech.techs_[name]) {
      return Tech.techs_[name];
    }

    if (window && window.videojs && window.videojs[name]) {
      log$1.warn('The ' + name + ' tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)');
      return window.videojs[name];
    }
  };

  return Tech;
}(Component);

/**
 * Get the {@link VideoTrackList}
 *
 * @returns {VideoTrackList}
 * @method Tech.prototype.videoTracks
 */

/**
 * Get the {@link AudioTrackList}
 *
 * @returns {AudioTrackList}
 * @method Tech.prototype.audioTracks
 */

/**
 * Get the {@link TextTrackList}
 *
 * @returns {TextTrackList}
 * @method Tech.prototype.textTracks
 */

/**
 * Get the remote element {@link TextTrackList}
 *
 * @returns {TextTrackList}
 * @method Tech.prototype.remoteTextTracks
 */

/**
 * Get the remote element {@link HtmlTrackElementList}
 *
 * @returns {HtmlTrackElementList}
 * @method Tech.prototype.remoteTextTrackEls
 */

ALL.names.forEach(function (name) {
  var props = ALL[name];

  Tech.prototype[props.getterName] = function () {
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});

/**
 * List of associated text tracks
 *
 * @type {TextTrackList}
 * @private
 * @property Tech#textTracks_
 */

/**
 * List of associated audio tracks.
 *
 * @type {AudioTrackList}
 * @private
 * @property Tech#audioTracks_
 */

/**
 * List of associated video tracks.
 *
 * @type {VideoTrackList}
 * @private
 * @property Tech#videoTracks_
 */

/**
 * Boolean indicating wether the `Tech` supports volume control.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresVolumeControl = true;

/**
 * Boolean indicating wether the `Tech` support fullscreen resize control.
 * Resizing plugins using request fullscreen reloads the plugin
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresFullscreenResize = false;

/**
 * Boolean indicating wether the `Tech` supports changing the speed at which the video
 * plays. Examples:
 *   - Set player to play 2x (twice) as fast
 *   - Set player to play 0.5x (half) as fast
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresPlaybackRate = false;

/**
 * Boolean indicating wether the `Tech` supports the `progress` event. This is currently
 * not triggered by video-js-swf. This will be used to determine if
 * {@link Tech#manualProgressOn} should be called.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresProgressEvents = false;

/**
 * Boolean indicating wether the `Tech` supports the `timeupdate` event. This is currently
 * not triggered by video-js-swf. This will be used to determine if
 * {@link Tech#manualTimeUpdates} should be called.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresTimeupdateEvents = false;

/**
 * Boolean indicating wether the `Tech` supports the native `TextTrack`s.
 * This will help us integrate with native `TextTrack`s if the browser supports them.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresNativeTextTracks = false;

/**
 * A functional mixin for techs that want to use the Source Handler pattern.
 * Source handlers are scripts for handling specific formats.
 * The source handler pattern is used for adaptive formats (HLS, DASH) that
 * manually load video data and feed it into a Source Buffer (Media Source Extensions)
 * Example: `Tech.withSourceHandlers.call(MyTech);`
 *
 * @param {Tech} _Tech
 *        The tech to add source handler functions to.
 *
 * @mixes Tech~SourceHandlerAdditions
 */
Tech.withSourceHandlers = function (_Tech) {

  /**
   * Register a source handler
   *
   * @param {Function} handler
   *        The source handler class
   *
   * @param {number} [index]
   *        Register it at the following index
   */
  _Tech.registerSourceHandler = function (handler, index) {
    var handlers = _Tech.sourceHandlers;

    if (!handlers) {
      handlers = _Tech.sourceHandlers = [];
    }

    if (index === undefined) {
      // add to the end of the list
      index = handlers.length;
    }

    handlers.splice(index, 0, handler);
  };

  /**
   * Check if the tech can support the given type. Also checks the
   * Techs sourceHandlers.
   *
   * @param {string} type
   *         The mimetype to check.
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */
  _Tech.canPlayType = function (type) {
    var handlers = _Tech.sourceHandlers || [];
    var can = void 0;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canPlayType(type);

      if (can) {
        return can;
      }
    }

    return '';
  };

  /**
   * Returns the first source handler that supports the source.
   *
   * TODO: Answer question: should 'probably' be prioritized over 'maybe'
   *
   * @param {Tech~SourceObject} source
   *        The source object
   *
   * @param {Object} options
   *        The options passed to the tech
   *
   * @return {SourceHandler|null}
   *          The first source handler that supports the source or null if
   *          no SourceHandler supports the source
   */
  _Tech.selectSourceHandler = function (source, options) {
    var handlers = _Tech.sourceHandlers || [];
    var can = void 0;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canHandleSource(source, options);

      if (can) {
        return handlers[i];
      }
    }

    return null;
  };

  /**
   * Check if the tech can support the given source.
   *
   * @param {Tech~SourceObject} srcObj
   *        The source object
   *
   * @param {Object} options
   *        The options passed to the tech
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */
  _Tech.canPlaySource = function (srcObj, options) {
    var sh = _Tech.selectSourceHandler(srcObj, options);

    if (sh) {
      return sh.canHandleSource(srcObj, options);
    }

    return '';
  };

  /**
   * When using a source handler, prefer its implementation of
   * any function normally provided by the tech.
   */
  var deferrable = ['seekable', 'duration'];

  /**
   * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable
   * function if it exists, with a fallback to the Techs seekable function.
   *
   * @method _Tech.seekable
   */

  /**
   * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration
   * function if it exists, otherwise it will fallback to the techs duration function.
   *
   * @method _Tech.duration
   */

  deferrable.forEach(function (fnName) {
    var originalFn = this[fnName];

    if (typeof originalFn !== 'function') {
      return;
    }

    this[fnName] = function () {
      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
      }
      return originalFn.apply(this, arguments);
    };
  }, _Tech.prototype);

  /**
   * Create a function for setting the source using a source object
   * and source handlers.
   * Should never be called unless a source handler was found.
   *
   * @param {Tech~SourceObject} source
   *        A source object with src and type keys
   */
  _Tech.prototype.setSource = function (source) {
    var sh = _Tech.selectSourceHandler(source, this.options_);

    if (!sh) {
      // Fall back to a native source hander when unsupported sources are
      // deliberately set
      if (_Tech.nativeSourceHandler) {
        sh = _Tech.nativeSourceHandler;
      } else {
        log$1.error('No source hander found for the current source.');
      }
    }

    // Dispose any existing source handler
    this.disposeSourceHandler();
    this.off('dispose', this.disposeSourceHandler);

    if (sh !== _Tech.nativeSourceHandler) {
      this.currentSource_ = source;
    }

    this.sourceHandler_ = sh.handleSource(source, this, this.options_);
    this.on('dispose', this.disposeSourceHandler);
  };

  /**
   * Clean up any existing SourceHandlers and listeners when the Tech is disposed.
   *
   * @listens Tech#dispose
   */
  _Tech.prototype.disposeSourceHandler = function () {
    // if we have a source and get another one
    // then we are loading something new
    // than clear all of our current tracks
    if (this.currentSource_) {
      this.clearTracks(['audio', 'video']);
      this.currentSource_ = null;
    }

    // always clean up auto-text tracks
    this.cleanupAutoTextTracks();

    if (this.sourceHandler_) {

      if (this.sourceHandler_.dispose) {
        this.sourceHandler_.dispose();
      }

      this.sourceHandler_ = null;
    }
  };
};

// The base Tech class needs to be registered as a Component. It is the only
// Tech that can be registered as a Component.
Component.registerComponent('Tech', Tech);
Tech.registerTech('Tech', Tech);

/**
 * A list of techs that should be added to techOrder on Players
 *
 * @private
 */
Tech.defaultTechOrder_ = [];

var middlewares = {};

function use(type, middleware) {
  middlewares[type] = middlewares[type] || [];
  middlewares[type].push(middleware);
}



function setSource(player, src, next) {
  player.setTimeout(function () {
    return setSourceHelper(src, middlewares[src.type], next, player);
  }, 1);
}

function setTech(middleware, tech) {
  middleware.forEach(function (mw) {
    return mw.setTech && mw.setTech(tech);
  });
}

function get$1(middleware, tech, method) {
  return middleware.reduceRight(middlewareIterator(method), tech[method]());
}

function set$1(middleware, tech, method, arg) {
  return tech[method](middleware.reduce(middlewareIterator(method), arg));
}

var allowedGetters = {
  buffered: 1,
  currentTime: 1,
  duration: 1,
  seekable: 1,
  played: 1
};

var allowedSetters = {
  setCurrentTime: 1
};

function middlewareIterator(method) {
  return function (value, mw) {
    if (mw[method]) {
      return mw[method](value);
    }

    return value;
  };
}

function setSourceHelper() {
  var src = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var middleware = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var next = arguments[2];
  var player = arguments[3];
  var acc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  var lastRun = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var mwFactory = middleware[0],
      mwrest = middleware.slice(1);

  // if mwFactory is a string, then we're at a fork in the road

  if (typeof mwFactory === 'string') {
    setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);

    // if we have an mwFactory, call it with the player to get the mw,
    // then call the mw's setSource method
  } else if (mwFactory) {
    var mw = mwFactory(player);

    mw.setSource(assign({}, src), function (err, _src) {

      // something happened, try the next middleware on the current level
      // make sure to use the old src
      if (err) {
        return setSourceHelper(src, mwrest, next, player, acc, lastRun);
      }

      // we've succeeded, now we need to go deeper
      acc.push(mw);

      // if it's the same time, continue does the current chain
      // otherwise, we want to go down the new chain
      setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
    });
  } else if (mwrest.length) {
    setSourceHelper(src, mwrest, next, player, acc, lastRun);
  } else if (lastRun) {
    next(src, acc);
  } else {
    setSourceHelper(src, middlewares['*'], next, player, acc, true);
  }
}

/**
 * @module filter-source
 */
/**
 * Filter out single bad source objects or multiple source objects in an
 * array. Also flattens nested source object arrays into a 1 dimensional
 * array of source objects.
 *
 * @param {Tech~SourceObject|Tech~SourceObject[]} src
 *        The src object to filter
 *
 * @return {Tech~SourceObject[]}
 *         An array of sourceobjects containing only valid sources
 *
 * @private
 */
var filterSource = function filterSource(src) {
  // traverse array
  if (Array.isArray(src)) {
    var newsrc = [];

    src.forEach(function (srcobj) {
      srcobj = filterSource(srcobj);

      if (Array.isArray(srcobj)) {
        newsrc = newsrc.concat(srcobj);
      } else if (isObject(srcobj)) {
        newsrc.push(srcobj);
      }
    });

    src = newsrc;
  } else if (typeof src === 'string' && src.trim()) {
    // convert string into object
    src = [{ src: src }];
  } else if (isObject(src) && typeof src.src === 'string' && src.src && src.src.trim()) {
    // src is already valid
    src = [src];
  } else {
    // invalid source, turn it into an empty array
    src = [];
  }

  return src;
};

/**
 * @file loader.js
 */
/**
 * The `MediaLoader` is the `Component` that decides which playback technology to load
 * when a player is initialized.
 *
 * @extends Component
 */

var MediaLoader = function (_Component) {
  inherits(MediaLoader, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value stroe of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function that is run when this component is ready.
   */
  function MediaLoader(player, options, ready) {
    classCallCheck(this, MediaLoader);

    // MediaLoader has no element
    var options_ = mergeOptions({ createEl: false }, options);

    // If there are no sources when the player is initialized,
    // load the first supported playback technology.

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options_, ready));

    if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
      for (var i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {
        var techName = toTitleCase(j[i]);
        var tech = Tech.getTech(techName);

        // Support old behavior of techs being registered as components.
        // Remove once that deprecated behavior is removed.
        if (!techName) {
          tech = Component.getComponent(techName);
        }

        // Check if the browser supports this technology
        if (tech && tech.isSupported()) {
          player.loadTech_(techName);
          break;
        }
      }
    } else {
      // Loop through playback technologies (HTML5, Flash) and check for support.
      // Then load the best source.
      // A few assumptions here:
      //   All playback technologies respect preload false.
      player.src(options.playerOptions.sources);
    }
    return _this;
  }

  return MediaLoader;
}(Component);

Component.registerComponent('MediaLoader', MediaLoader);

/**
 * @file button.js
 */
/**
 * Clickable Component which is clickable or keyboard actionable,
 * but is not a native HTML button.
 *
 * @extends Component
 */

var ClickableComponent = function (_Component) {
  inherits(ClickableComponent, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function ClickableComponent(player, options) {
    classCallCheck(this, ClickableComponent);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.emitTapEvents();

    _this.enable();
    return _this;
  }

  /**
   * Create the `Component`s DOM element.
   *
   * @param {string} [tag=div]
   *        The element's node type.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  ClickableComponent.prototype.createEl = function createEl$$1() {
    var tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    props = assign({
      innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>',
      className: this.buildCSSClass(),
      tabIndex: 0
    }, props);

    if (tag === 'button') {
      log$1.error('Creating a ClickableComponent with an HTML element of ' + tag + ' is not supported; use a Button instead.');
    }

    // Add ARIA attributes for clickable element which is not a native HTML button
    attributes = assign({
      'role': 'button',

      // let the screen reader user know that the text of the element may change
      'aria-live': 'polite'
    }, attributes);

    this.tabIndex_ = props.tabIndex;

    var el = _Component.prototype.createEl.call(this, tag, props, attributes);

    this.createControlTextEl(el);

    return el;
  };

  /**
   * Create a control text element on this `Component`
   *
   * @param {Element} [el]
   *        Parent element for the control text.
   *
   * @return {Element}
   *         The control text element that gets created.
   */


  ClickableComponent.prototype.createControlTextEl = function createControlTextEl(el) {
    this.controlTextEl_ = createEl('span', {
      className: 'vjs-control-text'
    });

    if (el) {
      el.appendChild(this.controlTextEl_);
    }

    this.controlText(this.controlText_, el);

    return this.controlTextEl_;
  };

  /**
   * Get or set the localize text to use for the controls on the `Component`.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */


  ClickableComponent.prototype.controlText = function controlText(text) {
    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.el();

    if (!text) {
      return this.controlText_ || 'Need Text';
    }

    var localizedText = this.localize(text);

    this.controlText_ = text;
    textContent(this.controlTextEl_, localizedText);
    if (!this.nonIconControl) {
      // Set title attribute if only an icon is shown
      el.setAttribute('title', localizedText);
    }
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ClickableComponent.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-control vjs-button ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Enable this `Component`s element.
   */


  ClickableComponent.prototype.enable = function enable() {
    if (!this.enabled_) {
      this.enabled_ = true;
      this.removeClass('vjs-disabled');
      this.el_.setAttribute('aria-disabled', 'false');
      if (typeof this.tabIndex_ !== 'undefined') {
        this.el_.setAttribute('tabIndex', this.tabIndex_);
      }
      this.on(['tap', 'click'], this.handleClick);
      this.on('focus', this.handleFocus);
      this.on('blur', this.handleBlur);
    }
  };

  /**
   * Disable this `Component`s element.
   */


  ClickableComponent.prototype.disable = function disable() {
    this.enabled_ = false;
    this.addClass('vjs-disabled');
    this.el_.setAttribute('aria-disabled', 'true');
    if (typeof this.tabIndex_ !== 'undefined') {
      this.el_.removeAttribute('tabIndex');
    }
    this.off(['tap', 'click'], this.handleClick);
    this.off('focus', this.handleFocus);
    this.off('blur', this.handleBlur);
  };

  /**
   * This gets called when a `ClickableComponent` gets:
   * - Clicked (via the `click` event, listening starts in the constructor)
   * - Tapped (via the `tap` event, listening starts in the constructor)
   * - The following things happen in order:
   *   1. {@link ClickableComponent#handleFocus} is called via a `focus` event on the
   *      `ClickableComponent`.
   *   2. {@link ClickableComponent#handleFocus} adds a listener for `keydown` on using
   *      {@link ClickableComponent#handleKeyPress}.
   *   3. `ClickableComponent` has not had a `blur` event (`blur` means that focus was lost). The user presses
   *      the space or enter key.
   *   4. {@link ClickableComponent#handleKeyPress} calls this function with the `keydown`
   *      event as a parameter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   * @abstract
   */


  ClickableComponent.prototype.handleClick = function handleClick(event) {};

  /**
   * This gets called when a `ClickableComponent` gains focus via a `focus` event.
   * Turns on listening for `keydown` events. When they happen it
   * calls `this.handleKeyPress`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to be called.
   *
   * @listens focus
   */


  ClickableComponent.prototype.handleFocus = function handleFocus(event) {
    on(document, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Called when this ClickableComponent has focus and a key gets pressed down. By
   * default it will call `this.handleClick` when the key is space or enter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  ClickableComponent.prototype.handleKeyPress = function handleKeyPress(event) {

    // Support Space (32) or Enter (13) key operation to fire a click event
    if (event.which === 32 || event.which === 13) {
      event.preventDefault();
      this.trigger('click');
    } else if (_Component.prototype.handleKeyPress) {

      // Pass keypress handling up for unsupported keys
      _Component.prototype.handleKeyPress.call(this, event);
    }
  };

  /**
   * Called when a `ClickableComponent` loses focus. Turns off the listener for
   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to be called.
   *
   * @listens blur
   */


  ClickableComponent.prototype.handleBlur = function handleBlur(event) {
    off(document, 'keydown', bind(this, this.handleKeyPress));
  };

  return ClickableComponent;
}(Component);

Component.registerComponent('ClickableComponent', ClickableComponent);

/**
 * @file poster-image.js
 */
/**
 * A `ClickableComponent` that handles showing the poster image for the player.
 *
 * @extends ClickableComponent
 */

var PosterImage = function (_ClickableComponent) {
  inherits(PosterImage, _ClickableComponent);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PosterImage(player, options) {
    classCallCheck(this, PosterImage);

    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));

    _this.update();
    player.on('posterchange', bind(_this, _this.update));
    return _this;
  }

  /**
   * Clean up and dispose of the `PosterImage`.
   */


  PosterImage.prototype.dispose = function dispose() {
    this.player().off('posterchange', this.update);
    _ClickableComponent.prototype.dispose.call(this);
  };

  /**
   * Create the `PosterImage`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  PosterImage.prototype.createEl = function createEl$$1() {
    var el = createEl('div', {
      className: 'vjs-poster',

      // Don't want poster to be tabbable.
      tabIndex: -1
    });

    // To ensure the poster image resizes while maintaining its original aspect
    // ratio, use a div with `background-size` when available. For browsers that
    // do not support `background-size` (e.g. IE8), fall back on using a regular
    // img element.
    if (!BACKGROUND_SIZE_SUPPORTED) {
      this.fallbackImg_ = createEl('img');
      el.appendChild(this.fallbackImg_);
    }

    return el;
  };

  /**
   * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.
   *
   * @listens Player#posterchange
   *
   * @param {EventTarget~Event} [event]
   *        The `Player#posterchange` event that triggered this function.
   */


  PosterImage.prototype.update = function update(event) {
    var url = this.player().poster();

    this.setSrc(url);

    // If there's no poster source we should display:none on this component
    // so it's not still clickable or right-clickable
    if (url) {
      this.show();
    } else {
      this.hide();
    }
  };

  /**
   * Set the source of the `PosterImage` depending on the display method.
   *
   * @param {string} url
   *        The URL to the source for the `PosterImage`.
   */


  PosterImage.prototype.setSrc = function setSrc(url) {
    if (this.fallbackImg_) {
      this.fallbackImg_.src = url;
    } else {
      var backgroundImage = '';

      // Any falsey values should stay as an empty string, otherwise
      // this will throw an extra error
      if (url) {
        backgroundImage = 'url("' + url + '")';
      }

      this.el_.style.backgroundImage = backgroundImage;
    }
  };

  /**
   * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See
   * {@link ClickableComponent#handleClick} for instances where this will be triggered.
   *
   * @listens tap
   * @listens click
   * @listens keydown
   *
   * @param {EventTarget~Event} event
   +        The `click`, `tap` or `keydown` event that caused this function to be called.
   */


  PosterImage.prototype.handleClick = function handleClick(event) {
    // We don't want a click to trigger playback when controls are disabled
    if (!this.player_.controls()) {
      return;
    }

    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  return PosterImage;
}(ClickableComponent);

Component.registerComponent('PosterImage', PosterImage);

/**
 * @file text-track-display.js
 */
var darkGray = '#222';
var lightGray = '#ccc';
var fontMap = {
  monospace: 'monospace',
  sansSerif: 'sans-serif',
  serif: 'serif',
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: 'sans-serif',
  proportionalSerif: 'serif',
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};

/**
 * Construct an rgba color from a given hex color code.
 *
 * @param {number} color
 *        Hex number for color, like #f0e.
 *
 * @param {number} opacity
 *        Value for opacity, 0.0 - 1.0.
 *
 * @return {string}
 *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.
 *
 * @private
 */
function constructColor(color, opacity) {
  return 'rgba(' +
  // color looks like "#f0e"
  parseInt(color[1] + color[1], 16) + ',' + parseInt(color[2] + color[2], 16) + ',' + parseInt(color[3] + color[3], 16) + ',' + opacity + ')';
}

/**
 * Try to update the style of a DOM element. Some style changes will throw an error,
 * particularly in IE8. Those should be noops.
 *
 * @param {Element} el
 *        The DOM element to be styled.
 *
 * @param {string} style
 *        The CSS property on the element that should be styled.
 *
 * @param {string} rule
 *        The style rule that should be applied to the property.
 *
 * @private
 */
function tryUpdateStyle(el, style, rule) {
  try {
    el.style[style] = rule;
  } catch (e) {

    // Satisfies linter.
    return;
  }
}

/**
 * The component for displaying text track cues.
 *
 * @extends Component
 */

var TextTrackDisplay = function (_Component) {
  inherits(TextTrackDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when `TextTrackDisplay` is ready.
   */
  function TextTrackDisplay(player, options, ready) {
    classCallCheck(this, TextTrackDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options, ready));

    player.on('loadstart', bind(_this, _this.toggleDisplay));
    player.on('texttrackchange', bind(_this, _this.updateDisplay));
    player.on('loadstart', bind(_this, _this.preselectTrack));

    // This used to be called during player init, but was causing an error
    // if a track should show by default and the display hadn't loaded yet.
    // Should probably be moved to an external track loader when we support
    // tracks that don't need a display.
    player.ready(bind(_this, function () {
      if (player.tech_ && player.tech_.featuresNativeTextTracks) {
        this.hide();
        return;
      }

      player.on('fullscreenchange', bind(this, this.updateDisplay));

      var tracks = this.options_.playerOptions.tracks || [];

      for (var i = 0; i < tracks.length; i++) {
        this.player_.addRemoteTextTrack(tracks[i], true);
      }

      this.preselectTrack();
    }));
    return _this;
  }

  /**
  * Preselect a track following this precedence:
  * - matches the previously selected {@link TextTrack}'s language and kind
  * - matches the previously selected {@link TextTrack}'s language only
  * - is the first default captions track
  * - is the first default descriptions track
  *
  * @listens Player#loadstart
  */


  TextTrackDisplay.prototype.preselectTrack = function preselectTrack() {
    var modes = { captions: 1, subtitles: 1 };
    var trackList = this.player_.textTracks();
    var userPref = this.player_.cache_.selectedLanguage;
    var firstDesc = void 0;
    var firstCaptions = void 0;
    var preferredTrack = void 0;

    for (var i = 0; i < trackList.length; i++) {
      var track = trackList[i];

      if (userPref && userPref.enabled && userPref.language === track.language) {
        // Always choose the track that matches both language and kind
        if (track.kind === userPref.kind) {
          preferredTrack = track;
          // or choose the first track that matches language
        } else if (!preferredTrack) {
          preferredTrack = track;
        }

        // clear everything if offTextTrackMenuItem was clicked
      } else if (userPref && !userPref.enabled) {
        preferredTrack = null;
        firstDesc = null;
        firstCaptions = null;
      } else if (track['default']) {
        if (track.kind === 'descriptions' && !firstDesc) {
          firstDesc = track;
        } else if (track.kind in modes && !firstCaptions) {
          firstCaptions = track;
        }
      }
    }

    // The preferredTrack matches the user preference and takes
    // precendence over all the other tracks.
    // So, display the preferredTrack before the first default track
    // and the subtitles/captions track before the descriptions track
    if (preferredTrack) {
      preferredTrack.mode = 'showing';
    } else if (firstCaptions) {
      firstCaptions.mode = 'showing';
    } else if (firstDesc) {
      firstDesc.mode = 'showing';
    }
  };

  /**
   * Turn display of {@link TextTrack}'s from the current state into the other state.
   * There are only two states:
   * - 'shown'
   * - 'hidden'
   *
   * @listens Player#loadstart
   */


  TextTrackDisplay.prototype.toggleDisplay = function toggleDisplay() {
    if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
      this.hide();
    } else {
      this.show();
    }
  };

  /**
   * Create the {@link Component}'s DOM element.
   *
   * @return {Element}
   *         The element that was created.
   */


  TextTrackDisplay.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-text-track-display'
    }, {
      'aria-live': 'off',
      'aria-atomic': 'true'
    });
  };

  /**
   * Clear all displayed {@link TextTrack}s.
   */


  TextTrackDisplay.prototype.clearDisplay = function clearDisplay() {
    if (typeof window.WebVTT === 'function') {
      window.WebVTT.processCues(window, [], this.el_);
    }
  };

  /**
   * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or
   * a {@link Player#fullscreenchange} is fired.
   *
   * @listens Player#texttrackchange
   * @listens Player#fullscreenchange
   */


  TextTrackDisplay.prototype.updateDisplay = function updateDisplay() {
    var tracks = this.player_.textTracks();

    this.clearDisplay();

    // Track display prioritization model: if multiple tracks are 'showing',
    //  display the first 'subtitles' or 'captions' track which is 'showing',
    //  otherwise display the first 'descriptions' track which is 'showing'

    var descriptionsTrack = null;
    var captionsSubtitlesTrack = null;
    var i = tracks.length;

    while (i--) {
      var track = tracks[i];

      if (track.mode === 'showing') {
        if (track.kind === 'descriptions') {
          descriptionsTrack = track;
        } else {
          captionsSubtitlesTrack = track;
        }
      }
    }

    if (captionsSubtitlesTrack) {
      if (this.getAttribute('aria-live') !== 'off') {
        this.setAttribute('aria-live', 'off');
      }
      this.updateForTrack(captionsSubtitlesTrack);
    } else if (descriptionsTrack) {
      if (this.getAttribute('aria-live') !== 'assertive') {
        this.setAttribute('aria-live', 'assertive');
      }
      this.updateForTrack(descriptionsTrack);
    }
  };

  /**
   * Add an {@link Texttrack} to to the {@link Tech}s {@link TextTrackList}.
   *
   * @param {TextTrack} track
   *        Text track object to be added to the list.
   */


  TextTrackDisplay.prototype.updateForTrack = function updateForTrack(track) {
    if (typeof window.WebVTT !== 'function' || !track.activeCues) {
      return;
    }

    var overrides = this.player_.textTrackSettings.getValues();
    var cues = [];

    for (var _i = 0; _i < track.activeCues.length; _i++) {
      cues.push(track.activeCues[_i]);
    }

    window.WebVTT.processCues(window, cues, this.el_);

    var i = cues.length;

    while (i--) {
      var cue = cues[i];

      if (!cue) {
        continue;
      }

      var cueDiv = cue.displayState;

      if (overrides.color) {
        cueDiv.firstChild.style.color = overrides.color;
      }
      if (overrides.textOpacity) {
        tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));
      }
      if (overrides.backgroundColor) {
        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
      }
      if (overrides.backgroundOpacity) {
        tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));
      }
      if (overrides.windowColor) {
        if (overrides.windowOpacity) {
          tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));
        } else {
          cueDiv.style.backgroundColor = overrides.windowColor;
        }
      }
      if (overrides.edgeStyle) {
        if (overrides.edgeStyle === 'dropshadow') {
          cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;
        } else if (overrides.edgeStyle === 'raised') {
          cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;
        } else if (overrides.edgeStyle === 'depressed') {
          cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;
        } else if (overrides.edgeStyle === 'uniform') {
          cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;
        }
      }
      if (overrides.fontPercent && overrides.fontPercent !== 1) {
        var fontSize = window.parseFloat(cueDiv.style.fontSize);

        cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';
        cueDiv.style.height = 'auto';
        cueDiv.style.top = 'auto';
        cueDiv.style.bottom = '2px';
      }
      if (overrides.fontFamily && overrides.fontFamily !== 'default') {
        if (overrides.fontFamily === 'small-caps') {
          cueDiv.firstChild.style.fontVariant = 'small-caps';
        } else {
          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
        }
      }
    }
  };

  return TextTrackDisplay;
}(Component);

Component.registerComponent('TextTrackDisplay', TextTrackDisplay);

/**
 * @file loading-spinner.js
 */
/**
 * A loading spinner for use during waiting/loading events.
 *
 * @extends Component
 */

var LoadingSpinner = function (_Component) {
  inherits(LoadingSpinner, _Component);

  function LoadingSpinner() {
    classCallCheck(this, LoadingSpinner);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `LoadingSpinner`s DOM element.
   *
   * @return {Element}
   *         The dom element that gets created.
   */
  LoadingSpinner.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-loading-spinner',
      dir: 'ltr'
    });
  };

  return LoadingSpinner;
}(Component);

Component.registerComponent('LoadingSpinner', LoadingSpinner);

/**
 * @file button.js
 */
/**
 * Base class for all buttons.
 *
 * @extends ClickableComponent
 */

var Button = function (_ClickableComponent) {
  inherits(Button, _ClickableComponent);

  function Button() {
    classCallCheck(this, Button);
    return possibleConstructorReturn(this, _ClickableComponent.apply(this, arguments));
  }

  /**
   * Create the `Button`s DOM element.
   *
   * @param {string} [tag="button"]
   *        The element's node type. This argument is IGNORED: no matter what
   *        is passed, it will always create a `button` element.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  Button.prototype.createEl = function createEl(tag) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    tag = 'button';

    props = assign({
      innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>',
      className: this.buildCSSClass()
    }, props);

    // Add attributes for button element
    attributes = assign({

      // Necessary since the default button type is "submit"
      'type': 'button',

      // let the screen reader user know that the text of the button may change
      'aria-live': 'polite'
    }, attributes);

    var el = Component.prototype.createEl.call(this, tag, props, attributes);

    this.createControlTextEl(el);

    return el;
  };

  /**
   * Add a child `Component` inside of this `Button`.
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   *
   * @deprecated since version 5
   */


  Button.prototype.addChild = function addChild(child) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var className = this.constructor.name;

    log$1.warn('Adding an actionable (user controllable) child to a Button (' + className + ') is not supported; use a ClickableComponent instead.');

    // Avoid the error message generated by ClickableComponent's addChild method
    return Component.prototype.addChild.call(this, child, options);
  };

  /**
   * Enable the `Button` element so that it can be activated or clicked. Use this with
   * {@link Button#disable}.
   */


  Button.prototype.enable = function enable() {
    _ClickableComponent.prototype.enable.call(this);
    this.el_.removeAttribute('disabled');
  };

  /**
   * Enable the `Button` element so that it cannot be activated or clicked. Use this with
   * {@link Button#enable}.
   */


  Button.prototype.disable = function disable() {
    _ClickableComponent.prototype.disable.call(this);
    this.el_.setAttribute('disabled', 'disabled');
  };

  /**
   * This gets called when a `Button` has focus and `keydown` is triggered via a key
   * press.
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to get called.
   *
   * @listens keydown
   */


  Button.prototype.handleKeyPress = function handleKeyPress(event) {

    // Ignore Space (32) or Enter (13) key operation, which is handled by the browser for a button.
    if (event.which === 32 || event.which === 13) {
      return;
    }

    // Pass keypress handling up for unsupported keys
    _ClickableComponent.prototype.handleKeyPress.call(this, event);
  };

  return Button;
}(ClickableComponent);

Component.registerComponent('Button', Button);

/**
 * @file big-play-button.js
 */
/**
 * The initial play button that shows before the video has played. The hiding of the
 * `BigPlayButton` get done via CSS and `Player` states.
 *
 * @extends Button
 */

var BigPlayButton = function (_Button) {
  inherits(BigPlayButton, _Button);

  function BigPlayButton(player, options) {
    classCallCheck(this, BigPlayButton);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.mouseused_ = false;

    _this.on('mousedown', _this.handleMouseDown);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.
   */


  BigPlayButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-big-play-button';
  };

  /**
   * This gets called when a `BigPlayButton` "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  BigPlayButton.prototype.handleClick = function handleClick(event) {
    var playPromise = this.player_.play();

    // exit early if clicked via the mouse
    if (this.mouseused_ && event.clientX && event.clientY) {
      return;
    }

    var cb = this.player_.getChild('controlBar');
    var playToggle = cb && cb.getChild('playToggle');

    if (!playToggle) {
      this.player_.focus();
      return;
    }

    var playFocus = function playFocus() {
      return playToggle.focus();
    };

    if (playPromise && playPromise.then) {
      var ignoreRejectedPlayPromise = function ignoreRejectedPlayPromise() {};

      playPromise.then(playFocus, ignoreRejectedPlayPromise);
    } else {
      this.setTimeout(playFocus, 1);
    }
  };

  BigPlayButton.prototype.handleKeyPress = function handleKeyPress(event) {
    this.mouseused_ = false;

    _Button.prototype.handleKeyPress.call(this, event);
  };

  BigPlayButton.prototype.handleMouseDown = function handleMouseDown(event) {
    this.mouseused_ = true;
  };

  return BigPlayButton;
}(Button);

/**
 * The text that should display over the `BigPlayButton`s controls. Added to for localization.
 *
 * @type {string}
 * @private
 */


BigPlayButton.prototype.controlText_ = 'Play Video';

Component.registerComponent('BigPlayButton', BigPlayButton);

/**
 * @file close-button.js
 */
/**
 * The `CloseButton` is a `{@link Button}` that fires a `close` event when
 * it gets clicked.
 *
 * @extends Button
 */

var CloseButton = function (_Button) {
  inherits(CloseButton, _Button);

  /**
   * Creates an instance of the this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function CloseButton(player, options) {
    classCallCheck(this, CloseButton);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.controlText(options && options.controlText || _this.localize('Close'));
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  CloseButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-close-button ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when a `CloseButton` gets clicked. See
   * {@link ClickableComponent#handleClick} for more information on when this will be
   * triggered
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   * @fires CloseButton#close
   */


  CloseButton.prototype.handleClick = function handleClick(event) {

    /**
     * Triggered when the a `CloseButton` is clicked.
     *
     * @event CloseButton#close
     * @type {EventTarget~Event}
     *
     * @property {boolean} [bubbles=false]
     *           set to false so that the close event does not
     *           bubble up to parents if there is no listener
     */
    this.trigger({ type: 'close', bubbles: false });
  };

  return CloseButton;
}(Button);

Component.registerComponent('CloseButton', CloseButton);

/**
 * @file play-toggle.js
 */
/**
 * Button to toggle between play and pause.
 *
 * @extends Button
 */

var PlayToggle = function (_Button) {
  inherits(PlayToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlayToggle(player, options) {
    classCallCheck(this, PlayToggle);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.on(player, 'play', _this.handlePlay);
    _this.on(player, 'pause', _this.handlePause);
    _this.on(player, 'ended', _this.handleEnded);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  PlayToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-play-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when an `PlayToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlayToggle.prototype.handleClick = function handleClick(event) {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  /**
   * Add the vjs-playing class to the element so it can change appearance.
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#play
   */


  PlayToggle.prototype.handlePlay = function handlePlay(event) {
    this.removeClass('vjs-ended');
    this.removeClass('vjs-paused');
    this.addClass('vjs-playing');
    // change the button text to "Pause"
    this.controlText('Pause');
  };

  /**
   * Add the vjs-paused class to the element so it can change appearance.
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#pause
   */


  PlayToggle.prototype.handlePause = function handlePause(event) {
    this.removeClass('vjs-playing');
    this.addClass('vjs-paused');
    // change the button text to "Play"
    this.controlText('Play');
  };

  /**
   * Add the vjs-ended class to the element so it can change appearance
   *
   */


  PlayToggle.prototype.handleEnded = function handleEnded(event) {
    this.removeClass('vjs-playing');
    this.addClass('vjs-ended');
    // change the button text to "Replay"
    this.controlText('Replay');
  };

  return PlayToggle;
}(Button);

/**
 * The text that should display over the `PlayToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlayToggle.prototype.controlText_ = 'Play';

Component.registerComponent('PlayToggle', PlayToggle);

/**
 * @file format-time.js
 * @module Format-time
 */

/**
 * Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in seconds)
 * will force a number of leading zeros to cover the length of the guide.
 *
 * @param {number} seconds
 *        Number of seconds to be turned into a string
 *
 * @param {number} guide
 *        Number (in seconds) to model the string after
 *
 * @return {string}
 *         Time formatted as H:MM:SS or M:SS
 */
function formatTime(seconds) {
  var guide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : seconds;

  seconds = seconds < 0 ? 0 : seconds;
  var s = Math.floor(seconds % 60);
  var m = Math.floor(seconds / 60 % 60);
  var h = Math.floor(seconds / 3600);
  var gm = Math.floor(guide / 60 % 60);
  var gh = Math.floor(guide / 3600);

  // handle invalid times
  if (isNaN(seconds) || seconds === Infinity) {
    // '-' is false for all relational operators (e.g. <, >=) so this setting
    // will add the minimum number of fields specified by the guide
    h = m = s = '-';
  }

  // Check if we need to show hours
  h = h > 0 || gh > 0 ? h + ':' : '';

  // If hours are showing, we may need to add a leading zero.
  // Always show at least one digit of minutes.
  m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';

  // Check if leading zero is need for seconds
  s = s < 10 ? '0' + s : s;

  return h + m + s;
}

/**
 * @file current-time-display.js
 */
/**
 * Displays the current time
 *
 * @extends Component
 */

var CurrentTimeDisplay = function (_Component) {
  inherits(CurrentTimeDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function CurrentTimeDisplay(player, options) {
    classCallCheck(this, CurrentTimeDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);
    _this.on(player, 'timeupdate', _this.throttledUpdateContent);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  CurrentTimeDisplay.prototype.createEl = function createEl$$1() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-current-time vjs-time-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: 'vjs-current-time-display'
    }, {
      // tell screen readers not to automatically read the time as it changes
      'aria-live': 'off'
    }, createEl('span', {
      className: 'vjs-control-text',
      textContent: this.localize('Current Time')
    }));

    this.updateTextNode_();
    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Updates the "current time" text node with new content using the
   * contents of the `formattedTime_` property.
   *
   * @private
   */


  CurrentTimeDisplay.prototype.updateTextNode_ = function updateTextNode_() {
    if (this.textNode_) {
      this.contentEl_.removeChild(this.textNode_);
    }
    this.textNode_ = document.createTextNode(' ' + (this.formattedTime_ || '0:00'));
    this.contentEl_.appendChild(this.textNode_);
  };

  /**
   * Update current time display
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` event that caused this function to run.
   *
   * @listens Player#timeupdate
   */


  CurrentTimeDisplay.prototype.updateContent = function updateContent(event) {
    // Allows for smooth scrubbing, when player can't keep up.
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    var formattedTime = formatTime(time, this.player_.duration());

    if (formattedTime !== this.formattedTime_) {
      this.formattedTime_ = formattedTime;
      this.requestAnimationFrame(this.updateTextNode_);
    }
  };

  return CurrentTimeDisplay;
}(Component);

Component.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);

/**
 * @file duration-display.js
 */
/**
 * Displays the duration
 *
 * @extends Component
 */

var DurationDisplay = function (_Component) {
  inherits(DurationDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function DurationDisplay(player, options) {
    classCallCheck(this, DurationDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);

    _this.on(player, ['durationchange',

    // Also listen for timeupdate and loadedmetadata because removing those
    // listeners could have broken dependent applications/libraries. These
    // can likely be removed for 7.0.
    'loadedmetadata', 'timeupdate'], _this.throttledUpdateContent);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  DurationDisplay.prototype.createEl = function createEl$$1() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-duration vjs-time-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: 'vjs-duration-display'
    }, {
      // tell screen readers not to automatically read the time as it changes
      'aria-live': 'off'
    }, createEl('span', {
      className: 'vjs-control-text',
      textContent: this.localize('Duration Time')
    }));

    this.updateTextNode_();
    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Updates the "current time" text node with new content using the
   * contents of the `formattedTime_` property.
   *
   * @private
   */


  DurationDisplay.prototype.updateTextNode_ = function updateTextNode_() {
    if (this.textNode_) {
      this.contentEl_.removeChild(this.textNode_);
    }
    this.textNode_ = document.createTextNode(' ' + (this.formattedTime_ || '0:00'));
    this.contentEl_.appendChild(this.textNode_);
  };

  /**
   * Update duration time display.
   *
   * @param {EventTarget~Event} [event]
   *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused
   *        this function to be called.
   *
   * @listens Player#durationchange
   * @listens Player#timeupdate
   * @listens Player#loadedmetadata
   */


  DurationDisplay.prototype.updateContent = function updateContent(event) {
    var duration = this.player_.duration();

    if (duration && this.duration_ !== duration) {
      this.duration_ = duration;
      this.formattedTime_ = formatTime(duration);
      this.requestAnimationFrame(this.updateTextNode_);
    }
  };

  return DurationDisplay;
}(Component);

Component.registerComponent('DurationDisplay', DurationDisplay);

/**
 * @file time-divider.js
 */
/**
 * The separator between the current time and duration.
 * Can be hidden if it's not needed in the design.
 *
 * @extends Component
 */

var TimeDivider = function (_Component) {
  inherits(TimeDivider, _Component);

  function TimeDivider() {
    classCallCheck(this, TimeDivider);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  TimeDivider.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-time-control vjs-time-divider',
      innerHTML: '<div><span>/</span></div>'
    });
  };

  return TimeDivider;
}(Component);

Component.registerComponent('TimeDivider', TimeDivider);

/**
 * @file remaining-time-display.js
 */
/**
 * Displays the time left in the video
 *
 * @extends Component
 */

var RemainingTimeDisplay = function (_Component) {
  inherits(RemainingTimeDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function RemainingTimeDisplay(player, options) {
    classCallCheck(this, RemainingTimeDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);
    _this.on(player, ['timeupdate', 'durationchange'], _this.throttledUpdateContent);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  RemainingTimeDisplay.prototype.createEl = function createEl$$1() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-remaining-time vjs-time-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: 'vjs-remaining-time-display'
    }, {
      // tell screen readers not to automatically read the time as it changes
      'aria-live': 'off'
    }, createEl('span', {
      className: 'vjs-control-text',
      textContent: this.localize('Remaining Time')
    }));

    this.updateTextNode_();
    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Updates the "remaining time" text node with new content using the
   * contents of the `formattedTime_` property.
   *
   * @private
   */


  RemainingTimeDisplay.prototype.updateTextNode_ = function updateTextNode_() {
    if (this.textNode_) {
      this.contentEl_.removeChild(this.textNode_);
    }
    this.textNode_ = document.createTextNode(' -' + (this.formattedTime_ || '0:00'));
    this.contentEl_.appendChild(this.textNode_);
  };

  /**
   * Update remaining time display.
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` or `durationchange` event that caused this to run.
   *
   * @listens Player#timeupdate
   * @listens Player#durationchange
   */


  RemainingTimeDisplay.prototype.updateContent = function updateContent(event) {
    if (this.player_.duration()) {
      var formattedTime = formatTime(this.player_.remainingTime());

      if (formattedTime !== this.formattedTime_) {
        this.formattedTime_ = formattedTime;
        this.requestAnimationFrame(this.updateTextNode_);
      }
    }
  };

  return RemainingTimeDisplay;
}(Component);

Component.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);

/**
 * @file live-display.js
 */
// TODO - Future make it click to snap to live

/**
 * Displays the live indicator when duration is Infinity.
 *
 * @extends Component
 */

var LiveDisplay = function (_Component) {
  inherits(LiveDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function LiveDisplay(player, options) {
    classCallCheck(this, LiveDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.updateShowing();
    _this.on(_this.player(), 'durationchange', _this.updateShowing);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  LiveDisplay.prototype.createEl = function createEl$$1() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-live-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: 'vjs-live-display',
      innerHTML: '<span class="vjs-control-text">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE')
    }, {
      'aria-live': 'off'
    });

    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide
   * it accordingly
   *
   * @param {EventTarget~Event} [event]
   *        The {@link Player#durationchange} event that caused this function to run.
   *
   * @listens Player#durationchange
   */


  LiveDisplay.prototype.updateShowing = function updateShowing(event) {
    if (this.player().duration() === Infinity) {
      this.show();
    } else {
      this.hide();
    }
  };

  return LiveDisplay;
}(Component);

Component.registerComponent('LiveDisplay', LiveDisplay);

/**
 * @file slider.js
 */
/**
 * The base functionality for a slider. Can be vertical or horizontal.
 * For instance the volume bar or the seek bar on a video is a slider.
 *
 * @extends Component
 */

var Slider = function (_Component) {
  inherits(Slider, _Component);

  /**
   * Create an instance of this class
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function Slider(player, options) {
    classCallCheck(this, Slider);

    // Set property names to bar to match with the child Slider class is looking for
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.bar = _this.getChild(_this.options_.barName);

    // Set a horizontal or vertical class on the slider depending on the slider type
    _this.vertical(!!_this.options_.vertical);

    _this.on('mousedown', _this.handleMouseDown);
    _this.on('touchstart', _this.handleMouseDown);
    _this.on('focus', _this.handleFocus);
    _this.on('blur', _this.handleBlur);
    _this.on('click', _this.handleClick);

    _this.on(player, 'controlsvisible', _this.update);

    if (_this.playerEvent) {
      _this.on(player, _this.playerEvent, _this.update);
    }
    return _this;
  }

  /**
   * Create the `Button`s DOM element.
   *
   * @param {string} type
   *        Type of element to create.
   *
   * @param {Object} [props={}]
   *        List of properties in Object form.
   *
   * @param {Object} [attributes={}]
   *        list of attributes in Object form.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Slider.prototype.createEl = function createEl$$1(type) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    // Add the slider element class to all sub classes
    props.className = props.className + ' vjs-slider';
    props = assign({
      tabIndex: 0
    }, props);

    attributes = assign({
      'role': 'slider',
      'aria-valuenow': 0,
      'aria-valuemin': 0,
      'aria-valuemax': 100,
      'tabIndex': 0
    }, attributes);

    return _Component.prototype.createEl.call(this, type, props, attributes);
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `Slider`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   * @fires Slider#slideractive
   */


  Slider.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.bar.el_.ownerDocument;

    event.preventDefault();
    blockTextSelection();

    this.addClass('vjs-sliding');
    /**
     * Triggered when the slider is in an active state
     *
     * @event Slider#slideractive
     * @type {EventTarget~Event}
     */
    this.trigger('slideractive');

    this.on(doc, 'mousemove', this.handleMouseMove);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchmove', this.handleMouseMove);
    this.on(doc, 'touchend', this.handleMouseUp);

    this.handleMouseMove(event);
  };

  /**
   * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.
   * The `mousemove` and `touchmove` events will only only trigger this function during
   * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and
   * {@link Slider#handleMouseUp}.
   *
   * @param {EventTarget~Event} event
   *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered
   *        this function
   *
   * @listens mousemove
   * @listens touchmove
   */


  Slider.prototype.handleMouseMove = function handleMouseMove(event) {};

  /**
   * Handle `mouseup` or `touchend` events on the `Slider`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   * @fires Slider#sliderinactive
   */


  Slider.prototype.handleMouseUp = function handleMouseUp() {
    var doc = this.bar.el_.ownerDocument;

    unblockTextSelection();

    this.removeClass('vjs-sliding');
    /**
     * Triggered when the slider is no longer in an active state.
     *
     * @event Slider#sliderinactive
     * @type {EventTarget~Event}
     */
    this.trigger('sliderinactive');

    this.off(doc, 'mousemove', this.handleMouseMove);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchmove', this.handleMouseMove);
    this.off(doc, 'touchend', this.handleMouseUp);

    this.update();
  };

  /**
   * Update the progress bar of the `Slider`.
   *
   * @returns {number}
   *          The percentage of progress the progress bar represents as a
   *          number from 0 to 1.
   */


  Slider.prototype.update = function update() {

    // In VolumeBar init we have a setTimeout for update that pops and update
    // to the end of the execution stack. The player is destroyed before then
    // update will cause an error
    if (!this.el_) {
      return;
    }

    // If scrubbing, we could use a cached value to make the handle keep up
    // with the user's mouse. On HTML5 browsers scrubbing is really smooth, but
    // some flash players are slow, so we might want to utilize this later.
    // var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();
    var progress = this.getPercent();
    var bar = this.bar;

    // If there's no bar...
    if (!bar) {
      return;
    }

    // Protect against no duration and other division issues
    if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {
      progress = 0;
    }

    // Convert to a percentage for setting
    var percentage = (progress * 100).toFixed(2) + '%';
    var style = bar.el().style;

    // Set the new bar width or height
    if (this.vertical()) {
      style.height = percentage;
    } else {
      style.width = percentage;
    }

    return progress;
  };

  /**
   * Calculate distance for slider
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run.
   *
   * @return {number}
   *         The current position of the Slider.
   *         - postition.x for vertical `Slider`s
   *         - postition.y for horizontal `Slider`s
   */


  Slider.prototype.calculateDistance = function calculateDistance(event) {
    var position = getPointerPosition(this.el_, event);

    if (this.vertical()) {
      return position.y;
    }
    return position.x;
  };

  /**
   * Handle a `focus` event on this `Slider`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to run.
   *
   * @listens focus
   */


  Slider.prototype.handleFocus = function handleFocus() {
    this.on(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);
  };

  /**
   * Handle a `keydown` event on the `Slider`. Watches for left, rigth, up, and down
   * arrow keys. This function will only be called when the slider has focus. See
   * {@link Slider#handleFocus} and {@link Slider#handleBlur}.
   *
   * @param {EventTarget~Event} event
   *        the `keydown` event that caused this function to run.
   *
   * @listens keydown
   */


  Slider.prototype.handleKeyPress = function handleKeyPress(event) {
    // Left and Down Arrows
    if (event.which === 37 || event.which === 40) {
      event.preventDefault();
      this.stepBack();

      // Up and Right Arrows
    } else if (event.which === 38 || event.which === 39) {
      event.preventDefault();
      this.stepForward();
    }
  };

  /**
   * Handle a `blur` event on this `Slider`.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to run.
   *
   * @listens blur
   */

  Slider.prototype.handleBlur = function handleBlur() {
    this.off(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);
  };

  /**
   * Listener for click events on slider, used to prevent clicks
   *   from bubbling up to parent elements like button menus.
   *
   * @param {Object} event
   *        Event that caused this object to run
   */


  Slider.prototype.handleClick = function handleClick(event) {
    event.stopImmediatePropagation();
    event.preventDefault();
  };

  /**
   * Get/set if slider is horizontal for vertical
   *
   * @param {boolean} [bool]
   *        - true if slider is vertical,
   *        - false is horizontal
   *
   * @return {boolean}
   *         - true if slider is vertical, and getting
   *         - false if the slider is horizontal, and getting
   */


  Slider.prototype.vertical = function vertical(bool) {
    if (bool === undefined) {
      return this.vertical_ || false;
    }

    this.vertical_ = !!bool;

    if (this.vertical_) {
      this.addClass('vjs-slider-vertical');
    } else {
      this.addClass('vjs-slider-horizontal');
    }
  };

  return Slider;
}(Component);

Component.registerComponent('Slider', Slider);

/**
 * @file load-progress-bar.js
 */
/**
 * Shows loading progress
 *
 * @extends Component
 */

var LoadProgressBar = function (_Component) {
  inherits(LoadProgressBar, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function LoadProgressBar(player, options) {
    classCallCheck(this, LoadProgressBar);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.partEls_ = [];
    _this.on(player, 'progress', _this.update);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  LoadProgressBar.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-load-progress',
      innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
    });
  };

  /**
   * Update progress bar
   *
   * @param {EventTarget~Event} [event]
   *        The `progress` event that caused this function to run.
   *
   * @listens Player#progress
   */


  LoadProgressBar.prototype.update = function update(event) {
    var buffered = this.player_.buffered();
    var duration = this.player_.duration();
    var bufferedEnd = this.player_.bufferedEnd();
    var children = this.partEls_;

    // get the percent width of a time compared to the total end
    var percentify = function percentify(time, end) {
      // no NaN
      var percent = time / end || 0;

      return (percent >= 1 ? 1 : percent) * 100 + '%';
    };

    // update the width of the progress bar
    this.el_.style.width = percentify(bufferedEnd, duration);

    // add child elements to represent the individual buffered time ranges
    for (var i = 0; i < buffered.length; i++) {
      var start = buffered.start(i);
      var end = buffered.end(i);
      var part = children[i];

      if (!part) {
        part = this.el_.appendChild(createEl());
        children[i] = part;
      }

      // set the percent based on the width of the progress bar (bufferedEnd)
      part.style.left = percentify(start, bufferedEnd);
      part.style.width = percentify(end - start, bufferedEnd);
    }

    // remove unused buffered range elements
    for (var _i = children.length; _i > buffered.length; _i--) {
      this.el_.removeChild(children[_i - 1]);
    }
    children.length = buffered.length;
  };

  return LoadProgressBar;
}(Component);

Component.registerComponent('LoadProgressBar', LoadProgressBar);

/**
 * @file time-tooltip.js
 */
/**
 * Time tooltips display a time above the progress bar.
 *
 * @extends Component
 */

var TimeTooltip = function (_Component) {
  inherits(TimeTooltip, _Component);

  function TimeTooltip() {
    classCallCheck(this, TimeTooltip);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the time tooltip DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  TimeTooltip.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-time-tooltip'
    });
  };

  /**
   * Updates the position of the time tooltip relative to the `SeekBar`.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  TimeTooltip.prototype.update = function update(seekBarRect, seekBarPoint, content) {
    var tooltipRect = getBoundingClientRect(this.el_);
    var playerRect = getBoundingClientRect(this.player_.el());
    var seekBarPointPx = seekBarRect.width * seekBarPoint;

    // do nothing if either rect isn't available
    // for example, if the player isn't in the DOM for testing
    if (!playerRect || !tooltipRect) {
      return;
    }

    // This is the space left of the `seekBarPoint` available within the bounds
    // of the player. We calculate any gap between the left edge of the player
    // and the left edge of the `SeekBar` and add the number of pixels in the
    // `SeekBar` before hitting the `seekBarPoint`
    var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;

    // This is the space right of the `seekBarPoint` available within the bounds
    // of the player. We calculate the number of pixels from the `seekBarPoint`
    // to the right edge of the `SeekBar` and add to that any gap between the
    // right edge of the `SeekBar` and the player.
    var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);

    // This is the number of pixels by which the tooltip will need to be pulled
    // further to the right to center it over the `seekBarPoint`.
    var pullTooltipBy = tooltipRect.width / 2;

    // Adjust the `pullTooltipBy` distance to the left or right depending on
    // the results of the space calculations above.
    if (spaceLeftOfPoint < pullTooltipBy) {
      pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
    } else if (spaceRightOfPoint < pullTooltipBy) {
      pullTooltipBy = spaceRightOfPoint;
    }

    // Due to the imprecision of decimal/ratio based calculations and varying
    // rounding behaviors, there are cases where the spacing adjustment is off
    // by a pixel or two. This adds insurance to these calculations.
    if (pullTooltipBy < 0) {
      pullTooltipBy = 0;
    } else if (pullTooltipBy > tooltipRect.width) {
      pullTooltipBy = tooltipRect.width;
    }

    this.el_.style.right = '-' + pullTooltipBy + 'px';
    textContent(this.el_, content);
  };

  return TimeTooltip;
}(Component);

Component.registerComponent('TimeTooltip', TimeTooltip);

/**
 * @file play-progress-bar.js
 */
/**
 * Used by {@link SeekBar} to display media playback progress as part of the
 * {@link ProgressControl}.
 *
 * @extends Component
 */

var PlayProgressBar = function (_Component) {
  inherits(PlayProgressBar, _Component);

  function PlayProgressBar() {
    classCallCheck(this, PlayProgressBar);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */
  PlayProgressBar.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-play-progress vjs-slider-bar',
      innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
    });
  };

  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  PlayProgressBar.prototype.update = function update(seekBarRect, seekBarPoint) {
    var _this2 = this;

    // If there is an existing rAF ID, cancel it so we don't over-queue.
    if (this.rafId_) {
      this.cancelAnimationFrame(this.rafId_);
    }

    this.rafId_ = this.requestAnimationFrame(function () {
      var time = _this2.player_.scrubbing() ? _this2.player_.getCache().currentTime : _this2.player_.currentTime();

      var content = formatTime(time, _this2.player_.duration());
      var timeTooltip = _this2.getChild('timeTooltip');

      if (timeTooltip) {
        timeTooltip.update(seekBarRect, seekBarPoint, content);
      }
    });
  };

  return PlayProgressBar;
}(Component);

/**
 * Default options for {@link PlayProgressBar}.
 *
 * @type {Object}
 * @private
 */


PlayProgressBar.prototype.options_ = {
  children: []
};

// Time tooltips should not be added to a player on mobile devices or IE8
if ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {
  PlayProgressBar.prototype.options_.children.push('timeTooltip');
}

Component.registerComponent('PlayProgressBar', PlayProgressBar);

/**
 * @file mouse-time-display.js
 */
/**
 * The {@link MouseTimeDisplay} component tracks mouse movement over the
 * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}
 * indicating the time which is represented by a given point in the
 * {@link ProgressControl}.
 *
 * @extends Component
 */

var MouseTimeDisplay = function (_Component) {
  inherits(MouseTimeDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function MouseTimeDisplay(player, options) {
    classCallCheck(this, MouseTimeDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.update = throttle(bind(_this, _this.update), 25);
    return _this;
  }

  /**
   * Create the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */


  MouseTimeDisplay.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-mouse-display'
    });
  };

  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  MouseTimeDisplay.prototype.update = function update(seekBarRect, seekBarPoint) {
    var _this2 = this;

    // If there is an existing rAF ID, cancel it so we don't over-queue.
    if (this.rafId_) {
      this.cancelAnimationFrame(this.rafId_);
    }

    this.rafId_ = this.requestAnimationFrame(function () {
      var duration = _this2.player_.duration();
      var content = formatTime(seekBarPoint * duration, duration);

      _this2.el_.style.left = seekBarRect.width * seekBarPoint + 'px';
      _this2.getChild('timeTooltip').update(seekBarRect, seekBarPoint, content);
    });
  };

  return MouseTimeDisplay;
}(Component);

/**
 * Default options for `MouseTimeDisplay`
 *
 * @type {Object}
 * @private
 */


MouseTimeDisplay.prototype.options_ = {
  children: ['timeTooltip']
};

Component.registerComponent('MouseTimeDisplay', MouseTimeDisplay);

/**
 * @file seek-bar.js
 */
// The number of seconds the `step*` functions move the timeline.
var STEP_SECONDS = 5;

/**
 * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}
 * as its `bar`.
 *
 * @extends Slider
 */

var SeekBar = function (_Slider) {
  inherits(SeekBar, _Slider);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function SeekBar(player, options) {
    classCallCheck(this, SeekBar);

    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));

    _this.update = throttle(bind(_this, _this.update), 50);
    _this.on(player, ['timeupdate', 'ended'], _this.update);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  SeekBar.prototype.createEl = function createEl$$1() {
    return _Slider.prototype.createEl.call(this, 'div', {
      className: 'vjs-progress-holder'
    }, {
      'aria-label': this.localize('Progress Bar')
    });
  };

  /**
   * Update the seek bar's UI.
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` or `ended` event that caused this to run.
   *
   * @listens Player#timeupdate
   * @listens Player#ended
   */


  SeekBar.prototype.update = function update() {
    var percent = _Slider.prototype.update.call(this);
    var duration = this.player_.duration();

    // Allows for smooth scrubbing, when player can't keep up.
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();

    // machine readable value of progress bar (percentage complete)
    this.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));

    // human readable value of progress bar (time complete)
    this.el_.setAttribute('aria-valuetext', this.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(time, duration), formatTime(duration, duration)], '{1} of {2}'));

    // Update the `PlayProgressBar`.
    this.bar.update(getBoundingClientRect(this.el_), percent);

    return percent;
  };

  /**
   * Get the percentage of media played so far.
   *
   * @return {number}
   *         The percentage of media played so far (0 to 1).
   */


  SeekBar.prototype.getPercent = function getPercent() {

    // Allows for smooth scrubbing, when player can't keep up.
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();

    var percent = time / this.player_.duration();

    return percent >= 1 ? 1 : percent;
  };

  /**
   * Handle mouse down on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mousedown` event that caused this to run.
   *
   * @listens mousedown
   */


  SeekBar.prototype.handleMouseDown = function handleMouseDown(event) {
    this.player_.scrubbing(true);

    this.videoWasPlaying = !this.player_.paused();
    this.player_.pause();

    _Slider.prototype.handleMouseDown.call(this, event);
  };

  /**
   * Handle mouse move on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this to run.
   *
   * @listens mousemove
   */


  SeekBar.prototype.handleMouseMove = function handleMouseMove(event) {
    var newTime = this.calculateDistance(event) * this.player_.duration();

    // Don't let video end while scrubbing.
    if (newTime === this.player_.duration()) {
      newTime = newTime - 0.1;
    }

    // Set new time (tell player to seek to new time)
    this.player_.currentTime(newTime);
  };

  /**
   * Handle mouse up on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mouseup` event that caused this to run.
   *
   * @listens mouseup
   */


  SeekBar.prototype.handleMouseUp = function handleMouseUp(event) {
    _Slider.prototype.handleMouseUp.call(this, event);

    this.player_.scrubbing(false);
    if (this.videoWasPlaying) {
      this.player_.play();
    }
  };

  /**
   * Move more quickly fast forward for keyboard-only users
   */


  SeekBar.prototype.stepForward = function stepForward() {
    this.player_.currentTime(this.player_.currentTime() + STEP_SECONDS);
  };

  /**
   * Move more quickly rewind for keyboard-only users
   */


  SeekBar.prototype.stepBack = function stepBack() {
    this.player_.currentTime(this.player_.currentTime() - STEP_SECONDS);
  };

  /**
   * Toggles the playback state of the player
   * This gets called when enter or space is used on the seekbar
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called
   *
   */


  SeekBar.prototype.handleAction = function handleAction(event) {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  /**
   * Called when this SeekBar has focus and a key gets pressed down. By
   * default it will call `this.handleAction` when the key is space or enter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  SeekBar.prototype.handleKeyPress = function handleKeyPress(event) {

    // Support Space (32) or Enter (13) key operation to fire a click event
    if (event.which === 32 || event.which === 13) {
      event.preventDefault();
      this.handleAction(event);
    } else if (_Slider.prototype.handleKeyPress) {

      // Pass keypress handling up for unsupported keys
      _Slider.prototype.handleKeyPress.call(this, event);
    }
  };

  return SeekBar;
}(Slider);

/**
 * Default options for the `SeekBar`
 *
 * @type {Object}
 * @private
 */


SeekBar.prototype.options_ = {
  children: ['loadProgressBar', 'playProgressBar'],
  barName: 'playProgressBar'
};

// MouseTimeDisplay tooltips should not be added to a player on mobile devices or IE8
if ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {
  SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');
}

/**
 * Call the update event for this Slider when this event happens on the player.
 *
 * @type {string}
 */
SeekBar.prototype.playerEvent = 'timeupdate';

Component.registerComponent('SeekBar', SeekBar);

/**
 * @file progress-control.js
 */
/**
 * The Progress Control component contains the seek bar, load progress,
 * and play progress.
 *
 * @extends Component
 */

var ProgressControl = function (_Component) {
  inherits(ProgressControl, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function ProgressControl(player, options) {
    classCallCheck(this, ProgressControl);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.handleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);
    _this.on(_this.el_, 'mousemove', _this.handleMouseMove);

    _this.throttledHandleMouseSeek = throttle(bind(_this, _this.handleMouseSeek), 25);
    _this.on(['mousedown', 'touchstart'], _this.handleMouseDown);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  ProgressControl.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-progress-control vjs-control'
    });
  };

  /**
   * When the mouse moves over the `ProgressControl`, the pointer position
   * gets passed down to the `MouseTimeDisplay` component.
   *
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   */


  ProgressControl.prototype.handleMouseMove = function handleMouseMove(event) {
    var seekBar = this.getChild('seekBar');
    var mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');
    var seekBarEl = seekBar.el();
    var seekBarRect = getBoundingClientRect(seekBarEl);
    var seekBarPoint = getPointerPosition(seekBarEl, event).x;

    // The default skin has a gap on either side of the `SeekBar`. This means
    // that it's possible to trigger this behavior outside the boundaries of
    // the `SeekBar`. This ensures we stay within it at all times.
    if (seekBarPoint > 1) {
      seekBarPoint = 1;
    } else if (seekBarPoint < 0) {
      seekBarPoint = 0;
    }

    if (mouseTimeDisplay) {
      mouseTimeDisplay.update(seekBarRect, seekBarPoint);
    }
  };

  /**
   * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.
   *
   * @method ProgressControl#throttledHandleMouseSeek
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   * @listen touchmove
   */

  /**
   * Handle `mousemove` or `touchmove` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousemove
   * @listens touchmove
   */


  ProgressControl.prototype.handleMouseSeek = function handleMouseSeek(event) {
    var seekBar = this.getChild('seekBar');

    seekBar.handleMouseMove(event);
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  ProgressControl.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;

    this.on(doc, 'mousemove', this.throttledHandleMouseSeek);
    this.on(doc, 'touchmove', this.throttledHandleMouseSeek);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mouseup` or `touchend` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */


  ProgressControl.prototype.handleMouseUp = function handleMouseUp(event) {
    var doc = this.el_.ownerDocument;

    this.off(doc, 'mousemove', this.throttledHandleMouseSeek);
    this.off(doc, 'touchmove', this.throttledHandleMouseSeek);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchend', this.handleMouseUp);
  };

  return ProgressControl;
}(Component);

/**
 * Default options for `ProgressControl`
 *
 * @type {Object}
 * @private
 */


ProgressControl.prototype.options_ = {
  children: ['seekBar']
};

Component.registerComponent('ProgressControl', ProgressControl);

/**
 * @file fullscreen-toggle.js
 */
/**
 * Toggle fullscreen video
 *
 * @extends Button
 */

var FullscreenToggle = function (_Button) {
  inherits(FullscreenToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function FullscreenToggle(player, options) {
    classCallCheck(this, FullscreenToggle);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.on(player, 'fullscreenchange', _this.handleFullscreenChange);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  FullscreenToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-fullscreen-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * Handles fullscreenchange on the player and change control text accordingly.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link Player#fullscreenchange} event that caused this function to be
   *        called.
   *
   * @listens Player#fullscreenchange
   */


  FullscreenToggle.prototype.handleFullscreenChange = function handleFullscreenChange(event) {
    if (this.player_.isFullscreen()) {
      this.controlText('Non-Fullscreen');
    } else {
      this.controlText('Fullscreen');
    }
  };

  /**
   * This gets called when an `FullscreenToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  FullscreenToggle.prototype.handleClick = function handleClick(event) {
    if (!this.player_.isFullscreen()) {
      this.player_.requestFullscreen();
    } else {
      this.player_.exitFullscreen();
    }
  };

  return FullscreenToggle;
}(Button);

/**
 * The text that should display over the `FullscreenToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


FullscreenToggle.prototype.controlText_ = 'Fullscreen';

Component.registerComponent('FullscreenToggle', FullscreenToggle);

/**
 * Check if volume control is supported and if it isn't hide the
 * `Component` that was passed  using the `vjs-hidden` class.
 *
 * @param {Component} self
 *        The component that should be hidden if volume is unsupported
 *
 * @param {Player} player
 *        A reference to the player
 *
 * @private
 */
var checkVolumeSupport = function checkVolumeSupport(self, player) {
  // hide volume controls when they're not supported by the current tech
  if (player.tech_ && !player.tech_.featuresVolumeControl) {
    self.addClass('vjs-hidden');
  }

  self.on(player, 'loadstart', function () {
    if (!player.tech_.featuresVolumeControl) {
      self.addClass('vjs-hidden');
    } else {
      self.removeClass('vjs-hidden');
    }
  });
};

/**
 * @file volume-level.js
 */
/**
 * Shows volume level
 *
 * @extends Component
 */

var VolumeLevel = function (_Component) {
  inherits(VolumeLevel, _Component);

  function VolumeLevel() {
    classCallCheck(this, VolumeLevel);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  VolumeLevel.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-level',
      innerHTML: '<span class="vjs-control-text"></span>'
    });
  };

  return VolumeLevel;
}(Component);

Component.registerComponent('VolumeLevel', VolumeLevel);

/**
 * @file volume-bar.js
 */
// Required children
/**
 * The bar that contains the volume level and can be clicked on to adjust the level
 *
 * @extends Slider
 */

var VolumeBar = function (_Slider) {
  inherits(VolumeBar, _Slider);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function VolumeBar(player, options) {
    classCallCheck(this, VolumeBar);

    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));

    _this.on('slideractive', _this.updateLastVolume_);
    _this.on(player, 'volumechange', _this.updateARIAAttributes);
    player.ready(function () {
      return _this.updateARIAAttributes();
    });
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumeBar.prototype.createEl = function createEl() {
    return _Slider.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-bar vjs-slider-bar'
    }, {
      'aria-label': this.localize('Volume Level'),
      'aria-live': 'polite'
    });
  };

  /**
   * Handle movement events on the {@link VolumeMenuButton}.
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run.
   *
   * @listens mousemove
   */


  VolumeBar.prototype.handleMouseMove = function handleMouseMove(event) {
    this.checkMuted();
    this.player_.volume(this.calculateDistance(event));
  };

  /**
   * If the player is muted unmute it.
   */


  VolumeBar.prototype.checkMuted = function checkMuted() {
    if (this.player_.muted()) {
      this.player_.muted(false);
    }
  };

  /**
   * Get percent of volume level
   *
   * @return {number}
   *         Volume level percent as a decimal number.
   */


  VolumeBar.prototype.getPercent = function getPercent() {
    if (this.player_.muted()) {
      return 0;
    }
    return this.player_.volume();
  };

  /**
   * Increase volume level for keyboard users
   */


  VolumeBar.prototype.stepForward = function stepForward() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() + 0.1);
  };

  /**
   * Decrease volume level for keyboard users
   */


  VolumeBar.prototype.stepBack = function stepBack() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() - 0.1);
  };

  /**
   * Update ARIA accessibility attributes
   *
   * @param {EventTarget~Event} [event]
   *        The `volumechange` event that caused this function to run.
   *
   * @listens Player#volumechange
   */


  VolumeBar.prototype.updateARIAAttributes = function updateARIAAttributes(event) {
    var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();

    this.el_.setAttribute('aria-valuenow', ariaValue);
    this.el_.setAttribute('aria-valuetext', ariaValue + '%');
  };

  /**
   * Returns the current value of the player volume as a percentage
   *
   * @private
   */


  VolumeBar.prototype.volumeAsPercentage_ = function volumeAsPercentage_() {
    return Math.round(this.player_.volume() * 100);
  };

  /**
   * When user starts dragging the VolumeBar, store the volume and listen for
   * the end of the drag. When the drag ends, if the volume was set to zero,
   * set lastVolume to the stored volume.
   *
   * @listens slideractive
   * @private
   */


  VolumeBar.prototype.updateLastVolume_ = function updateLastVolume_() {
    var _this2 = this;

    var volumeBeforeDrag = this.player_.volume();

    this.one('sliderinactive', function () {
      if (_this2.player_.volume() === 0) {
        _this2.player_.lastVolume_(volumeBeforeDrag);
      }
    });
  };

  return VolumeBar;
}(Slider);

/**
 * Default options for the `VolumeBar`
 *
 * @type {Object}
 * @private
 */


VolumeBar.prototype.options_ = {
  children: ['volumeLevel'],
  barName: 'volumeLevel'
};

/**
 * Call the update event for this Slider when this event happens on the player.
 *
 * @type {string}
 */
VolumeBar.prototype.playerEvent = 'volumechange';

Component.registerComponent('VolumeBar', VolumeBar);

/**
 * @file volume-control.js
 */
// Required children
/**
 * The component for controlling the volume level
 *
 * @extends Component
 */

var VolumeControl = function (_Component) {
  inherits(VolumeControl, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function VolumeControl(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, VolumeControl);

    options.vertical = options.vertical || false;

    // Pass the vertical option down to the VolumeBar if
    // the VolumeBar is turned on.
    if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {
      options.volumeBar = options.volumeBar || {};
      options.volumeBar.vertical = options.vertical;
    }

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    checkVolumeSupport(_this, player);

    _this.throttledHandleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);

    _this.on('mousedown', _this.handleMouseDown);
    _this.on('touchstart', _this.handleMouseDown);

    // while the slider is active (the mouse has been pressed down and
    // is dragging) or in focus we do not want to hide the VolumeBar
    _this.on(_this.volumeBar, ['focus', 'slideractive'], function () {
      _this.volumeBar.addClass('vjs-slider-active');
      _this.addClass('vjs-slider-active');
      _this.trigger('slideractive');
    });

    _this.on(_this.volumeBar, ['blur', 'sliderinactive'], function () {
      _this.volumeBar.removeClass('vjs-slider-active');
      _this.removeClass('vjs-slider-active');
      _this.trigger('sliderinactive');
    });
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumeControl.prototype.createEl = function createEl() {
    var orientationClass = 'vjs-volume-horizontal';

    if (this.options_.vertical) {
      orientationClass = 'vjs-volume-vertical';
    }

    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-control vjs-control ' + orientationClass
    });
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  VolumeControl.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;

    this.on(doc, 'mousemove', this.throttledHandleMouseMove);
    this.on(doc, 'touchmove', this.throttledHandleMouseMove);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mouseup` or `touchend` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */


  VolumeControl.prototype.handleMouseUp = function handleMouseUp(event) {
    var doc = this.el_.ownerDocument;

    this.off(doc, 'mousemove', this.throttledHandleMouseMove);
    this.off(doc, 'touchmove', this.throttledHandleMouseMove);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  VolumeControl.prototype.handleMouseMove = function handleMouseMove(event) {
    this.volumeBar.handleMouseMove(event);
  };

  return VolumeControl;
}(Component);

/**
 * Default options for the `VolumeControl`
 *
 * @type {Object}
 * @private
 */


VolumeControl.prototype.options_ = {
  children: ['volumeBar']
};

Component.registerComponent('VolumeControl', VolumeControl);

/**
 * @file mute-toggle.js
 */
/**
 * A button component for muting the audio.
 *
 * @extends Button
 */

var MuteToggle = function (_Button) {
  inherits(MuteToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function MuteToggle(player, options) {
    classCallCheck(this, MuteToggle);

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    checkVolumeSupport(_this, player);

    _this.on(player, ['loadstart', 'volumechange'], _this.update);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  MuteToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-mute-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when an `MuteToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MuteToggle.prototype.handleClick = function handleClick(event) {
    var vol = this.player_.volume();
    var lastVolume = this.player_.lastVolume_();

    if (vol === 0) {
      var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;

      this.player_.volume(volumeToSet);
      this.player_.muted(false);
    } else {
      this.player_.muted(this.player_.muted() ? false : true);
    }
  };

  /**
   * Update the `MuteToggle` button based on the state of `volume` and `muted`
   * on the player.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link Player#loadstart} event if this function was called
   *        through an event.
   *
   * @listens Player#loadstart
   * @listens Player#volumechange
   */


  MuteToggle.prototype.update = function update(event) {
    this.updateIcon_();
    this.updateControlText_();
  };

  /**
   * Update the appearance of the `MuteToggle` icon.
   *
   * Possible states (given `level` variable below):
   * - 0: crossed out
   * - 1: zero bars of volume
   * - 2: one bar of volume
   * - 3: two bars of volume
   *
   * @private
   */


  MuteToggle.prototype.updateIcon_ = function updateIcon_() {
    var vol = this.player_.volume();
    var level = 3;

    if (vol === 0 || this.player_.muted()) {
      level = 0;
    } else if (vol < 0.33) {
      level = 1;
    } else if (vol < 0.67) {
      level = 2;
    }

    // TODO improve muted icon classes
    for (var i = 0; i < 4; i++) {
      removeClass(this.el_, 'vjs-vol-' + i);
    }
    addClass(this.el_, 'vjs-vol-' + level);
  };

  /**
   * If `muted` has changed on the player, update the control text
   * (`title` attribute on `vjs-mute-control` element and content of
   * `vjs-control-text` element).
   *
   * @private
   */


  MuteToggle.prototype.updateControlText_ = function updateControlText_() {
    var soundOff = this.player_.muted() || this.player_.volume() === 0;
    var text = soundOff ? 'Unmute' : 'Mute';

    if (this.controlText() !== text) {
      this.controlText(text);
    }
  };

  return MuteToggle;
}(Button);

/**
 * The text that should display over the `MuteToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


MuteToggle.prototype.controlText_ = 'Mute';

Component.registerComponent('MuteToggle', MuteToggle);

/**
 * @file volume-control.js
 */
// Required children
/**
 * A Component to contain the MuteToggle and VolumeControl so that
 * they can work together.
 *
 * @extends Component
 */

var VolumePanel = function (_Component) {
  inherits(VolumePanel, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function VolumePanel(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, VolumePanel);

    if (typeof options.inline !== 'undefined') {
      options.inline = options.inline;
    } else {
      options.inline = true;
    }

    // pass the inline option down to the VolumeControl as vertical if
    // the VolumeControl is on.
    if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {
      options.volumeControl = options.volumeControl || {};
      options.volumeControl.vertical = !options.inline;
    }

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    checkVolumeSupport(_this, player);

    // while the slider is active (the mouse has been pressed down and
    // is dragging) or in focus we do not want to hide the VolumeBar
    _this.on(_this.volumeControl, ['slideractive'], _this.sliderActive_);
    _this.on(_this.muteToggle, 'focus', _this.sliderActive_);

    _this.on(_this.volumeControl, ['sliderinactive'], _this.sliderInactive_);
    _this.on(_this.muteToggle, 'blur', _this.sliderInactive_);
    return _this;
  }

  /**
   * Add vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#slideractive
   * @private
   */


  VolumePanel.prototype.sliderActive_ = function sliderActive_() {
    this.addClass('vjs-slider-active');
  };

  /**
   * Removes vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#sliderinactive
   * @private
   */


  VolumePanel.prototype.sliderInactive_ = function sliderInactive_() {
    this.removeClass('vjs-slider-active');
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumePanel.prototype.createEl = function createEl() {
    var orientationClass = 'vjs-volume-panel-horizontal';

    if (!this.options_.inline) {
      orientationClass = 'vjs-volume-panel-vertical';
    }

    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-panel vjs-control ' + orientationClass
    });
  };

  return VolumePanel;
}(Component);

/**
 * Default options for the `VolumeControl`
 *
 * @type {Object}
 * @private
 */


VolumePanel.prototype.options_ = {
  children: ['muteToggle', 'volumeControl']
};

Component.registerComponent('VolumePanel', VolumePanel);

/**
 * @file menu.js
 */
/**
 * The Menu component is used to build popup menus, including subtitle and
 * captions selection menus.
 *
 * @extends Component
 */

var Menu = function (_Component) {
  inherits(Menu, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        the player that this component should attach to
   *
   * @param {Object} [options]
   *        Object of option names and values
   *
   */
  function Menu(player, options) {
    classCallCheck(this, Menu);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    if (options) {
      _this.menuButton_ = options.menuButton;
    }

    _this.focusedChild_ = -1;

    _this.on('keydown', _this.handleKeyPress);
    return _this;
  }

  /**
   * Add a {@link MenuItem} to the menu.
   *
   * @param {Object|string} component
   *        The name or instance of the `MenuItem` to add.
   *
   */


  Menu.prototype.addItem = function addItem(component) {
    this.addChild(component);
    component.on('click', bind(this, function (event) {
      // Unpress the associated MenuButton, and move focus back to it
      if (this.menuButton_) {
        this.menuButton_.unpressButton();

        // don't focus menu button if item is a caption settings item
        // because focus will move elsewhere and it logs an error on IE8
        if (component.name() !== 'CaptionSettingsMenuItem') {
          this.menuButton_.focus();
        }
      }
    }));
  };

  /**
   * Create the `Menu`s DOM element.
   *
   * @return {Element}
   *         the element that was created
   */


  Menu.prototype.createEl = function createEl$$1() {
    var contentElType = this.options_.contentElType || 'ul';

    this.contentEl_ = createEl(contentElType, {
      className: 'vjs-menu-content'
    });

    this.contentEl_.setAttribute('role', 'menu');

    var el = _Component.prototype.createEl.call(this, 'div', {
      append: this.contentEl_,
      className: 'vjs-menu'
    });

    el.appendChild(this.contentEl_);

    // Prevent clicks from bubbling up. Needed for Menu Buttons,
    // where a click on the parent is significant
    on(el, 'click', function (event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    });

    return el;
  };

  /**
   * Handle a `keydown` event on this menu. This listener is added in the constructor.
   *
   * @param {EventTarget~Event} event
   *        A `keydown` event that happened on the menu.
   *
   * @listens keydown
   */


  Menu.prototype.handleKeyPress = function handleKeyPress(event) {
    // Left and Down Arrows
    if (event.which === 37 || event.which === 40) {
      event.preventDefault();
      this.stepForward();

      // Up and Right Arrows
    } else if (event.which === 38 || event.which === 39) {
      event.preventDefault();
      this.stepBack();
    }
  };

  /**
   * Move to next (lower) menu item for keyboard users.
   */


  Menu.prototype.stepForward = function stepForward() {
    var stepChild = 0;

    if (this.focusedChild_ !== undefined) {
      stepChild = this.focusedChild_ + 1;
    }
    this.focus(stepChild);
  };

  /**
   * Move to previous (higher) menu item for keyboard users.
   */


  Menu.prototype.stepBack = function stepBack() {
    var stepChild = 0;

    if (this.focusedChild_ !== undefined) {
      stepChild = this.focusedChild_ - 1;
    }
    this.focus(stepChild);
  };

  /**
   * Set focus on a {@link MenuItem} in the `Menu`.
   *
   * @param {Object|string} [item=0]
   *        Index of child item set focus on.
   */


  Menu.prototype.focus = function focus() {
    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    var children = this.children().slice();
    var haveTitle = children.length && children[0].className && /vjs-menu-title/.test(children[0].className);

    if (haveTitle) {
      children.shift();
    }

    if (children.length > 0) {
      if (item < 0) {
        item = 0;
      } else if (item >= children.length) {
        item = children.length - 1;
      }

      this.focusedChild_ = item;

      children[item].el_.focus();
    }
  };

  return Menu;
}(Component);

Component.registerComponent('Menu', Menu);

/**
 * @file menu-button.js
 */
/**
 * A `MenuButton` class for any popup {@link Menu}.
 *
 * @extends Component
 */

var MenuButton = function (_Component) {
  inherits(MenuButton, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function MenuButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, MenuButton);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.menuButton_ = new Button(player, options);

    _this.menuButton_.controlText(_this.controlText_);
    _this.menuButton_.el_.setAttribute('aria-haspopup', 'true');

    // Add buildCSSClass values to the button, not the wrapper
    var buttonClass = Button.prototype.buildCSSClass();

    _this.menuButton_.el_.className = _this.buildCSSClass() + ' ' + buttonClass;
    _this.menuButton_.removeClass('vjs-control');

    _this.addChild(_this.menuButton_);

    _this.update();

    _this.enabled_ = true;

    _this.on(_this.menuButton_, 'tap', _this.handleClick);
    _this.on(_this.menuButton_, 'click', _this.handleClick);
    _this.on(_this.menuButton_, 'focus', _this.handleFocus);
    _this.on(_this.menuButton_, 'blur', _this.handleBlur);

    _this.on('keydown', _this.handleSubmenuKeyPress);
    return _this;
  }

  /**
   * Update the menu based on the current state of its items.
   */


  MenuButton.prototype.update = function update() {
    var menu = this.createMenu();

    if (this.menu) {
      this.removeChild(this.menu);
    }

    this.menu = menu;
    this.addChild(menu);

    /**
     * Track the state of the menu button
     *
     * @type {Boolean}
     * @private
     */
    this.buttonPressed_ = false;
    this.menuButton_.el_.setAttribute('aria-expanded', 'false');

    if (this.items && this.items.length <= this.hideThreshold_) {
      this.hide();
    } else {
      this.show();
    }
  };

  /**
   * Create the menu and add all items to it.
   *
   * @return {Menu}
   *         The constructed menu
   */


  MenuButton.prototype.createMenu = function createMenu() {
    var menu = new Menu(this.player_, { menuButton: this });

    /**
     * Hide the menu if the number of items is less than or equal to this threshold. This defaults
     * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list
     * it here because every time we run `createMenu` we need to reset the value.
     *
     * @protected
     * @type {Number}
     */
    this.hideThreshold_ = 0;

    // Add a title list item to the top
    if (this.options_.title) {
      var title = createEl('li', {
        className: 'vjs-menu-title',
        innerHTML: toTitleCase(this.options_.title),
        tabIndex: -1
      });

      this.hideThreshold_ += 1;

      menu.children_.unshift(title);
      prependTo(title, menu.contentEl());
    }

    this.items = this.createItems();

    if (this.items) {
      // Add menu items to the menu
      for (var i = 0; i < this.items.length; i++) {
        menu.addItem(this.items[i]);
      }
    }

    return menu;
  };

  /**
   * Create the list of menu items. Specific to each subclass.
   *
   * @abstract
   */


  MenuButton.prototype.createItems = function createItems() {};

  /**
   * Create the `MenuButtons`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  MenuButton.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildWrapperCSSClass()
    }, {});
  };

  /**
   * Allow sub components to stack CSS class names for the wrapper element
   *
   * @return {string}
   *         The constructed wrapper DOM `className`
   */


  MenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    var menuButtonClass = 'vjs-menu-button';

    // If the inline option is passed, we want to use different styles altogether.
    if (this.options_.inline === true) {
      menuButtonClass += '-inline';
    } else {
      menuButtonClass += '-popup';
    }

    // TODO: Fix the CSS so that this isn't necessary
    var buttonClass = Button.prototype.buildCSSClass();

    return 'vjs-menu-button ' + menuButtonClass + ' ' + buttonClass + ' ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  MenuButton.prototype.buildCSSClass = function buildCSSClass() {
    var menuButtonClass = 'vjs-menu-button';

    // If the inline option is passed, we want to use different styles altogether.
    if (this.options_.inline === true) {
      menuButtonClass += '-inline';
    } else {
      menuButtonClass += '-popup';
    }

    return 'vjs-menu-button ' + menuButtonClass + ' ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Get or set the localized control text that will be used for accessibility.
   *
   * > NOTE: This will come from the internal `menuButton_` element.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.menuButton_.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */


  MenuButton.prototype.controlText = function controlText(text) {
    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.menuButton_.el();

    return this.menuButton_.controlText(text, el);
  };

  /**
   * Handle a click on a `MenuButton`.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MenuButton.prototype.handleClick = function handleClick(event) {
    // When you click the button it adds focus, which will show the menu.
    // So we'll remove focus when the mouse leaves the button. Focus is needed
    // for tab navigation.

    this.one(this.menu.contentEl(), 'mouseleave', bind(this, function (e) {
      this.unpressButton();
      this.el_.blur();
    }));
    if (this.buttonPressed_) {
      this.unpressButton();
    } else {
      this.pressButton();
    }
  };

  /**
   * Set the focus to the actual button, not to this element
   */


  MenuButton.prototype.focus = function focus() {
    this.menuButton_.focus();
  };

  /**
   * Remove the focus from the actual button, not this element
   */


  MenuButton.prototype.blur = function blur() {
    this.menuButton_.blur();
  };

  /**
   * This gets called when a `MenuButton` gains focus via a `focus` event.
   * Turns on listening for `keydown` events. When they happen it
   * calls `this.handleKeyPress`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to be called.
   *
   * @listens focus
   */


  MenuButton.prototype.handleFocus = function handleFocus() {
    on(document, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Called when a `MenuButton` loses focus. Turns off the listener for
   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to be called.
   *
   * @listens blur
   */


  MenuButton.prototype.handleBlur = function handleBlur() {
    off(document, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See
   * {@link ClickableComponent#handleKeyPress} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  MenuButton.prototype.handleKeyPress = function handleKeyPress(event) {

    // Escape (27) key or Tab (9) key unpress the 'button'
    if (event.which === 27 || event.which === 9) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      // Don't preventDefault for Tab key - we still want to lose focus
      if (event.which !== 9) {
        event.preventDefault();
        // Set focus back to the menu button's button
        this.menuButton_.el_.focus();
      }
      // Up (38) key or Down (40) key press the 'button'
    } else if (event.which === 38 || event.which === 40) {
      if (!this.buttonPressed_) {
        this.pressButton();
        event.preventDefault();
      }
    }
  };

  /**
   * Handle a `keydown` event on a sub-menu. The listener for this is added in
   * the constructor.
   *
   * @param {EventTarget~Event} event
   *        Key press event
   *
   * @listens keydown
   */


  MenuButton.prototype.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {

    // Escape (27) key or Tab (9) key unpress the 'button'
    if (event.which === 27 || event.which === 9) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      // Don't preventDefault for Tab key - we still want to lose focus
      if (event.which !== 9) {
        event.preventDefault();
        // Set focus back to the menu button's button
        this.menuButton_.el_.focus();
      }
    }
  };

  /**
   * Put the current `MenuButton` into a pressed state.
   */


  MenuButton.prototype.pressButton = function pressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = true;
      this.menu.lockShowing();
      this.menuButton_.el_.setAttribute('aria-expanded', 'true');
      // set the focus into the submenu
      this.menu.focus();
    }
  };

  /**
   * Take the current `MenuButton` out of a pressed state.
   */


  MenuButton.prototype.unpressButton = function unpressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = false;
      this.menu.unlockShowing();
      this.menuButton_.el_.setAttribute('aria-expanded', 'false');
    }
  };

  /**
   * Disable the `MenuButton`. Don't allow it to be clicked.
   */


  MenuButton.prototype.disable = function disable() {
    this.unpressButton();

    this.enabled_ = false;
    this.addClass('vjs-disabled');

    this.menuButton_.disable();
  };

  /**
   * Enable the `MenuButton`. Allow it to be clicked.
   */


  MenuButton.prototype.enable = function enable() {
    this.enabled_ = true;
    this.removeClass('vjs-disabled');

    this.menuButton_.enable();
  };

  return MenuButton;
}(Component);

Component.registerComponent('MenuButton', MenuButton);

/**
 * @file track-button.js
 */
/**
 * The base class for buttons that toggle specific  track types (e.g. subtitles).
 *
 * @extends MenuButton
 */

var TrackButton = function (_MenuButton) {
  inherits(TrackButton, _MenuButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function TrackButton(player, options) {
    classCallCheck(this, TrackButton);

    var tracks = options.tracks;

    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));

    if (_this.items.length <= 1) {
      _this.hide();
    }

    if (!tracks) {
      return possibleConstructorReturn(_this);
    }

    var updateHandler = bind(_this, _this.update);

    tracks.addEventListener('removetrack', updateHandler);
    tracks.addEventListener('addtrack', updateHandler);
    _this.player_.on('ready', updateHandler);

    _this.player_.on('dispose', function () {
      tracks.removeEventListener('removetrack', updateHandler);
      tracks.removeEventListener('addtrack', updateHandler);
    });
    return _this;
  }

  return TrackButton;
}(MenuButton);

Component.registerComponent('TrackButton', TrackButton);

/**
 * @file menu-item.js
 */
/**
 * The component for a menu item. `<li>`
 *
 * @extends ClickableComponent
 */

var MenuItem = function (_ClickableComponent) {
  inherits(MenuItem, _ClickableComponent);

  /**
   * Creates an instance of the this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   *
   */
  function MenuItem(player, options) {
    classCallCheck(this, MenuItem);

    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));

    _this.selectable = options.selectable;

    _this.selected(options.selected);

    if (_this.selectable) {
      // TODO: May need to be either menuitemcheckbox or menuitemradio,
      //       and may need logical grouping of menu items.
      _this.el_.setAttribute('role', 'menuitemcheckbox');
    } else {
      _this.el_.setAttribute('role', 'menuitem');
    }
    return _this;
  }

  /**
   * Create the `MenuItem's DOM element
   *
   * @param {string} [type=li]
   *        Element's node type, not actually used, always set to `li`.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element
   *
   * @param {Object} [attrs={}]
   *        An object of attributes that should be set on the element
   *
   * @return {Element}
   *         The element that gets created.
   */


  MenuItem.prototype.createEl = function createEl(type, props, attrs) {
    // The control is textual, not just an icon
    this.nonIconControl = true;

    return _ClickableComponent.prototype.createEl.call(this, 'li', assign({
      className: 'vjs-menu-item',
      innerHTML: '<span class="vjs-menu-item-text">' + this.localize(this.options_.label) + '</span>',
      tabIndex: -1
    }, props), attrs);
  };

  /**
   * Any click on a `MenuItem` puts int into the selected state.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MenuItem.prototype.handleClick = function handleClick(event) {
    this.selected(true);
  };

  /**
   * Set the state for this menu item as selected or not.
   *
   * @param {boolean} selected
   *        if the menu item is selected or not
   */


  MenuItem.prototype.selected = function selected(_selected) {
    if (this.selectable) {
      if (_selected) {
        this.addClass('vjs-selected');
        this.el_.setAttribute('aria-checked', 'true');
        // aria-checked isn't fully supported by browsers/screen readers,
        // so indicate selected state to screen reader in the control text.
        this.controlText(', selected');
      } else {
        this.removeClass('vjs-selected');
        this.el_.setAttribute('aria-checked', 'false');
        // Indicate un-selected state to screen reader
        // Note that a space clears out the selected state text
        this.controlText(' ');
      }
    }
  };

  return MenuItem;
}(ClickableComponent);

Component.registerComponent('MenuItem', MenuItem);

/**
 * @file text-track-menu-item.js
 */
/**
 * The specific menu item type for selecting a language within a text track kind
 *
 * @extends MenuItem
 */

var TextTrackMenuItem = function (_MenuItem) {
  inherits(TextTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function TextTrackMenuItem(player, options) {
    classCallCheck(this, TextTrackMenuItem);

    var track = options.track;
    var tracks = player.textTracks();

    // Modify options for parent MenuItem class's init.
    options.label = track.label || track.language || 'Unknown';
    options.selected = track.mode === 'showing';

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;
    var changeHandler = bind(_this, _this.handleTracksChange);
    var selectedLanguageChangeHandler = bind(_this, _this.handleSelectedLanguageChange);

    player.on(['loadstart', 'texttrackchange'], changeHandler);
    tracks.addEventListener('change', changeHandler);
    tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
    _this.on('dispose', function () {
      tracks.removeEventListener('change', changeHandler);
      tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
    });

    // iOS7 doesn't dispatch change events to TextTrackLists when an
    // associated track's mode changes. Without something like
    // Object.observe() (also not present on iOS7), it's not
    // possible to detect changes to the mode attribute and polyfill
    // the change event. As a poor substitute, we manually dispatch
    // change events whenever the controls modify the mode.
    if (tracks.onchange === undefined) {
      var event = void 0;

      _this.on(['tap', 'click'], function () {
        if (_typeof(window.Event) !== 'object') {
          // Android 2.3 throws an Illegal Constructor error for window.Event
          try {
            event = new window.Event('change');
          } catch (err) {
            // continue regardless of error
          }
        }

        if (!event) {
          event = document.createEvent('Event');
          event.initEvent('change', true, true);
        }

        tracks.dispatchEvent(event);
      });
    }
    return _this;
  }

  /**
   * This gets called when an `TextTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  TextTrackMenuItem.prototype.handleClick = function handleClick(event) {
    var kind = this.track.kind;
    var kinds = this.track.kinds;
    var tracks = this.player_.textTracks();

    if (!kinds) {
      kinds = [kind];
    }

    _MenuItem.prototype.handleClick.call(this, event);

    if (!tracks) {
      return;
    }

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      if (track === this.track && kinds.indexOf(track.kind) > -1) {
        if (track.mode !== 'showing') {
          track.mode = 'showing';
        }
      } else if (track.mode !== 'disabled') {
        track.mode = 'disabled';
      }
    }
  };

  /**
   * Handle text track list change
   *
   * @param {EventTarget~Event} event
   *        The `change` event that caused this function to be called.
   *
   * @listens TextTrackList#change
   */


  TextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    this.selected(this.track.mode === 'showing');
  };

  TextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    if (this.track.mode === 'showing') {
      var selectedLanguage = this.player_.cache_.selectedLanguage;

      // Don't replace the kind of track across the same language
      if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
        return;
      }

      this.player_.cache_.selectedLanguage = {
        enabled: true,
        language: this.track.language,
        kind: this.track.kind
      };
    }
  };

  return TextTrackMenuItem;
}(MenuItem);

Component.registerComponent('TextTrackMenuItem', TextTrackMenuItem);

/**
 * @file off-text-track-menu-item.js
 */
/**
 * A special menu item for turning of a specific type of text track
 *
 * @extends TextTrackMenuItem
 */

var OffTextTrackMenuItem = function (_TextTrackMenuItem) {
  inherits(OffTextTrackMenuItem, _TextTrackMenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function OffTextTrackMenuItem(player, options) {
    classCallCheck(this, OffTextTrackMenuItem);

    // Create pseudo track info
    // Requires options['kind']
    options.track = {
      player: player,
      kind: options.kind,
      kinds: options.kinds,
      'default': false,
      mode: 'disabled'
    };

    if (!options.kinds) {
      options.kinds = [options.kind];
    }

    if (options.label) {
      options.track.label = options.label;
    } else {
      options.track.label = options.kinds.join(' and ') + ' off';
    }

    // MenuItem is selectable
    options.selectable = true;

    var _this = possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));

    _this.selected(true);
    return _this;
  }

  /**
   * Handle text track change
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run
   */


  OffTextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var selected = true;

    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {
        selected = false;
        break;
      }
    }

    this.selected(selected);
  };

  OffTextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    var tracks = this.player().textTracks();
    var allHidden = true;

    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {
        allHidden = false;
        break;
      }
    }

    if (allHidden) {
      this.player_.cache_.selectedLanguage = {
        enabled: false
      };
    }
  };

  return OffTextTrackMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);

/**
 * @file text-track-button.js
 */
/**
 * The base class for buttons that toggle specific text track types (e.g. subtitles)
 *
 * @extends MenuButton
 */

var TextTrackButton = function (_TrackButton) {
  inherits(TextTrackButton, _TrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function TextTrackButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, TextTrackButton);

    options.tracks = player.textTracks();

    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));
  }

  /**
   * Create a menu item for each text track
   *
   * @param {TextTrackMenuItem[]} [items=[]]
   *        Existing array of items to use during creation
   *
   * @return {TextTrackMenuItem[]}
   *         Array of menu items that were created
   */


  TextTrackButton.prototype.createItems = function createItems() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var TrackMenuItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TextTrackMenuItem;


    // Label is an overide for the [track] off label
    // USed to localise captions/subtitles
    var label = void 0;

    if (this.label_) {
      label = this.label_ + ' off';
    }
    // Add an OFF menu item to turn all tracks off
    items.push(new OffTextTrackMenuItem(this.player_, {
      kinds: this.kinds_,
      kind: this.kind_,
      label: label
    }));

    this.hideThreshold_ += 1;

    var tracks = this.player_.textTracks();

    if (!Array.isArray(this.kinds_)) {
      this.kinds_ = [this.kind_];
    }

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      // only add tracks that are of an appropriate kind and have a label
      if (this.kinds_.indexOf(track.kind) > -1) {

        var item = new TrackMenuItem(this.player_, {
          track: track,
          // MenuItem is selectable
          selectable: true
        });

        item.addClass('vjs-' + track.kind + '-menu-item');
        items.push(item);
      }
    }

    return items;
  };

  return TextTrackButton;
}(TrackButton);

Component.registerComponent('TextTrackButton', TextTrackButton);

/**
 * @file chapters-track-menu-item.js
 */
/**
 * The chapter track menu item
 *
 * @extends MenuItem
 */

var ChaptersTrackMenuItem = function (_MenuItem) {
  inherits(ChaptersTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function ChaptersTrackMenuItem(player, options) {
    classCallCheck(this, ChaptersTrackMenuItem);

    var track = options.track;
    var cue = options.cue;
    var currentTime = player.currentTime();

    // Modify options for parent MenuItem class's init.
    options.selectable = true;
    options.label = cue.text;
    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;
    _this.cue = cue;
    track.addEventListener('cuechange', bind(_this, _this.update));
    return _this;
  }

  /**
   * This gets called when an `ChaptersTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  ChaptersTrackMenuItem.prototype.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player_.currentTime(this.cue.startTime);
    this.update(this.cue.startTime);
  };

  /**
   * Update chapter menu item
   *
   * @param {EventTarget~Event} [event]
   *        The `cuechange` event that caused this function to run.
   *
   * @listens TextTrack#cuechange
   */


  ChaptersTrackMenuItem.prototype.update = function update(event) {
    var cue = this.cue;
    var currentTime = this.player_.currentTime();

    // vjs.log(currentTime, cue.startTime);
    this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);
  };

  return ChaptersTrackMenuItem;
}(MenuItem);

Component.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);

/**
 * @file chapters-button.js
 */
/**
 * The button component for toggling and selecting chapters
 * Chapters act much differently than other text tracks
 * Cues are navigation vs. other tracks of alternative languages
 *
 * @extends TextTrackButton
 */

var ChaptersButton = function (_TextTrackButton) {
  inherits(ChaptersButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this function is ready.
   */
  function ChaptersButton(player, options, ready) {
    classCallCheck(this, ChaptersButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ChaptersButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  ChaptersButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Update the menu based on the current state of its items.
   *
   * @param {EventTarget~Event} [event]
   *        An event that triggered this function to run.
   *
   * @listens TextTrackList#addtrack
   * @listens TextTrackList#removetrack
   * @listens TextTrackList#change
   */


  ChaptersButton.prototype.update = function update(event) {
    if (!this.track_ || event && (event.type === 'addtrack' || event.type === 'removetrack')) {
      this.setTrack(this.findChaptersTrack());
    }
    _TextTrackButton.prototype.update.call(this);
  };

  /**
   * Set the currently selected track for the chapters button.
   *
   * @param {TextTrack} track
   *        The new track to select. Nothing will change if this is the currently selected
   *        track.
   */


  ChaptersButton.prototype.setTrack = function setTrack(track) {
    if (this.track_ === track) {
      return;
    }

    if (!this.updateHandler_) {
      this.updateHandler_ = this.update.bind(this);
    }

    // here this.track_ refers to the old track instance
    if (this.track_) {
      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);

      if (remoteTextTrackEl) {
        remoteTextTrackEl.removeEventListener('load', this.updateHandler_);
      }

      this.track_ = null;
    }

    this.track_ = track;

    // here this.track_ refers to the new track instance
    if (this.track_) {
      this.track_.mode = 'hidden';

      var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);

      if (_remoteTextTrackEl) {
        _remoteTextTrackEl.addEventListener('load', this.updateHandler_);
      }
    }
  };

  /**
   * Find the track object that is currently in use by this ChaptersButton
   *
   * @return {TextTrack|undefined}
   *         The current track or undefined if none was found.
   */


  ChaptersButton.prototype.findChaptersTrack = function findChaptersTrack() {
    var tracks = this.player_.textTracks() || [];

    for (var i = tracks.length - 1; i >= 0; i--) {
      // We will always choose the last track as our chaptersTrack
      var track = tracks[i];

      if (track.kind === this.kind_) {
        return track;
      }
    }
  };

  /**
   * Get the caption for the ChaptersButton based on the track label. This will also
   * use the current tracks localized kind as a fallback if a label does not exist.
   *
   * @return {string}
   *         The tracks current label or the localized track kind.
   */


  ChaptersButton.prototype.getMenuCaption = function getMenuCaption() {
    if (this.track_ && this.track_.label) {
      return this.track_.label;
    }
    return this.localize(toTitleCase(this.kind_));
  };

  /**
   * Create menu from chapter track
   *
   * @return {Menu}
   *         New menu for the chapter buttons
   */


  ChaptersButton.prototype.createMenu = function createMenu() {
    this.options_.title = this.getMenuCaption();
    return _TextTrackButton.prototype.createMenu.call(this);
  };

  /**
   * Create a menu item for each text track
   *
   * @return {TextTrackMenuItem[]}
   *         Array of menu items
   */


  ChaptersButton.prototype.createItems = function createItems() {
    var items = [];

    if (!this.track_) {
      return items;
    }

    var cues = this.track_.cues;

    if (!cues) {
      return items;
    }

    for (var i = 0, l = cues.length; i < l; i++) {
      var cue = cues[i];
      var mi = new ChaptersTrackMenuItem(this.player_, { track: this.track_, cue: cue });

      items.push(mi);
    }

    return items;
  };

  return ChaptersButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


ChaptersButton.prototype.kind_ = 'chapters';

/**
 * The text that should display over the `ChaptersButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
ChaptersButton.prototype.controlText_ = 'Chapters';

Component.registerComponent('ChaptersButton', ChaptersButton);

/**
 * @file descriptions-button.js
 */
/**
 * The button component for toggling and selecting descriptions
 *
 * @extends TextTrackButton
 */

var DescriptionsButton = function (_TextTrackButton) {
  inherits(DescriptionsButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function DescriptionsButton(player, options, ready) {
    classCallCheck(this, DescriptionsButton);

    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));

    var tracks = player.textTracks();
    var changeHandler = bind(_this, _this.handleTracksChange);

    tracks.addEventListener('change', changeHandler);
    _this.on('dispose', function () {
      tracks.removeEventListener('change', changeHandler);
    });
    return _this;
  }

  /**
   * Handle text track change
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run
   *
   * @listens TextTrackList#change
   */


  DescriptionsButton.prototype.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var disabled = false;

    // Check whether a track of a different kind is showing
    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (track.kind !== this.kind_ && track.mode === 'showing') {
        disabled = true;
        break;
      }
    }

    // If another track is showing, disable this menu button
    if (disabled) {
      this.disable();
    } else {
      this.enable();
    }
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  DescriptionsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  DescriptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  return DescriptionsButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


DescriptionsButton.prototype.kind_ = 'descriptions';

/**
 * The text that should display over the `DescriptionsButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
DescriptionsButton.prototype.controlText_ = 'Descriptions';

Component.registerComponent('DescriptionsButton', DescriptionsButton);

/**
 * @file subtitles-button.js
 */
/**
 * The button component for toggling and selecting subtitles
 *
 * @extends TextTrackButton
 */

var SubtitlesButton = function (_TextTrackButton) {
  inherits(SubtitlesButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function SubtitlesButton(player, options, ready) {
    classCallCheck(this, SubtitlesButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  SubtitlesButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  SubtitlesButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  return SubtitlesButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


SubtitlesButton.prototype.kind_ = 'subtitles';

/**
 * The text that should display over the `SubtitlesButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
SubtitlesButton.prototype.controlText_ = 'Subtitles';

Component.registerComponent('SubtitlesButton', SubtitlesButton);

/**
 * @file caption-settings-menu-item.js
 */
/**
 * The menu item for caption track settings menu
 *
 * @extends TextTrackMenuItem
 */

var CaptionSettingsMenuItem = function (_TextTrackMenuItem) {
  inherits(CaptionSettingsMenuItem, _TextTrackMenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function CaptionSettingsMenuItem(player, options) {
    classCallCheck(this, CaptionSettingsMenuItem);

    options.track = {
      player: player,
      kind: options.kind,
      label: options.kind + ' settings',
      selectable: false,
      'default': false,
      mode: 'disabled'
    };

    // CaptionSettingsMenuItem has no concept of 'selected'
    options.selectable = false;

    options.name = 'CaptionSettingsMenuItem';

    var _this = possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));

    _this.addClass('vjs-texttrack-settings');
    _this.controlText(', opens ' + options.kind + ' settings dialog');
    return _this;
  }

  /**
   * This gets called when an `CaptionSettingsMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  CaptionSettingsMenuItem.prototype.handleClick = function handleClick(event) {
    this.player().getChild('textTrackSettings').open();
  };

  return CaptionSettingsMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);

/**
 * @file captions-button.js
 */
/**
 * The button component for toggling and selecting captions
 *
 * @extends TextTrackButton
 */

var CaptionsButton = function (_TextTrackButton) {
  inherits(CaptionsButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function CaptionsButton(player, options, ready) {
    classCallCheck(this, CaptionsButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  CaptionsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  CaptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create caption menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */


  CaptionsButton.prototype.createItems = function createItems() {
    var items = [];

    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks)) {
      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.kind_ }));

      this.hideThreshold_ += 1;
    }

    return _TextTrackButton.prototype.createItems.call(this, items);
  };

  return CaptionsButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


CaptionsButton.prototype.kind_ = 'captions';

/**
 * The text that should display over the `CaptionsButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
CaptionsButton.prototype.controlText_ = 'Captions';

Component.registerComponent('CaptionsButton', CaptionsButton);

/**
 * @file subs-caps-menu-item.js
 */
/**
 * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles
 * in the SubsCapsMenu.
 *
 * @extends TextTrackMenuItem
 */

var SubsCapsMenuItem = function (_TextTrackMenuItem) {
  inherits(SubsCapsMenuItem, _TextTrackMenuItem);

  function SubsCapsMenuItem() {
    classCallCheck(this, SubsCapsMenuItem);
    return possibleConstructorReturn(this, _TextTrackMenuItem.apply(this, arguments));
  }

  SubsCapsMenuItem.prototype.createEl = function createEl(type, props, attrs) {
    var innerHTML = '<span class="vjs-menu-item-text">' + this.localize(this.options_.label);

    if (this.options_.track.kind === 'captions') {
      innerHTML += '\n        <span aria-hidden="true" class="vjs-icon-placeholder"></span>\n        <span class="vjs-control-text"> ' + this.localize('Captions') + '</span>\n      ';
    }

    innerHTML += '</span>';

    var el = _TextTrackMenuItem.prototype.createEl.call(this, type, assign({
      innerHTML: innerHTML
    }, props), attrs);

    return el;
  };

  return SubsCapsMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);

/**
 * @file sub-caps-button.js
 */
/**
 * The button component for toggling and selecting captions and/or subtitles
 *
 * @extends TextTrackButton
 */

var SubsCapsButton = function (_TextTrackButton) {
  inherits(SubsCapsButton, _TextTrackButton);

  function SubsCapsButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, SubsCapsButton);

    // Although North America uses "captions" in most cases for
    // "captions and subtitles" other locales use "subtitles"
    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options));

    _this.label_ = 'subtitles';
    if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(_this.player_.language_) > -1) {
      _this.label_ = 'captions';
    }
    _this.menuButton_.controlText(toTitleCase(_this.label_));
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  SubsCapsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  SubsCapsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create caption/subtitles menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */


  SubsCapsButton.prototype.createItems = function createItems() {
    var items = [];

    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks)) {
      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.label_ }));

      this.hideThreshold_ += 1;
    }

    items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);
    return items;
  };

  return SubsCapsButton;
}(TextTrackButton);

/**
 * `kind`s of TextTrack to look for to associate it with this menu.
 *
 * @type {array}
 * @private
 */


SubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];

/**
 * The text that should display over the `SubsCapsButton`s controls.
 *
 *
 * @type {string}
 * @private
 */
SubsCapsButton.prototype.controlText_ = 'Subtitles';

Component.registerComponent('SubsCapsButton', SubsCapsButton);

/**
 * @file audio-track-menu-item.js
 */
/**
 * An {@link AudioTrack} {@link MenuItem}
 *
 * @extends MenuItem
 */

var AudioTrackMenuItem = function (_MenuItem) {
  inherits(AudioTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function AudioTrackMenuItem(player, options) {
    classCallCheck(this, AudioTrackMenuItem);

    var track = options.track;
    var tracks = player.audioTracks();

    // Modify options for parent MenuItem class's init.
    options.label = track.label || track.language || 'Unknown';
    options.selected = track.enabled;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;

    var changeHandler = bind(_this, _this.handleTracksChange);

    tracks.addEventListener('change', changeHandler);
    _this.on('dispose', function () {
      tracks.removeEventListener('change', changeHandler);
    });
    return _this;
  }

  /**
   * This gets called when an `AudioTrackMenuItem is "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  AudioTrackMenuItem.prototype.handleClick = function handleClick(event) {
    var tracks = this.player_.audioTracks();

    _MenuItem.prototype.handleClick.call(this, event);

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      track.enabled = track === this.track;
    }
  };

  /**
   * Handle any {@link AudioTrack} change.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link AudioTrackList#change} event that caused this to run.
   *
   * @listens AudioTrackList#change
   */


  AudioTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    this.selected(this.track.enabled);
  };

  return AudioTrackMenuItem;
}(MenuItem);

Component.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);

/**
 * @file audio-track-button.js
 */
/**
 * The base class for buttons that toggle specific {@link AudioTrack} types.
 *
 * @extends TrackButton
 */

var AudioTrackButton = function (_TrackButton) {
  inherits(AudioTrackButton, _TrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function AudioTrackButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, AudioTrackButton);

    options.tracks = player.audioTracks();

    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  AudioTrackButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-audio-button ' + _TrackButton.prototype.buildCSSClass.call(this);
  };

  AudioTrackButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-audio-button ' + _TrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create a menu item for each audio track
   *
   * @param {AudioTrackMenuItem[]} [items=[]]
   *        An array of existing menu items to use.
   *
   * @return {AudioTrackMenuItem[]}
   *         An array of menu items
   */


  AudioTrackButton.prototype.createItems = function createItems() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    // if there's only one audio track, there no point in showing it
    this.hideThreshold_ = 1;

    var tracks = this.player_.audioTracks();

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      items.push(new AudioTrackMenuItem(this.player_, {
        track: track,
        // MenuItem is selectable
        selectable: true
      }));
    }

    return items;
  };

  return AudioTrackButton;
}(TrackButton);

/**
 * The text that should display over the `AudioTrackButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


AudioTrackButton.prototype.controlText_ = 'Audio Track';
Component.registerComponent('AudioTrackButton', AudioTrackButton);

/**
 * @file playback-rate-menu-item.js
 */
/**
 * The specific menu item type for selecting a playback rate.
 *
 * @extends MenuItem
 */

var PlaybackRateMenuItem = function (_MenuItem) {
  inherits(PlaybackRateMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlaybackRateMenuItem(player, options) {
    classCallCheck(this, PlaybackRateMenuItem);

    var label = options.rate;
    var rate = parseFloat(label, 10);

    // Modify options for parent MenuItem class's init.
    options.label = label;
    options.selected = rate === 1;
    options.selectable = true;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.label = label;
    _this.rate = rate;

    _this.on(player, 'ratechange', _this.update);
    return _this;
  }

  /**
   * This gets called when an `PlaybackRateMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlaybackRateMenuItem.prototype.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player().playbackRate(this.rate);
  };

  /**
   * Update the PlaybackRateMenuItem when the playbackrate changes.
   *
   * @param {EventTarget~Event} [event]
   *        The `ratechange` event that caused this function to run.
   *
   * @listens Player#ratechange
   */


  PlaybackRateMenuItem.prototype.update = function update(event) {
    this.selected(this.player().playbackRate() === this.rate);
  };

  return PlaybackRateMenuItem;
}(MenuItem);

/**
 * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlaybackRateMenuItem.prototype.contentElType = 'button';

Component.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);

/**
 * @file playback-rate-menu-button.js
 */
/**
 * The component for controlling the playback rate.
 *
 * @extends MenuButton
 */

var PlaybackRateMenuButton = function (_MenuButton) {
  inherits(PlaybackRateMenuButton, _MenuButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlaybackRateMenuButton(player, options) {
    classCallCheck(this, PlaybackRateMenuButton);

    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));

    _this.updateVisibility();
    _this.updateLabel();

    _this.on(player, 'loadstart', _this.updateVisibility);
    _this.on(player, 'ratechange', _this.updateLabel);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  PlaybackRateMenuButton.prototype.createEl = function createEl$$1() {
    var el = _MenuButton.prototype.createEl.call(this);

    this.labelEl_ = createEl('div', {
      className: 'vjs-playback-rate-value',
      innerHTML: 1.0
    });

    el.appendChild(this.labelEl_);

    return el;
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  PlaybackRateMenuButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-playback-rate ' + _MenuButton.prototype.buildCSSClass.call(this);
  };

  PlaybackRateMenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-playback-rate ' + _MenuButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create the playback rate menu
   *
   * @return {Menu}
   *         Menu object populated with {@link PlaybackRateMenuItem}s
   */


  PlaybackRateMenuButton.prototype.createMenu = function createMenu() {
    var menu = new Menu(this.player());
    var rates = this.playbackRates();

    if (rates) {
      for (var i = rates.length - 1; i >= 0; i--) {
        menu.addChild(new PlaybackRateMenuItem(this.player(), { rate: rates[i] + 'x' }));
      }
    }

    return menu;
  };

  /**
   * Updates ARIA accessibility attributes
   */


  PlaybackRateMenuButton.prototype.updateARIAAttributes = function updateARIAAttributes() {
    // Current playback rate
    this.el().setAttribute('aria-valuenow', this.player().playbackRate());
  };

  /**
   * This gets called when an `PlaybackRateMenuButton` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlaybackRateMenuButton.prototype.handleClick = function handleClick(event) {
    // select next rate option
    var currentRate = this.player().playbackRate();
    var rates = this.playbackRates();

    // this will select first one if the last one currently selected
    var newRate = rates[0];

    for (var i = 0; i < rates.length; i++) {
      if (rates[i] > currentRate) {
        newRate = rates[i];
        break;
      }
    }
    this.player().playbackRate(newRate);
  };

  /**
   * Get possible playback rates
   *
   * @return {Array}
   *         All possible playback rates
   */


  PlaybackRateMenuButton.prototype.playbackRates = function playbackRates() {
    return this.options_.playbackRates || this.options_.playerOptions && this.options_.playerOptions.playbackRates;
  };

  /**
   * Get whether playback rates is supported by the tech
   * and an array of playback rates exists
   *
   * @return {boolean}
   *         Whether changing playback rate is supported
   */


  PlaybackRateMenuButton.prototype.playbackRateSupported = function playbackRateSupported() {
    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
  };

  /**
   * Hide playback rate controls when they're no playback rate options to select
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#loadstart
   */


  PlaybackRateMenuButton.prototype.updateVisibility = function updateVisibility(event) {
    if (this.playbackRateSupported()) {
      this.removeClass('vjs-hidden');
    } else {
      this.addClass('vjs-hidden');
    }
  };

  /**
   * Update button label when rate changed
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#ratechange
   */


  PlaybackRateMenuButton.prototype.updateLabel = function updateLabel(event) {
    if (this.playbackRateSupported()) {
      this.labelEl_.innerHTML = this.player().playbackRate() + 'x';
    }
  };

  return PlaybackRateMenuButton;
}(MenuButton);

/**
 * The text that should display over the `FullscreenToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';

Component.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);

/**
 * @file spacer.js
 */
/**
 * Just an empty spacer element that can be used as an append point for plugins, etc.
 * Also can be used to create space between elements when necessary.
 *
 * @extends Component
 */

var Spacer = function (_Component) {
  inherits(Spacer, _Component);

  function Spacer() {
    classCallCheck(this, Spacer);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  Spacer.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-spacer ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  Spacer.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildCSSClass()
    });
  };

  return Spacer;
}(Component);

Component.registerComponent('Spacer', Spacer);

/**
 * @file custom-control-spacer.js
 */
/**
 * Spacer specifically meant to be used as an insertion point for new plugins, etc.
 *
 * @extends Spacer
 */

var CustomControlSpacer = function (_Spacer) {
  inherits(CustomControlSpacer, _Spacer);

  function CustomControlSpacer() {
    classCallCheck(this, CustomControlSpacer);
    return possibleConstructorReturn(this, _Spacer.apply(this, arguments));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  CustomControlSpacer.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-custom-control-spacer ' + _Spacer.prototype.buildCSSClass.call(this);
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  CustomControlSpacer.prototype.createEl = function createEl() {
    var el = _Spacer.prototype.createEl.call(this, {
      className: this.buildCSSClass()
    });

    // No-flex/table-cell mode requires there be some content
    // in the cell to fill the remaining space of the table.
    el.innerHTML = '&nbsp;';
    return el;
  };

  return CustomControlSpacer;
}(Spacer);

Component.registerComponent('CustomControlSpacer', CustomControlSpacer);

/**
 * @file control-bar.js
 */
// Required children
/**
 * Container of main controls.
 *
 * @extends Component
 */

var ControlBar = function (_Component) {
  inherits(ControlBar, _Component);

  function ControlBar() {
    classCallCheck(this, ControlBar);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  ControlBar.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-control-bar',
      dir: 'ltr'
    }, {
      // The control bar is a group, but we don't aria-label it to avoid
      //  over-announcing by JAWS
      role: 'group'
    });
  };

  return ControlBar;
}(Component);

/**
 * Default options for `ControlBar`
 *
 * @type {Object}
 * @private
 */


ControlBar.prototype.options_ = {
  children: ['playToggle', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'fullscreenToggle']
};

Component.registerComponent('ControlBar', ControlBar);

/**
 * @file error-display.js
 */
/**
 * A display that indicates an error has occurred. This means that the video
 * is unplayable.
 *
 * @extends ModalDialog
 */

var ErrorDisplay = function (_ModalDialog) {
  inherits(ErrorDisplay, _ModalDialog);

  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function ErrorDisplay(player, options) {
    classCallCheck(this, ErrorDisplay);

    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));

    _this.on(player, 'error', _this.open);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   *
   * @deprecated Since version 5.
   */


  ErrorDisplay.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-error-display ' + _ModalDialog.prototype.buildCSSClass.call(this);
  };

  /**
   * Gets the localized error message based on the `Player`s error.
   *
   * @return {string}
   *         The `Player`s error message localized or an empty string.
   */


  ErrorDisplay.prototype.content = function content() {
    var error = this.player().error();

    return error ? this.localize(error.message) : '';
  };

  return ErrorDisplay;
}(ModalDialog);

/**
 * The default options for an `ErrorDisplay`.
 *
 * @private
 */


ErrorDisplay.prototype.options_ = mergeOptions(ModalDialog.prototype.options_, {
  pauseOnOpen: false,
  fillAlways: true,
  temporary: false,
  uncloseable: true
});

Component.registerComponent('ErrorDisplay', ErrorDisplay);

/**
 * @file text-track-settings.js
 */
var LOCAL_STORAGE_KEY = 'vjs-text-track-settings';

var COLOR_BLACK = ['#000', 'Black'];
var COLOR_BLUE = ['#00F', 'Blue'];
var COLOR_CYAN = ['#0FF', 'Cyan'];
var COLOR_GREEN = ['#0F0', 'Green'];
var COLOR_MAGENTA = ['#F0F', 'Magenta'];
var COLOR_RED = ['#F00', 'Red'];
var COLOR_WHITE = ['#FFF', 'White'];
var COLOR_YELLOW = ['#FF0', 'Yellow'];

var OPACITY_OPAQUE = ['1', 'Opaque'];
var OPACITY_SEMI = ['0.5', 'Semi-Transparent'];
var OPACITY_TRANS = ['0', 'Transparent'];

// Configuration for the various <select> elements in the DOM of this component.
//
// Possible keys include:
//
// `default`:
//   The default option index. Only needs to be provided if not zero.
// `parser`:
//   A function which is used to parse the value from the selected option in
//   a customized way.
// `selector`:
//   The selector used to find the associated <select> element.
var selectConfigs = {
  backgroundColor: {
    selector: '.vjs-bg-color > select',
    id: 'captions-background-color-%s',
    label: 'Color',
    options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },

  backgroundOpacity: {
    selector: '.vjs-bg-opacity > select',
    id: 'captions-background-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]
  },

  color: {
    selector: '.vjs-fg-color > select',
    id: 'captions-foreground-color-%s',
    label: 'Color',
    options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },

  edgeStyle: {
    selector: '.vjs-edge-style > select',
    id: '%s',
    label: 'Text Edge Style',
    options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Dropshadow']]
  },

  fontFamily: {
    selector: '.vjs-font-family > select',
    id: 'captions-font-family-%s',
    label: 'Font Family',
    options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]
  },

  fontPercent: {
    selector: '.vjs-font-percent > select',
    id: 'captions-font-size-%s',
    label: 'Font Size',
    options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],
    'default': 2,
    parser: function parser(v) {
      return v === '1.00' ? null : Number(v);
    }
  },

  textOpacity: {
    selector: '.vjs-text-opacity > select',
    id: 'captions-foreground-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_OPAQUE, OPACITY_SEMI]
  },

  // Options for this object are defined below.
  windowColor: {
    selector: '.vjs-window-color > select',
    id: 'captions-window-color-%s',
    label: 'Color'
  },

  // Options for this object are defined below.
  windowOpacity: {
    selector: '.vjs-window-opacity > select',
    id: 'captions-window-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]
  }
};

selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;

/**
 * Get the actual value of an option.
 *
 * @param  {string} value
 *         The value to get
 *
 * @param  {Function} [parser]
 *         Optional function to adjust the value.
 *
 * @return {Mixed}
 *         - Will be `undefined` if no value exists
 *         - Will be `undefined` if the given value is "none".
 *         - Will be the actual value otherwise.
 *
 * @private
 */
function parseOptionValue(value, parser) {
  if (parser) {
    value = parser(value);
  }

  if (value && value !== 'none') {
    return value;
  }
}

/**
 * Gets the value of the selected <option> element within a <select> element.
 *
 * @param  {Element} el
 *         the element to look in
 *
 * @param  {Function} [parser]
 *         Optional function to adjust the value.
 *
 * @return {Mixed}
 *         - Will be `undefined` if no value exists
 *         - Will be `undefined` if the given value is "none".
 *         - Will be the actual value otherwise.
 *
 * @private
 */
function getSelectedOptionValue(el, parser) {
  var value = el.options[el.options.selectedIndex].value;

  return parseOptionValue(value, parser);
}

/**
 * Sets the selected <option> element within a <select> element based on a
 * given value.
 *
 * @param {Element} el
 *        The element to look in.
 *
 * @param {string} value
 *        the property to look on.
 *
 * @param {Function} [parser]
 *        Optional function to adjust the value before comparing.
 *
 * @private
 */
function setSelectedOption(el, value, parser) {
  if (!value) {
    return;
  }

  for (var i = 0; i < el.options.length; i++) {
    if (parseOptionValue(el.options[i].value, parser) === value) {
      el.selectedIndex = i;
      break;
    }
  }
}

/**
 * Manipulate Text Tracks settings.
 *
 * @extends ModalDialog
 */

var TextTrackSettings = function (_ModalDialog) {
  inherits(TextTrackSettings, _ModalDialog);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *         The key/value store of player options.
   */
  function TextTrackSettings(player, options) {
    classCallCheck(this, TextTrackSettings);

    options.temporary = false;

    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));

    _this.updateDisplay = bind(_this, _this.updateDisplay);

    // fill the modal and pretend we have opened it
    _this.fill();
    _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;

    _this.endDialog = createEl('p', {
      className: 'vjs-control-text',
      textContent: _this.localize('End of dialog window.')
    });
    _this.el().appendChild(_this.endDialog);

    _this.setDefaults();

    // Grab `persistTextTrackSettings` from the player options if not passed in child options
    if (options.persistTextTrackSettings === undefined) {
      _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;
    }

    _this.on(_this.$('.vjs-done-button'), 'click', function () {
      _this.saveSettings();
      _this.close();
    });

    _this.on(_this.$('.vjs-default-button'), 'click', function () {
      _this.setDefaults();
      _this.updateDisplay();
    });

    each(selectConfigs, function (config) {
      _this.on(_this.$(config.selector), 'change', _this.updateDisplay);
    });

    if (_this.options_.persistTextTrackSettings) {
      _this.restoreSettings();
    }
    return _this;
  }

  /**
   * Create a <select> element with configured options.
   *
   * @param {string} key
   *        Configuration key to use during creation.
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElSelect_ = function createElSelect_(key) {
    var _this2 = this;

    var legendId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'label';

    var config = selectConfigs[key];
    var id = config.id.replace('%s', this.id_);

    return ['<' + type + ' id="' + id + '" class="' + (type === 'label' ? 'vjs-label' : '') + '">', this.localize(config.label), '</' + type + '>', '<select aria-labelledby="' + legendId + ' ' + id + '">'].concat(config.options.map(function (o) {
      var optionId = id + '-' + o[1];

      return ['<option id="' + optionId + '" value="' + o[0] + '" ', 'aria-labelledby="' + legendId + ' ' + id + ' ' + optionId + '">', _this2.localize(o[1]), '</option>'].join('');
    })).concat('</select>').join('');
  };

  /**
   * Create foreground color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElFgColor_ = function createElFgColor_() {
    var legendId = 'captions-text-legend-' + this.id_;

    return ['<fieldset class="vjs-fg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Text'), '</legend>', this.createElSelect_('color', legendId), '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_('textOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create background color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElBgColor_ = function createElBgColor_() {
    var legendId = 'captions-background-' + this.id_;

    return ['<fieldset class="vjs-bg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Background'), '</legend>', this.createElSelect_('backgroundColor', legendId), '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_('backgroundOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create window color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElWinColor_ = function createElWinColor_() {
    var legendId = 'captions-window-' + this.id_;

    return ['<fieldset class="vjs-window-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Window'), '</legend>', this.createElSelect_('windowColor', legendId), '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_('windowOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create color elements for the component
   *
   * @return {Element}
   *         The element that was created
   *
   * @private
   */


  TextTrackSettings.prototype.createElColors_ = function createElColors_() {
    return createEl('div', {
      className: 'vjs-track-settings-colors',
      innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join('')
    });
  };

  /**
   * Create font elements for the component
   *
   * @return {Element}
   *         The element that was created.
   *
   * @private
   */


  TextTrackSettings.prototype.createElFont_ = function createElFont_() {
    return createEl('div', {
      className: 'vjs-track-settings-font">',
      innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_('fontPercent', '', 'legend'), '</fieldset>', '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_('edgeStyle', '', 'legend'), '</fieldset>', '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_('fontFamily', '', 'legend'), '</fieldset>'].join('')
    });
  };

  /**
   * Create controls for the component
   *
   * @return {Element}
   *         The element that was created.
   *
   * @private
   */


  TextTrackSettings.prototype.createElControls_ = function createElControls_() {
    var defaultsDescription = this.localize('restore all settings to the default values');

    return createEl('div', {
      className: 'vjs-track-settings-controls',
      innerHTML: ['<button class="vjs-default-button" title="' + defaultsDescription + '">', this.localize('Reset'), '<span class="vjs-control-text"> ' + defaultsDescription + '</span>', '</button>', '<button class="vjs-done-button">' + this.localize('Done') + '</button>'].join('')
    });
  };

  TextTrackSettings.prototype.content = function content() {
    return [this.createElColors_(), this.createElFont_(), this.createElControls_()];
  };

  TextTrackSettings.prototype.label = function label() {
    return this.localize('Caption Settings Dialog');
  };

  TextTrackSettings.prototype.description = function description() {
    return this.localize('Beginning of dialog window. Escape will cancel and close the window.');
  };

  TextTrackSettings.prototype.buildCSSClass = function buildCSSClass() {
    return _ModalDialog.prototype.buildCSSClass.call(this) + ' vjs-text-track-settings';
  };

  /**
   * Gets an object of text track settings (or null).
   *
   * @return {Object}
   *         An object with config values parsed from the DOM or localStorage.
   */


  TextTrackSettings.prototype.getValues = function getValues() {
    var _this3 = this;

    return reduce(selectConfigs, function (accum, config, key) {
      var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);

      if (value !== undefined) {
        accum[key] = value;
      }

      return accum;
    }, {});
  };

  /**
   * Sets text track settings from an object of values.
   *
   * @param {Object} values
   *        An object with config values parsed from the DOM or localStorage.
   */


  TextTrackSettings.prototype.setValues = function setValues(values) {
    var _this4 = this;

    each(selectConfigs, function (config, key) {
      setSelectedOption(_this4.$(config.selector), values[key], config.parser);
    });
  };

  /**
   * Sets all `<select>` elements to their default values.
   */


  TextTrackSettings.prototype.setDefaults = function setDefaults() {
    var _this5 = this;

    each(selectConfigs, function (config) {
      var index = config.hasOwnProperty('default') ? config['default'] : 0;

      _this5.$(config.selector).selectedIndex = index;
    });
  };

  /**
   * Restore texttrack settings from localStorage
   */


  TextTrackSettings.prototype.restoreSettings = function restoreSettings() {
    var values = void 0;

    try {
      values = JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY));
    } catch (err) {
      log$1.warn(err);
    }

    if (values) {
      this.setValues(values);
    }
  };

  /**
   * Save text track settings to localStorage
   */


  TextTrackSettings.prototype.saveSettings = function saveSettings() {
    if (!this.options_.persistTextTrackSettings) {
      return;
    }

    var values = this.getValues();

    try {
      if (Object.keys(values).length) {
        window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(values));
      } else {
        window.localStorage.removeItem(LOCAL_STORAGE_KEY);
      }
    } catch (err) {
      log$1.warn(err);
    }
  };

  /**
   * Update display of text track settings
   */


  TextTrackSettings.prototype.updateDisplay = function updateDisplay() {
    var ttDisplay = this.player_.getChild('textTrackDisplay');

    if (ttDisplay) {
      ttDisplay.updateDisplay();
    }
  };

  /**
   * conditionally blur the element and refocus the captions button
   *
   * @private
   */


  TextTrackSettings.prototype.conditionalBlur_ = function conditionalBlur_() {
    this.previouslyActiveEl_ = null;
    this.off(document, 'keydown', this.handleKeyDown);

    var cb = this.player_.controlBar;
    var subsCapsBtn = cb && cb.subsCapsButton;
    var ccBtn = cb && cb.captionsButton;

    if (subsCapsBtn) {
      subsCapsBtn.focus();
    } else if (ccBtn) {
      ccBtn.focus();
    }
  };

  return TextTrackSettings;
}(ModalDialog);

Component.registerComponent('TextTrackSettings', TextTrackSettings);

var _templateObject$2 = taggedTemplateLiteralLoose(['Text Tracks are being loaded from another origin but the crossorigin attribute isn\'t used.\n            This may prevent text tracks from loading.'], ['Text Tracks are being loaded from another origin but the crossorigin attribute isn\'t used.\n            This may prevent text tracks from loading.']);

/**
 * @file html5.js
 */
/**
 * HTML5 Media Controller - Wrapper for HTML5 Media API
 *
 * @mixes Tech~SouceHandlerAdditions
 * @extends Tech
 */

var Html5 = function (_Tech) {
  inherits(Html5, _Tech);

  /**
   * Create an instance of this Tech.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} ready
   *        Callback function to call when the `HTML5` Tech is ready.
   */
  function Html5(options, ready) {
    classCallCheck(this, Html5);

    var _this = possibleConstructorReturn(this, _Tech.call(this, options, ready));

    var source = options.source;
    var crossoriginTracks = false;

    // Set the source if one is provided
    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
    // anyway so the error gets fired.
    if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
      _this.setSource(source);
    } else {
      _this.handleLateInit_(_this.el_);
    }

    if (_this.el_.hasChildNodes()) {

      var nodes = _this.el_.childNodes;
      var nodesLength = nodes.length;
      var removeNodes = [];

      while (nodesLength--) {
        var node = nodes[nodesLength];
        var nodeName = node.nodeName.toLowerCase();

        if (nodeName === 'track') {
          if (!_this.featuresNativeTextTracks) {
            // Empty video tag tracks so the built-in player doesn't use them also.
            // This may not be fast enough to stop HTML5 browsers from reading the tags
            // so we'll need to turn off any default tracks if we're manually doing
            // captions and subtitles. videoElement.textTracks
            removeNodes.push(node);
          } else {
            // store HTMLTrackElement and TextTrack to remote list
            _this.remoteTextTrackEls().addTrackElement_(node);
            _this.remoteTextTracks().addTrack(node.track);
            _this.textTracks().addTrack(node.track);
            if (!crossoriginTracks && !_this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {
              crossoriginTracks = true;
            }
          }
        }
      }

      for (var i = 0; i < removeNodes.length; i++) {
        _this.el_.removeChild(removeNodes[i]);
      }
    }

    _this.proxyNativeTracks_();
    if (_this.featuresNativeTextTracks && crossoriginTracks) {
      log$1.warn(tsml(_templateObject$2));
    }

    // Determine if native controls should be used
    // Our goal should be to get the custom controls on mobile solid everywhere
    // so we can remove this all together. Right now this will block custom
    // controls on touch enabled laptops like the Chrome Pixel
    if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {
      _this.setControls(true);
    }

    // on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`
    // into a `fullscreenchange` event
    _this.proxyWebkitFullscreen_();

    _this.triggerReady();
    return _this;
  }

  /**
   * Dispose of `HTML5` media element and remove all tracks.
   */


  Html5.prototype.dispose = function dispose() {
    Html5.disposeMediaElement(this.el_);
    // tech will handle clearing of the emulated track list
    _Tech.prototype.dispose.call(this);
  };

  /**
   * Proxy all native track list events to our track lists if the browser we are playing
   * in supports that type of track list.
   *
   * @private
   */


  Html5.prototype.proxyNativeTracks_ = function proxyNativeTracks_() {
    var _this2 = this;

    NORMAL.names.forEach(function (name) {
      var props = NORMAL[name];
      var elTracks = _this2.el()[props.getterName];
      var techTracks = _this2[props.getterName]();

      if (!_this2['featuresNative' + props.capitalName + 'Tracks'] || !elTracks || !elTracks.addEventListener) {
        return;
      }
      var listeners = {
        change: function change(e) {
          techTracks.trigger({
            type: 'change',
            target: techTracks,
            currentTarget: techTracks,
            srcElement: techTracks
          });
        },
        addtrack: function addtrack(e) {
          techTracks.addTrack(e.track);
        },
        removetrack: function removetrack(e) {
          techTracks.removeTrack(e.track);
        }
      };
      var removeOldTracks = function removeOldTracks() {
        var removeTracks = [];

        for (var i = 0; i < techTracks.length; i++) {
          var found = false;

          for (var j = 0; j < elTracks.length; j++) {
            if (elTracks[j] === techTracks[i]) {
              found = true;
              break;
            }
          }

          if (!found) {
            removeTracks.push(techTracks[i]);
          }
        }

        while (removeTracks.length) {
          techTracks.removeTrack(removeTracks.shift());
        }
      };

      Object.keys(listeners).forEach(function (eventName) {
        var listener = listeners[eventName];

        elTracks.addEventListener(eventName, listener);
        _this2.on('dispose', function (e) {
          return elTracks.removeEventListener(eventName, listener);
        });
      });

      // Remove (native) tracks that are not used anymore
      _this2.on('loadstart', removeOldTracks);
      _this2.on('dispose', function (e) {
        return _this2.off('loadstart', removeOldTracks);
      });
    });
  };

  /**
   * Create the `Html5` Tech's DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Html5.prototype.createEl = function createEl$$1() {
    var el = this.options_.tag;

    // Check if this browser supports moving the element into the box.
    // On the iPhone video will break if you move the element,
    // So we have to create a brand new element.
    // If we ingested the player div, we do not need to move the media element.
    if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {

      // If the original tag is still there, clone and remove it.
      if (el) {
        var clone = el.cloneNode(true);

        if (el.parentNode) {
          el.parentNode.insertBefore(clone, el);
        }
        Html5.disposeMediaElement(el);
        el = clone;
      } else {
        el = document.createElement('video');

        // determine if native controls should be used
        var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
        var attributes = mergeOptions({}, tagAttributes);

        if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
          delete attributes.controls;
        }

        setAttributes(el, assign(attributes, {
          id: this.options_.techId,
          'class': 'vjs-tech'
        }));
      }

      el.playerId = this.options_.playerId;
    }

    // Update specific tag settings, in case they were overridden
    var settingsAttrs = ['autoplay', 'preload', 'loop', 'muted', 'playsinline'];

    for (var i = settingsAttrs.length - 1; i >= 0; i--) {
      var attr = settingsAttrs[i];
      var overwriteAttrs = {};

      if (typeof this.options_[attr] !== 'undefined') {
        overwriteAttrs[attr] = this.options_[attr];
      }
      setAttributes(el, overwriteAttrs);
    }

    return el;
  };

  /**
   * This will be triggered if the loadstart event has already fired, before videojs was
   * ready. Two known examples of when this can happen are:
   * 1. If we're loading the playback object after it has started loading
   * 2. The media is already playing the (often with autoplay on) then
   *
   * This function will fire another loadstart so that videojs can catchup.
   *
   * @fires Tech#loadstart
   *
   * @return {undefined}
   *         returns nothing.
   */


  Html5.prototype.handleLateInit_ = function handleLateInit_(el) {
    if (el.networkState === 0 || el.networkState === 3) {
      // The video element hasn't started loading the source yet
      // or didn't find a source
      return;
    }

    if (el.readyState === 0) {
      // NetworkState is set synchronously BUT loadstart is fired at the
      // end of the current stack, usually before setInterval(fn, 0).
      // So at this point we know loadstart may have already fired or is
      // about to fire, and either way the player hasn't seen it yet.
      // We don't want to fire loadstart prematurely here and cause a
      // double loadstart so we'll wait and see if it happens between now
      // and the next loop, and fire it if not.
      // HOWEVER, we also want to make sure it fires before loadedmetadata
      // which could also happen between now and the next loop, so we'll
      // watch for that also.
      var loadstartFired = false;
      var setLoadstartFired = function setLoadstartFired() {
        loadstartFired = true;
      };

      this.on('loadstart', setLoadstartFired);

      var triggerLoadstart = function triggerLoadstart() {
        // We did miss the original loadstart. Make sure the player
        // sees loadstart before loadedmetadata
        if (!loadstartFired) {
          this.trigger('loadstart');
        }
      };

      this.on('loadedmetadata', triggerLoadstart);

      this.ready(function () {
        this.off('loadstart', setLoadstartFired);
        this.off('loadedmetadata', triggerLoadstart);

        if (!loadstartFired) {
          // We did miss the original native loadstart. Fire it now.
          this.trigger('loadstart');
        }
      });

      return;
    }

    // From here on we know that loadstart already fired and we missed it.
    // The other readyState events aren't as much of a problem if we double
    // them, so not going to go to as much trouble as loadstart to prevent
    // that unless we find reason to.
    var eventsToTrigger = ['loadstart'];

    // loadedmetadata: newly equal to HAVE_METADATA (1) or greater
    eventsToTrigger.push('loadedmetadata');

    // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater
    if (el.readyState >= 2) {
      eventsToTrigger.push('loadeddata');
    }

    // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater
    if (el.readyState >= 3) {
      eventsToTrigger.push('canplay');
    }

    // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)
    if (el.readyState >= 4) {
      eventsToTrigger.push('canplaythrough');
    }

    // We still need to give the player time to add event listeners
    this.ready(function () {
      eventsToTrigger.forEach(function (type) {
        this.trigger(type);
      }, this);
    });
  };

  /**
   * Set current time for the `HTML5` tech.
   *
   * @param {number} seconds
   *        Set the current time of the media to this.
   */


  Html5.prototype.setCurrentTime = function setCurrentTime(seconds) {
    try {
      this.el_.currentTime = seconds;
    } catch (e) {
      log$1(e, 'Video is not ready. (Video.js)');
      // this.warning(VideoJS.warnings.videoNotReady);
    }
  };

  /**
   * Get the current duration of the HTML5 media element.
   *
   * @return {number}
   *         The duration of the media or 0 if there is no duration.
   */


  Html5.prototype.duration = function duration() {
    var _this3 = this;

    // Android Chrome will report duration as Infinity for VOD HLS until after
    // playback has started, which triggers the live display erroneously.
    // Return NaN if playback has not started and trigger a durationupdate once
    // the duration can be reliably known.
    if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
      // Wait for the first `timeupdate` with currentTime > 0 - there may be
      // several with 0
      var checkProgress = function checkProgress() {
        if (_this3.el_.currentTime > 0) {
          // Trigger durationchange for genuinely live video
          if (_this3.el_.duration === Infinity) {
            _this3.trigger('durationchange');
          }
          _this3.off('timeupdate', checkProgress);
        }
      };

      this.on('timeupdate', checkProgress);
      return NaN;
    }
    return this.el_.duration || NaN;
  };

  /**
   * Get the current width of the HTML5 media element.
   *
   * @return {number}
   *         The width of the HTML5 media element.
   */


  Html5.prototype.width = function width() {
    return this.el_.offsetWidth;
  };

  /**
   * Get the current height of the HTML5 media element.
   *
   * @return {number}
   *         The heigth of the HTML5 media element.
   */


  Html5.prototype.height = function height() {
    return this.el_.offsetHeight;
  };

  /**
   * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into
   * `fullscreenchange` event.
   *
   * @private
   * @fires fullscreenchange
   * @listens webkitendfullscreen
   * @listens webkitbeginfullscreen
   * @listens webkitbeginfullscreen
   */


  Html5.prototype.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {
    var _this4 = this;

    if (!('webkitDisplayingFullscreen' in this.el_)) {
      return;
    }

    var endFn = function endFn() {
      this.trigger('fullscreenchange', { isFullscreen: false });
    };

    var beginFn = function beginFn() {
      if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {
        this.one('webkitendfullscreen', endFn);

        this.trigger('fullscreenchange', { isFullscreen: true });
      }
    };

    this.on('webkitbeginfullscreen', beginFn);
    this.on('dispose', function () {
      _this4.off('webkitbeginfullscreen', beginFn);
      _this4.off('webkitendfullscreen', endFn);
    });
  };

  /**
   * Check if fullscreen is supported on the current playback device.
   *
   * @return {boolean}
   *         - True if fullscreen is supported.
   *         - False if fullscreen is not supported.
   */


  Html5.prototype.supportsFullScreen = function supportsFullScreen() {
    if (typeof this.el_.webkitEnterFullScreen === 'function') {
      var userAgent = window.navigator && window.navigator.userAgent || '';

      // Seems to be broken in Chromium/Chrome && Safari in Leopard
      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Request that the `HTML5` Tech enter fullscreen.
   */


  Html5.prototype.enterFullScreen = function enterFullScreen() {
    var video = this.el_;

    if (video.paused && video.networkState <= video.HAVE_METADATA) {
      // attempt to prime the video element for programmatic access
      // this isn't necessary on the desktop but shouldn't hurt
      this.el_.play();

      // playing and pausing synchronously during the transition to fullscreen
      // can get iOS ~6.1 devices into a play/pause loop
      this.setTimeout(function () {
        video.pause();
        video.webkitEnterFullScreen();
      }, 0);
    } else {
      video.webkitEnterFullScreen();
    }
  };

  /**
   * Request that the `HTML5` Tech exit fullscreen.
   */


  Html5.prototype.exitFullScreen = function exitFullScreen() {
    this.el_.webkitExitFullScreen();
  };

  /**
   * A getter/setter for the `Html5` Tech's source object.
   * > Note: Please use {@link Html5#setSource}
   *
   * @param {Tech~SourceObject} [src]
   *        The source object you want to set on the `HTML5` techs element.
   *
   * @return {Tech~SourceObject|undefined}
   *         - The current source object when a source is not passed in.
   *         - undefined when setting
   *
   * @deprecated Since version 5.
   */


  Html5.prototype.src = function src(_src) {
    if (_src === undefined) {
      return this.el_.src;
    }

    // Setting src through `src` instead of `setSrc` will be deprecated
    this.setSrc(_src);
  };

  /**
   * Reset the tech by removing all sources and then calling
   * {@link Html5.resetMediaElement}.
   */


  Html5.prototype.reset = function reset() {
    Html5.resetMediaElement(this.el_);
  };

  /**
   * Get the current source on the `HTML5` Tech. Falls back to returning the source from
   * the HTML5 media element.
   *
   * @return {Tech~SourceObject}
   *         The current source object from the HTML5 tech. With a fallback to the
   *         elements source.
   */


  Html5.prototype.currentSrc = function currentSrc() {
    if (this.currentSource_) {
      return this.currentSource_.src;
    }
    return this.el_.currentSrc;
  };

  /**
   * Set controls attribute for the HTML5 media Element.
   *
   * @param {string} val
   *        Value to set the controls attribute to
   */


  Html5.prototype.setControls = function setControls(val) {
    this.el_.controls = !!val;
  };

  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */


  Html5.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.addTextTrack.call(this, kind, label, language);
    }

    return this.el_.addTextTrack(kind, label, language);
  };

  /**
   * Creates either native TextTrack or an emulated TextTrack depending
   * on the value of `featuresNativeTextTracks`
   *
   * @param {Object} options
   *        The object should contain the options to intialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label].
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @param {boolean} [options.default]
   *        Default this track to on.
   *
   * @param {string} [options.id]
   *        The internal id to assign this track.
   *
   * @param {string} [options.src]
   *        A source url for the track.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */


  Html5.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.createRemoteTextTrack.call(this, options);
    }
    var htmlTrackElement = document.createElement('track');

    if (options.kind) {
      htmlTrackElement.kind = options.kind;
    }
    if (options.label) {
      htmlTrackElement.label = options.label;
    }
    if (options.language || options.srclang) {
      htmlTrackElement.srclang = options.language || options.srclang;
    }
    if (options['default']) {
      htmlTrackElement['default'] = options['default'];
    }
    if (options.id) {
      htmlTrackElement.id = options.id;
    }
    if (options.src) {
      htmlTrackElement.src = options.src;
    }

    return htmlTrackElement;
  };

  /**
   * Creates a remote text track object and returns an html track element.
   *
   * @param {Object} options The object should contain values for
   * kind, language, label, and src (location of the WebVTT file)
   * @param {Boolean} [manualCleanup=true] if set to false, the TextTrack will be
   * automatically removed from the video element whenever the source changes
   * @return {HTMLTrackElement} An Html Track Element.
   * This can be an emulated {@link HTMLTrackElement} or a native one.
   * @deprecated The default value of the "manualCleanup" parameter will default
   * to "false" in upcoming versions of Video.js
   */


  Html5.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);

    if (this.featuresNativeTextTracks) {
      this.el().appendChild(htmlTrackElement);
    }

    return htmlTrackElement;
  };

  /**
   * Remove remote `TextTrack` from `TextTrackList` object
   *
   * @param {TextTrack} track
   *        `TextTrack` object to remove
   */


  Html5.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    _Tech.prototype.removeRemoteTextTrack.call(this, track);

    if (this.featuresNativeTextTracks) {
      var tracks = this.$$('track');

      var i = tracks.length;

      while (i--) {
        if (track === tracks[i] || track === tracks[i].track) {
          this.el().removeChild(tracks[i]);
        }
      }
    }
  };

  /**
   * Get the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#playsinline
   * @return {boolean}
   *         - The value of `playsinline` from the media element.
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */


  Html5.prototype.playsinline = function playsinline() {
    return this.el_.hasAttribute('playsinline');
  };

  /**
   * Set the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#setPlaysinline
   * @param {boolean} playsinline
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */


  Html5.prototype.setPlaysinline = function setPlaysinline(value) {
    if (value) {
      this.el_.setAttribute('playsinline', 'playsinline');
    } else {
      this.el_.removeAttribute('playsinline');
    }
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   */


  Html5.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    if (typeof this.el().getVideoPlaybackQuality === 'function') {
      return this.el().getVideoPlaybackQuality();
    }

    var videoPlaybackQuality = {};

    if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {
      videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
      videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
    }

    if (window.performance && typeof window.performance.now === 'function') {
      videoPlaybackQuality.creationTime = window.performance.now();
    } else if (window.performance && window.performance.timing && typeof window.performance.timing.navigationStart === 'number') {
      videoPlaybackQuality.creationTime = window.Date.now() - window.performance.timing.navigationStart;
    }

    return videoPlaybackQuality;
  };

  return Html5;
}(Tech);

/* HTML5 Support Testing ---------------------------------------------------- */

if (isReal()) {

  /**
   * Element for testing browser HTML5 media capabilities
   *
   * @type {Element}
   * @constant
   * @private
   */
  Html5.TEST_VID = document.createElement('video');
  var track = document.createElement('track');

  track.kind = 'captions';
  track.srclang = 'en';
  track.label = 'English';
  Html5.TEST_VID.appendChild(track);
}

/**
 * Check if HTML5 media is supported by this browser/device.
 *
 * @return {boolean}
 *         - True if HTML5 media is supported.
 *         - False if HTML5 media is not supported.
 */
Html5.isSupported = function () {
  // IE9 with no Media Player is a LIAR! (#984)
  try {
    Html5.TEST_VID.volume = 0.5;
  } catch (e) {
    return false;
  }

  return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
};

/**
 * Check if the tech can support the given type
 *
 * @param {string} type
 *        The mimetype to check
 * @return {string} 'probably', 'maybe', or '' (empty string)
 */
Html5.canPlayType = function (type) {
  return Html5.TEST_VID.canPlayType(type);
};

/**
 * Check if the tech can support the given source
 * @param {Object} srcObj
 *        The source object
 * @param {Object} options
 *        The options passed to the tech
 * @return {string} 'probably', 'maybe', or '' (empty string)
 */
Html5.canPlaySource = function (srcObj, options) {
  return Html5.canPlayType(srcObj.type);
};

/**
 * Check if the volume can be changed in this browser/device.
 * Volume cannot be changed in a lot of mobile devices.
 * Specifically, it can't be changed from 1 on iOS.
 *
 * @return {boolean}
 *         - True if volume can be controlled
 *         - False otherwise
 */
Html5.canControlVolume = function () {
  // IE will error if Windows Media Player not installed #3315
  try {
    var volume = Html5.TEST_VID.volume;

    Html5.TEST_VID.volume = volume / 2 + 0.1;
    return volume !== Html5.TEST_VID.volume;
  } catch (e) {
    return false;
  }
};

/**
 * Check if the playback rate can be changed in this browser/device.
 *
 * @return {boolean}
 *         - True if playback rate can be controlled
 *         - False otherwise
 */
Html5.canControlPlaybackRate = function () {
  // Playback rate API is implemented in Android Chrome, but doesn't do anything
  // https://github.com/videojs/video.js/issues/3180
  if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {
    return false;
  }
  // IE will error if Windows Media Player not installed #3315
  try {
    var playbackRate = Html5.TEST_VID.playbackRate;

    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
    return playbackRate !== Html5.TEST_VID.playbackRate;
  } catch (e) {
    return false;
  }
};

/**
 * Check to see if native `TextTrack`s are supported by this browser/device.
 *
 * @return {boolean}
 *         - True if native `TextTrack`s are supported.
 *         - False otherwise
 */
Html5.supportsNativeTextTracks = function () {
  return IS_ANY_SAFARI;
};

/**
 * Check to see if native `VideoTrack`s are supported by this browser/device
 *
 * @return {boolean}
 *        - True if native `VideoTrack`s are supported.
 *        - False otherwise
 */
Html5.supportsNativeVideoTracks = function () {
  return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
};

/**
 * Check to see if native `AudioTrack`s are supported by this browser/device
 *
 * @return {boolean}
 *        - True if native `AudioTrack`s are supported.
 *        - False otherwise
 */
Html5.supportsNativeAudioTracks = function () {
  return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
};

/**
 * An array of events available on the Html5 tech.
 *
 * @private
 * @type {Array}
 */
Html5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];

/**
 * Boolean indicating whether the `Tech` supports volume control.
 *
 * @type {boolean}
 * @default {@link Html5.canControlVolume}
 */
Html5.prototype.featuresVolumeControl = Html5.canControlVolume();

/**
 * Boolean indicating whether the `Tech` supports changing the speed at which the media
 * plays. Examples:
 *   - Set player to play 2x (twice) as fast
 *   - Set player to play 0.5x (half) as fast
 *
 * @type {boolean}
 * @default {@link Html5.canControlPlaybackRate}
 */
Html5.prototype.featuresPlaybackRate = Html5.canControlPlaybackRate();

/**
 * Boolean indicating whether the `HTML5` tech currently supports the media element
 * moving in the DOM. iOS breaks if you move the media element, so this is set this to
 * false there. Everywhere else this should be true.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.movingMediaElementInDOM = !IS_IOS;

// TODO: Previous comment: No longer appears to be used. Can probably be removed.
//       Is this true?
/**
 * Boolean indicating whether the `HTML5` tech currently supports automatic media resize
 * when going into fullscreen.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.featuresFullscreenResize = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports the progress event.
 * If this is false, manual `progress` events will be triggred instead.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.featuresProgressEvents = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.
 * If this is false, manual `timeupdate` events will be triggred instead.
 *
 * @default
 */
Html5.prototype.featuresTimeupdateEvents = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeTextTracks}
 */
Html5.prototype.featuresNativeTextTracks = Html5.supportsNativeTextTracks();

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeVideoTracks}
 */
Html5.prototype.featuresNativeVideoTracks = Html5.supportsNativeVideoTracks();

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeAudioTracks}
 */
Html5.prototype.featuresNativeAudioTracks = Html5.supportsNativeAudioTracks();

// HTML5 Feature detection and Device Fixes --------------------------------- //
var canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;
var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
var mp4RE = /^video\/mp4/i;

Html5.patchCanPlayType = function () {

  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so
  if (ANDROID_VERSION >= 4.0 && !IS_FIREFOX) {
    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mpegurlRE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };

    // Override Android 2.2 and less canPlayType method which is broken
  } else if (IS_OLD_ANDROID) {
    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mp4RE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };
  }
};

Html5.unpatchCanPlayType = function () {
  var r = Html5.TEST_VID.constructor.prototype.canPlayType;

  Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;
  return r;
};

// by default, patch the media element
Html5.patchCanPlayType();

Html5.disposeMediaElement = function (el) {
  if (!el) {
    return;
  }

  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }

  // remove any child track or source nodes to prevent their loading
  while (el.hasChildNodes()) {
    el.removeChild(el.firstChild);
  }

  // remove any src reference. not setting `src=''` because that causes a warning
  // in firefox
  el.removeAttribute('src');

  // force the media element to update its loading state by calling load()
  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {
        // not supported
      }
    })();
  }
};

Html5.resetMediaElement = function (el) {
  if (!el) {
    return;
  }

  var sources = el.querySelectorAll('source');
  var i = sources.length;

  while (i--) {
    el.removeChild(sources[i]);
  }

  // remove any src reference.
  // not setting `src=''` because that throws an error
  el.removeAttribute('src');

  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {
        // satisfy linter
      }
    })();
  }
};

/* Native HTML5 element property wrapping ----------------------------------- */
// Wrap native properties with a getter
[
/**
 * Get the value of `paused` from the media element. `paused` indicates whether the media element
 * is currently paused or not.
 *
 * @method Html5#paused
 * @return {boolean}
 *         The value of `paused` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
 */
'paused',

/**
 * Get the value of `currentTime` from the media element. `currentTime` indicates
 * the current second that the media is at in playback.
 *
 * @method Html5#currentTime
 * @return {number}
 *         The value of `currentTime` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
 */
'currentTime',

/**
 * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
 * object that represents the parts of the media that are already downloaded and
 * available for playback.
 *
 * @method Html5#buffered
 * @return {TimeRange}
 *         The value of `buffered` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
 */
'buffered',

/**
 * Get the value of `volume` from the media element. `volume` indicates
 * the current playback volume of audio for a media. `volume` will be a value from 0
 * (silent) to 1 (loudest and default).
 *
 * @method Html5#volume
 * @return {number}
 *         The value of `volume` from the media element. Value will be between 0-1.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
 */
'volume',

/**
 * Get the value of `muted` from the media element. `muted` indicates
 * that the volume for the media should be set to silent. This does not actually change
 * the `volume` attribute.
 *
 * @method Html5#muted
 * @return {boolean}
 *         - True if the value of `volume` should be ignored and the audio set to silent.
 *         - False if the value of `volume` should be used.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
 */
'muted',

/**
 * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
 * that the volume for the media should be set to silent when the video first starts.
 * This does not actually change the `volume` attribute. After playback has started `muted`
 * will indicate the current status of the volume and `defaultMuted` will not.
 *
 * @method Html5.prototype.defaultMuted
 * @return {boolean}
 *         - True if the value of `volume` should be ignored and the audio set to silent.
 *         - False if the value of `volume` should be used.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
 */
'defaultMuted',

/**
 * Get the value of `poster` from the media element. `poster` indicates
 * that the url of an image file that can/will be shown when no media data is available.
 *
 * @method Html5#poster
 * @return {string}
 *         The value of `poster` from the media element. Value will be a url to an
 *         image.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
 */
'poster',

/**
 * Get the value of `preload` from the media element. `preload` indicates
 * what should download before the media is interacted with. It can have the following
 * values:
 * - none: nothing should be downloaded
 * - metadata: poster and the first few frames of the media may be downloaded to get
 *   media dimensions and other metadata
 * - auto: allow the media and metadata for the media to be downloaded before
 *    interaction
 *
 * @method Html5#preload
 * @return {string}
 *         The value of `preload` from the media element. Will be 'none', 'metadata',
 *         or 'auto'.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
 */
'preload',

/**
 * Get the value of `autoplay` from the media element. `autoplay` indicates
 * that the media should start to play as soon as the page is ready.
 *
 * @method Html5#autoplay
 * @return {boolean}
 *         - The value of `autoplay` from the media element.
 *         - True indicates that the media should start as soon as the page loads.
 *         - False indicates that the media should not start as soon as the page loads.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
 */
'autoplay',

/**
 * Get the value of `controls` from the media element. `controls` indicates
 * whether the native media controls should be shown or hidden.
 *
 * @method Html5#controls
 * @return {boolean}
 *         - The value of `controls` from the media element.
 *         - True indicates that native controls should be showing.
 *         - False indicates that native controls should be hidden.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
 */
'controls',

/**
 * Get the value of `loop` from the media element. `loop` indicates
 * that the media should return to the start of the media and continue playing once
 * it reaches the end.
 *
 * @method Html5#loop
 * @return {boolean}
 *         - The value of `loop` from the media element.
 *         - True indicates that playback should seek back to start once
 *           the end of a media is reached.
 *         - False indicates that playback should not loop back to the start when the
 *           end of the media is reached.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
 */
'loop',

/**
 * Get the value of the `error` from the media element. `error` indicates any
 * MediaError that may have occured during playback. If error returns null there is no
 * current error.
 *
 * @method Html5#error
 * @return {MediaError|null}
 *         The value of `error` from the media element. Will be `MediaError` if there
 *         is a current error and null otherwise.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
 */
'error',

/**
 * Get the value of `seeking` from the media element. `seeking` indicates whether the
 * media is currently seeking to a new position or not.
 *
 * @method Html5#seeking
 * @return {boolean}
 *         - The value of `seeking` from the media element.
 *         - True indicates that the media is currently seeking to a new position.
 *         - Flase indicates that the media is not seeking to a new position at this time.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
 */
'seeking',

/**
 * Get the value of `seekable` from the media element. `seekable` returns a
 * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
 *
 * @method Html5#seekable
 * @return {TimeRange}
 *         The value of `seekable` from the media element. A `TimeRange` object
 *         indicating the current ranges of time that can be seeked to.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
 */
'seekable',

/**
 * Get the value of `ended` from the media element. `ended` indicates whether
 * the media has reached the end or not.
 *
 * @method Html5#ended
 * @return {boolean}
 *         - The value of `ended` from the media element.
 *         - True indicates that the media has ended.
 *         - False indicates that the media has not ended.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
 */
'ended',

/**
 * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
 * whether the media should start muted or not. Only changes the default state of the
 * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
 * current state.
 *
 * @method Html5#defaultMuted
 * @return {boolean}
 *         - The value of `defaultMuted` from the media element.
 *         - True indicates that the media should start muted.
 *         - False indicates that the media should not start muted
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
 */
'defaultMuted',

/**
 * Get the value of `playbackRate` from the media element. `playbackRate` indicates
 * the rate at which the media is currently playing back. Examples:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5#playbackRate
 * @return {number}
 *         The value of `playbackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'playbackRate',

/**
 * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
 * the rate at which the media is currently playing back. This value will not indicate the current
 * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
 *
 * Examples:
 *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
 *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5.prototype.defaultPlaybackRate
 * @return {number}
 *         The value of `defaultPlaybackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'defaultPlaybackRate',

/**
 * Get the value of `played` from the media element. `played` returns a `TimeRange`
 * object representing points in the media timeline that have been played.
 *
 * @method Html5#played
 * @return {TimeRange}
 *         The value of `played` from the media element. A `TimeRange` object indicating
 *         the ranges of time that have been played.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
 */
'played',

/**
 * Get the value of `networkState` from the media element. `networkState` indicates
 * the current network state. It returns an enumeration from the following list:
 * - 0: NETWORK_EMPTY
 * - 1: NEWORK_IDLE
 * - 2: NETWORK_LOADING
 * - 3: NETWORK_NO_SOURCE
 *
 * @method Html5#networkState
 * @return {number}
 *         The value of `networkState` from the media element. This will be a number
 *         from the list in the description.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
 */
'networkState',

/**
 * Get the value of `readyState` from the media element. `readyState` indicates
 * the current state of the media element. It returns an enumeration from the
 * following list:
 * - 0: HAVE_NOTHING
 * - 1: HAVE_METADATA
 * - 2: HAVE_CURRENT_DATA
 * - 3: HAVE_FUTURE_DATA
 * - 4: HAVE_ENOUGH_DATA
 *
 * @method Html5#readyState
 * @return {number}
 *         The value of `readyState` from the media element. This will be a number
 *         from the list in the description.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
 */
'readyState',

/**
 * Get the value of `videoWidth` from the video element. `videoWidth` indicates
 * the current width of the video in css pixels.
 *
 * @method Html5#videoWidth
 * @return {number}
 *         The value of `videoWidth` from the video element. This will be a number
 *         in css pixels.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
 */
'videoWidth',

/**
 * Get the value of `videoHeight` from the video element. `videoHeigth` indicates
 * the current height of the video in css pixels.
 *
 * @method Html5#videoHeight
 * @return {number}
 *         The value of `videoHeight` from the video element. This will be a number
 *         in css pixels.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
 */
'videoHeight'].forEach(function (prop) {
  Html5.prototype[prop] = function () {
    return this.el_[prop];
  };
});

// Wrap native properties with a setter in this format:
// set + toTitleCase(name)
[
/**
 * Set the value of `volume` on the media element. `volume` indicates the current
 * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
 * so on.
 *
 * @method Html5#setVolume
 * @param {number} percentAsDecimal
 *        The volume percent as a decimal. Valid range is from 0-1.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
 */
'volume',

/**
 * Set the value of `muted` on the media element. `muted` indicates that the current
 * audio level should be silent.
 *
 * @method Html5#setMuted
 * @param {boolean} muted
 *        - True if the audio should be set to silent
 *        - False otherwise
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
 */
'muted',

/**
 * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
 * audio level should be silent, but will only effect the muted level on intial playback..
 *
 * @method Html5.prototype.setDefaultMuted
 * @param {boolean} defaultMuted
 *        - True if the audio should be set to silent
 *        - False otherwise
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
 */
'defaultMuted',

/**
 * Set the value of `src` on the media element. `src` indicates the current
 * {@link Tech~SourceObject} for the media.
 *
 * @method Html5#setSrc
 * @param {Tech~SourceObject} src
 *        The source object to set as the current source.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
 */
'src',

/**
 * Set the value of `poster` on the media element. `poster` is the url to
 * an image file that can/will be shown when no media data is available.
 *
 * @method Html5#setPoster
 * @param {string} poster
 *        The url to an image that should be used as the `poster` for the media
 *        element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
 */
'poster',

/**
 * Set the value of `preload` on the media element. `preload` indicates
 * what should download before the media is interacted with. It can have the following
 * values:
 * - none: nothing should be downloaded
 * - metadata: poster and the first few frames of the media may be downloaded to get
 *   media dimensions and other metadata
 * - auto: allow the media and metadata for the media to be downloaded before
 *    interaction
 *
 * @method Html5#setPreload
 * @param {string} preload
 *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
 *         or 'auto'.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
 */
'preload',

/**
 * Set the value of `autoplay` on the media element. `autoplay` indicates
 * that the media should start to play as soon as the page is ready.
 *
 * @method Html5#setAutoplay
 * @param {boolean} autoplay
 *         - True indicates that the media should start as soon as the page loads.
 *         - False indicates that the media should not start as soon as the page loads.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
 */
'autoplay',

/**
 * Set the value of `loop` on the media element. `loop` indicates
 * that the media should return to the start of the media and continue playing once
 * it reaches the end.
 *
 * @method Html5#setLoop
 * @param {boolean} loop
 *         - True indicates that playback should seek back to start once
 *           the end of a media is reached.
 *         - False indicates that playback should not loop back to the start when the
 *           end of the media is reached.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
 */
'loop',

/**
 * Set the value of `playbackRate` on the media element. `playbackRate` indicates
 * the rate at which the media should play back. Examples:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5#setPlaybackRate
 * @return {number}
 *         The value of `playbackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'playbackRate',

/**
 * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
 * the rate at which the media should play back upon initial startup. Changing this value
 * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
 *
 * Example Values:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5.prototype.setDefaultPlaybackRate
 * @return {number}
 *         The value of `defaultPlaybackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
 */
'defaultPlaybackRate'].forEach(function (prop) {
  Html5.prototype['set' + toTitleCase(prop)] = function (v) {
    this.el_[prop] = v;
  };
});

// wrap native functions with a function
[
/**
 * A wrapper around the media elements `pause` function. This will call the `HTML5`
 * media elements `pause` function.
 *
 * @method Html5#pause
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
 */
'pause',

/**
 * A wrapper around the media elements `load` function. This will call the `HTML5`s
 * media element `load` function.
 *
 * @method Html5#load
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
 */
'load',

/**
 * A wrapper around the media elements `play` function. This will call the `HTML5`s
 * media element `play` function.
 *
 * @method Html5#play
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
 */
'play'].forEach(function (prop) {
  Html5.prototype[prop] = function () {
    return this.el_[prop]();
  };
});

Tech.withSourceHandlers(Html5);

/**
 * Native source handler for Html5, simply passes the source to the media element.
 *
 * @proprety {Tech~SourceObject} source
 *        The source object
 *
 * @proprety {Html5} tech
 *        The instance of the HTML5 tech.
 */
Html5.nativeSourceHandler = {};

/**
 * Check if the media element can play the given mime type.
 *
 * @param {string} type
 *        The mimetype to check
 *
 * @return {string}
 *         'probably', 'maybe', or '' (empty string)
 */
Html5.nativeSourceHandler.canPlayType = function (type) {
  // IE9 on Windows 7 without MediaPlayer throws an error here
  // https://github.com/videojs/video.js/issues/519
  try {
    return Html5.TEST_VID.canPlayType(type);
  } catch (e) {
    return '';
  }
};

/**
 * Check if the media element can handle a source natively.
 *
 * @param {Tech~SourceObject} source
 *         The source object
 *
 * @param {Object} [options]
 *         Options to be passed to the tech.
 *
 * @return {string}
 *         'probably', 'maybe', or '' (empty string).
 */
Html5.nativeSourceHandler.canHandleSource = function (source, options) {

  // If a type was provided we should rely on that
  if (source.type) {
    return Html5.nativeSourceHandler.canPlayType(source.type);

    // If no type, fall back to checking 'video/[EXTENSION]'
  } else if (source.src) {
    var ext = getFileExtension(source.src);

    return Html5.nativeSourceHandler.canPlayType('video/' + ext);
  }

  return '';
};

/**
 * Pass the source to the native media element.
 *
 * @param {Tech~SourceObject} source
 *        The source object
 *
 * @param {Html5} tech
 *        The instance of the Html5 tech
 *
 * @param {Object} [options]
 *        The options to pass to the source
 */
Html5.nativeSourceHandler.handleSource = function (source, tech, options) {
  tech.setSrc(source.src);
};

/**
 * A noop for the native dispose function, as cleanup is not needed.
 */
Html5.nativeSourceHandler.dispose = function () {};

// Register the native source handler
Html5.registerSourceHandler(Html5.nativeSourceHandler);

Tech.registerTech('Html5', Html5);

var _templateObject$1 = taggedTemplateLiteralLoose(['\n        Using the tech directly can be dangerous. I hope you know what you\'re doing.\n        See https://github.com/videojs/video.js/issues/2617 for more info.\n      '], ['\n        Using the tech directly can be dangerous. I hope you know what you\'re doing.\n        See https://github.com/videojs/video.js/issues/2617 for more info.\n      ']);

/**
 * @file player.js
 */
// Subclasses Component
// The following imports are used only to ensure that the corresponding modules
// are always included in the video.js package. Importing the modules will
// execute them and they will register themselves with video.js.
// Import Html5 tech, at least for disposing the original video tag.
// The following tech events are simply re-triggered
// on the player when they happen
var TECH_EVENTS_RETRIGGER = [
/**
 * Fired while the user agent is downloading media data.
 *
 * @event Player#progress
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `progress` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechProgress_
 * @fires Player#progress
 * @listens Tech#progress
 */
'progress',

/**
 * Fires when the loading of an audio/video is aborted.
 *
 * @event Player#abort
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `abort` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechAbort_
 * @fires Player#abort
 * @listens Tech#abort
 */
'abort',

/**
 * Fires when the browser is intentionally not getting media data.
 *
 * @event Player#suspend
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `suspend` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechSuspend_
 * @fires Player#suspend
 * @listens Tech#suspend
 */
'suspend',

/**
 * Fires when the current playlist is empty.
 *
 * @event Player#emptied
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `emptied` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechEmptied_
 * @fires Player#emptied
 * @listens Tech#emptied
 */
'emptied',
/**
 * Fires when the browser is trying to get media data, but data is not available.
 *
 * @event Player#stalled
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `stalled` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechStalled_
 * @fires Player#stalled
 * @listens Tech#stalled
 */
'stalled',

/**
 * Fires when the browser has loaded meta data for the audio/video.
 *
 * @event Player#loadedmetadata
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `stalled` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechLoadedmetadata_
 * @fires Player#loadedmetadata
 * @listens Tech#loadedmetadata
 */
'loadedmetadata',

/**
 * Fires when the browser has loaded the current frame of the audio/video.
 *
 * @event Player#loadeddata
 * @type {event}
 */
/**
 * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechLoaddeddata_
 * @fires Player#loadeddata
 * @listens Tech#loadeddata
 */
'loadeddata',

/**
 * Fires when the current playback position has changed.
 *
 * @event Player#timeupdate
 * @type {event}
 */
/**
 * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechTimeUpdate_
 * @fires Player#timeupdate
 * @listens Tech#timeupdate
 */
'timeupdate',

/**
 * Fires when the playing speed of the audio/video is changed
 *
 * @event Player#ratechange
 * @type {event}
 */
/**
 * Retrigger the `ratechange` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechRatechange_
 * @fires Player#ratechange
 * @listens Tech#ratechange
 */
'ratechange',

/**
 * Fires when the video's intrinsic dimensions change
 *
 * @event Player#resize
 * @type {event}
 */
/**
 * Retrigger the `resize` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechResize_
 * @fires Player#resize
 * @listens Tech#resize
 */
'resize',

/**
 * Fires when the volume has been changed
 *
 * @event Player#volumechange
 * @type {event}
 */
/**
 * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechVolumechange_
 * @fires Player#volumechange
 * @listens Tech#volumechange
 */
'volumechange',

/**
 * Fires when the text track has been changed
 *
 * @event Player#texttrackchange
 * @type {event}
 */
/**
 * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechTexttrackchange_
 * @fires Player#texttrackchange
 * @listens Tech#texttrackchange
 */
'texttrackchange'];

/**
 * An instance of the `Player` class is created when any of the Video.js setup methods
 * are used to initialize a video.
 *
 * After an instance has been created it can be accessed globally in two ways:
 * 1. By calling `videojs('example_video_1');`
 * 2. By using it directly via  `videojs.players.example_video_1;`
 *
 * @extends Component
 */

var Player = function (_Component) {
  inherits(Player, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Element} tag
   *        The original video DOM element used for configuring options.
   *
   * @param {Object} [options]
   *        Object of option names and values.
   *
   * @param {Component~ReadyCallback} [ready]
   *        Ready callback function.
   */
  function Player(tag, options, ready) {
    classCallCheck(this, Player);

    // Make sure tag ID exists
    tag.id = tag.id || 'vjs_video_' + newGUID();

    // Set Options
    // The options argument overrides options set in the video tag
    // which overrides globally set options.
    // This latter part coincides with the load order
    // (tag must exist before Player)
    options = assign(Player.getTagSettings(tag), options);

    // Delay the initialization of children because we need to set up
    // player properties first, and can't use `this` before `super()`
    options.initChildren = false;

    // Same with creating the element
    options.createEl = false;

    // we don't want the player to report touch activity on itself
    // see enableTouchActivity in Component
    options.reportTouchActivity = false;

    // If language is not set, get the closest lang attribute
    if (!options.language) {
      if (typeof tag.closest === 'function') {
        var closest = tag.closest('[lang]');

        if (closest) {
          options.language = closest.getAttribute('lang');
        }
      } else {
        var element = tag;

        while (element && element.nodeType === 1) {
          if (getAttributes(element).hasOwnProperty('lang')) {
            options.language = element.getAttribute('lang');
            break;
          }
          element = element.parentNode;
        }
      }
    }

    // Run base component initializing with new options

    // Turn off API access because we're loading a new tech that might load asynchronously
    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));

    _this.isReady_ = false;

    // if the global option object was accidentally blown away by
    // someone, bail early with an informative error
    if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {
      throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');
    }

    // Store the original tag used to set options
    _this.tag = tag;

    // Store the tag attributes used to restore html5 element
    _this.tagAttributes = tag && getAttributes(tag);

    // Update current language
    _this.language(_this.options_.language);

    // Update Supported Languages
    if (options.languages) {
      // Normalise player option languages to lowercase
      var languagesToLower = {};

      Object.getOwnPropertyNames(options.languages).forEach(function (name$$1) {
        languagesToLower[name$$1.toLowerCase()] = options.languages[name$$1];
      });
      _this.languages_ = languagesToLower;
    } else {
      _this.languages_ = Player.prototype.options_.languages;
    }

    // Cache for video property values.
    _this.cache_ = {};

    // Set poster
    _this.poster_ = options.poster || '';

    // Set controls
    _this.controls_ = !!options.controls;

    // Set default values for lastVolume
    _this.cache_.lastVolume = 1;

    // Original tag settings stored in options
    // now remove immediately so native controls don't flash.
    // May be turned back on by HTML5 tech if nativeControlsForTouch is true
    tag.controls = false;

    /*
     * Store the internal state of scrubbing
     *
     * @private
     * @return {Boolean} True if the user is scrubbing
     */
    _this.scrubbing_ = false;

    _this.el_ = _this.createEl();

    // Make this an evented object and use `el_` as its event bus.
    evented(_this, { eventBusKey: 'el_' });

    // We also want to pass the original player options to each component and plugin
    // as well so they don't need to reach back into the player for options later.
    // We also need to do another copy of this.options_ so we don't end up with
    // an infinite loop.
    var playerOptionsCopy = mergeOptions(_this.options_);

    // Load plugins
    if (options.plugins) {
      var plugins = options.plugins;

      Object.keys(plugins).forEach(function (name$$1) {
        if (typeof this[name$$1] === 'function') {
          this[name$$1](plugins[name$$1]);
        } else {
          throw new Error('plugin "' + name$$1 + '" does not exist');
        }
      }, _this);
    }

    _this.options_.playerOptions = playerOptionsCopy;

    _this.middleware_ = [];

    _this.initChildren();

    // Set isAudio based on whether or not an audio tag was used
    _this.isAudio(tag.nodeName.toLowerCase() === 'audio');

    // Update controls className. Can't do this when the controls are initially
    // set because the element doesn't exist yet.
    if (_this.controls()) {
      _this.addClass('vjs-controls-enabled');
    } else {
      _this.addClass('vjs-controls-disabled');
    }

    // Set ARIA label and region role depending on player type
    _this.el_.setAttribute('role', 'region');
    if (_this.isAudio()) {
      _this.el_.setAttribute('aria-label', _this.localize('Audio Player'));
    } else {
      _this.el_.setAttribute('aria-label', _this.localize('Video Player'));
    }

    if (_this.isAudio()) {
      _this.addClass('vjs-audio');
    }

    if (_this.flexNotSupported_()) {
      _this.addClass('vjs-no-flex');
    }

    // TODO: Make this smarter. Toggle user state between touching/mousing
    // using events, since devices can have both touch and mouse events.
    // if (browser.TOUCH_ENABLED) {
    //   this.addClass('vjs-touch-enabled');
    // }

    // iOS Safari has broken hover handling
    if (!IS_IOS) {
      _this.addClass('vjs-workinghover');
    }

    // Make player easily findable by ID
    Player.players[_this.id_] = _this;

    // Add a major version class to aid css in plugins
    var majorVersion = version.split('.')[0];

    _this.addClass('vjs-v' + majorVersion);

    // When the player is first initialized, trigger activity so components
    // like the control bar show themselves if needed
    _this.userActive(true);
    _this.reportUserActivity();
    _this.listenForUserActivity_();

    _this.on('fullscreenchange', _this.handleFullscreenChange_);
    _this.on('stageclick', _this.handleStageClick_);

    _this.changingSrc_ = false;
    return _this;
  }

  /**
   * Destroys the video player and does any necessary cleanup.
   *
   * This is especially helpful if you are dynamically adding and removing videos
   * to/from the DOM.
   *
   * @fires Player#dispose
   */


  Player.prototype.dispose = function dispose() {
    /**
     * Called when the player is being disposed of.
     *
     * @event Player#dispose
     * @type {EventTarget~Event}
     */
    this.trigger('dispose');
    // prevent dispose from being called twice
    this.off('dispose');

    if (this.styleEl_ && this.styleEl_.parentNode) {
      this.styleEl_.parentNode.removeChild(this.styleEl_);
    }

    // Kill reference to this player
    Player.players[this.id_] = null;

    if (this.tag && this.tag.player) {
      this.tag.player = null;
    }

    if (this.el_ && this.el_.player) {
      this.el_.player = null;
    }

    if (this.tech_) {
      this.tech_.dispose();
    }

    _Component.prototype.dispose.call(this);
  };

  /**
   * Create the `Player`'s DOM element.
   *
   * @return {Element}
   *         The DOM element that gets created.
   */


  Player.prototype.createEl = function createEl$$1() {
    var tag = this.tag;
    var el = void 0;
    var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');

    if (playerElIngest) {
      el = this.el_ = tag.parentNode;
    } else {
      el = this.el_ = _Component.prototype.createEl.call(this, 'div');
    }

    // set tabindex to -1 so we could focus on the player element
    tag.setAttribute('tabindex', '-1');

    // Remove width/height attrs from tag so CSS can make it 100% width/height
    tag.removeAttribute('width');
    tag.removeAttribute('height');

    // Copy over all the attributes from the tag, including ID and class
    // ID will now reference player box, not the video tag
    var attrs = getAttributes(tag);

    Object.getOwnPropertyNames(attrs).forEach(function (attr) {
      // workaround so we don't totally break IE7
      // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7
      if (attr === 'class') {
        el.className += ' ' + attrs[attr];
      } else {
        el.setAttribute(attr, attrs[attr]);
      }
    });

    // Update tag id/class for use as HTML5 playback tech
    // Might think we should do this after embedding in container so .vjs-tech class
    // doesn't flash 100% width/height, but class only applies with .video-js parent
    tag.playerId = tag.id;
    tag.id += '_html5_api';
    tag.className = 'vjs-tech';

    // Make player findable on elements
    tag.player = el.player = this;
    // Default state of video is paused
    this.addClass('vjs-paused');

    // Add a style element in the player that we'll use to set the width/height
    // of the player in a way that's still overrideable by CSS, just like the
    // video element
    if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true) {
      this.styleEl_ = createStyleElement('vjs-styles-dimensions');
      var defaultsStyleEl = $('.vjs-styles-defaults');
      var head = $('head');

      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
    }

    // Pass in the width/height/aspectRatio options which will update the style el
    this.width(this.options_.width);
    this.height(this.options_.height);
    this.fluid(this.options_.fluid);
    this.aspectRatio(this.options_.aspectRatio);

    // Hide any links within the video/audio tag, because IE doesn't hide them completely.
    var links = tag.getElementsByTagName('a');

    for (var i = 0; i < links.length; i++) {
      var linkEl = links.item(i);

      addClass(linkEl, 'vjs-hidden');
      linkEl.setAttribute('hidden', 'hidden');
    }

    // insertElFirst seems to cause the networkState to flicker from 3 to 2, so
    // keep track of the original for later so we can know if the source originally failed
    tag.initNetworkState_ = tag.networkState;

    // Wrap video tag in div (el/box) container
    if (tag.parentNode && !playerElIngest) {
      tag.parentNode.insertBefore(el, tag);
    }

    // insert the tag as the first child of the player element
    // then manually add it to the children array so that this.addChild
    // will work properly for other components
    //
    // Breaks iPhone, fixed in HTML5 setup.
    prependTo(tag, el);
    this.children_.unshift(tag);

    // Set lang attr on player to ensure CSS :lang() in consistent with player
    // if it's been set to something different to the doc
    this.el_.setAttribute('lang', this.language_);

    this.el_ = el;

    return el;
  };

  /**
   * A getter/setter for the `Player`'s width.
   *
   * @param {number} [value]
   *        The value to set the `Player's width to.
   *
   * @return {number}
   *         The current width of the `Player` when getting.
   */


  Player.prototype.width = function width(value) {
    return this.dimension('width', value);
  };

  /**
   * A getter/setter for the `Player`'s height.
   *
   * @param {number} [value]
   *        The value to set the `Player's heigth to.
   *
   * @return {number}
   *         The current height of the `Player` when getting.
   */


  Player.prototype.height = function height(value) {
    return this.dimension('height', value);
  };

  /**
   * A getter/setter for the `Player`'s width & height.
   *
   * @param {string} dimension
   *        This string can be:
   *        - 'width'
   *        - 'height'
   *
   * @param {number} [value]
   *        Value for dimension specified in the first argument.
   *
   * @return {number}
   *         The dimension arguments value when getting (width/height).
   */


  Player.prototype.dimension = function dimension(_dimension, value) {
    var privDimension = _dimension + '_';

    if (value === undefined) {
      return this[privDimension] || 0;
    }

    if (value === '') {
      // If an empty string is given, reset the dimension to be automatic
      this[privDimension] = undefined;
    } else {
      var parsedVal = parseFloat(value);

      if (isNaN(parsedVal)) {
        log$1.error('Improper value "' + value + '" supplied for for ' + _dimension);
        return;
      }

      this[privDimension] = parsedVal;
    }

    this.updateStyleEl_();
  };

  /**
   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.
   *
   * @param {boolean} [bool]
   *        - A value of true adds the class.
   *        - A value of false removes the class.
   *        - No value will toggle the fluid class.
   *
   * @return {boolean|undefined}
   *         - The value of fluid when getting.
   *         - `undefined` when setting.
   */


  Player.prototype.fluid = function fluid(bool) {
    if (bool === undefined) {
      return !!this.fluid_;
    }

    this.fluid_ = !!bool;

    if (bool) {
      this.addClass('vjs-fluid');
    } else {
      this.removeClass('vjs-fluid');
    }

    this.updateStyleEl_();
  };

  /**
   * Get/Set the aspect ratio
   *
   * @param {string} [ratio]
   *        Aspect ratio for player
   *
   * @return {string|undefined}
   *         returns the current aspect ratio when getting
   */

  /**
   * A getter/setter for the `Player`'s aspect ratio.
   *
   * @param {string} [ratio]
   *        The value to set the `Player's aspect ratio to.
   *
   * @return {string|undefined}
   *         - The current aspect ratio of the `Player` when getting.
   *         - undefined when setting
   */


  Player.prototype.aspectRatio = function aspectRatio(ratio) {
    if (ratio === undefined) {
      return this.aspectRatio_;
    }

    // Check for width:height format
    if (!/^\d+\:\d+$/.test(ratio)) {
      throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');
    }
    this.aspectRatio_ = ratio;

    // We're assuming if you set an aspect ratio you want fluid mode,
    // because in fixed mode you could calculate width and height yourself.
    this.fluid(true);

    this.updateStyleEl_();
  };

  /**
   * Update styles of the `Player` element (height, width and aspect ratio).
   *
   * @private
   * @listens Tech#loadedmetadata
   */


  Player.prototype.updateStyleEl_ = function updateStyleEl_() {
    if (window.VIDEOJS_NO_DYNAMIC_STYLE === true) {
      var _width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;
      var _height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;
      var techEl = this.tech_ && this.tech_.el();

      if (techEl) {
        if (_width >= 0) {
          techEl.width = _width;
        }
        if (_height >= 0) {
          techEl.height = _height;
        }
      }

      return;
    }

    var width = void 0;
    var height = void 0;
    var aspectRatio = void 0;
    var idClass = void 0;

    // The aspect ratio is either used directly or to calculate width and height.
    if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {
      // Use any aspectRatio that's been specifically set
      aspectRatio = this.aspectRatio_;
    } else if (this.videoWidth() > 0) {
      // Otherwise try to get the aspect ratio from the video metadata
      aspectRatio = this.videoWidth() + ':' + this.videoHeight();
    } else {
      // Or use a default. The video element's is 2:1, but 16:9 is more common.
      aspectRatio = '16:9';
    }

    // Get the ratio as a decimal we can use to calculate dimensions
    var ratioParts = aspectRatio.split(':');
    var ratioMultiplier = ratioParts[1] / ratioParts[0];

    if (this.width_ !== undefined) {
      // Use any width that's been specifically set
      width = this.width_;
    } else if (this.height_ !== undefined) {
      // Or calulate the width from the aspect ratio if a height has been set
      width = this.height_ / ratioMultiplier;
    } else {
      // Or use the video's metadata, or use the video el's default of 300
      width = this.videoWidth() || 300;
    }

    if (this.height_ !== undefined) {
      // Use any height that's been specifically set
      height = this.height_;
    } else {
      // Otherwise calculate the height from the ratio and the width
      height = width * ratioMultiplier;
    }

    // Ensure the CSS class is valid by starting with an alpha character
    if (/^[^a-zA-Z]/.test(this.id())) {
      idClass = 'dimensions-' + this.id();
    } else {
      idClass = this.id() + '-dimensions';
    }

    // Ensure the right class is still on the player for the style element
    this.addClass(idClass);

    setTextContent(this.styleEl_, '\n      .' + idClass + ' {\n        width: ' + width + 'px;\n        height: ' + height + 'px;\n      }\n\n      .' + idClass + '.vjs-fluid {\n        padding-top: ' + ratioMultiplier * 100 + '%;\n      }\n    ');
  };

  /**
   * Load/Create an instance of playback {@link Tech} including element
   * and API methods. Then append the `Tech` element in `Player` as a child.
   *
   * @param {string} techName
   *        name of the playback technology
   *
   * @param {string} source
   *        video source
   *
   * @private
   */


  Player.prototype.loadTech_ = function loadTech_(techName, source) {
    var _this2 = this;

    // Pause and remove current playback technology
    if (this.tech_) {
      this.unloadTech_();
    }

    var titleTechName = toTitleCase(techName);
    var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);

    // get rid of the HTML5 video tag as soon as we are using another tech
    if (titleTechName !== 'Html5' && this.tag) {
      Tech.getTech('Html5').disposeMediaElement(this.tag);
      this.tag.player = null;
      this.tag = null;
    }

    this.techName_ = titleTechName;

    // Turn off API access because we're loading a new tech that might load asynchronously
    this.isReady_ = false;

    // Grab tech-specific options from player options and add source and parent element to use.
    var techOptions = {
      source: source,
      'nativeControlsForTouch': this.options_.nativeControlsForTouch,
      'playerId': this.id(),
      'techId': this.id() + '_' + titleTechName + '_api',
      'autoplay': this.options_.autoplay,
      'playsinline': this.options_.playsinline,
      'preload': this.options_.preload,
      'loop': this.options_.loop,
      'muted': this.options_.muted,
      'poster': this.poster(),
      'language': this.language(),
      'playerElIngest': this.playerElIngest_ || false,
      'vtt.js': this.options_['vtt.js']
    };

    ALL.names.forEach(function (name$$1) {
      var props = ALL[name$$1];

      techOptions[props.getterName] = _this2[props.privateName];
    });

    assign(techOptions, this.options_[titleTechName]);
    assign(techOptions, this.options_[camelTechName]);
    assign(techOptions, this.options_[techName.toLowerCase()]);

    if (this.tag) {
      techOptions.tag = this.tag;
    }

    if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
      techOptions.startTime = this.cache_.currentTime;
    }

    // Initialize tech instance
    var TechClass = Tech.getTech(techName);

    if (!TechClass) {
      throw new Error('No Tech named \'' + titleTechName + '\' exists! \'' + titleTechName + '\' should be registered using videojs.registerTech()\'');
    }

    this.tech_ = new TechClass(techOptions);

    // player.triggerReady is always async, so don't need this to be async
    this.tech_.ready(bind(this, this.handleTechReady_), true);

    textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);

    // Listen to all HTML5-defined events and trigger them on the player
    TECH_EVENTS_RETRIGGER.forEach(function (event) {
      _this2.on(_this2.tech_, event, _this2['handleTech' + toTitleCase(event) + '_']);
    });
    this.on(this.tech_, 'loadstart', this.handleTechLoadStart_);
    this.on(this.tech_, 'waiting', this.handleTechWaiting_);
    this.on(this.tech_, 'canplay', this.handleTechCanPlay_);
    this.on(this.tech_, 'canplaythrough', this.handleTechCanPlayThrough_);
    this.on(this.tech_, 'playing', this.handleTechPlaying_);
    this.on(this.tech_, 'ended', this.handleTechEnded_);
    this.on(this.tech_, 'seeking', this.handleTechSeeking_);
    this.on(this.tech_, 'seeked', this.handleTechSeeked_);
    this.on(this.tech_, 'play', this.handleTechPlay_);
    this.on(this.tech_, 'firstplay', this.handleTechFirstPlay_);
    this.on(this.tech_, 'pause', this.handleTechPause_);
    this.on(this.tech_, 'durationchange', this.handleTechDurationChange_);
    this.on(this.tech_, 'fullscreenchange', this.handleTechFullscreenChange_);
    this.on(this.tech_, 'error', this.handleTechError_);
    this.on(this.tech_, 'loadedmetadata', this.updateStyleEl_);
    this.on(this.tech_, 'posterchange', this.handleTechPosterChange_);
    this.on(this.tech_, 'textdata', this.handleTechTextData_);

    this.usingNativeControls(this.techGet_('controls'));

    if (this.controls() && !this.usingNativeControls()) {
      this.addTechControlsListeners_();
    }

    // Add the tech element in the DOM if it was not already there
    // Make sure to not insert the original video element if using Html5
    if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {
      prependTo(this.tech_.el(), this.el());
    }

    // Get rid of the original video tag reference after the first tech is loaded
    if (this.tag) {
      this.tag.player = null;
      this.tag = null;
    }
  };

  /**
   * Unload and dispose of the current playback {@link Tech}.
   *
   * @private
   */


  Player.prototype.unloadTech_ = function unloadTech_() {
    var _this3 = this;

    // Save the current text tracks so that we can reuse the same text tracks with the next tech
    ALL.names.forEach(function (name$$1) {
      var props = ALL[name$$1];

      _this3[props.privateName] = _this3[props.getterName]();
    });
    this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);

    this.isReady_ = false;

    this.tech_.dispose();

    this.tech_ = false;
  };

  /**
   * Return a reference to the current {@link Tech}.
   * It will print a warning by default about the danger of using the tech directly
   * but any argument that is passed in will silence the warning.
   *
   * @param {*} [safety]
   *        Anything passed in to silence the warning
   *
   * @return {Tech}
   *         The Tech
   */


  Player.prototype.tech = function tech(safety) {
    if (safety === undefined) {
      log$1.warn(tsml(_templateObject$1));
    }

    return this.tech_;
  };

  /**
   * Set up click and touch listeners for the playback element
   *
   * - On desktops: a click on the video itself will toggle playback
   * - On mobile devices: a click on the video toggles controls
   *   which is done by toggling the user state between active and
   *   inactive
   * - A tap can signal that a user has become active or has become inactive
   *   e.g. a quick tap on an iPhone movie should reveal the controls. Another
   *   quick tap should hide them again (signaling the user is in an inactive
   *   viewing state)
   * - In addition to this, we still want the user to be considered inactive after
   *   a few seconds of inactivity.
   *
   * > Note: the only part of iOS interaction we can't mimic with this setup
   * is a touch and hold on the video element counting as activity in order to
   * keep the controls showing, but that shouldn't be an issue. A touch and hold
   * on any controls will still keep the user active
   *
   * @private
   */


  Player.prototype.addTechControlsListeners_ = function addTechControlsListeners_() {
    // Make sure to remove all the previous listeners in case we are called multiple times.
    this.removeTechControlsListeners_();

    // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do
    // trigger mousedown/up.
    // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object
    // Any touch events are set to block the mousedown event from happening
    this.on(this.tech_, 'mousedown', this.handleTechClick_);

    // If the controls were hidden we don't want that to change without a tap event
    // so we'll check if the controls were already showing before reporting user
    // activity
    this.on(this.tech_, 'touchstart', this.handleTechTouchStart_);
    this.on(this.tech_, 'touchmove', this.handleTechTouchMove_);
    this.on(this.tech_, 'touchend', this.handleTechTouchEnd_);

    // The tap listener needs to come after the touchend listener because the tap
    // listener cancels out any reportedUserActivity when setting userActive(false)
    this.on(this.tech_, 'tap', this.handleTechTap_);
  };

  /**
   * Remove the listeners used for click and tap controls. This is needed for
   * toggling to controls disabled, where a tap/touch should do nothing.
   *
   * @private
   */


  Player.prototype.removeTechControlsListeners_ = function removeTechControlsListeners_() {
    // We don't want to just use `this.off()` because there might be other needed
    // listeners added by techs that extend this.
    this.off(this.tech_, 'tap', this.handleTechTap_);
    this.off(this.tech_, 'touchstart', this.handleTechTouchStart_);
    this.off(this.tech_, 'touchmove', this.handleTechTouchMove_);
    this.off(this.tech_, 'touchend', this.handleTechTouchEnd_);
    this.off(this.tech_, 'mousedown', this.handleTechClick_);
  };

  /**
   * Player waits for the tech to be ready
   *
   * @private
   */


  Player.prototype.handleTechReady_ = function handleTechReady_() {
    this.triggerReady();

    // Keep the same volume as before
    if (this.cache_.volume) {
      this.techCall_('setVolume', this.cache_.volume);
    }

    // Look if the tech found a higher resolution poster while loading
    this.handleTechPosterChange_();

    // Update the duration if available
    this.handleTechDurationChange_();

    // Chrome and Safari both have issues with autoplay.
    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.
    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)
    // This fixes both issues. Need to wait for API, so it updates displays correctly
    if ((this.src() || this.currentSrc()) && this.tag && this.options_.autoplay && this.paused()) {
      try {
        // Chrome Fix. Fixed in Chrome v16.
        delete this.tag.poster;
      } catch (e) {
        log$1('deleting tag.poster throws in some browsers', e);
      }
      this.play();
    }
  };

  /**
   * Retrigger the `loadstart` event that was triggered by the {@link Tech}. This
   * function will also trigger {@link Player#firstplay} if it is the first loadstart
   * for a video.
   *
   * @fires Player#loadstart
   * @fires Player#firstplay
   * @listens Tech#loadstart
   * @private
   */


  Player.prototype.handleTechLoadStart_ = function handleTechLoadStart_() {
    // TODO: Update to use `emptied` event instead. See #1277.

    this.removeClass('vjs-ended');
    this.removeClass('vjs-seeking');

    // reset the error state
    this.error(null);

    // If it's already playing we want to trigger a firstplay event now.
    // The firstplay event relies on both the play and loadstart events
    // which can happen in any order for a new source
    if (!this.paused()) {
      /**
       * Fired when the user agent begins looking for media data
       *
       * @event Player#loadstart
       * @type {EventTarget~Event}
       */
      this.trigger('loadstart');
      this.trigger('firstplay');
    } else {
      // reset the hasStarted state
      this.hasStarted(false);
      this.trigger('loadstart');
    }
  };

  /**
   * Add/remove the vjs-has-started class
   *
   * @fires Player#firstplay
   *
   * @param {boolean} hasStarted
   *        - true: adds the class
   *        - false: remove the class
   *
   * @return {boolean}
   *         the boolean value of hasStarted
   */


  Player.prototype.hasStarted = function hasStarted(_hasStarted) {
    if (_hasStarted !== undefined) {
      // only update if this is a new value
      if (this.hasStarted_ !== _hasStarted) {
        this.hasStarted_ = _hasStarted;
        if (_hasStarted) {
          this.addClass('vjs-has-started');
          // trigger the firstplay event if this newly has played
          this.trigger('firstplay');
        } else {
          this.removeClass('vjs-has-started');
        }
      }
      return;
    }
    return !!this.hasStarted_;
  };

  /**
   * Fired whenever the media begins or resumes playback
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}
   * @fires Player#play
   * @listens Tech#play
   * @private
   */


  Player.prototype.handleTechPlay_ = function handleTechPlay_() {
    this.removeClass('vjs-ended');
    this.removeClass('vjs-paused');
    this.addClass('vjs-playing');

    // hide the poster when the user hits play
    this.hasStarted(true);
    /**
     * Triggered whenever an {@link Tech#play} event happens. Indicates that
     * playback has started or resumed.
     *
     * @event Player#play
     * @type {EventTarget~Event}
     */
    this.trigger('play');
  };

  /**
   * Retrigger the `waiting` event that was triggered by the {@link Tech}.
   *
   * @fires Player#waiting
   * @listens Tech#waiting
   * @private
   */


  Player.prototype.handleTechWaiting_ = function handleTechWaiting_() {
    var _this4 = this;

    this.addClass('vjs-waiting');
    /**
     * A readyState change on the DOM element has caused playback to stop.
     *
     * @event Player#waiting
     * @type {EventTarget~Event}
     */
    this.trigger('waiting');
    this.one('timeupdate', function () {
      return _this4.removeClass('vjs-waiting');
    });
  };

  /**
   * Retrigger the `canplay` event that was triggered by the {@link Tech}.
   * > Note: This is not consistent between browsers. See #1351
   *
   * @fires Player#canplay
   * @listens Tech#canplay
   * @private
   */


  Player.prototype.handleTechCanPlay_ = function handleTechCanPlay_() {
    this.removeClass('vjs-waiting');
    /**
     * The media has a readyState of HAVE_FUTURE_DATA or greater.
     *
     * @event Player#canplay
     * @type {EventTarget~Event}
     */
    this.trigger('canplay');
  };

  /**
   * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.
   *
   * @fires Player#canplaythrough
   * @listens Tech#canplaythrough
   * @private
   */


  Player.prototype.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {
    this.removeClass('vjs-waiting');
    /**
     * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the
     * entire media file can be played without buffering.
     *
     * @event Player#canplaythrough
     * @type {EventTarget~Event}
     */
    this.trigger('canplaythrough');
  };

  /**
   * Retrigger the `playing` event that was triggered by the {@link Tech}.
   *
   * @fires Player#playing
   * @listens Tech#playing
   * @private
   */


  Player.prototype.handleTechPlaying_ = function handleTechPlaying_() {
    this.removeClass('vjs-waiting');
    /**
     * The media is no longer blocked from playback, and has started playing.
     *
     * @event Player#playing
     * @type {EventTarget~Event}
     */
    this.trigger('playing');
  };

  /**
   * Retrigger the `seeking` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeking
   * @listens Tech#seeking
   * @private
   */


  Player.prototype.handleTechSeeking_ = function handleTechSeeking_() {
    this.addClass('vjs-seeking');
    /**
     * Fired whenever the player is jumping to a new time
     *
     * @event Player#seeking
     * @type {EventTarget~Event}
     */
    this.trigger('seeking');
  };

  /**
   * Retrigger the `seeked` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeked
   * @listens Tech#seeked
   * @private
   */


  Player.prototype.handleTechSeeked_ = function handleTechSeeked_() {
    this.removeClass('vjs-seeking');
    /**
     * Fired when the player has finished jumping to a new time
     *
     * @event Player#seeked
     * @type {EventTarget~Event}
     */
    this.trigger('seeked');
  };

  /**
   * Retrigger the `firstplay` event that was triggered by the {@link Tech}.
   *
   * @fires Player#firstplay
   * @listens Tech#firstplay
   * @deprecated As of 6.0 firstplay event is deprecated.
   * @deprecated As of 6.0 passing the `starttime` option to the player and the firstplay event are deprecated.
   * @private
   */


  Player.prototype.handleTechFirstPlay_ = function handleTechFirstPlay_() {
    // If the first starttime attribute is specified
    // then we will start at the given offset in seconds
    if (this.options_.starttime) {
      log$1.warn('Passing the `starttime` option to the player will be deprecated in 6.0');
      this.currentTime(this.options_.starttime);
    }

    this.addClass('vjs-has-started');
    /**
     * Fired the first time a video is played. Not part of the HLS spec, and this is
     * probably not the best implementation yet, so use sparingly. If you don't have a
     * reason to prevent playback, use `myPlayer.one('play');` instead.
     *
     * @event Player#firstplay
     * @deprecated As of 6.0 firstplay event is deprecated.
     * @type {EventTarget~Event}
     */
    this.trigger('firstplay');
  };

  /**
   * Retrigger the `pause` event that was triggered by the {@link Tech}.
   *
   * @fires Player#pause
   * @listens Tech#pause
   * @private
   */


  Player.prototype.handleTechPause_ = function handleTechPause_() {
    this.removeClass('vjs-playing');
    this.addClass('vjs-paused');
    /**
     * Fired whenever the media has been paused
     *
     * @event Player#pause
     * @type {EventTarget~Event}
     */
    this.trigger('pause');
  };

  /**
   * Retrigger the `ended` event that was triggered by the {@link Tech}.
   *
   * @fires Player#ended
   * @listens Tech#ended
   * @private
   */


  Player.prototype.handleTechEnded_ = function handleTechEnded_() {
    this.addClass('vjs-ended');
    if (this.options_.loop) {
      this.currentTime(0);
      this.play();
    } else if (!this.paused()) {
      this.pause();
    }

    /**
     * Fired when the end of the media resource is reached (currentTime == duration)
     *
     * @event Player#ended
     * @type {EventTarget~Event}
     */
    this.trigger('ended');
  };

  /**
   * Fired when the duration of the media resource is first known or changed
   *
   * @listens Tech#durationchange
   * @private
   */


  Player.prototype.handleTechDurationChange_ = function handleTechDurationChange_() {
    this.duration(this.techGet_('duration'));
  };

  /**
   * Handle a click on the media element to play/pause
   *
   * @param {EventTarget~Event} event
   *        the event that caused this function to trigger
   *
   * @listens Tech#mousedown
   * @private
   */


  Player.prototype.handleTechClick_ = function handleTechClick_(event) {
    // We're using mousedown to detect clicks thanks to Flash, but mousedown
    // will also be triggered with right-clicks, so we need to prevent that
    if (event.button !== 0) {
      return;
    }

    // When controls are disabled a click should not toggle playback because
    // the click is considered a control
    if (this.controls()) {
      if (this.paused()) {
        this.play();
      } else {
        this.pause();
      }
    }
  };

  /**
   * Handle a tap on the media element. It will toggle the user
   * activity state, which hides and shows the controls.
   *
   * @listens Tech#tap
   * @private
   */


  Player.prototype.handleTechTap_ = function handleTechTap_() {
    this.userActive(!this.userActive());
  };

  /**
   * Handle touch to start
   *
   * @listens Tech#touchstart
   * @private
   */


  Player.prototype.handleTechTouchStart_ = function handleTechTouchStart_() {
    this.userWasActive = this.userActive();
  };

  /**
   * Handle touch to move
   *
   * @listens Tech#touchmove
   * @private
   */


  Player.prototype.handleTechTouchMove_ = function handleTechTouchMove_() {
    if (this.userWasActive) {
      this.reportUserActivity();
    }
  };

  /**
   * Handle touch to end
   *
   * @param {EventTarget~Event} event
   *        the touchend event that triggered
   *        this function
   *
   * @listens Tech#touchend
   * @private
   */


  Player.prototype.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {
    // Stop the mouse events from also happening
    event.preventDefault();
  };

  /**
   * Fired when the player switches in or out of fullscreen mode
   *
   * @private
   * @listens Player#fullscreenchange
   */


  Player.prototype.handleFullscreenChange_ = function handleFullscreenChange_() {
    if (this.isFullscreen()) {
      this.addClass('vjs-fullscreen');
    } else {
      this.removeClass('vjs-fullscreen');
    }
  };

  /**
   * native click events on the SWF aren't triggered on IE11, Win8.1RT
   * use stageclick events triggered from inside the SWF instead
   *
   * @private
   * @listens stageclick
   */


  Player.prototype.handleStageClick_ = function handleStageClick_() {
    this.reportUserActivity();
  };

  /**
   * Handle Tech Fullscreen Change
   *
   * @param {EventTarget~Event} event
   *        the fullscreenchange event that triggered this function
   *
   * @param {Object} data
   *        the data that was sent with the event
   *
   * @private
   * @listens Tech#fullscreenchange
   * @fires Player#fullscreenchange
   */


  Player.prototype.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {
    if (data) {
      this.isFullscreen(data.isFullscreen);
    }
    /**
     * Fired when going in and out of fullscreen.
     *
     * @event Player#fullscreenchange
     * @type {EventTarget~Event}
     */
    this.trigger('fullscreenchange');
  };

  /**
   * Fires when an error occurred during the loading of an audio/video.
   *
   * @private
   * @listens Tech#error
   */


  Player.prototype.handleTechError_ = function handleTechError_() {
    var error = this.tech_.error();

    this.error(error);
  };

  /**
   * Retrigger the `textdata` event that was triggered by the {@link Tech}.
   *
   * @fires Player#textdata
   * @listens Tech#textdata
   * @private
   */


  Player.prototype.handleTechTextData_ = function handleTechTextData_() {
    var data = null;

    if (arguments.length > 1) {
      data = arguments[1];
    }

    /**
     * Fires when we get a textdata event from tech
     *
     * @event Player#textdata
     * @type {EventTarget~Event}
     */
    this.trigger('textdata', data);
  };

  /**
   * Get object for cached values.
   *
   * @return {Object}
   *         get the current object cache
   */


  Player.prototype.getCache = function getCache() {
    return this.cache_;
  };

  /**
   * Pass values to the playback tech
   *
   * @param {string} [method]
   *        the method to call
   *
   * @param {Object} arg
   *        the argument to pass
   *
   * @private
   */


  Player.prototype.techCall_ = function techCall_(method, arg) {
    // If it's not ready yet, call method when it is

    this.ready(function () {
      if (method in allowedSetters) {
        return set$1(this.middleware_, this.tech_, method, arg);
      }

      try {
        if (this.tech_) {
          this.tech_[method](arg);
        }
      } catch (e) {
        log$1(e);
        throw e;
      }
    }, true);
  };

  /**
   * Get calls can't wait for the tech, and sometimes don't need to.
   *
   * @param {string} method
   *        Tech method
   *
   * @return {Function|undefined}
   *         the method or undefined
   *
   * @private
   */


  Player.prototype.techGet_ = function techGet_(method) {
    if (this.tech_ && this.tech_.isReady_) {

      if (method in allowedGetters) {
        return get$1(this.middleware_, this.tech_, method);
      }

      // Flash likes to die and reload when you hide or reposition it.
      // In these cases the object methods go away and we get errors.
      // When that happens we'll catch the errors and inform tech that it's not ready any more.
      try {
        return this.tech_[method]();
      } catch (e) {
        // When building additional tech libs, an expected method may not be defined yet
        if (this.tech_[method] === undefined) {
          log$1('Video.js: ' + method + ' method not defined for ' + this.techName_ + ' playback technology.', e);

          // When a method isn't available on the object it throws a TypeError
        } else if (e.name === 'TypeError') {
          log$1('Video.js: ' + method + ' unavailable on ' + this.techName_ + ' playback technology element.', e);
          this.tech_.isReady_ = false;
        } else {
          log$1(e);
        }
        throw e;
      }
    }

    return;
  };

  /**
   * start media playback
   *
   * @return {Promise|undefined}
   *         Returns a `Promise` if the browser returns one, for most browsers this will
   *         return undefined.
   */


  Player.prototype.play = function play() {
    if (this.changingSrc_) {
      this.ready(function () {
        var retval = this.techGet_('play');

        // silence errors (unhandled promise from play)
        if (retval !== undefined && typeof retval.then === 'function') {
          retval.then(null, function (e) {});
        }
      });

      // Only calls the tech's play if we already have a src loaded
    } else if (this.isReady_ && (this.src() || this.currentSrc())) {
      return this.techGet_('play');
    } else {
      this.ready(function () {
        this.tech_.one('loadstart', function () {
          var retval = this.play();

          // silence errors (unhandled promise from play)
          if (retval !== undefined && typeof retval.then === 'function') {
            retval.then(null, function (e) {});
          }
        });
      });
    }
  };

  /**
   * Pause the video playback
   *
   * @return {Player}
   *         A reference to the player object this function was called on
   */


  Player.prototype.pause = function pause() {
    this.techCall_('pause');
  };

  /**
   * Check if the player is paused or has yet to play
   *
   * @return {boolean}
   *         - false: if the media is currently playing
   *         - true: if media is not currently playing
   */


  Player.prototype.paused = function paused() {
    // The initial state of paused should be true (in Safari it's actually false)
    return this.techGet_('paused') === false ? false : true;
  };

  /**
   * Get a TimeRange object representing the current ranges of time that the user
   * has played.
   *
   * @return {TimeRange}
   *         A time range object that represents all the increments of time that have
   *         been played.
   */


  Player.prototype.played = function played() {
    return this.techGet_('played') || createTimeRanges(0, 0);
  };

  /**
   * Returns whether or not the user is "scrubbing". Scrubbing is
   * when the user has clicked the progress bar handle and is
   * dragging it along the progress bar.
   *
   * @param {boolean} [isScrubbing]
   *        wether the user is or is not scrubbing
   *
   * @return {boolean}
   *         The value of scrubbing when getting
   */


  Player.prototype.scrubbing = function scrubbing(isScrubbing) {
    if (typeof isScrubbing === 'undefined') {
      return this.scrubbing_;
    }
    this.scrubbing_ = !!isScrubbing;

    if (isScrubbing) {
      this.addClass('vjs-scrubbing');
    } else {
      this.removeClass('vjs-scrubbing');
    }
  };

  /**
   * Get or set the current time (in seconds)
   *
   * @param {number|string} [seconds]
   *        The time to seek to in seconds
   *
   * @return {number}
   *         - the current time in seconds when getting
   */


  Player.prototype.currentTime = function currentTime(seconds) {
    if (typeof seconds !== 'undefined') {
      this.techCall_('setCurrentTime', seconds);
      return;
    }

    // cache last currentTime and return. default to 0 seconds
    //
    // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
    // currentTime when scrubbing, but may not provide much performance benefit afterall.
    // Should be tested. Also something has to read the actual current time or the cache will
    // never get updated.
    this.cache_.currentTime = this.techGet_('currentTime') || 0;
    return this.cache_.currentTime;
  };

  /**
   * Normally gets the length in time of the video in seconds;
   * in all but the rarest use cases an argument will NOT be passed to the method
   *
   * > **NOTE**: The video must have started loading before the duration can be
   * known, and in the case of Flash, may not be known until the video starts
   * playing.
   *
   * @fires Player#durationchange
   *
   * @param {number} [seconds]
   *        The duration of the video to set in seconds
   *
   * @return {number}
   *         - The duration of the video in seconds when getting
   */


  Player.prototype.duration = function duration(seconds) {
    if (seconds === undefined) {
      // return NaN if the duration is not known
      return this.cache_.duration !== undefined ? this.cache_.duration : NaN;
    }

    seconds = parseFloat(seconds);

    // Standardize on Inifity for signaling video is live
    if (seconds < 0) {
      seconds = Infinity;
    }

    if (seconds !== this.cache_.duration) {
      // Cache the last set value for optimized scrubbing (esp. Flash)
      this.cache_.duration = seconds;

      if (seconds === Infinity) {
        this.addClass('vjs-live');
      } else {
        this.removeClass('vjs-live');
      }
      /**
       * @event Player#durationchange
       * @type {EventTarget~Event}
       */
      this.trigger('durationchange');
    }
  };

  /**
   * Calculates how much time is left in the video. Not part
   * of the native video API.
   *
   * @return {number}
   *         The time remaining in seconds
   */


  Player.prototype.remainingTime = function remainingTime() {
    return this.duration() - this.currentTime();
  };

  //
  // Kind of like an array of portions of the video that have been downloaded.

  /**
   * Get a TimeRange object with an array of the times of the video
   * that have been downloaded. If you just want the percent of the
   * video that's been downloaded, use bufferedPercent.
   *
   * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}
   *
   * @return {TimeRange}
   *         A mock TimeRange object (following HTML spec)
   */


  Player.prototype.buffered = function buffered() {
    var buffered = this.techGet_('buffered');

    if (!buffered || !buffered.length) {
      buffered = createTimeRanges(0, 0);
    }

    return buffered;
  };

  /**
   * Get the percent (as a decimal) of the video that's been downloaded.
   * This method is not a part of the native HTML video API.
   *
   * @return {number}
   *         A decimal between 0 and 1 representing the percent
   *         that is bufferred 0 being 0% and 1 being 100%
   */


  Player.prototype.bufferedPercent = function bufferedPercent$$1() {
    return bufferedPercent(this.buffered(), this.duration());
  };

  /**
   * Get the ending time of the last buffered time range
   * This is used in the progress bar to encapsulate all time ranges.
   *
   * @return {number}
   *         The end of the last buffered time range
   */


  Player.prototype.bufferedEnd = function bufferedEnd() {
    var buffered = this.buffered();
    var duration = this.duration();
    var end = buffered.end(buffered.length - 1);

    if (end > duration) {
      end = duration;
    }

    return end;
  };

  /**
   * Get or set the current volume of the media
   *
   * @param  {number} [percentAsDecimal]
   *         The new volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number}
   *         The current volume as a percent when getting
   */


  Player.prototype.volume = function volume(percentAsDecimal) {
    var vol = void 0;

    if (percentAsDecimal !== undefined) {
      // Force value to between 0 and 1
      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));
      this.cache_.volume = vol;
      this.techCall_('setVolume', vol);

      if (vol > 0) {
        this.lastVolume_(vol);
      }

      return;
    }

    // Default to 1 when returning current volume.
    vol = parseFloat(this.techGet_('volume'));
    return isNaN(vol) ? 1 : vol;
  };

  /**
   * Get the current muted state, or turn mute on or off
   *
   * @param {boolean} [muted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean}
   *         - true if mute is on and getting
   *         - false if mute is off and getting
   */


  Player.prototype.muted = function muted(_muted) {
    if (_muted !== undefined) {
      this.techCall_('setMuted', _muted);
      return;
    }
    return this.techGet_('muted') || false;
  };

  /**
   * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted
   * indicates the state of muted on intial playback.
   *
   * ```js
   *   var myPlayer = videojs('some-player-id');
   *
   *   myPlayer.src("http://www.example.com/path/to/video.mp4");
   *
   *   // get, should be false
   *   console.log(myPlayer.defaultMuted());
   *   // set to true
   *   myPlayer.defaultMuted(true);
   *   // get should be true
   *   console.log(myPlayer.defaultMuted());
   * ```
   *
   * @param {boolean} [defaultMuted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean|Player}
   *         - true if defaultMuted is on and getting
   *         - false if defaultMuted is off and getting
   *         - A reference to the current player when setting
   */


  Player.prototype.defaultMuted = function defaultMuted(_defaultMuted) {
    if (_defaultMuted !== undefined) {
      return this.techCall_('setDefaultMuted', _defaultMuted);
    }
    return this.techGet_('defaultMuted') || false;
  };

  /**
   * Get the last volume, or set it
   *
   * @param  {number} [percentAsDecimal]
   *         The new last volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number}
   *         the current value of lastVolume as a percent when getting
   *
   * @private
   */


  Player.prototype.lastVolume_ = function lastVolume_(percentAsDecimal) {
    if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {
      this.cache_.lastVolume = percentAsDecimal;
      return;
    }
    return this.cache_.lastVolume;
  };

  /**
   * Check if current tech can support native fullscreen
   * (e.g. with built in controls like iOS, so not our flash swf)
   *
   * @return {boolean}
   *         if native fullscreen is supported
   */


  Player.prototype.supportsFullScreen = function supportsFullScreen() {
    return this.techGet_('supportsFullScreen') || false;
  };

  /**
   * Check if the player is in fullscreen mode or tell the player that it
   * is or is not in fullscreen mode.
   *
   * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
   * property and instead document.fullscreenElement is used. But isFullscreen is
   * still a valuable property for internal player workings.
   *
   * @param  {boolean} [isFS]
   *         Set the players current fullscreen state
   *
   * @return {boolean}
   *         - true if fullscreen is on and getting
   *         - false if fullscreen is off and getting
   */


  Player.prototype.isFullscreen = function isFullscreen(isFS) {
    if (isFS !== undefined) {
      this.isFullscreen_ = !!isFS;
      return;
    }
    return !!this.isFullscreen_;
  };

  /**
   * Increase the size of the video to full screen
   * In some browsers, full screen is not supported natively, so it enters
   * "full window mode", where the video fills the browser window.
   * In browsers and devices that support native full screen, sometimes the
   * browser's default controls will be shown, and not the Video.js custom skin.
   * This includes most mobile devices (iOS, Android) and older versions of
   * Safari.
   *
   * @fires Player#fullscreenchange
   */


  Player.prototype.requestFullscreen = function requestFullscreen() {
    var fsApi = FullscreenApi;

    this.isFullscreen(true);

    if (fsApi.requestFullscreen) {
      // the browser supports going fullscreen at the element level so we can
      // take the controls fullscreen as well as the video

      // Trigger fullscreenchange event after change
      // We have to specifically add this each time, and remove
      // when canceling fullscreen. Otherwise if there's multiple
      // players on a page, they would all be reacting to the same fullscreen
      // events
      on(document, fsApi.fullscreenchange, bind(this, function documentFullscreenChange(e) {
        this.isFullscreen(document[fsApi.fullscreenElement]);

        // If cancelling fullscreen, remove event listener.
        if (this.isFullscreen() === false) {
          off(document, fsApi.fullscreenchange, documentFullscreenChange);
        }
        /**
         * @event Player#fullscreenchange
         * @type {EventTarget~Event}
         */
        this.trigger('fullscreenchange');
      }));

      this.el_[fsApi.requestFullscreen]();
    } else if (this.tech_.supportsFullScreen()) {
      // we can't take the video.js controls fullscreen but we can go fullscreen
      // with native controls
      this.techCall_('enterFullScreen');
    } else {
      // fullscreen isn't supported so we'll just stretch the video element to
      // fill the viewport
      this.enterFullWindow();
      /**
       * @event Player#fullscreenchange
       * @type {EventTarget~Event}
       */
      this.trigger('fullscreenchange');
    }
  };

  /**
   * Return the video to its normal size after having been in full screen mode
   *
   * @fires Player#fullscreenchange
   */


  Player.prototype.exitFullscreen = function exitFullscreen() {
    var fsApi = FullscreenApi;

    this.isFullscreen(false);

    // Check for browser element fullscreen support
    if (fsApi.requestFullscreen) {
      document[fsApi.exitFullscreen]();
    } else if (this.tech_.supportsFullScreen()) {
      this.techCall_('exitFullScreen');
    } else {
      this.exitFullWindow();
      /**
       * @event Player#fullscreenchange
       * @type {EventTarget~Event}
       */
      this.trigger('fullscreenchange');
    }
  };

  /**
   * When fullscreen isn't supported we can stretch the
   * video container to as wide as the browser will let us.
   *
   * @fires Player#enterFullWindow
   */


  Player.prototype.enterFullWindow = function enterFullWindow() {
    this.isFullWindow = true;

    // Storing original doc overflow value to return to when fullscreen is off
    this.docOrigOverflow = document.documentElement.style.overflow;

    // Add listener for esc key to exit fullscreen
    on(document, 'keydown', bind(this, this.fullWindowOnEscKey));

    // Hide any scroll bars
    document.documentElement.style.overflow = 'hidden';

    // Apply fullscreen styles
    addClass(document.body, 'vjs-full-window');

    /**
     * @event Player#enterFullWindow
     * @type {EventTarget~Event}
     */
    this.trigger('enterFullWindow');
  };

  /**
   * Check for call to either exit full window or
   * full screen on ESC key
   *
   * @param {string} event
   *        Event to check for key press
   */


  Player.prototype.fullWindowOnEscKey = function fullWindowOnEscKey(event) {
    if (event.keyCode === 27) {
      if (this.isFullscreen() === true) {
        this.exitFullscreen();
      } else {
        this.exitFullWindow();
      }
    }
  };

  /**
   * Exit full window
   *
   * @fires Player#exitFullWindow
   */


  Player.prototype.exitFullWindow = function exitFullWindow() {
    this.isFullWindow = false;
    off(document, 'keydown', this.fullWindowOnEscKey);

    // Unhide scroll bars.
    document.documentElement.style.overflow = this.docOrigOverflow;

    // Remove fullscreen styles
    removeClass(document.body, 'vjs-full-window');

    // Resize the box, controller, and poster to original sizes
    // this.positionAll();
    /**
     * @event Player#exitFullWindow
     * @type {EventTarget~Event}
     */
    this.trigger('exitFullWindow');
  };

  /**
   * Check whether the player can play a given mimetype
   *
   * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype
   *
   * @param {string} type
   *        The mimetype to check
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */


  Player.prototype.canPlayType = function canPlayType(type) {
    var can = void 0;

    // Loop through each playback technology in the options order
    for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {
      var techName = j[i];
      var tech = Tech.getTech(techName);

      // Support old behavior of techs being registered as components.
      // Remove once that deprecated behavior is removed.
      if (!tech) {
        tech = Component.getComponent(techName);
      }

      // Check if the current tech is defined before continuing
      if (!tech) {
        log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
        continue;
      }

      // Check if the browser supports this technology
      if (tech.isSupported()) {
        can = tech.canPlayType(type);

        if (can) {
          return can;
        }
      }
    }

    return '';
  };

  /**
   * Select source based on tech-order or source-order
   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,
   * defaults to tech-order selection
   *
   * @param {Array} sources
   *        The sources for a media asset
   *
   * @return {Object|boolean}
   *         Object of source and tech order or false
   */


  Player.prototype.selectSource = function selectSource(sources) {
    var _this5 = this;

    // Get only the techs specified in `techOrder` that exist and are supported by the
    // current platform
    var techs = this.options_.techOrder.map(function (techName) {
      return [techName, Tech.getTech(techName)];
    }).filter(function (_ref) {
      var techName = _ref[0],
          tech = _ref[1];

      // Check if the current tech is defined before continuing
      if (tech) {
        // Check if the browser supports this technology
        return tech.isSupported();
      }

      log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
      return false;
    });

    // Iterate over each `innerArray` element once per `outerArray` element and execute
    // `tester` with both. If `tester` returns a non-falsy value, exit early and return
    // that value.
    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair(outerArray, innerArray, tester) {
      var found = void 0;

      outerArray.some(function (outerChoice) {
        return innerArray.some(function (innerChoice) {
          found = tester(outerChoice, innerChoice);

          if (found) {
            return true;
          }
        });
      });

      return found;
    };

    var foundSourceAndTech = void 0;
    var flip = function flip(fn) {
      return function (a, b) {
        return fn(b, a);
      };
    };
    var finder = function finder(_ref2, source) {
      var techName = _ref2[0],
          tech = _ref2[1];

      if (tech.canPlaySource(source, _this5.options_[techName.toLowerCase()])) {
        return { source: source, tech: techName };
      }
    };

    // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources
    // to select from them based on their priority.
    if (this.options_.sourceOrder) {
      // Source-first ordering
      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));
    } else {
      // Tech-first ordering
      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
    }

    return foundSourceAndTech || false;
  };

  /**
   * Get or set the video source.
   *
   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
   *        A SourceObject, an array of SourceObjects, or a string referencing
   *        a URL to a media source. It is _highly recommended_ that an object
   *        or array of objects is used here, so that source selection
   *        algorithms can take the `type` into account.
   *
   *        If not provided, this method acts as a getter.
   *
   * @return {string|undefined}
   *         If the `source` argument is missing, returns the current source
   *         URL. Otherwise, returns nothing/undefined.
   */


  Player.prototype.src = function src(source) {
    var _this6 = this;

    // getter usage
    if (typeof source === 'undefined') {
      return this.cache_.src;
    }
    // filter out invalid sources and turn our source into
    // an array of source objects
    var sources = filterSource(source);

    // if a source was passed in then it is invalid because
    // it was filtered to a zero length Array. So we have to
    // show an error
    if (!sources.length) {
      this.setTimeout(function () {
        this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });
      }, 0);
      return;
    }

    // intial sources
    this.cache_.sources = sources;
    this.changingSrc_ = true;

    // intial source
    this.cache_.source = sources[0];

    // middlewareSource is the source after it has been changed by middleware
    setSource(this, sources[0], function (middlewareSource, mws) {
      _this6.middleware_ = mws;

      var err = _this6.src_(middlewareSource);

      if (err) {
        if (sources.length > 1) {
          return _this6.src(sources.slice(1));
        }

        // We need to wrap this in a timeout to give folks a chance to add error event handlers
        _this6.setTimeout(function () {
          this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });
        }, 0);

        // we could not find an appropriate tech, but let's still notify the delegate that this is it
        // this needs a better comment about why this is needed
        _this6.triggerReady();

        return;
      }

      _this6.changingSrc_ = false;
      // video element listed source
      _this6.cache_.src = middlewareSource.src;

      setTech(mws, _this6.tech_);
    });
  };

  /**
   * Set the source object on the tech, returns a boolean that indicates wether
   * there is a tech that can play the source or not
   *
   * @param {Tech~SourceObject} source
   *        The source object to set on the Tech
   *
   * @return {Boolean}
   *         - True if there is no Tech to playback this source
   *         - False otherwise
   *
   * @private
   */


  Player.prototype.src_ = function src_(source) {
    var sourceTech = this.selectSource([source]);

    if (!sourceTech) {
      return true;
    }

    if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
      this.changingSrc_ = true;

      // load this technology with the chosen source
      this.loadTech_(sourceTech.tech, sourceTech.source);
      return false;
    }

    // wait until the tech is ready to set the source
    this.ready(function () {

      // The setSource tech method was added with source handlers
      // so older techs won't support it
      // We need to check the direct prototype for the case where subclasses
      // of the tech do not support source handlers
      if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {
        this.techCall_('setSource', source);
      } else {
        this.techCall_('src', source.src);
      }

      if (this.options_.preload === 'auto') {
        this.load();
      }

      if (this.options_.autoplay) {
        this.play();
      }

      // Set the source synchronously if possible (#2326)
    }, true);

    return false;
  };

  /**
   * Begin loading the src data.
   */


  Player.prototype.load = function load() {
    this.techCall_('load');
  };

  /**
   * Reset the player. Loads the first tech in the techOrder,
   * and calls `reset` on the tech`.
   */


  Player.prototype.reset = function reset() {
    this.loadTech_(this.options_.techOrder[0], null);
    this.techCall_('reset');
  };

  /**
   * Returns all of the current source objects.
   *
   * @return {Tech~SourceObject[]}
   *         The current source objects
   */


  Player.prototype.currentSources = function currentSources() {
    var source = this.currentSource();
    var sources = [];

    // assume `{}` or `{ src }`
    if (Object.keys(source).length !== 0) {
      sources.push(source);
    }

    return this.cache_.sources || sources;
  };

  /**
   * Returns the current source object.
   *
   * @return {Tech~SourceObject}
   *         The current source object
   */


  Player.prototype.currentSource = function currentSource() {
    return this.cache_.source || {};
  };

  /**
   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
   * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.
   *
   * @return {string}
   *         The current source
   */


  Player.prototype.currentSrc = function currentSrc() {
    return this.currentSource() && this.currentSource().src || '';
  };

  /**
   * Get the current source type e.g. video/mp4
   * This can allow you rebuild the current source object so that you could load the same
   * source and tech later
   *
   * @return {string}
   *         The source MIME type
   */


  Player.prototype.currentType = function currentType() {
    return this.currentSource() && this.currentSource().type || '';
  };

  /**
   * Get or set the preload attribute
   *
   * @param {boolean} [value]
   *        - true means that we should preload
   *        - false maens that we should not preload
   *
   * @return {string}
   *         The preload attribute value when getting
   */


  Player.prototype.preload = function preload(value) {
    if (value !== undefined) {
      this.techCall_('setPreload', value);
      this.options_.preload = value;
      return;
    }
    return this.techGet_('preload');
  };

  /**
   * Get or set the autoplay attribute.
   *
   * @param {boolean} [value]
   *        - true means that we should autoplay
   *        - false means that we should not autoplay
   *
   * @return {string}
   *         The current value of autoplay when getting
   */


  Player.prototype.autoplay = function autoplay(value) {
    if (value !== undefined) {
      this.techCall_('setAutoplay', value);
      this.options_.autoplay = value;
      return;
    }
    return this.techGet_('autoplay', value);
  };

  /**
   * Set or unset the playsinline attribute.
   * Playsinline tells the browser that non-fullscreen playback is preferred.
   *
   * @param {boolean} [value]
   *        - true means that we should try to play inline by default
   *        - false means that we should use the browser's default playback mode,
   *          which in most cases is inline. iOS Safari is a notable exception
   *          and plays fullscreen by default.
   *
   * @return {string|Player}
   *         - the current value of playsinline
   *         - the player when setting
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */


  Player.prototype.playsinline = function playsinline(value) {
    if (value !== undefined) {
      this.techCall_('setPlaysinline', value);
      this.options_.playsinline = value;
      return this;
    }
    return this.techGet_('playsinline');
  };

  /**
   * Get or set the loop attribute on the video element.
   *
   * @param {boolean} [value]
   *        - true means that we should loop the video
   *        - false means that we should not loop the video
   *
   * @return {string}
   *         The current value of loop when getting
   */


  Player.prototype.loop = function loop(value) {
    if (value !== undefined) {
      this.techCall_('setLoop', value);
      this.options_.loop = value;
      return;
    }
    return this.techGet_('loop');
  };

  /**
   * Get or set the poster image source url
   *
   * @fires Player#posterchange
   *
   * @param {string} [src]
   *        Poster image source URL
   *
   * @return {string}
   *         The current value of poster when getting
   */


  Player.prototype.poster = function poster(src) {
    if (src === undefined) {
      return this.poster_;
    }

    // The correct way to remove a poster is to set as an empty string
    // other falsey values will throw errors
    if (!src) {
      src = '';
    }

    // update the internal poster variable
    this.poster_ = src;

    // update the tech's poster
    this.techCall_('setPoster', src);

    // alert components that the poster has been set
    /**
     * This event fires when the poster image is changed on the player.
     *
     * @event Player#posterchange
     * @type {EventTarget~Event}
     */
    this.trigger('posterchange');
  };

  /**
   * Some techs (e.g. YouTube) can provide a poster source in an
   * asynchronous way. We want the poster component to use this
   * poster source so that it covers up the tech's controls.
   * (YouTube's play button). However we only want to use this
   * source if the player user hasn't set a poster through
   * the normal APIs.
   *
   * @fires Player#posterchange
   * @listens Tech#posterchange
   * @private
   */


  Player.prototype.handleTechPosterChange_ = function handleTechPosterChange_() {
    if (!this.poster_ && this.tech_ && this.tech_.poster) {
      this.poster_ = this.tech_.poster() || '';

      // Let components know the poster has changed
      this.trigger('posterchange');
    }
  };

  /**
   * Get or set whether or not the controls are showing.
   *
   * @fires Player#controlsenabled
   *
   * @param {boolean} [bool]
   *        - true to turn controls on
   *        - false to turn controls off
   *
   * @return {boolean}
   *         The current value of controls when getting
   */


  Player.prototype.controls = function controls(bool) {
    if (bool !== undefined) {
      bool = !!bool;

      // Don't trigger a change event unless it actually changed
      if (this.controls_ !== bool) {
        this.controls_ = bool;

        if (this.usingNativeControls()) {
          this.techCall_('setControls', bool);
        }

        if (bool) {
          this.removeClass('vjs-controls-disabled');
          this.addClass('vjs-controls-enabled');
          /**
           * @event Player#controlsenabled
           * @type {EventTarget~Event}
           */
          this.trigger('controlsenabled');

          if (!this.usingNativeControls()) {
            this.addTechControlsListeners_();
          }
        } else {
          this.removeClass('vjs-controls-enabled');
          this.addClass('vjs-controls-disabled');
          /**
           * @event Player#controlsdisabled
           * @type {EventTarget~Event}
           */
          this.trigger('controlsdisabled');

          if (!this.usingNativeControls()) {
            this.removeTechControlsListeners_();
          }
        }
      }
      return;
    }
    return !!this.controls_;
  };

  /**
   * Toggle native controls on/off. Native controls are the controls built into
   * devices (e.g. default iPhone controls), Flash, or other techs
   * (e.g. Vimeo Controls)
   * **This should only be set by the current tech, because only the tech knows
   * if it can support native controls**
   *
   * @fires Player#usingnativecontrols
   * @fires Player#usingcustomcontrols
   *
   * @param {boolean} [bool]
   *        - true to turn native controls on
   *        - false to turn native controls off
   *
   * @return {boolean}
   *         The current value of native controls when getting
   */


  Player.prototype.usingNativeControls = function usingNativeControls(bool) {
    if (bool !== undefined) {
      bool = !!bool;

      // Don't trigger a change event unless it actually changed
      if (this.usingNativeControls_ !== bool) {
        this.usingNativeControls_ = bool;
        if (bool) {
          this.addClass('vjs-using-native-controls');

          /**
           * player is using the native device controls
           *
           * @event Player#usingnativecontrols
           * @type {EventTarget~Event}
           */
          this.trigger('usingnativecontrols');
        } else {
          this.removeClass('vjs-using-native-controls');

          /**
           * player is using the custom HTML controls
           *
           * @event Player#usingcustomcontrols
           * @type {EventTarget~Event}
           */
          this.trigger('usingcustomcontrols');
        }
      }
      return;
    }
    return !!this.usingNativeControls_;
  };

  /**
   * Set or get the current MediaError
   *
   * @fires Player#error
   *
   * @param  {MediaError|string|number} [err]
   *         A MediaError or a string/number to be turned
   *         into a MediaError
   *
   * @return {MediaError|null}
   *         The current MediaError when getting (or null)
   */


  Player.prototype.error = function error(err) {
    if (err === undefined) {
      return this.error_ || null;
    }

    // restoring to default
    if (err === null) {
      this.error_ = err;
      this.removeClass('vjs-error');
      if (this.errorDisplay) {
        this.errorDisplay.close();
      }
      return;
    }

    this.error_ = new MediaError(err);

    // add the vjs-error classname to the player
    this.addClass('vjs-error');

    // log the name of the error type and any message
    // ie8 just logs "[object object]" if you just log the error object
    log$1.error('(CODE:' + this.error_.code + ' ' + MediaError.errorTypes[this.error_.code] + ')', this.error_.message, this.error_);

    /**
     * @event Player#error
     * @type {EventTarget~Event}
     */
    this.trigger('error');

    return;
  };

  /**
   * Report user activity
   *
   * @param {Object} event
   *        Event object
   */


  Player.prototype.reportUserActivity = function reportUserActivity(event) {
    this.userActivity_ = true;
  };

  /**
   * Get/set if user is active
   *
   * @fires Player#useractive
   * @fires Player#userinactive
   *
   * @param {boolean} [bool]
   *        - true if the user is active
   *        - false if the user is inactive
   *
   * @return {boolean}
   *         The current value of userActive when getting
   */


  Player.prototype.userActive = function userActive(bool) {
    if (bool !== undefined) {
      bool = !!bool;
      if (bool !== this.userActive_) {
        this.userActive_ = bool;
        if (bool) {
          // If the user was inactive and is now active we want to reset the
          // inactivity timer
          this.userActivity_ = true;
          this.removeClass('vjs-user-inactive');
          this.addClass('vjs-user-active');
          /**
           * @event Player#useractive
           * @type {EventTarget~Event}
           */
          this.trigger('useractive');
        } else {
          // We're switching the state to inactive manually, so erase any other
          // activity
          this.userActivity_ = false;

          // Chrome/Safari/IE have bugs where when you change the cursor it can
          // trigger a mousemove event. This causes an issue when you're hiding
          // the cursor when the user is inactive, and a mousemove signals user
          // activity. Making it impossible to go into inactive mode. Specifically
          // this happens in fullscreen when we really need to hide the cursor.
          //
          // When this gets resolved in ALL browsers it can be removed
          // https://code.google.com/p/chromium/issues/detail?id=103041
          if (this.tech_) {
            this.tech_.one('mousemove', function (e) {
              e.stopPropagation();
              e.preventDefault();
            });
          }

          this.removeClass('vjs-user-active');
          this.addClass('vjs-user-inactive');
          /**
           * @event Player#userinactive
           * @type {EventTarget~Event}
           */
          this.trigger('userinactive');
        }
      }
      return;
    }
    return this.userActive_;
  };

  /**
   * Listen for user activity based on timeout value
   *
   * @private
   */


  Player.prototype.listenForUserActivity_ = function listenForUserActivity_() {
    var mouseInProgress = void 0;
    var lastMoveX = void 0;
    var lastMoveY = void 0;
    var handleActivity = bind(this, this.reportUserActivity);

    var handleMouseMove = function handleMouseMove(e) {
      // #1068 - Prevent mousemove spamming
      // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
        lastMoveX = e.screenX;
        lastMoveY = e.screenY;
        handleActivity();
      }
    };

    var handleMouseDown = function handleMouseDown() {
      handleActivity();
      // For as long as the they are touching the device or have their mouse down,
      // we consider them active even if they're not moving their finger or mouse.
      // So we want to continue to update that they are active
      this.clearInterval(mouseInProgress);
      // Setting userActivity=true now and setting the interval to the same time
      // as the activityCheck interval (250) should ensure we never miss the
      // next activityCheck
      mouseInProgress = this.setInterval(handleActivity, 250);
    };

    var handleMouseUp = function handleMouseUp(event) {
      handleActivity();
      // Stop the interval that maintains activity if the mouse/touch is down
      this.clearInterval(mouseInProgress);
    };

    // Any mouse movement will be considered user activity
    this.on('mousedown', handleMouseDown);
    this.on('mousemove', handleMouseMove);
    this.on('mouseup', handleMouseUp);

    // Listen for keyboard navigation
    // Shouldn't need to use inProgress interval because of key repeat
    this.on('keydown', handleActivity);
    this.on('keyup', handleActivity);

    // Run an interval every 250 milliseconds instead of stuffing everything into
    // the mousemove/touchmove function itself, to prevent performance degradation.
    // `this.reportUserActivity` simply sets this.userActivity_ to true, which
    // then gets picked up by this loop
    // http://ejohn.org/blog/learning-from-twitter/
    var inactivityTimeout = void 0;

    this.setInterval(function () {
      // Check to see if mouse/touch activity has happened
      if (this.userActivity_) {
        // Reset the activity tracker
        this.userActivity_ = false;

        // If the user state was inactive, set the state to active
        this.userActive(true);

        // Clear any existing inactivity timeout to start the timer over
        this.clearTimeout(inactivityTimeout);

        var timeout = this.options_.inactivityTimeout;

        if (timeout > 0) {
          // In <timeout> milliseconds, if no more activity has occurred the
          // user will be considered inactive
          inactivityTimeout = this.setTimeout(function () {
            // Protect against the case where the inactivityTimeout can trigger just
            // before the next user activity is picked up by the activity check loop
            // causing a flicker
            if (!this.userActivity_) {
              this.userActive(false);
            }
          }, timeout);
        }
      }
    }, 250);
  };

  /**
   * Gets or sets the current playback rate. A playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed
   * playback, for instance.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate
   *
   * @param {number} [rate]
   *       New playback rate to set.
   *
   * @return {number}
   *         The current playback rate when getting or 1.0
   */


  Player.prototype.playbackRate = function playbackRate(rate) {
    if (rate !== undefined) {
      this.techCall_('setPlaybackRate', rate);
      return;
    }

    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.techGet_('playbackRate');
    }
    return 1.0;
  };

  /**
   * Gets or sets the current default playback rate. A default playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.
   * defaultPlaybackRate will only represent what the intial playbackRate of a video was, not
   * not the current playbackRate.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate
   *
   * @param {number} [rate]
   *       New default playback rate to set.
   *
   * @return {number|Player}
   *         - The default playback rate when getting or 1.0
   *         - the player when setting
   */


  Player.prototype.defaultPlaybackRate = function defaultPlaybackRate(rate) {
    if (rate !== undefined) {
      return this.techCall_('setDefaultPlaybackRate', rate);
    }

    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.techGet_('defaultPlaybackRate');
    }
    return 1.0;
  };

  /**
   * Gets or sets the audio flag
   *
   * @param {boolean} bool
   *        - true signals that this is an audio player
   *        - false signals that this is not an audio player
   *
   * @return {boolean}
   *         The current value of isAudio when getting
   */


  Player.prototype.isAudio = function isAudio(bool) {
    if (bool !== undefined) {
      this.isAudio_ = !!bool;
      return;
    }

    return !!this.isAudio_;
  };

  /**
   * A helper method for adding a {@link TextTrack} to our
   * {@link TextTrackList}.
   *
   * In addition to the W3C settings we allow adding additional info through options.
   *
   * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
   *
   * @param {string} [kind]
   *        the kind of TextTrack you are adding
   *
   * @param {string} [label]
   *        the label to give the TextTrack label
   *
   * @param {string} [language]
   *        the language to set on the TextTrack
   *
   * @return {TextTrack|undefined}
   *         the TextTrack that was added or undefined
   *         if there is no tech
   */


  Player.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (this.tech_) {
      return this.tech_.addTextTrack(kind, label, language);
    }
  };

  /**
   * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}. It will
   * automatically removed from the video element whenever the source changes, unless
   * manualCleanup is set to false.
   *
   * @param {Object} options
   *        Options to pass to {@link HTMLTrackElement} during creation. See
   *        {@link HTMLTrackElement} for object properties that you should use.
   *
   * @param {boolean} [manualCleanup=true] if set to false, the TextTrack will be
   *
   * @return {HtmlTrackElement}
   *         the HTMLTrackElement that was created and added
   *         to the HtmlTrackElementList and the remote
   *         TextTrackList
   *
   * @deprecated The default value of the "manualCleanup" parameter will default
   *             to "false" in upcoming versions of Video.js
   */


  Player.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    if (this.tech_) {
      return this.tech_.addRemoteTextTrack(options, manualCleanup);
    }
  };

  /**
   * Remove a remote {@link TextTrack} from the respective
   * {@link TextTrackList} and {@link HtmlTrackElementList}.
   *
   * @param {Object} track
   *        Remote {@link TextTrack} to remove
   *
   * @return {undefined}
   *         does not return anything
   */


  Player.prototype.removeRemoteTextTrack = function removeRemoteTextTrack() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$track = _ref3.track,
        track = _ref3$track === undefined ? arguments[0] : _ref3$track;

    // destructure the input into an object with a track argument, defaulting to arguments[0]
    // default the whole argument to an empty object if nothing was passed in

    if (this.tech_) {
      return this.tech_.removeRemoteTextTrack(track);
    }
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object|undefined}
   *         An object with supported media playback quality metrics or undefined if there
   *         is no tech or the tech does not support it.
   */


  Player.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return this.techGet_('getVideoPlaybackQuality');
  };

  /**
   * Get video width
   *
   * @return {number}
   *         current video width
   */


  Player.prototype.videoWidth = function videoWidth() {
    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
  };

  /**
   * Get video height
   *
   * @return {number}
   *         current video height
   */


  Player.prototype.videoHeight = function videoHeight() {
    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
  };

  /**
   * The player's language code
   * NOTE: The language should be set in the player options if you want the
   * the controls to be built with a specific language. Changing the lanugage
   * later will not update controls text.
   *
   * @param {string} [code]
   *        the language code to set the player to
   *
   * @return {string}
   *         The current language code when getting
   */


  Player.prototype.language = function language(code) {
    if (code === undefined) {
      return this.language_;
    }

    this.language_ = String(code).toLowerCase();
  };

  /**
   * Get the player's language dictionary
   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time
   * Languages specified directly in the player options have precedence
   *
   * @return {Array}
   *         An array of of supported languages
   */


  Player.prototype.languages = function languages() {
    return mergeOptions(Player.prototype.options_.languages, this.languages_);
  };

  /**
   * returns a JavaScript object reperesenting the current track
   * information. **DOES not return it as JSON**
   *
   * @return {Object}
   *         Object representing the current of track info
   */


  Player.prototype.toJSON = function toJSON() {
    var options = mergeOptions(this.options_);
    var tracks = options.tracks;

    options.tracks = [];

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      // deep merge tracks and null out player so no circular references
      track = mergeOptions(track);
      track.player = undefined;
      options.tracks[i] = track;
    }

    return options;
  };

  /**
   * Creates a simple modal dialog (an instance of the {@link ModalDialog}
   * component) that immediately overlays the player with arbitrary
   * content and removes itself when closed.
   *
   * @param {string|Function|Element|Array|null} content
   *        Same as {@link ModalDialog#content}'s param of the same name.
   *        The most straight-forward usage is to provide a string or DOM
   *        element.
   *
   * @param {Object} [options]
   *        Extra options which will be passed on to the {@link ModalDialog}.
   *
   * @return {ModalDialog}
   *         the {@link ModalDialog} that was created
   */


  Player.prototype.createModal = function createModal(content, options) {
    var _this7 = this;

    options = options || {};
    options.content = content || '';

    var modal = new ModalDialog(this, options);

    this.addChild(modal);
    modal.on('dispose', function () {
      _this7.removeChild(modal);
    });

    modal.open();
    return modal;
  };

  /**
   * Gets tag settings
   *
   * @param {Element} tag
   *        The player tag
   *
   * @return {Object}
   *         An object containing all of the settings
   *         for a player tag
   */


  Player.getTagSettings = function getTagSettings(tag) {
    var baseOptions = {
      sources: [],
      tracks: []
    };

    var tagOptions = getAttributes(tag);
    var dataSetup = tagOptions['data-setup'];

    if (hasClass(tag, 'vjs-fluid')) {
      tagOptions.fluid = true;
    }

    // Check if data-setup attr exists.
    if (dataSetup !== null) {
      // Parse options JSON
      // If empty string, make it a parsable json object.
      var _safeParseTuple = safeParseTuple(dataSetup || '{}'),
          err = _safeParseTuple[0],
          data = _safeParseTuple[1];

      if (err) {
        log$1.error(err);
      }
      assign(tagOptions, data);
    }

    assign(baseOptions, tagOptions);

    // Get tag children settings
    if (tag.hasChildNodes()) {
      var children = tag.childNodes;

      for (var i = 0, j = children.length; i < j; i++) {
        var child = children[i];
        // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
        var childName = child.nodeName.toLowerCase();

        if (childName === 'source') {
          baseOptions.sources.push(getAttributes(child));
        } else if (childName === 'track') {
          baseOptions.tracks.push(getAttributes(child));
        }
      }
    }

    return baseOptions;
  };

  /**
   * Determine wether or not flexbox is supported
   *
   * @return {boolean}
   *         - true if flexbox is supported
   *         - false if flexbox is not supported
   */


  Player.prototype.flexNotSupported_ = function flexNotSupported_() {
    var elem = document.createElement('i');

    // Note: We don't actually use flexBasis (or flexOrder), but it's one of the more
    // common flex features that we can rely on when checking for flex support.
    return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style ||
    // IE10-specific (2012 flex spec)
    'msFlexOrder' in elem.style);
  };

  return Player;
}(Component);

/**
 * Get the {@link VideoTrackList}
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist
 *
 * @return {VideoTrackList}
 *         the current video track list
 *
 * @method Player.prototype.videoTracks
 */

/**
 * Get the {@link AudioTrackList}
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist
 *
 * @return {AudioTrackList}
 *         the current audio track list
 *
 * @method Player.prototype.audioTracks
 */

/**
 * Get the {@link TextTrackList}
 *
 * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks
 *
 * @return {TextTrackList}
 *         the current text track list
 *
 * @method Player.prototype.textTracks
 */

/**
 * Get the remote {@link TextTrackList}
 *
 * @return {TextTrackList}
 *         The current remote text track list
 *
 * @method Player.prototype.remoteTextTracks
 */

/**
 * Get the remote {@link HtmlTrackElementList} tracks.
 *
 * @return {HtmlTrackElementList}
 *         The current remote text track element list
 *
 * @method Player.prototype.remoteTextTrackEls
 */

ALL.names.forEach(function (name$$1) {
  var props = ALL[name$$1];

  Player.prototype[props.getterName] = function () {
    if (this.tech_) {
      return this.tech_[props.getterName]();
    }

    // if we have not yet loadTech_, we create {video,audio,text}Tracks_
    // these will be passed to the tech during loading
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});

/**
 * Global player list
 *
 * @type {Object}
 */
Player.players = {};

var navigator = window.navigator;

/*
 * Player instance options, surfaced using options
 * options = Player.prototype.options_
 * Make changes in options, not here.
 *
 * @type {Object}
 * @private
 */
Player.prototype.options_ = {
  // Default order of fallback technology
  techOrder: Tech.defaultTechOrder_,

  html5: {},
  flash: {},

  // default inactivity timeout
  inactivityTimeout: 2000,

  // default playback rates
  playbackRates: [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],

  // Included control sets
  children: ['mediaLoader', 'posterImage', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'controlBar', 'errorDisplay', 'textTrackSettings'],

  language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || 'en',

  // locales and their language translations
  languages: {},

  // Default message to show when a video cannot be played.
  notSupportedMessage: 'No compatible source was found for this media.'
};

[
/**
 * Returns whether or not the player is in the "ended" state.
 *
 * @return {Boolean} True if the player is in the ended state, false if not.
 * @method Player#ended
 */
'ended',
/**
 * Returns whether or not the player is in the "seeking" state.
 *
 * @return {Boolean} True if the player is in the seeking state, false if not.
 * @method Player#seeking
 */
'seeking',
/**
 * Returns the TimeRanges of the media that are currently available
 * for seeking to.
 *
 * @return {TimeRanges} the seekable intervals of the media timeline
 * @method Player#seekable
 */
'seekable',
/**
 * Returns the current state of network activity for the element, from
 * the codes in the list below.
 * - NETWORK_EMPTY (numeric value 0)
 *   The element has not yet been initialised. All attributes are in
 *   their initial states.
 * - NETWORK_IDLE (numeric value 1)
 *   The element's resource selection algorithm is active and has
 *   selected a resource, but it is not actually using the network at
 *   this time.
 * - NETWORK_LOADING (numeric value 2)
 *   The user agent is actively trying to download data.
 * - NETWORK_NO_SOURCE (numeric value 3)
 *   The element's resource selection algorithm is active, but it has
 *   not yet found a resource to use.
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
 * @return {number} the current network activity state
 * @method Player#networkState
 */
'networkState',
/**
 * Returns a value that expresses the current state of the element
 * with respect to rendering the current playback position, from the
 * codes in the list below.
 * - HAVE_NOTHING (numeric value 0)
 *   No information regarding the media resource is available.
 * - HAVE_METADATA (numeric value 1)
 *   Enough of the resource has been obtained that the duration of the
 *   resource is available.
 * - HAVE_CURRENT_DATA (numeric value 2)
 *   Data for the immediate current playback position is available.
 * - HAVE_FUTURE_DATA (numeric value 3)
 *   Data for the immediate current playback position is available, as
 *   well as enough data for the user agent to advance the current
 *   playback position in the direction of playback.
 * - HAVE_ENOUGH_DATA (numeric value 4)
 *   The user agent estimates that enough data is available for
 *   playback to proceed uninterrupted.
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
 * @return {number} the current playback rendering state
 * @method Player#readyState
 */
'readyState'].forEach(function (fn) {
  Player.prototype[fn] = function () {
    return this.techGet_(fn);
  };
});

TECH_EVENTS_RETRIGGER.forEach(function (event) {
  Player.prototype['handleTech' + toTitleCase(event) + '_'] = function () {
    return this.trigger(event);
  };
});

/**
 * Fired when the player has initial duration and dimension information
 *
 * @event Player#loadedmetadata
 * @type {EventTarget~Event}
 */

/**
 * Fired when the player has downloaded data at the current playback position
 *
 * @event Player#loadeddata
 * @type {EventTarget~Event}
 */

/**
 * Fired when the current playback position has changed *
 * During playback this is fired every 15-250 milliseconds, depending on the
 * playback technology in use.
 *
 * @event Player#timeupdate
 * @type {EventTarget~Event}
 */

/**
 * Fired when the volume changes
 *
 * @event Player#volumechange
 * @type {EventTarget~Event}
 */

/**
 * Reports whether or not a player has a plugin available.
 *
 * This does not report whether or not the plugin has ever been initialized
 * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.
 *
 * @method Player#hasPlugin
 * @param  {string}  name
 *         The name of a plugin.
 *
 * @return {boolean}
 *         Whether or not this player has the requested plugin available.
 */

/**
 * Reports whether or not a player is using a plugin by name.
 *
 * For basic plugins, this only reports whether the plugin has _ever_ been
 * initialized on this player.
 *
 * @method Player#usingPlugin
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {boolean}
 *         Whether or not this player is using the requested plugin.
 */

Component.registerComponent('Player', Player);

/**
 * @file plugin.js
 */
/**
 * The base plugin name.
 *
 * @private
 * @constant
 * @type {string}
 */
var BASE_PLUGIN_NAME = 'plugin';

/**
 * The key on which a player's active plugins cache is stored.
 *
 * @private
 * @constant
 * @type     {string}
 */
var PLUGIN_CACHE_KEY = 'activePlugins_';

/**
 * Stores registered plugins in a private space.
 *
 * @private
 * @type    {Object}
 */
var pluginStorage = {};

/**
 * Reports whether or not a plugin has been registered.
 *
 * @private
 * @param   {string} name
 *          The name of a plugin.
 *
 * @returns {boolean}
 *          Whether or not the plugin has been registered.
 */
var pluginExists = function pluginExists(name) {
  return pluginStorage.hasOwnProperty(name);
};

/**
 * Get a single registered plugin by name.
 *
 * @private
 * @param   {string} name
 *          The name of a plugin.
 *
 * @returns {Function|undefined}
 *          The plugin (or undefined).
 */
var getPlugin = function getPlugin(name) {
  return pluginExists(name) ? pluginStorage[name] : undefined;
};

/**
 * Marks a plugin as "active" on a player.
 *
 * Also, ensures that the player has an object for tracking active plugins.
 *
 * @private
 * @param   {Player} player
 *          A Video.js player instance.
 *
 * @param   {string} name
 *          The name of a plugin.
 */
var markPluginAsActive = function markPluginAsActive(player, name) {
  player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
  player[PLUGIN_CACHE_KEY][name] = true;
};

/**
 * Triggers a pair of plugin setup events.
 *
 * @private
 * @param  {Player} player
 *         A Video.js player instance.
 *
 * @param  {Plugin~PluginEventHash} hash
 *         A plugin event hash.
 *
 * @param  {Boolean} [before]
 *         If true, prefixes the event name with "before". In other words,
 *         use this to trigger "beforepluginsetup" instead of "pluginsetup".
 */
var triggerSetupEvent = function triggerSetupEvent(player, hash, before) {
  var eventName = (before ? 'before' : '') + 'pluginsetup';

  player.trigger(eventName, hash);
  player.trigger(eventName + ':' + hash.name, hash);
};

/**
 * Takes a basic plugin function and returns a wrapper function which marks
 * on the player that the plugin has been activated.
 *
 * @private
 * @param   {string} name
 *          The name of the plugin.
 *
 * @param   {Function} plugin
 *          The basic plugin.
 *
 * @returns {Function}
 *          A wrapper function for the given plugin.
 */
var createBasicPlugin = function createBasicPlugin(name, plugin) {
  var basicPluginWrapper = function basicPluginWrapper() {

    // We trigger the "beforepluginsetup" and "pluginsetup" events on the player
    // regardless, but we want the hash to be consistent with the hash provided
    // for advanced plugins.
    //
    // The only potentially counter-intuitive thing here is the `instance` in
    // the "pluginsetup" event is the value returned by the `plugin` function.
    triggerSetupEvent(this, { name: name, plugin: plugin, instance: null }, true);

    var instance = plugin.apply(this, arguments);

    markPluginAsActive(this, name);
    triggerSetupEvent(this, { name: name, plugin: plugin, instance: instance });

    return instance;
  };

  Object.keys(plugin).forEach(function (prop) {
    basicPluginWrapper[prop] = plugin[prop];
  });

  return basicPluginWrapper;
};

/**
 * Takes a plugin sub-class and returns a factory function for generating
 * instances of it.
 *
 * This factory function will replace itself with an instance of the requested
 * sub-class of Plugin.
 *
 * @private
 * @param   {string} name
 *          The name of the plugin.
 *
 * @param   {Plugin} PluginSubClass
 *          The advanced plugin.
 *
 * @returns {Function}
 */
var createPluginFactory = function createPluginFactory(name, PluginSubClass) {

  // Add a `name` property to the plugin prototype so that each plugin can
  // refer to itself by name.
  PluginSubClass.prototype.name = name;

  return function () {
    triggerSetupEvent(this, { name: name, plugin: PluginSubClass, instance: null }, true);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var instance = new (Function.prototype.bind.apply(PluginSubClass, [null].concat([this].concat(args))))();

    // The plugin is replaced by a function that returns the current instance.
    this[name] = function () {
      return instance;
    };

    triggerSetupEvent(this, instance.getEventHash());

    return instance;
  };
};

/**
 * Parent class for all advanced plugins.
 *
 * @mixes   module:evented~EventedMixin
 * @mixes   module:stateful~StatefulMixin
 * @fires   Player#beforepluginsetup
 * @fires   Player#beforepluginsetup:$name
 * @fires   Player#pluginsetup
 * @fires   Player#pluginsetup:$name
 * @listens Player#dispose
 * @throws  {Error}
 *          If attempting to instantiate the base {@link Plugin} class
 *          directly instead of via a sub-class.
 */

var Plugin = function () {

  /**
   * Creates an instance of this class.
   *
   * Sub-classes should call `super` to ensure plugins are properly initialized.
   *
   * @param {Player} player
   *        A Video.js player instance.
   */
  function Plugin(player) {
    classCallCheck(this, Plugin);

    if (this.constructor === Plugin) {
      throw new Error('Plugin must be sub-classed; not directly instantiated.');
    }

    this.player = player;

    // Make this object evented, but remove the added `trigger` method so we
    // use the prototype version instead.
    evented(this);
    delete this.trigger;

    stateful(this, this.constructor.defaultState);
    markPluginAsActive(player, this.name);

    // Auto-bind the dispose method so we can use it as a listener and unbind
    // it later easily.
    this.dispose = bind(this, this.dispose);

    // If the player is disposed, dispose the plugin.
    player.on('dispose', this.dispose);
  }

  /**
   * Each event triggered by plugins includes a hash of additional data with
   * conventional properties.
   *
   * This returns that object or mutates an existing hash.
   *
   * @param   {Object} [hash={}]
   *          An object to be used as event an event hash.
   *
   * @returns {Plugin~PluginEventHash}
   *          An event hash object with provided properties mixed-in.
   */


  Plugin.prototype.getEventHash = function getEventHash() {
    var hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    hash.name = this.name;
    hash.plugin = this.constructor;
    hash.instance = this;
    return hash;
  };

  /**
   * Triggers an event on the plugin object and overrides
   * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash={}]
   *          Additional data hash to merge with a
   *          {@link Plugin~PluginEventHash|PluginEventHash}.
   *
   * @returns {boolean}
   *          Whether or not default was prevented.
   */


  Plugin.prototype.trigger = function trigger$$1(event) {
    var hash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return trigger(this.eventBusEl_, event, this.getEventHash(hash));
  };

  /**
   * Handles "statechanged" events on the plugin. No-op by default, override by
   * subclassing.
   *
   * @abstract
   * @param    {Event} e
   *           An event object provided by a "statechanged" event.
   *
   * @param    {Object} e.changes
   *           An object describing changes that occurred with the "statechanged"
   *           event.
   */


  Plugin.prototype.handleStateChanged = function handleStateChanged(e) {};

  /**
   * Disposes a plugin.
   *
   * Subclasses can override this if they want, but for the sake of safety,
   * it's probably best to subscribe the "dispose" event.
   *
   * @fires Plugin#dispose
   */


  Plugin.prototype.dispose = function dispose() {
    var name = this.name,
        player = this.player;

    /**
     * Signals that a advanced plugin is about to be disposed.
     *
     * @event Plugin#dispose
     * @type  {EventTarget~Event}
     */

    this.trigger('dispose');
    this.off();
    player.off('dispose', this.dispose);

    // Eliminate any possible sources of leaking memory by clearing up
    // references between the player and the plugin instance and nulling out
    // the plugin's state and replacing methods with a function that throws.
    player[PLUGIN_CACHE_KEY][name] = false;
    this.player = this.state = null;

    // Finally, replace the plugin name on the player with a new factory
    // function, so that the plugin is ready to be set up again.
    player[name] = createPluginFactory(name, pluginStorage[name]);
  };

  /**
   * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).
   *
   * @param   {string|Function} plugin
   *          If a string, matches the name of a plugin. If a function, will be
   *          tested directly.
   *
   * @returns {boolean}
   *          Whether or not a plugin is a basic plugin.
   */


  Plugin.isBasic = function isBasic(plugin) {
    var p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;

    return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);
  };

  /**
   * Register a Video.js plugin.
   *
   * @param   {string} name
   *          The name of the plugin to be registered. Must be a string and
   *          must not match an existing plugin or a method on the `Player`
   *          prototype.
   *
   * @param   {Function} plugin
   *          A sub-class of `Plugin` or a function for basic plugins.
   *
   * @returns {Function}
   *          For advanced plugins, a factory function for that plugin. For
   *          basic plugins, a wrapper function that initializes the plugin.
   */


  Plugin.registerPlugin = function registerPlugin(name, plugin) {
    if (typeof name !== 'string') {
      throw new Error('Illegal plugin name, "' + name + '", must be a string, was ' + (typeof name === 'undefined' ? 'undefined' : _typeof(name)) + '.');
    }

    if (pluginExists(name)) {
      log$1.warn('A plugin named "' + name + '" already exists. You may want to avoid re-registering plugins!');
    } else if (Player.prototype.hasOwnProperty(name)) {
      throw new Error('Illegal plugin name, "' + name + '", cannot share a name with an existing player method!');
    }

    if (typeof plugin !== 'function') {
      throw new Error('Illegal plugin for "' + name + '", must be a function, was ' + (typeof plugin === 'undefined' ? 'undefined' : _typeof(plugin)) + '.');
    }

    pluginStorage[name] = plugin;

    // Add a player prototype method for all sub-classed plugins (but not for
    // the base Plugin class).
    if (name !== BASE_PLUGIN_NAME) {
      if (Plugin.isBasic(plugin)) {
        Player.prototype[name] = createBasicPlugin(name, plugin);
      } else {
        Player.prototype[name] = createPluginFactory(name, plugin);
      }
    }

    return plugin;
  };

  /**
   * De-register a Video.js plugin.
   *
   * @param {string} name
   *        The name of the plugin to be deregistered.
   */


  Plugin.deregisterPlugin = function deregisterPlugin(name) {
    if (name === BASE_PLUGIN_NAME) {
      throw new Error('Cannot de-register base plugin.');
    }
    if (pluginExists(name)) {
      delete pluginStorage[name];
      delete Player.prototype[name];
    }
  };

  /**
   * Gets an object containing multiple Video.js plugins.
   *
   * @param   {Array} [names]
   *          If provided, should be an array of plugin names. Defaults to _all_
   *          plugin names.
   *
   * @returns {Object|undefined}
   *          An object containing plugin(s) associated with their name(s) or
   *          `undefined` if no matching plugins exist).
   */


  Plugin.getPlugins = function getPlugins() {
    var names = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.keys(pluginStorage);

    var result = void 0;

    names.forEach(function (name) {
      var plugin = getPlugin(name);

      if (plugin) {
        result = result || {};
        result[name] = plugin;
      }
    });

    return result;
  };

  /**
   * Gets a plugin's version, if available
   *
   * @param   {string} name
   *          The name of a plugin.
   *
   * @returns {string}
   *          The plugin's version or an empty string.
   */


  Plugin.getPluginVersion = function getPluginVersion(name) {
    var plugin = getPlugin(name);

    return plugin && plugin.VERSION || '';
  };

  return Plugin;
}();

/**
 * Gets a plugin by name if it exists.
 *
 * @static
 * @method   getPlugin
 * @memberOf Plugin
 * @param    {string} name
 *           The name of a plugin.
 *
 * @returns  {Function|undefined}
 *           The plugin (or `undefined`).
 */


Plugin.getPlugin = getPlugin;

/**
 * The name of the base plugin class as it is registered.
 *
 * @type {string}
 */
Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;

Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);

/**
 * Documented in player.js
 *
 * @ignore
 */
Player.prototype.usingPlugin = function (name) {
  return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
};

/**
 * Documented in player.js
 *
 * @ignore
 */
Player.prototype.hasPlugin = function (name) {
  return !!pluginExists(name);
};

/**
 * Signals that a plugin is about to be set up on a player.
 *
 * @event    Player#beforepluginsetup
 * @type     {Plugin~PluginEventHash}
 */

/**
 * Signals that a plugin is about to be set up on a player - by name. The name
 * is the name of the plugin.
 *
 * @event    Player#beforepluginsetup:$name
 * @type     {Plugin~PluginEventHash}
 */

/**
 * Signals that a plugin has just been set up on a player.
 *
 * @event    Player#pluginsetup
 * @type     {Plugin~PluginEventHash}
 */

/**
 * Signals that a plugin has just been set up on a player - by name. The name
 * is the name of the plugin.
 *
 * @event    Player#pluginsetup:$name
 * @type     {Plugin~PluginEventHash}
 */

/**
 * @typedef  {Object} Plugin~PluginEventHash
 *
 * @property {string} instance
 *           For basic plugins, the return value of the plugin function. For
 *           advanced plugins, the plugin instance on which the event is fired.
 *
 * @property {string} name
 *           The name of the plugin.
 *
 * @property {string} plugin
 *           For basic plugins, the plugin function. For advanced plugins, the
 *           plugin class/constructor.
 */

/**
 * @file extend.js
 * @module extend
 */

/**
 * A combination of node inherits and babel's inherits (after transpile).
 * Both work the same but node adds `super_` to the subClass
 * and Bable adds the superClass as __proto__. Both seem useful.
 *
 * @param {Object} subClass
 *        The class to inherit to
 *
 * @param {Object} superClass
 *        The class to inherit from
 *
 * @private
 */
var _inherits = function _inherits(subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (superClass) {
    // node
    subClass.super_ = superClass;
  }
};

/**
 * Function for subclassing using the same inheritance that
 * videojs uses internally
 *
 * @static
 * @const
 *
 * @param {Object} superClass
 *        The class to inherit from
 *
 * @param {Object} [subClassMethods={}]
 *        The class to inherit to
 *
 * @return {Object}
 *         The new object with subClassMethods that inherited superClass.
 */
var extendFn = function extendFn(superClass) {
  var subClassMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var subClass = function subClass() {
    superClass.apply(this, arguments);
  };

  var methods = {};

  if ((typeof subClassMethods === 'undefined' ? 'undefined' : _typeof(subClassMethods)) === 'object') {
    if (subClassMethods.constructor !== Object.prototype.constructor) {
      subClass = subClassMethods.constructor;
    }
    methods = subClassMethods;
  } else if (typeof subClassMethods === 'function') {
    subClass = subClassMethods;
  }

  _inherits(subClass, superClass);

  // Extend subObj's prototype with functions and other properties from props
  for (var name in methods) {
    if (methods.hasOwnProperty(name)) {
      subClass.prototype[name] = methods[name];
    }
  }

  return subClass;
};

/**
 * @file video.js
 * @module videojs
 */
// Include the built-in techs
// HTML5 Element Shim for IE8
if (typeof HTMLVideoElement === 'undefined' && isReal()) {
  document.createElement('video');
  document.createElement('audio');
  document.createElement('track');
}

/**
 * Doubles as the main function for users to create a player instance and also
 * the main library object.
 * The `videojs` function can be used to initialize or retrieve a player.
  *
 * @param {string|Element} id
 *        Video element or video element ID
 *
 * @param {Object} [options]
 *        Optional options object for config/settings
 *
 * @param {Component~ReadyCallback} [ready]
 *        Optional ready callback
 *
 * @return {Player}
 *         A player instance
 */
function videojs(id, options, ready) {
  var tag = void 0;

  // Allow for element or ID to be passed in
  // String ID
  if (typeof id === 'string') {
    var players = videojs.getPlayers();

    // Adjust for jQuery ID syntax
    if (id.indexOf('#') === 0) {
      id = id.slice(1);
    }

    // If a player instance has already been created for this ID return it.
    if (players[id]) {

      // If options or ready function are passed, warn
      if (options) {
        log$1.warn('Player "' + id + '" is already initialised. Options will not be applied.');
      }

      if (ready) {
        players[id].ready(ready);
      }

      return players[id];
    }

    // Otherwise get element for ID
    tag = $('#' + id);

    // ID is a media element
  } else {
    tag = id;
  }

  // Check for a useable element
  // re: nodeName, could be a box div also
  if (!tag || !tag.nodeName) {
    throw new TypeError('The element or ID supplied is not valid. (videojs)');
  }

  // Element may have a player attr referring to an already created player instance.
  // If so return that otherwise set up a new player below
  if (tag.player || Player.players[tag.playerId]) {
    return tag.player || Player.players[tag.playerId];
  }

  options = options || {};

  videojs.hooks('beforesetup').forEach(function (hookFunction) {
    var opts = hookFunction(tag, mergeOptions(options));

    if (!isObject(opts) || Array.isArray(opts)) {
      log$1.error('please return an object in beforesetup hooks');
      return;
    }

    options = mergeOptions(options, opts);
  });

  var PlayerComponent = Component.getComponent('Player');
  // If not, set up a new player
  var player = new PlayerComponent(tag, options, ready);

  videojs.hooks('setup').forEach(function (hookFunction) {
    return hookFunction(player);
  });

  return player;
}

/**
 * An Object that contains lifecycle hooks as keys which point to an array
 * of functions that are run when a lifecycle is triggered
 */
videojs.hooks_ = {};

/**
 * Get a list of hooks for a specific lifecycle
 * @function videojs.hooks
 *
 * @param {string} type
 *        the lifecyle to get hooks from
 *
 * @param {Function} [fn]
 *        Optionally add a hook to the lifecycle that your are getting.
 *
 * @return {Array}
 *         an array of hooks, or an empty array if there are none.
 */
videojs.hooks = function (type, fn) {
  videojs.hooks_[type] = videojs.hooks_[type] || [];
  if (fn) {
    videojs.hooks_[type] = videojs.hooks_[type].concat(fn);
  }
  return videojs.hooks_[type];
};

/**
 * Add a function hook to a specific videojs lifecycle.
 *
 * @param {string} type
 *        the lifecycle to hook the function to.
 *
 * @param {Function|Function[]}
 *        The function or array of functions to attach.
 */
videojs.hook = function (type, fn) {
  videojs.hooks(type, fn);
};

/**
 * Remove a hook from a specific videojs lifecycle.
 *
 * @param {string} type
 *        the lifecycle that the function hooked to
 *
 * @param {Function} fn
 *        The hooked function to remove
 *
 * @return {boolean}
 *         The function that was removed or undef
 */
videojs.removeHook = function (type, fn) {
  var index = videojs.hooks(type).indexOf(fn);

  if (index <= -1) {
    return false;
  }

  videojs.hooks_[type] = videojs.hooks_[type].slice();
  videojs.hooks_[type].splice(index, 1);

  return true;
};

// Add default styles
if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
  var style = $('.vjs-styles-defaults');

  if (!style) {
    style = createStyleElement('vjs-styles-defaults');
    var head = $('head');

    if (head) {
      head.insertBefore(style, head.firstChild);
    }
    setTextContent(style, '\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid {\n        padding-top: 56.25%\n      }\n    ');
  }
}

// Run Auto-load players
// You have to wait at least once in case this script is loaded after your
// video in the DOM (weird behavior only with minified version)
autoSetupTimeout(1, videojs);

/**
 * Current software version. Follows semver.
 *
 * @type {string}
 */
videojs.VERSION = version;

/**
 * The global options object. These are the settings that take effect
 * if no overrides are specified when the player is created.
 *
 * @type {Object}
 */
videojs.options = Player.prototype.options_;

/**
 * Get an object with the currently created players, keyed by player ID
 *
 * @return {Object}
 *         The created players
 */
videojs.getPlayers = function () {
  return Player.players;
};

/**
 * Expose players object.
 *
 * @memberOf videojs
 * @property {Object} players
 */
videojs.players = Player.players;

/**
 * Get a component class object by name
 *
 * @borrows Component.getComponent as videojs.getComponent
 */
videojs.getComponent = Component.getComponent;

/**
 * Register a component so it can referred to by name. Used when adding to other
 * components, either through addChild `component.addChild('myComponent')` or through
 * default children options  `{ children: ['myComponent'] }`.
 *
 * > NOTE: You could also just initialize the component before adding.
 * `component.addChild(new MyComponent());`
 *
 * @param {string} name
 *        The class name of the component
 *
 * @param {Component} comp
 *        The component class
 *
 * @return {Component}
 *         The newly registered component
 */
videojs.registerComponent = function (name$$1, comp) {
  if (Tech.isTech(comp)) {
    log$1.warn('The ' + name$$1 + ' tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)');
  }

  Component.registerComponent.call(Component, name$$1, comp);
};

/**
 * Get a Tech class object by name
 *
 * @borrows Tech.getTech as videojs.getTech
 */
videojs.getTech = Tech.getTech;

/**
 * Register a Tech so it can referred to by name.
 * This is used in the tech order for the player.
 *
 * @borrows Tech.registerTech as videojs.registerTech
 */
videojs.registerTech = Tech.registerTech;

videojs.use = use;

/**
 * A suite of browser and device tests from {@link browser}.
 *
 * @type {Object}
 * @private
 */
videojs.browser = browser;

/**
 * Whether or not the browser supports touch events. Included for backward
 * compatibility with 4.x, but deprecated. Use `videojs.browser.TOUCH_ENABLED`
 * instead going forward.
 *
 * @deprecated since version 5.0
 * @type {boolean}
 */
videojs.TOUCH_ENABLED = TOUCH_ENABLED;

/**
 * Subclass an existing class
 * Mimics ES6 subclassing with the `extend` keyword
 *
 * @borrows extend:extendFn as videojs.extend
 */
videojs.extend = extendFn;

/**
 * Merge two options objects recursively
 * Performs a deep merge like lodash.merge but **only merges plain objects**
 * (not arrays, elements, anything else)
 * Other values will be copied directly from the second object.
 *
 * @borrows merge-options:mergeOptions as videojs.mergeOptions
 */
videojs.mergeOptions = mergeOptions;

/**
 * Change the context (this) of a function
 *
 * > NOTE: as of v5.0 we require an ES5 shim, so you should use the native
 * `function() {}.bind(newContext);` instead of this.
 *
 * @borrows fn:bind as videojs.bind
 */
videojs.bind = bind;

/**
 * Register a Video.js plugin.
 *
 * @borrows plugin:registerPlugin as videojs.registerPlugin
 * @method registerPlugin
 *
 * @param  {string} name
 *         The name of the plugin to be registered. Must be a string and
 *         must not match an existing plugin or a method on the `Player`
 *         prototype.
 *
 * @param  {Function} plugin
 *         A sub-class of `Plugin` or a function for basic plugins.
 *
 * @return {Function}
 *         For advanced plugins, a factory function for that plugin. For
 *         basic plugins, a wrapper function that initializes the plugin.
 */
videojs.registerPlugin = Plugin.registerPlugin;

/**
 * Deprecated method to register a plugin with Video.js
 *
 * @deprecated
 *        videojs.plugin() is deprecated; use videojs.registerPlugin() instead
 *
 * @param {string} name
 *        The plugin name
 *
 * @param {Plugin|Function} plugin
 *         The plugin sub-class or function
 */
videojs.plugin = function (name$$1, plugin) {
  log$1.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');
  return Plugin.registerPlugin(name$$1, plugin);
};

/**
 * Gets an object containing multiple Video.js plugins.
 *
 * @param  {Array} [names]
 *         If provided, should be an array of plugin names. Defaults to _all_
 *         plugin names.
 *
 * @return {Object|undefined}
 *         An object containing plugin(s) associated with their name(s) or
 *         `undefined` if no matching plugins exist).
 */
videojs.getPlugins = Plugin.getPlugins;

/**
 * Gets a plugin by name if it exists.
 *
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {Function|undefined}
 *         The plugin (or `undefined`).
 */
videojs.getPlugin = Plugin.getPlugin;

/**
 * Gets a plugin's version, if available
 *
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {string}
 *         The plugin's version or an empty string.
 */
videojs.getPluginVersion = Plugin.getPluginVersion;

/**
 * Adding languages so that they're available to all players.
 * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`
 *
 * @param {string} code
 *        The language code or dictionary property
 *
 * @param {Object} data
 *        The data values to be translated
 *
 * @return {Object}
 *         The resulting language dictionary object
 */
videojs.addLanguage = function (code, data) {
  var _mergeOptions;

  code = ('' + code).toLowerCase();

  videojs.options.languages = mergeOptions(videojs.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));

  return videojs.options.languages[code];
};

/**
 * Log messages
 *
 * @borrows log:log as videojs.log
 */
videojs.log = log$1;

/**
 * Creates an emulated TimeRange object.
 *
 * @borrows time-ranges:createTimeRanges as videojs.createTimeRange
 */
/**
 * @borrows time-ranges:createTimeRanges as videojs.createTimeRanges
 */
videojs.createTimeRange = videojs.createTimeRanges = createTimeRanges;

/**
 * Format seconds as a time string, H:MM:SS or M:SS
 * Supplying a guide (in seconds) will force a number of leading zeros
 * to cover the length of the guide
 *
 * @borrows format-time:formatTime as videojs.formatTime
 */
videojs.formatTime = formatTime;

/**
 * Resolve and parse the elements of a URL
 *
 * @borrows url:parseUrl as videojs.parseUrl
 */
videojs.parseUrl = parseUrl;

/**
 * Returns whether the url passed is a cross domain request or not.
 *
 * @borrows url:isCrossOrigin as videojs.isCrossOrigin
 */
videojs.isCrossOrigin = isCrossOrigin;

/**
 * Event target class.
 *
 * @borrows EventTarget as videojs.EventTarget
 */
videojs.EventTarget = EventTarget;

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 *
 * @borrows events:on as videojs.on
 */
videojs.on = on;

/**
 * Trigger a listener only once for an event
 *
 * @borrows events:one as videojs.one
 */
videojs.one = one;

/**
 * Removes event listeners from an element
 *
 * @borrows events:off as videojs.off
 */
videojs.off = off;

/**
 * Trigger an event for an element
 *
 * @borrows events:trigger as videojs.trigger
 */
videojs.trigger = trigger;

/**
 * A cross-browser XMLHttpRequest wrapper. Here's a simple example:
 *
 * @param {Object} options
 *        settings for the request.
 *
 * @return {XMLHttpRequest|XDomainRequest}
 *         The request object.
 *
 * @see https://github.com/Raynos/xhr
 */
videojs.xhr = xhr;

/**
 * TextTrack class
 *
 * @borrows TextTrack as videojs.TextTrack
 */
videojs.TextTrack = TextTrack;

/**
 * export the AudioTrack class so that source handlers can create
 * AudioTracks and then add them to the players AudioTrackList
 *
 * @borrows AudioTrack as videojs.AudioTrack
 */
videojs.AudioTrack = AudioTrack;

/**
 * export the VideoTrack class so that source handlers can create
 * VideoTracks and then add them to the players VideoTrackList
 *
 * @borrows VideoTrack as videojs.VideoTrack
 */
videojs.VideoTrack = VideoTrack;

/**
 * Determines, via duck typing, whether or not a value is a DOM element.
 *
 * @borrows dom:isEl as videojs.isEl
 * @deprecated Use videojs.dom.isEl() instead
 */

/**
 * Determines, via duck typing, whether or not a value is a text node.
 *
 * @borrows dom:isTextNode as videojs.isTextNode
 * @deprecated Use videojs.dom.isTextNode() instead
 */

/**
 * Creates an element and applies properties.
 *
 * @borrows dom:createEl as videojs.createEl
 * @deprecated Use videojs.dom.createEl() instead
 */

/**
 * Check if an element has a CSS class
 *
 * @borrows dom:hasElClass as videojs.hasClass
 * @deprecated Use videojs.dom.hasClass() instead
 */

/**
 * Add a CSS class name to an element
 *
 * @borrows dom:addElClass as videojs.addClass
 * @deprecated Use videojs.dom.addClass() instead
 */

/**
 * Remove a CSS class name from an element
 *
 * @borrows dom:removeElClass as videojs.removeClass
 * @deprecated Use videojs.dom.removeClass() instead
 */

/**
 * Adds or removes a CSS class name on an element depending on an optional
 * condition or the presence/absence of the class name.
 *
 * @borrows dom:toggleElClass as videojs.toggleClass
 * @deprecated Use videojs.dom.toggleClass() instead
 */

/**
 * Apply attributes to an HTML element.
 *
 * @borrows dom:setElAttributes as videojs.setAttribute
 * @deprecated Use videojs.dom.setAttributes() instead
 */

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 *
 * @borrows dom:getElAttributes as videojs.getAttributes
 * @deprecated Use videojs.dom.getAttributes() instead
 */

/**
 * Empties the contents of an element.
 *
 * @borrows dom:emptyEl as videojs.emptyEl
 * @deprecated Use videojs.dom.emptyEl() instead
 */

/**
 * Normalizes and appends content to an element.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * - String
 *   Normalized into a text node.
 *
 * - Element, TextNode
 *   Passed through.
 *
 * - Array
 *   A one-dimensional array of strings, elements, nodes, or functions (which
 *   return single strings, elements, or nodes).
 *
 * - Function
 *   If the sole argument, is expected to produce a string, element,
 *   node, or array.
 *
 * @borrows dom:appendContents as videojs.appendContet
 * @deprecated Use videojs.dom.appendContent() instead
 */

/**
 * Normalizes and inserts content into an element; this is identical to
 * `appendContent()`, except it empties the element first.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * - String
 *   Normalized into a text node.
 *
 * - Element, TextNode
 *   Passed through.
 *
 * - Array
 *   A one-dimensional array of strings, elements, nodes, or functions (which
 *   return single strings, elements, or nodes).
 *
 * - Function
 *   If the sole argument, is expected to produce a string, element,
 *   node, or array.
 *
 * @borrows dom:insertContent as videojs.insertContent
 * @deprecated Use videojs.dom.insertContent() instead
 */
['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(function (k) {
  videojs[k] = function () {
    log$1.warn('videojs.' + k + '() is deprecated; use videojs.dom.' + k + '() instead');
    return Dom[k].apply(null, arguments);
  };
});

/**
 * A safe getComputedStyle with an IE8 fallback.
 *
 * This is because in Firefox, if the player is loaded in an iframe with `display:none`,
 * then `getComputedStyle` returns `null`, so, we do a null-check to make sure
 * that the player doesn't break in these cases.
 * See https://bugzilla.mozilla.org/show_bug.cgi?id=548397 for more details.
 *
 * @borrows computed-style:computedStyle as videojs.computedStyle
 */
videojs.computedStyle = computedStyle;

/**
 * Export the Dom utilities for use in external plugins
 * and Tech's
 */
videojs.dom = Dom;

/**
 * Export the Url utilities for use in external plugins
 * and Tech's
 */
videojs.url = Url;

module.exports = videojs;

},{"global/document":41,"global/window":42,"safe-json-parse/tuple":45,"tsml":47,"videojs-vtt.js":49,"xhr":53}],49:[function(require,module,exports){
/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Default exports for Node. Export the extended versions of VTTCue and
// VTTRegion in Node since we likely want the capability to convert back and
// forth between JSON. If we don't then it's not that big of a deal since we're
// off browser.

var window = require('global/window');

var vttjs = module.exports = {
  WebVTT: require("./vtt.js"),
  VTTCue: require("./vttcue.js"),
  VTTRegion: require("./vttregion.js")
};

window.vttjs = vttjs;
window.WebVTT = vttjs.WebVTT;

var cueShim = vttjs.VTTCue;
var regionShim = vttjs.VTTRegion;
var nativeVTTCue = window.VTTCue;
var nativeVTTRegion = window.VTTRegion;

vttjs.shim = function() {
  window.VTTCue = cueShim;
  window.VTTRegion = regionShim;
};

vttjs.restore = function() {
  window.VTTCue = nativeVTTCue;
  window.VTTRegion = nativeVTTRegion;
};

if (!window.VTTCue) {
  vttjs.shim();
}

},{"./vtt.js":50,"./vttcue.js":51,"./vttregion.js":52,"global/window":42}],50:[function(require,module,exports){
/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
var _objCreate = Object.create || (function() {
  function F() {}
  return function(o) {
    if (arguments.length !== 1) {
      throw new Error('Object.create shim only accepts one parameter.');
    }
    F.prototype = o;
    return new F();
  };
})();

// Creates a new ParserError object from an errorData object. The errorData
// object should have default code and message properties. The default message
// property can be overriden by passing in a message parameter.
// See ParsingError.Errors below for acceptable errors.
function ParsingError(errorData, message) {
  this.name = "ParsingError";
  this.code = errorData.code;
  this.message = message || errorData.message;
}
ParsingError.prototype = _objCreate(Error.prototype);
ParsingError.prototype.constructor = ParsingError;

// ParsingError metadata for acceptable ParsingErrors.
ParsingError.Errors = {
  BadSignature: {
    code: 0,
    message: "Malformed WebVTT signature."
  },
  BadTimeStamp: {
    code: 1,
    message: "Malformed time stamp."
  }
};

// Try to parse input as a time stamp.
function parseTimeStamp(input) {

  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) {
    return null;
  }

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0,  m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = _objCreate(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function(k, v) {
    if (!this.get(k) && v !== "") {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }
    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function(k, v) {
    if (/^-?\d+$/.test(v)) { // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function(k, v) {
    var m;
    if ((m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/))) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== "string") {
      continue;
    }
    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }
    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) {
      throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                            "Malformed timestamp: " + oInput);
    }
    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, "");
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
      case "region":
        // Find the last region we parsed with the same region id.
        for (var i = regionList.length - 1; i >= 0; i--) {
          if (regionList[i].id === v) {
            settings.set(k, regionList[i].region);
            break;
          }
        }
        break;
      case "vertical":
        settings.alt(k, v, ["rl", "lr"]);
        break;
      case "line":
        var vals = v.split(","),
            vals0 = vals[0];
        settings.integer(k, vals0);
        settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
        settings.alt(k, vals0, ["auto"]);
        if (vals.length === 2) {
          settings.alt("lineAlign", vals[1], ["start", "middle", "end"]);
        }
        break;
      case "position":
        vals = v.split(",");
        settings.percent(k, vals[0]);
        if (vals.length === 2) {
          settings.alt("positionAlign", vals[1], ["start", "middle", "end"]);
        }
        break;
      case "size":
        settings.percent(k, v);
        break;
      case "align":
        settings.alt(k, v, ["start", "middle", "end", "left", "right"]);
        break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get("region", null);
    cue.vertical = settings.get("vertical", "");
    cue.line = settings.get("line", "auto");
    cue.lineAlign = settings.get("lineAlign", "start");
    cue.snapToLines = settings.get("snapToLines", true);
    cue.size = settings.get("size", 100);
    cue.align = settings.get("align", "middle");
    cue.position = settings.get("position", {
      start: 0,
      left: 0,
      middle: 50,
      end: 100,
      right: 100
    }, cue.align);
    cue.positionAlign = settings.get("positionAlign", {
      start: "start",
      left: "start",
      middle: "middle",
      end: "end",
      right: "end"
    }, cue.align);
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, "");
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp();   // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== "-->") {     // (3) next characters must match "-->"
    throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                           "Malformed time stamp (time stamps must be separated by '-->'): " +
                           oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp();     // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

var ESCAPE = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&lrm;": "\u200e",
  "&rlm;": "\u200f",
  "&nbsp;": "\u00a0"
};

var TAG_NAME = {
  c: "span",
  i: "i",
  b: "b",
  u: "u",
  ruby: "ruby",
  rt: "rt",
  v: "span",
  lang: "span"
};

var TAG_ANNOTATION = {
  v: "title",
  lang: "lang"
};

var NEEDS_PARENT = {
  rt: "ruby"
};

// Parse content into a document fragment.
function parseContent(window, input) {
  function nextToken() {
    // Check for end-of-string.
    if (!input) {
      return null;
    }

    // Consume 'n' characters from the input.
    function consume(result) {
      input = input.substr(result.length);
      return result;
    }

    var m = input.match(/^([^<]*)(<[^>]+>?)?/);
    // If there is some text before the next tag, return it, otherwise return
    // the tag.
    return consume(m[1] ? m[1] : m[2]);
  }

  // Unescape a string 's'.
  function unescape1(e) {
    return ESCAPE[e];
  }
  function unescape(s) {
    while ((m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/))) {
      s = s.replace(m[0], unescape1);
    }
    return s;
  }

  function shouldAdd(current, element) {
    return !NEEDS_PARENT[element.localName] ||
           NEEDS_PARENT[element.localName] === current.localName;
  }

  // Create an element for this tag.
  function createElement(type, annotation) {
    var tagName = TAG_NAME[type];
    if (!tagName) {
      return null;
    }
    var element = window.document.createElement(tagName);
    element.localName = tagName;
    var name = TAG_ANNOTATION[type];
    if (name && annotation) {
      element[name] = annotation.trim();
    }
    return element;
  }

  var rootDiv = window.document.createElement("div"),
      current = rootDiv,
      t,
      tagStack = [];

  while ((t = nextToken()) !== null) {
    if (t[0] === '<') {
      if (t[1] === "/") {
        // If the closing tag matches, move back up to the parent node.
        if (tagStack.length &&
            tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
          tagStack.pop();
          current = current.parentNode;
        }
        // Otherwise just ignore the end tag.
        continue;
      }
      var ts = parseTimeStamp(t.substr(1, t.length - 2));
      var node;
      if (ts) {
        // Timestamps are lead nodes as well.
        node = window.document.createProcessingInstruction("timestamp", ts);
        current.appendChild(node);
        continue;
      }
      var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
      // If we can't parse the tag, skip to the next tag.
      if (!m) {
        continue;
      }
      // Try to construct an element, and ignore the tag if we couldn't.
      node = createElement(m[1], m[3]);
      if (!node) {
        continue;
      }
      // Determine if the tag should be added based on the context of where it
      // is placed in the cuetext.
      if (!shouldAdd(current, node)) {
        continue;
      }
      // Set the class list (as a list of classes, separated by space).
      if (m[2]) {
        node.className = m[2].substr(1).replace('.', ' ');
      }
      // Append the node to the current node, and enter the scope of the new
      // node.
      tagStack.push(m[1]);
      current.appendChild(node);
      current = node;
      continue;
    }

    // Text nodes are leaf nodes.
    current.appendChild(window.document.createTextNode(unescape(t)));
  }

  return rootDiv;
}

// This is a list of all the Unicode characters that have a strong
// right-to-left category. What this means is that these characters are
// written right-to-left for sure. It was generated by pulling all the strong
// right-to-left characters out of the Unicode data table. That table can
// found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt
var strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6],
 [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d],
 [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6],
 [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5],
 [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815],
 [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858],
 [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f],
 [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c],
 [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1],
 [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc],
 [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808],
 [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855],
 [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f],
 [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13],
 [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58],
 [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72],
 [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f],
 [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32],
 [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42],
 [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f],
 [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59],
 [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62],
 [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77],
 [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b],
 [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];

function isStrongRTLChar(charCode) {
  for (var i = 0; i < strongRTLRanges.length; i++) {
    var currentRange = strongRTLRanges[i];
    if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
      return true;
    }
  }

  return false;
}

function determineBidi(cueDiv) {
  var nodeStack = [],
      text = "",
      charCode;

  if (!cueDiv || !cueDiv.childNodes) {
    return "ltr";
  }

  function pushNodes(nodeStack, node) {
    for (var i = node.childNodes.length - 1; i >= 0; i--) {
      nodeStack.push(node.childNodes[i]);
    }
  }

  function nextTextNode(nodeStack) {
    if (!nodeStack || !nodeStack.length) {
      return null;
    }

    var node = nodeStack.pop(),
        text = node.textContent || node.innerText;
    if (text) {
      // TODO: This should match all unicode type B characters (paragraph
      // separator characters). See issue #115.
      var m = text.match(/^.*(\n|\r)/);
      if (m) {
        nodeStack.length = 0;
        return m[0];
      }
      return text;
    }
    if (node.tagName === "ruby") {
      return nextTextNode(nodeStack);
    }
    if (node.childNodes) {
      pushNodes(nodeStack, node);
      return nextTextNode(nodeStack);
    }
  }

  pushNodes(nodeStack, cueDiv);
  while ((text = nextTextNode(nodeStack))) {
    for (var i = 0; i < text.length; i++) {
      charCode = text.charCodeAt(i);
      if (isStrongRTLChar(charCode)) {
        return "rtl";
      }
    }
  }
  return "ltr";
}

function computeLinePos(cue) {
  if (typeof cue.line === "number" &&
      (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {
    return cue.line;
  }
  if (!cue.track || !cue.track.textTrackList ||
      !cue.track.textTrackList.mediaElement) {
    return -1;
  }
  var track = cue.track,
      trackList = track.textTrackList,
      count = 0;
  for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
    if (trackList[i].mode === "showing") {
      count++;
    }
  }
  return ++count * -1;
}

function StyleBox() {
}

// Apply styles to a div. If there is no div passed then it defaults to the
// div on 'this'.
StyleBox.prototype.applyStyles = function(styles, div) {
  div = div || this.div;
  for (var prop in styles) {
    if (styles.hasOwnProperty(prop)) {
      div.style[prop] = styles[prop];
    }
  }
};

StyleBox.prototype.formatStyle = function(val, unit) {
  return val === 0 ? 0 : val + unit;
};

// Constructs the computed display state of the cue (a div). Places the div
// into the overlay which should be a block level element (usually a div).
function CueStyleBox(window, cue, styleOptions) {
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
  var color = "rgba(255, 255, 255, 1)";
  var backgroundColor = "rgba(0, 0, 0, 0.8)";

  if (isIE8) {
    color = "rgb(255, 255, 255)";
    backgroundColor = "rgb(0, 0, 0)";
  }

  StyleBox.call(this);
  this.cue = cue;

  // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will
  // have inline positioning and will function as the cue background box.
  this.cueDiv = parseContent(window, cue.text);
  var styles = {
    color: color,
    backgroundColor: backgroundColor,
    position: "relative",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    display: "inline"
  };

  if (!isIE8) {
    styles.writingMode = cue.vertical === "" ? "horizontal-tb"
                                             : cue.vertical === "lr" ? "vertical-lr"
                                                                     : "vertical-rl";
    styles.unicodeBidi = "plaintext";
  }
  this.applyStyles(styles, this.cueDiv);

  // Create an absolutely positioned div that will be used to position the cue
  // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS
  // mirrors of them except "middle" which is "center" in CSS.
  this.div = window.document.createElement("div");
  styles = {
    textAlign: cue.align === "middle" ? "center" : cue.align,
    font: styleOptions.font,
    whiteSpace: "pre-line",
    position: "absolute"
  };

  if (!isIE8) {
    styles.direction = determineBidi(this.cueDiv);
    styles.writingMode = cue.vertical === "" ? "horizontal-tb"
                                             : cue.vertical === "lr" ? "vertical-lr"
                                                                     : "vertical-rl".
    stylesunicodeBidi =  "plaintext";
  }

  this.applyStyles(styles);

  this.div.appendChild(this.cueDiv);

  // Calculate the distance from the reference edge of the viewport to the text
  // position of the cue box. The reference edge will be resolved later when
  // the box orientation styles are applied.
  var textPos = 0;
  switch (cue.positionAlign) {
  case "start":
    textPos = cue.position;
    break;
  case "middle":
    textPos = cue.position - (cue.size / 2);
    break;
  case "end":
    textPos = cue.position - cue.size;
    break;
  }

  // Horizontal box orientation; textPos is the distance from the left edge of the
  // area to the left edge of the box and cue.size is the distance extending to
  // the right from there.
  if (cue.vertical === "") {
    this.applyStyles({
      left:  this.formatStyle(textPos, "%"),
      width: this.formatStyle(cue.size, "%")
    });
  // Vertical box orientation; textPos is the distance from the top edge of the
  // area to the top edge of the box and cue.size is the height extending
  // downwards from there.
  } else {
    this.applyStyles({
      top: this.formatStyle(textPos, "%"),
      height: this.formatStyle(cue.size, "%")
    });
  }

  this.move = function(box) {
    this.applyStyles({
      top: this.formatStyle(box.top, "px"),
      bottom: this.formatStyle(box.bottom, "px"),
      left: this.formatStyle(box.left, "px"),
      right: this.formatStyle(box.right, "px"),
      height: this.formatStyle(box.height, "px"),
      width: this.formatStyle(box.width, "px")
    });
  };
}
CueStyleBox.prototype = _objCreate(StyleBox.prototype);
CueStyleBox.prototype.constructor = CueStyleBox;

// Represents the co-ordinates of an Element in a way that we can easily
// compute things with such as if it overlaps or intersects with another Element.
// Can initialize it with either a StyleBox or another BoxPosition.
function BoxPosition(obj) {
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);

  // Either a BoxPosition was passed in and we need to copy it, or a StyleBox
  // was passed in and we need to copy the results of 'getBoundingClientRect'
  // as the object returned is readonly. All co-ordinate values are in reference
  // to the viewport origin (top left).
  var lh, height, width, top;
  if (obj.div) {
    height = obj.div.offsetHeight;
    width = obj.div.offsetWidth;
    top = obj.div.offsetTop;

    var rects = (rects = obj.div.childNodes) && (rects = rects[0]) &&
                rects.getClientRects && rects.getClientRects();
    obj = obj.div.getBoundingClientRect();
    // In certain cases the outter div will be slightly larger then the sum of
    // the inner div's lines. This could be due to bold text, etc, on some platforms.
    // In this case we should get the average line height and use that. This will
    // result in the desired behaviour.
    lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length)
               : 0;

  }
  this.left = obj.left;
  this.right = obj.right;
  this.top = obj.top || top;
  this.height = obj.height || height;
  this.bottom = obj.bottom || (top + (obj.height || height));
  this.width = obj.width || width;
  this.lineHeight = lh !== undefined ? lh : obj.lineHeight;

  if (isIE8 && !this.lineHeight) {
    this.lineHeight = 13;
  }
}

// Move the box along a particular axis. Optionally pass in an amount to move
// the box. If no amount is passed then the default is the line height of the
// box.
BoxPosition.prototype.move = function(axis, toMove) {
  toMove = toMove !== undefined ? toMove : this.lineHeight;
  switch (axis) {
  case "+x":
    this.left += toMove;
    this.right += toMove;
    break;
  case "-x":
    this.left -= toMove;
    this.right -= toMove;
    break;
  case "+y":
    this.top += toMove;
    this.bottom += toMove;
    break;
  case "-y":
    this.top -= toMove;
    this.bottom -= toMove;
    break;
  }
};

// Check if this box overlaps another box, b2.
BoxPosition.prototype.overlaps = function(b2) {
  return this.left < b2.right &&
         this.right > b2.left &&
         this.top < b2.bottom &&
         this.bottom > b2.top;
};

// Check if this box overlaps any other boxes in boxes.
BoxPosition.prototype.overlapsAny = function(boxes) {
  for (var i = 0; i < boxes.length; i++) {
    if (this.overlaps(boxes[i])) {
      return true;
    }
  }
  return false;
};

// Check if this box is within another box.
BoxPosition.prototype.within = function(container) {
  return this.top >= container.top &&
         this.bottom <= container.bottom &&
         this.left >= container.left &&
         this.right <= container.right;
};

// Check if this box is entirely within the container or it is overlapping
// on the edge opposite of the axis direction passed. For example, if "+x" is
// passed and the box is overlapping on the left edge of the container, then
// return true.
BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
  switch (axis) {
  case "+x":
    return this.left < container.left;
  case "-x":
    return this.right > container.right;
  case "+y":
    return this.top < container.top;
  case "-y":
    return this.bottom > container.bottom;
  }
};

// Find the percentage of the area that this box is overlapping with another
// box.
BoxPosition.prototype.intersectPercentage = function(b2) {
  var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),
      y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),
      intersectArea = x * y;
  return intersectArea / (this.height * this.width);
};

// Convert the positions from this box to CSS compatible positions using
// the reference container's positions. This has to be done because this
// box's positions are in reference to the viewport origin, whereas, CSS
// values are in referecne to their respective edges.
BoxPosition.prototype.toCSSCompatValues = function(reference) {
  return {
    top: this.top - reference.top,
    bottom: reference.bottom - this.bottom,
    left: this.left - reference.left,
    right: reference.right - this.right,
    height: this.height,
    width: this.width
  };
};

// Get an object that represents the box's position without anything extra.
// Can pass a StyleBox, HTMLElement, or another BoxPositon.
BoxPosition.getSimpleBoxPosition = function(obj) {
  var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
  var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
  var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;

  obj = obj.div ? obj.div.getBoundingClientRect() :
                obj.tagName ? obj.getBoundingClientRect() : obj;
  var ret = {
    left: obj.left,
    right: obj.right,
    top: obj.top || top,
    height: obj.height || height,
    bottom: obj.bottom || (top + (obj.height || height)),
    width: obj.width || width
  };
  return ret;
};

// Move a StyleBox to its specified, or next best, position. The containerBox
// is the box that contains the StyleBox, such as a div. boxPositions are
// a list of other boxes that the styleBox can't overlap with.
function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {

  // Find the best position for a cue box, b, on the video. The axis parameter
  // is a list of axis, the order of which, it will move the box along. For example:
  // Passing ["+x", "-x"] will move the box first along the x axis in the positive
  // direction. If it doesn't find a good position for it there it will then move
  // it along the x axis in the negative direction.
  function findBestPosition(b, axis) {
    var bestPosition,
        specifiedPosition = new BoxPosition(b),
        percentage = 1; // Highest possible so the first thing we get is better.

    for (var i = 0; i < axis.length; i++) {
      while (b.overlapsOppositeAxis(containerBox, axis[i]) ||
             (b.within(containerBox) && b.overlapsAny(boxPositions))) {
        b.move(axis[i]);
      }
      // We found a spot where we aren't overlapping anything. This is our
      // best position.
      if (b.within(containerBox)) {
        return b;
      }
      var p = b.intersectPercentage(containerBox);
      // If we're outside the container box less then we were on our last try
      // then remember this position as the best position.
      if (percentage > p) {
        bestPosition = new BoxPosition(b);
        percentage = p;
      }
      // Reset the box position to the specified position.
      b = new BoxPosition(specifiedPosition);
    }
    return bestPosition || specifiedPosition;
  }

  var boxPosition = new BoxPosition(styleBox),
      cue = styleBox.cue,
      linePos = computeLinePos(cue),
      axis = [];

  // If we have a line number to align the cue to.
  if (cue.snapToLines) {
    var size;
    switch (cue.vertical) {
    case "":
      axis = [ "+y", "-y" ];
      size = "height";
      break;
    case "rl":
      axis = [ "+x", "-x" ];
      size = "width";
      break;
    case "lr":
      axis = [ "-x", "+x" ];
      size = "width";
      break;
    }

    var step = boxPosition.lineHeight,
        position = step * Math.round(linePos),
        maxPosition = containerBox[size] + step,
        initialAxis = axis[0];

    // If the specified intial position is greater then the max position then
    // clamp the box to the amount of steps it would take for the box to
    // reach the max position.
    if (Math.abs(position) > maxPosition) {
      position = position < 0 ? -1 : 1;
      position *= Math.ceil(maxPosition / step) * step;
    }

    // If computed line position returns negative then line numbers are
    // relative to the bottom of the video instead of the top. Therefore, we
    // need to increase our initial position by the length or width of the
    // video, depending on the writing direction, and reverse our axis directions.
    if (linePos < 0) {
      position += cue.vertical === "" ? containerBox.height : containerBox.width;
      axis = axis.reverse();
    }

    // Move the box to the specified position. This may not be its best
    // position.
    boxPosition.move(initialAxis, position);

  } else {
    // If we have a percentage line value for the cue.
    var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;

    switch (cue.lineAlign) {
    case "middle":
      linePos -= (calculatedPercentage / 2);
      break;
    case "end":
      linePos -= calculatedPercentage;
      break;
    }

    // Apply initial line position to the cue box.
    switch (cue.vertical) {
    case "":
      styleBox.applyStyles({
        top: styleBox.formatStyle(linePos, "%")
      });
      break;
    case "rl":
      styleBox.applyStyles({
        left: styleBox.formatStyle(linePos, "%")
      });
      break;
    case "lr":
      styleBox.applyStyles({
        right: styleBox.formatStyle(linePos, "%")
      });
      break;
    }

    axis = [ "+y", "-x", "+x", "-y" ];

    // Get the box position again after we've applied the specified positioning
    // to it.
    boxPosition = new BoxPosition(styleBox);
  }

  var bestPosition = findBestPosition(boxPosition, axis);
  styleBox.move(bestPosition.toCSSCompatValues(containerBox));
}

function WebVTT() {
  // Nothing
}

// Helper to allow strings to be decoded instead of the default binary utf8 data.
WebVTT.StringDecoder = function() {
  return {
    decode: function(data) {
      if (!data) {
        return "";
      }
      if (typeof data !== "string") {
        throw new Error("Error - expected string data.");
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  };
};

WebVTT.convertCueToDOMTree = function(window, cuetext) {
  if (!window || !cuetext) {
    return null;
  }
  return parseContent(window, cuetext);
};

var FONT_SIZE_PERCENT = 0.05;
var FONT_STYLE = "sans-serif";
var CUE_BACKGROUND_PADDING = "1.5%";

// Runs the processing model over the cues and regions passed to it.
// @param overlay A block level element (usually a div) that the computed cues
//                and regions will be placed into.
WebVTT.processCues = function(window, cues, overlay) {
  if (!window || !cues || !overlay) {
    return null;
  }

  // Remove all previous children.
  while (overlay.firstChild) {
    overlay.removeChild(overlay.firstChild);
  }

  var paddedOverlay = window.document.createElement("div");
  paddedOverlay.style.position = "absolute";
  paddedOverlay.style.left = "0";
  paddedOverlay.style.right = "0";
  paddedOverlay.style.top = "0";
  paddedOverlay.style.bottom = "0";
  paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
  overlay.appendChild(paddedOverlay);

  // Determine if we need to compute the display states of the cues. This could
  // be the case if a cue's state has been changed since the last computation or
  // if it has not been computed yet.
  function shouldCompute(cues) {
    for (var i = 0; i < cues.length; i++) {
      if (cues[i].hasBeenReset || !cues[i].displayState) {
        return true;
      }
    }
    return false;
  }

  // We don't need to recompute the cues' display states. Just reuse them.
  if (!shouldCompute(cues)) {
    for (var i = 0; i < cues.length; i++) {
      paddedOverlay.appendChild(cues[i].displayState);
    }
    return;
  }

  var boxPositions = [],
      containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),
      fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
  var styleOptions = {
    font: fontSize + "px " + FONT_STYLE
  };

  (function() {
    var styleBox, cue;

    for (var i = 0; i < cues.length; i++) {
      cue = cues[i];

      // Compute the intial position and styles of the cue div.
      styleBox = new CueStyleBox(window, cue, styleOptions);
      paddedOverlay.appendChild(styleBox.div);

      // Move the cue div to it's correct line position.
      moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);

      // Remember the computed div so that we don't have to recompute it later
      // if we don't have too.
      cue.displayState = styleBox.div;

      boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
    }
  })();
};

WebVTT.Parser = function(window, vttjs, decoder) {
  if (!decoder) {
    decoder = vttjs;
    vttjs = {};
  }
  if (!vttjs) {
    vttjs = {};
  }

  this.window = window;
  this.vttjs = vttjs;
  this.state = "INITIAL";
  this.buffer = "";
  this.decoder = decoder || new TextDecoder("utf8");
  this.regionList = [];
};

WebVTT.Parser.prototype = {
  // If the error is a ParsingError then report it to the consumer if
  // possible. If it's not a ParsingError then throw it like normal.
  reportOrThrowError: function(e) {
    if (e instanceof ParsingError) {
      this.onparsingerror && this.onparsingerror(e);
    } else {
      throw e;
    }
  },
  parse: function (data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, {stream: true});
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;
      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }
      var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') {
        ++pos;
      }
      if (buffer[pos] === '\n') {
        ++pos;
      }
      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.4 WebVTT region and WebVTT region settings syntax
    function parseRegion(input) {
      var settings = new Settings();

      parseOptions(input, function (k, v) {
        switch (k) {
        case "id":
          settings.set(k, v);
          break;
        case "width":
          settings.percent(k, v);
          break;
        case "lines":
          settings.integer(k, v);
          break;
        case "regionanchor":
        case "viewportanchor":
          var xy = v.split(',');
          if (xy.length !== 2) {
            break;
          }
          // We have to make sure both x and y parse, so use a temporary
          // settings object here.
          var anchor = new Settings();
          anchor.percent("x", xy[0]);
          anchor.percent("y", xy[1]);
          if (!anchor.has("x") || !anchor.has("y")) {
            break;
          }
          settings.set(k + "X", anchor.get("x"));
          settings.set(k + "Y", anchor.get("y"));
          break;
        case "scroll":
          settings.alt(k, v, ["up"]);
          break;
        }
      }, /=/, /\s/);

      // Create the region, using default values for any values that were not
      // specified.
      if (settings.has("id")) {
        var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();
        region.width = settings.get("width", 100);
        region.lines = settings.get("lines", 3);
        region.regionAnchorX = settings.get("regionanchorX", 0);
        region.regionAnchorY = settings.get("regionanchorY", 100);
        region.viewportAnchorX = settings.get("viewportanchorX", 0);
        region.viewportAnchorY = settings.get("viewportanchorY", 100);
        region.scroll = settings.get("scroll", "");
        // Register the region.
        self.onregion && self.onregion(region);
        // Remember the VTTRegion for later in case we parse any VTTCues that
        // reference it.
        self.regionList.push({
          id: settings.get("id"),
          region: region
        });
      }
    }

    // draft-pantos-http-live-streaming-20
    // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5
    // 3.5 WebVTT
    function parseTimestampMap(input) {
      var settings = new Settings();

      parseOptions(input, function(k, v) {
        switch(k) {
        case "MPEGT":
          settings.integer(k + 'S', v);
          break;
        case "LOCA":
          settings.set(k + 'L', parseTimeStamp(v));
          break;
        }
      }, /[^\d]:/, /,/);

      self.ontimestampmap && self.ontimestampmap({
        "MPEGTS": settings.get("MPEGTS"),
        "LOCAL": settings.get("LOCAL")
      });
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      if (input.match(/X-TIMESTAMP-MAP/)) {
        // This line contains HLS X-TIMESTAMP-MAP metadata
        parseOptions(input, function(k, v) {
          switch(k) {
          case "X-TIMESTAMP-MAP":
            parseTimestampMap(v);
            break;
          }
        }, /=/);
      } else {
        parseOptions(input, function (k, v) {
          switch (k) {
          case "Region":
            // 3.3 WebVTT region metadata header syntax
            parseRegion(v);
            break;
          }
        }, /:/);
      }

    }

    // 5.1 WebVTT file parsing.
    try {
      var line;
      if (self.state === "INITIAL") {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        line = collectNextLine();

        var m = line.match(/^WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new ParsingError(ParsingError.Errors.BadSignature);
        }

        self.state = "HEADER";
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (self.state) {
        case "HEADER":
          // 13-18 - Allow a header (metadata) under the WEBVTT line.
          if (/:/.test(line)) {
            parseHeader(line);
          } else if (!line) {
            // An empty line terminates the header and starts the body (cues).
            self.state = "ID";
          }
          continue;
        case "NOTE":
          // Ignore NOTE blocks.
          if (!line) {
            self.state = "ID";
          }
          continue;
        case "ID":
          // Check for the start of NOTE blocks.
          if (/^NOTE($|[ \t])/.test(line)) {
            self.state = "NOTE";
            break;
          }
          // 19-29 - Allow any number of line terminators, then initialize new cue values.
          if (!line) {
            continue;
          }
          self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, "");
          self.state = "CUE";
          // 30-39 - Check if self line contains an optional identifier or timing data.
          if (line.indexOf("-->") === -1) {
            self.cue.id = line;
            continue;
          }
          // Process line as start of a cue.
          /*falls through*/
        case "CUE":
          // 40 - Collect cue timings and settings.
          try {
            parseCue(line, self.cue, self.regionList);
          } catch (e) {
            self.reportOrThrowError(e);
            // In case of an error ignore rest of the cue.
            self.cue = null;
            self.state = "BADCUE";
            continue;
          }
          self.state = "CUETEXT";
          continue;
        case "CUETEXT":
          var hasSubstring = line.indexOf("-->") !== -1;
          // 34 - If we have an empty line then report the cue.
          // 35 - If we have the special substring '-->' then report the cue,
          // but do not collect the line as we need to process the current
          // one as a new cue.
          if (!line || hasSubstring && (alreadyCollectedLine = true)) {
            // We are done parsing self cue.
            self.oncue && self.oncue(self.cue);
            self.cue = null;
            self.state = "ID";
            continue;
          }
          if (self.cue.text) {
            self.cue.text += "\n";
          }
          self.cue.text += line;
          continue;
        case "BADCUE": // BADCUE
          // 54-62 - Collect and discard the remaining cue.
          if (!line) {
            self.state = "ID";
          }
          continue;
        }
      }
    } catch (e) {
      self.reportOrThrowError(e);

      // If we are currently parsing a cue, report what we have.
      if (self.state === "CUETEXT" && self.cue && self.oncue) {
        self.oncue(self.cue);
      }
      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  },
  flush: function () {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === "HEADER") {
        self.buffer += "\n\n";
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === "INITIAL") {
        throw new ParsingError(ParsingError.Errors.BadSignature);
      }
    } catch(e) {
      self.reportOrThrowError(e);
    }
    self.onflush && self.onflush();
    return this;
  }
};

module.exports = WebVTT;

},{}],51:[function(require,module,exports){
/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var autoKeyword = "auto";
var directionSetting = {
  "": true,
  "lr": true,
  "rl": true
};
var alignSetting = {
  "start": true,
  "middle": true,
  "end": true,
  "left": true,
  "right": true
};

function findDirectionSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var dir = directionSetting[value.toLowerCase()];
  return dir ? value.toLowerCase() : false;
}

function findAlignSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var align = alignSetting[value.toLowerCase()];
  return align ? value.toLowerCase() : false;
}

function extend(obj) {
  var i = 1;
  for (; i < arguments.length; i++) {
    var cobj = arguments[i];
    for (var p in cobj) {
      obj[p] = cobj[p];
    }
  }

  return obj;
}

function VTTCue(startTime, endTime, text) {
  var cue = this;
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
  var baseObj = {};

  if (isIE8) {
    cue = document.createElement('custom');
  } else {
    baseObj.enumerable = true;
  }

  /**
   * Shim implementation specific properties. These properties are not in
   * the spec.
   */

  // Lets us know when the VTTCue's data has changed in such a way that we need
  // to recompute its display state. This lets us compute its display state
  // lazily.
  cue.hasBeenReset = false;

  /**
   * VTTCue and TextTrackCue properties
   * http://dev.w3.org/html5/webvtt/#vttcue-interface
   */

  var _id = "";
  var _pauseOnExit = false;
  var _startTime = startTime;
  var _endTime = endTime;
  var _text = text;
  var _region = null;
  var _vertical = "";
  var _snapToLines = true;
  var _line = "auto";
  var _lineAlign = "start";
  var _position = 50;
  var _positionAlign = "middle";
  var _size = 50;
  var _align = "middle";

  Object.defineProperty(cue,
    "id", extend({}, baseObj, {
      get: function() {
        return _id;
      },
      set: function(value) {
        _id = "" + value;
      }
    }));

  Object.defineProperty(cue,
    "pauseOnExit", extend({}, baseObj, {
      get: function() {
        return _pauseOnExit;
      },
      set: function(value) {
        _pauseOnExit = !!value;
      }
    }));

  Object.defineProperty(cue,
    "startTime", extend({}, baseObj, {
      get: function() {
        return _startTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("Start time must be set to a number.");
        }
        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "endTime", extend({}, baseObj, {
      get: function() {
        return _endTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("End time must be set to a number.");
        }
        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "text", extend({}, baseObj, {
      get: function() {
        return _text;
      },
      set: function(value) {
        _text = "" + value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "region", extend({}, baseObj, {
      get: function() {
        return _region;
      },
      set: function(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "vertical", extend({}, baseObj, {
      get: function() {
        return _vertical;
      },
      set: function(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "snapToLines", extend({}, baseObj, {
      get: function() {
        return _snapToLines;
      },
      set: function(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "line", extend({}, baseObj, {
      get: function() {
        return _line;
      },
      set: function(value) {
        if (typeof value !== "number" && value !== autoKeyword) {
          throw new SyntaxError("An invalid number or illegal string was specified.");
        }
        _line = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "lineAlign", extend({}, baseObj, {
      get: function() {
        return _lineAlign;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "position", extend({}, baseObj, {
      get: function() {
        return _position;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Position must be between 0 and 100.");
        }
        _position = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "positionAlign", extend({}, baseObj, {
      get: function() {
        return _positionAlign;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "size", extend({}, baseObj, {
      get: function() {
        return _size;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Size must be between 0 and 100.");
        }
        _size = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "align", extend({}, baseObj, {
      get: function() {
        return _align;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _align = setting;
        this.hasBeenReset = true;
      }
    }));

  /**
   * Other <track> spec defined properties
   */

  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
  cue.displayState = undefined;

  if (isIE8) {
    return cue;
  }
}

/**
 * VTTCue methods
 */

VTTCue.prototype.getCueAsHTML = function() {
  // Assume WebVTT.convertCueToDOMTree is on the global.
  return WebVTT.convertCueToDOMTree(window, this.text);
};

module.exports = VTTCue;

},{}],52:[function(require,module,exports){
/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var scrollSetting = {
  "": true,
  "up": true
};

function findScrollSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var scroll = scrollSetting[value.toLowerCase()];
  return scroll ? value.toLowerCase() : false;
}

function isValidPercentValue(value) {
  return typeof value === "number" && (value >= 0 && value <= 100);
}

// VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface
function VTTRegion() {
  var _width = 100;
  var _lines = 3;
  var _regionAnchorX = 0;
  var _regionAnchorY = 100;
  var _viewportAnchorX = 0;
  var _viewportAnchorY = 100;
  var _scroll = "";

  Object.defineProperties(this, {
    "width": {
      enumerable: true,
      get: function() {
        return _width;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("Width must be between 0 and 100.");
        }
        _width = value;
      }
    },
    "lines": {
      enumerable: true,
      get: function() {
        return _lines;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("Lines must be set to a number.");
        }
        _lines = value;
      }
    },
    "regionAnchorY": {
      enumerable: true,
      get: function() {
        return _regionAnchorY;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("RegionAnchorX must be between 0 and 100.");
        }
        _regionAnchorY = value;
      }
    },
    "regionAnchorX": {
      enumerable: true,
      get: function() {
        return _regionAnchorX;
      },
      set: function(value) {
        if(!isValidPercentValue(value)) {
          throw new Error("RegionAnchorY must be between 0 and 100.");
        }
        _regionAnchorX = value;
      }
    },
    "viewportAnchorY": {
      enumerable: true,
      get: function() {
        return _viewportAnchorY;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("ViewportAnchorY must be between 0 and 100.");
        }
        _viewportAnchorY = value;
      }
    },
    "viewportAnchorX": {
      enumerable: true,
      get: function() {
        return _viewportAnchorX;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("ViewportAnchorX must be between 0 and 100.");
        }
        _viewportAnchorX = value;
      }
    },
    "scroll": {
      enumerable: true,
      get: function() {
        return _scroll;
      },
      set: function(value) {
        var setting = findScrollSetting(value);
        // Have to check for false as an empty string is a legal value.
        if (setting === false) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _scroll = setting;
      }
    }
  });
}

module.exports = VTTRegion;

},{}],53:[function(require,module,exports){
"use strict";
var window = require("global/window")
var isFunction = require("is-function")
var parseHeaders = require("parse-headers")
var xtend = require("xtend")

module.exports = createXHR
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true
            options.callback(err, response, body)
        }
    }

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0)
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else {
            body = xhr.responseText || getXml(xhr)
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    }

    if ("json" in options && options.json !== false) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.onabort = function(){
        aborted = true;
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null)

    return xhr


}

function getXml(xhr) {
    if (xhr.responseType === "document") {
        return xhr.responseXML
    }
    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML
    }

    return null
}

function noop() {}

},{"global/window":42,"is-function":43,"parse-headers":44,"xtend":54}],54:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.videojs = require('video.js');
videojs = videojs.default || videojs;
exports.default = {
  name: 'video-player',
  props: {
    options: {
      type: Object,
      required: true
    },
    start: {
      type: Number,
      default: function _default() {
        return 0;
      }
    },
    playsinline: {
      type: Boolean,
      default: function _default() {
        return false;
      }
    },
    customEventName: {
      type: String,
      default: function _default() {
        return 'statechanged';
      }
    }
  },
  mounted: function mounted() {
    if (!this.player) {
      this.initialize();
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.player) {
      this.dispose();
    }
  },
  methods: {
    initialize: function initialize() {

      // init
      var self = this;
      this.player = null;

      // videojs options
      var videoOptions = (0, _assign2.default)({
        autoplay: false,
        controls: true,
        preload: 'auto',
        fluid: false,
        muted: false,
        width: '100%',
        height: '360',
        language: 'en',
        controlBar: {
          remainingTimeDisplay: false,
          playToggle: {},
          progressControl: {},
          fullscreenToggle: {},
          volumeMenuButton: {
            inline: false,
            vertical: true
          }
        },
        techOrder: ['html5'],
        plugins: {}
      }, this.options);

      // check sources
      /*
      if (!videoOptions.sources || !videoOptions.sources.length) {
        console.warn('Missing required option: "sources".')
        return false
      }
      */

      // ios fullscreen
      var playsinline = this.playsinline;
      if (playsinline) {
        this.$el.children[0].setAttribute('playsinline', playsinline);
        this.$el.children[0].setAttribute('webkit-playsinline', playsinline);
      }

      // emit event
      var emitPlayerState = function emitPlayerState(event, value) {
        if (event) {
          self.$emit(event, self.player);
        }
        if (value) {
          var values = {};
          values[event] = value;
          self.$emit(self.customEventName, values);
        }
      };

      // videoOptions
      // console.log(videoOptions)

      // avoid error "VIDEOJS: ERROR: Unable to find plugin: __ob__"
      if (videoOptions.plugins) {
        delete videoOptions.plugins.__ob__;
      }

      this.player = videojs(this.$el.children[0], videoOptions, function () {

        // player readied
        var _this = this;
        self.$emit('ready', self.player);

        // events
        var events = ['loadeddata', 'canplay', 'canplaythrough', 'play', 'pause', 'waiting', 'playing', 'ended', 'error'];
        for (var i = 0; i < events.length; i++) {
          (function (event) {
            _this.on(event, function () {
              emitPlayerState(event, true);
            });
          })(events[i]);
        }

        this.on('timeupdate', function () {
          emitPlayerState('timeupdate', this.currentTime());
        });
      });
    },
    dispose: function dispose() {
      if (this.player && videojs) {
        if (this.player.techName_ !== 'Flash') {
          this.player.pause && this.player.pause();
        }
        videojs(this.$el.children[0]).dispose();
        if (!this.$el.children.length) {
          var video = document.createElement('video');
          video.className = 'video-js';
          this.$el.appendChild(video);
        }
        this.player = null;
      }
    }
  },
  watch: {
    options: {
      deep: true,
      handler: function handler(options, oldOptions) {
        this.dispose();
        if (options && options.sources && options.sources.length) {
          this.initialize();
        }
      }
    }
  }
};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div class=video-player><video class=video-js></video></div>"

},{"babel-runtime/core-js/object/assign":2,"video.js":48}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9fYnJvd3Nlci1wYWNrQDYuMC4yQGJyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImluZGV4LmpzIiwibm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9fYnJvd3Nlci1yZXNvbHZlQDEuMTEuMkBicm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL19mb3ItZWFjaEAwLjMuMkBmb3ItZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9fZ2xvYmFsQDQuMy4yQGdsb2JhbC9ub2RlX21vZHVsZXMvX3ZpZGVvLmpzQDYuMi41QHZpZGVvLmpzL25vZGVfbW9kdWxlcy9nbG9iYWwvZG9jdW1lbnQuanMiLCJub2RlX21vZHVsZXMvX2dsb2JhbEA0LjMuMkBnbG9iYWwvbm9kZV9tb2R1bGVzL192aWRlby5qc0A2LjIuNUB2aWRlby5qcy9ub2RlX21vZHVsZXMvZ2xvYmFsL3dpbmRvdy5qcyIsIm5vZGVfbW9kdWxlcy9faXMtZnVuY3Rpb25AMS4wLjFAaXMtZnVuY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvX3BhcnNlLWhlYWRlcnNAMi4wLjFAcGFyc2UtaGVhZGVycy9wYXJzZS1oZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzL19zYWZlLWpzb24tcGFyc2VANC4wLjBAc2FmZS1qc29uLXBhcnNlL3R1cGxlLmpzIiwibm9kZV9tb2R1bGVzL190cmltQDAuMC4xQHRyaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvX3RzbWxAMS4wLjFAdHNtbC90c21sLmpzIiwibm9kZV9tb2R1bGVzL192aWRlby5qc0A2LjIuNUB2aWRlby5qcy9kaXN0L3ZpZGVvLmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9fdmlkZW9qcy12dHQuanNAMC4xMi40QHZpZGVvanMtdnR0LmpzL2xpYi9icm93c2VyLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL192aWRlb2pzLXZ0dC5qc0AwLjEyLjRAdmlkZW9qcy12dHQuanMvbGliL3Z0dC5qcyIsIm5vZGVfbW9kdWxlcy9fdmlkZW9qcy12dHQuanNAMC4xMi40QHZpZGVvanMtdnR0LmpzL2xpYi92dHRjdWUuanMiLCJub2RlX21vZHVsZXMvX3ZpZGVvanMtdnR0LmpzQDAuMTIuNEB2aWRlb2pzLXZ0dC5qcy9saWIvdnR0cmVnaW9uLmpzIiwibm9kZV9tb2R1bGVzL194aHJAMi40LjBAeGhyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL194dGVuZEA0LjAuMUB4dGVuZC9pbW11dGFibGUuanMiLCJzcmMvcGxheWVyLnZ1ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3g5ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDanpDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIgLyoqXG4gKlxuICogVnVlLVZpZGVvLVBsYXllclxuICogQWRhcHRlZCBmcm9tIFZpZGVvanMgKGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzKVxuICpcbiAqL1xuXG53aW5kb3cudmlkZW9qcyA9IHJlcXVpcmUoJ3ZpZGVvLmpzJylcbnZpZGVvanMgPSB2aWRlb2pzLmRlZmF1bHQgfHwgdmlkZW9qc1xudmFyIHBsYXllckNvbXBvbmVudCA9IHJlcXVpcmUoJy4vc3JjL3BsYXllci52dWUnKVxucGxheWVyQ29tcG9uZW50ID0gcGxheWVyQ29tcG9uZW50LmRlZmF1bHQgfHwgcGxheWVyQ29tcG9uZW50XG5cbnZhciB2aWRlb1BsYXllciA9IHtcbiAgdmlkZW9qczogdmlkZW9qcyxcbiAgdmlkZW9QbGF5ZXI6IHBsYXllckNvbXBvbmVudCxcbiAgaW5zdGFsbDogZnVuY3Rpb24oVnVlKSB7XG4gICAgVnVlLmNvbXBvbmVudChwbGF5ZXJDb21wb25lbnQubmFtZSwgcGxheWVyQ29tcG9uZW50KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmlkZW9QbGF5ZXJcbiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwiIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNS4wJyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBrZXksIG93biwgb3V0O1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChvd24gJiYga2V5IGluIGV4cG9ydHMpIGNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZiAoSVNfUFJPVE8pIHtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuXG5mdW5jdGlvbiBmb3JFYWNoKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGl0ZXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBjb250ZXh0ID0gdGhpc1xuICAgIH1cbiAgICBcbiAgICBpZiAodG9TdHJpbmcuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJylcbiAgICAgICAgZm9yRWFjaEFycmF5KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgZm9yRWFjaFN0cmluZyhsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlXG4gICAgICAgIGZvckVhY2hPYmplY3QobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG59XG5cbmZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnJheSwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksIGkpKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIGFycmF5W2ldLCBpLCBhcnJheSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBubyBzdWNoIHRoaW5nIGFzIGEgc3BhcnNlIHN0cmluZy5cbiAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpXG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoT2JqZWN0KG9iamVjdCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBrIGluIG9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGspKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9iamVjdFtrXSwgaywgb2JqZWN0KVxuICAgICAgICB9XG4gICAgfVxufVxuIiwidmFyIHRvcExldmVsID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge31cbnZhciBtaW5Eb2MgPSByZXF1aXJlKCdtaW4tZG9jdW1lbnQnKTtcblxudmFyIGRvY2N5O1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRvY2N5ID0gZG9jdW1lbnQ7XG59IGVsc2Uge1xuICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXTtcblxuICAgIGlmICghZG9jY3kpIHtcbiAgICAgICAgZG9jY3kgPSB0b3BMZXZlbFsnX19HTE9CQUxfRE9DVU1FTlRfQ0FDSEVANCddID0gbWluRG9jO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb2NjeTtcbiIsInZhciB3aW47XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgd2luID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgd2luID0ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHN0cmluZyA9IHRvU3RyaW5nLmNhbGwoZm4pXG4gIHJldHVybiBzdHJpbmcgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfHxcbiAgICAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHN0cmluZyAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHx8XG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgIC8vIElFOCBhbmQgYmVsb3dcbiAgICAgKGZuID09PSB3aW5kb3cuc2V0VGltZW91dCB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5hbGVydCB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5jb25maXJtIHx8XG4gICAgICBmbiA9PT0gd2luZG93LnByb21wdCkpXG59O1xuIiwidmFyIHRyaW0gPSByZXF1aXJlKCd0cmltJylcbiAgLCBmb3JFYWNoID0gcmVxdWlyZSgnZm9yLWVhY2gnKVxuICAsIGlzQXJyYXkgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgaWYgKCFoZWFkZXJzKVxuICAgIHJldHVybiB7fVxuXG4gIHZhciByZXN1bHQgPSB7fVxuXG4gIGZvckVhY2goXG4gICAgICB0cmltKGhlYWRlcnMpLnNwbGl0KCdcXG4nKVxuICAgICwgZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgaW5kZXggPSByb3cuaW5kZXhPZignOicpXG4gICAgICAgICAgLCBrZXkgPSB0cmltKHJvdy5zbGljZSgwLCBpbmRleCkpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAsIHZhbHVlID0gdHJpbShyb3cuc2xpY2UoaW5kZXggKyAxKSlcblxuICAgICAgICBpZiAodHlwZW9mKHJlc3VsdFtrZXldKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShyZXN1bHRba2V5XSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gWyByZXN1bHRba2V5XSwgdmFsdWUgXVxuICAgICAgICB9XG4gICAgICB9XG4gIClcblxuICByZXR1cm4gcmVzdWx0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBTYWZlUGFyc2VUdXBsZVxuXG5mdW5jdGlvbiBTYWZlUGFyc2VUdXBsZShvYmosIHJldml2ZXIpIHtcbiAgICB2YXIganNvblxuICAgIHZhciBlcnJvciA9IG51bGxcblxuICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBKU09OLnBhcnNlKG9iaiwgcmV2aXZlcilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyb3IgPSBlcnJcbiAgICB9XG5cbiAgICByZXR1cm4gW2Vycm9yLCBqc29uXVxufVxuIiwiXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0cmltO1xuXG5mdW5jdGlvbiB0cmltKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuXG5leHBvcnRzLmxlZnQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpO1xufTtcblxuZXhwb3J0cy5yaWdodCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59O1xuIiwiZnVuY3Rpb24gY2xlYW4gKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvXFxuXFxyP1xccyovZywgJycpXG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0c21sIChzYSkge1xuICB2YXIgcyA9ICcnXG4gICAgLCBpID0gMFxuXG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgIHMgKz0gY2xlYW4oc2FbaV0pICsgKGFyZ3VtZW50c1tpICsgMV0gfHwgJycpXG5cbiAgcmV0dXJuIHNcbn0iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBWaWRlby5qcyA2LjIuNSA8aHR0cDovL3ZpZGVvanMuY29tLz5cbiAqIENvcHlyaWdodCBCcmlnaHRjb3ZlLCBJbmMuIDxodHRwczovL3d3dy5icmlnaHRjb3ZlLmNvbS8+XG4gKiBBdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjBcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9ibG9iL21hc3Rlci9MSUNFTlNFPlxuICpcbiAqIEluY2x1ZGVzIHZ0dC5qcyA8aHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzPlxuICogQXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wXG4gKiA8aHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0U+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIHdpbmRvdyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdnbG9iYWwvd2luZG93JykpO1xudmFyIGRvY3VtZW50ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2dsb2JhbC9kb2N1bWVudCcpKTtcbnZhciB0c21sID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3RzbWwnKSk7XG52YXIgc2FmZVBhcnNlVHVwbGUgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnc2FmZS1qc29uLXBhcnNlL3R1cGxlJykpO1xudmFyIHhociA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd4aHInKSk7XG52YXIgdnR0ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3ZpZGVvanMtdnR0LmpzJykpO1xuXG52YXIgdmVyc2lvbiA9IFwiNi4yLjVcIjtcblxuLyoqXG4gKiBAZmlsZSBicm93c2VyLmpzXG4gKiBAbW9kdWxlIGJyb3dzZXJcbiAqL1xudmFyIFVTRVJfQUdFTlQgPSB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xudmFyIHdlYmtpdFZlcnNpb25NYXAgPSAvQXBwbGVXZWJLaXRcXC8oW1xcZC5dKykvaS5leGVjKFVTRVJfQUdFTlQpO1xudmFyIGFwcGxlV2Via2l0VmVyc2lvbiA9IHdlYmtpdFZlcnNpb25NYXAgPyBwYXJzZUZsb2F0KHdlYmtpdFZlcnNpb25NYXAucG9wKCkpIDogbnVsbDtcblxuLypcbiAqIERldmljZSBpcyBhbiBpUGhvbmVcbiAqXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBjb25zdGFudFxuICogQHByaXZhdGVcbiAqL1xudmFyIElTX0lQQUQgPSAvaVBhZC9pLnRlc3QoVVNFUl9BR0VOVCk7XG5cbi8vIFRoZSBGYWNlYm9vayBhcHAncyBVSVdlYlZpZXcgaWRlbnRpZmllcyBhcyBib3RoIGFuIGlQaG9uZSBhbmQgaVBhZCwgc29cbi8vIHRvIGlkZW50aWZ5IGlQaG9uZXMsIHdlIG5lZWQgdG8gZXhjbHVkZSBpUGFkcy5cbi8vIGh0dHA6Ly9hcnRzeS5naXRodWIuaW8vYmxvZy8yMDEyLzEwLzE4L3RoZS1wZXJpbHMtb2YtaW9zLXVzZXItYWdlbnQtc25pZmZpbmcvXG52YXIgSVNfSVBIT05FID0gL2lQaG9uZS9pLnRlc3QoVVNFUl9BR0VOVCkgJiYgIUlTX0lQQUQ7XG52YXIgSVNfSVBPRCA9IC9pUG9kL2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBJU19JT1MgPSBJU19JUEhPTkUgfHwgSVNfSVBBRCB8fCBJU19JUE9EO1xuXG52YXIgSU9TX1ZFUlNJT04gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtYXRjaCA9IFVTRVJfQUdFTlQubWF0Y2goL09TIChcXGQrKV8vaSk7XG5cbiAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7XG4gICAgcmV0dXJuIG1hdGNoWzFdO1xuICB9XG4gIHJldHVybiBudWxsO1xufSgpO1xuXG52YXIgSVNfQU5EUk9JRCA9IC9BbmRyb2lkL2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBBTkRST0lEX1ZFUlNJT04gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRoaXMgbWF0Y2hlcyBBbmRyb2lkIE1ham9yLk1pbm9yLlBhdGNoIHZlcnNpb25zXG4gIC8vIEFORFJPSURfVkVSU0lPTiBpcyBNYWpvci5NaW5vciBhcyBhIE51bWJlciwgaWYgTWlub3IgaXNuJ3QgYXZhaWxhYmxlLCB0aGVuIG9ubHkgTWFqb3IgaXMgcmV0dXJuZWRcbiAgdmFyIG1hdGNoID0gVVNFUl9BR0VOVC5tYXRjaCgvQW5kcm9pZCAoXFxkKykoPzpcXC4oXFxkKykpPyg/OlxcLihcXGQrKSkqL2kpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYWpvciA9IG1hdGNoWzFdICYmIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgbWlub3IgPSBtYXRjaFsyXSAmJiBwYXJzZUZsb2F0KG1hdGNoWzJdKTtcblxuICBpZiAobWFqb3IgJiYgbWlub3IpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsxXSArICcuJyArIG1hdGNoWzJdKTtcbiAgfSBlbHNlIGlmIChtYWpvcikge1xuICAgIHJldHVybiBtYWpvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0oKTtcblxuLy8gT2xkIEFuZHJvaWQgaXMgZGVmaW5lZCBhcyBWZXJzaW9uIG9sZGVyIHRoYW4gMi4zLCBhbmQgcmVxdWlyaW5nIGEgd2Via2l0IHZlcnNpb24gb2YgdGhlIGFuZHJvaWQgYnJvd3NlclxudmFyIElTX09MRF9BTkRST0lEID0gSVNfQU5EUk9JRCAmJiAvd2Via2l0L2kudGVzdChVU0VSX0FHRU5UKSAmJiBBTkRST0lEX1ZFUlNJT04gPCAyLjM7XG52YXIgSVNfTkFUSVZFX0FORFJPSUQgPSBJU19BTkRST0lEICYmIEFORFJPSURfVkVSU0lPTiA8IDUgJiYgYXBwbGVXZWJraXRWZXJzaW9uIDwgNTM3O1xuXG52YXIgSVNfRklSRUZPWCA9IC9GaXJlZm94L2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBJU19FREdFID0gL0VkZ2UvaS50ZXN0KFVTRVJfQUdFTlQpO1xudmFyIElTX0NIUk9NRSA9ICFJU19FREdFICYmIC9DaHJvbWUvaS50ZXN0KFVTRVJfQUdFTlQpO1xudmFyIENIUk9NRV9WRVJTSU9OID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWF0Y2ggPSBVU0VSX0FHRU5ULm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcblxuICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KCk7XG52YXIgSVNfSUU4ID0gL01TSUVcXHM4XFwuMC8udGVzdChVU0VSX0FHRU5UKTtcbnZhciBJRV9WRVJTSU9OID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVzdWx0ID0gL01TSUVcXHMoXFxkKylcXC5cXGQvLmV4ZWMoVVNFUl9BR0VOVCk7XG4gIHZhciB2ZXJzaW9uID0gcmVzdWx0ICYmIHBhcnNlRmxvYXQocmVzdWx0WzFdKTtcblxuICBpZiAoIXZlcnNpb24gJiYgL1RyaWRlbnRcXC83LjAvaS50ZXN0KFVTRVJfQUdFTlQpICYmIC9ydjoxMS4wLy50ZXN0KFVTRVJfQUdFTlQpKSB7XG4gICAgLy8gSUUgMTEgaGFzIGEgZGlmZmVyZW50IHVzZXIgYWdlbnQgc3RyaW5nIHRoYW4gb3RoZXIgSUUgdmVyc2lvbnNcbiAgICB2ZXJzaW9uID0gMTEuMDtcbiAgfVxuXG4gIHJldHVybiB2ZXJzaW9uO1xufSgpO1xuXG52YXIgSVNfU0FGQVJJID0gL1NhZmFyaS9pLnRlc3QoVVNFUl9BR0VOVCkgJiYgIUlTX0NIUk9NRSAmJiAhSVNfQU5EUk9JRCAmJiAhSVNfRURHRTtcbnZhciBJU19BTllfU0FGQVJJID0gSVNfU0FGQVJJIHx8IElTX0lPUztcblxudmFyIFRPVUNIX0VOQUJMRUQgPSBpc1JlYWwoKSAmJiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIHdpbmRvdy5kb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKTtcblxudmFyIEJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURUQgPSBpc1JlYWwoKSAmJiAnYmFja2dyb3VuZFNpemUnIGluIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpLnN0eWxlO1xuXG52YXIgYnJvd3NlciA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRJU19JUEFEOiBJU19JUEFELFxuXHRJU19JUEhPTkU6IElTX0lQSE9ORSxcblx0SVNfSVBPRDogSVNfSVBPRCxcblx0SVNfSU9TOiBJU19JT1MsXG5cdElPU19WRVJTSU9OOiBJT1NfVkVSU0lPTixcblx0SVNfQU5EUk9JRDogSVNfQU5EUk9JRCxcblx0QU5EUk9JRF9WRVJTSU9OOiBBTkRST0lEX1ZFUlNJT04sXG5cdElTX09MRF9BTkRST0lEOiBJU19PTERfQU5EUk9JRCxcblx0SVNfTkFUSVZFX0FORFJPSUQ6IElTX05BVElWRV9BTkRST0lELFxuXHRJU19GSVJFRk9YOiBJU19GSVJFRk9YLFxuXHRJU19FREdFOiBJU19FREdFLFxuXHRJU19DSFJPTUU6IElTX0NIUk9NRSxcblx0Q0hST01FX1ZFUlNJT046IENIUk9NRV9WRVJTSU9OLFxuXHRJU19JRTg6IElTX0lFOCxcblx0SUVfVkVSU0lPTjogSUVfVkVSU0lPTixcblx0SVNfU0FGQVJJOiBJU19TQUZBUkksXG5cdElTX0FOWV9TQUZBUkk6IElTX0FOWV9TQUZBUkksXG5cdFRPVUNIX0VOQUJMRUQ6IFRPVUNIX0VOQUJMRUQsXG5cdEJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURUQ6IEJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURURcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB0YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZSA9IGZ1bmN0aW9uIChzdHJpbmdzLCByYXcpIHtcbiAgc3RyaW5ncy5yYXcgPSByYXc7XG4gIHJldHVybiBzdHJpbmdzO1xufTtcblxuLyoqXG4gKiBAZmlsZSBvYmouanNcbiAqIEBtb2R1bGUgb2JqXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb2JqOkVhY2hDYWxsYmFja1xuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiAgICAgICAgVGhlIGN1cnJlbnQga2V5IGZvciB0aGUgb2JqZWN0IHRoYXQgaXMgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiAgICAgICAgVGhlIGN1cnJlbnQga2V5LXZhbHVlIGZvciBvYmplY3QgdGhhdCBpcyBiZWluZyBpdGVyYXRlZCBvdmVyXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb2JqOlJlZHVjZUNhbGxiYWNrXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYWNjdW1cbiAqICAgICAgICBUaGUgdmFsdWUgdGhhdCBpcyBhY2N1bXVsYXRpbmcgb3ZlciB0aGUgcmVkdWNlIGxvb3AuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAqICAgICAgICBUaGUgY3VycmVudCBrZXkgZm9yIHRoZSBvYmplY3QgdGhhdCBpcyBiZWluZyBpdGVyYXRlZCBvdmVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqICAgICAgICBUaGUgY3VycmVudCBrZXktdmFsdWUgZm9yIG9iamVjdCB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXJcbiAqXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqICAgICAgICAgVGhlIG5ldyBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBHZXQgdGhlIGtleXMgb2YgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiAgICAgICAgVGhlIE9iamVjdCB0byBnZXQgdGhlIGtleXMgZnJvbVxuICpcbiAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICogICAgICAgICBBbiBhcnJheSBvZiB0aGUga2V5cyBmcm9tIHRoZSBvYmplY3QuIFJldHVybnMgYW4gZW1wdHkgYXJyYXkgaWYgdGhlXG4gKiAgICAgICAgIG9iamVjdCBwYXNzZWQgaW4gd2FzIGludmFsaWQgb3IgaGFkIG5vIGtleXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IE9iamVjdC5rZXlzKG9iamVjdCkgOiBbXTtcbn07XG5cbi8qKlxuICogQXJyYXktbGlrZSBpdGVyYXRpb24gZm9yIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogICAgICAgIFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyXG4gKlxuICogQHBhcmFtIHtvYmo6RWFjaENhbGxiYWNrfSBmblxuICogICAgICAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZm9yIGVhY2gga2V5IGluIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGVhY2gob2JqZWN0LCBmbikge1xuICBrZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGZuKG9iamVjdFtrZXldLCBrZXkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBBcnJheS1saWtlIHJlZHVjZSBmb3Igb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiAgICAgICAgVGhlIE9iamVjdCB0aGF0IHlvdSB3YW50IHRvIHJlZHVjZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogICAgICAgICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBmb3IgZWFjaCBrZXkgaW4gdGhlIG9iamVjdC4gSXRcbiAqICAgICAgICAgcmVjZWl2ZXMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlIGFuZCB0aGUgcGVyLWl0ZXJhdGlvbiB2YWx1ZSBhbmQga2V5XG4gKiAgICAgICAgIGFzIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBbaW5pdGlhbCA9IDBdXG4gKiAgICAgICAgU3RhcnRpbmcgdmFsdWVcbiAqXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqICAgICAgICAgVGhlIGZpbmFsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiByZWR1Y2Uob2JqZWN0LCBmbikge1xuICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICByZXR1cm4ga2V5cyhvYmplY3QpLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGtleSkge1xuICAgIHJldHVybiBmbihhY2N1bSwgb2JqZWN0W2tleV0sIGtleSk7XG4gIH0sIGluaXRpYWwpO1xufVxuXG4vKipcbiAqIE9iamVjdC5hc3NpZ24tc3R5bGUgb2JqZWN0IHNoYWxsb3cgbWVyZ2UvZXh0ZW5kLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtPYmplY3R9IC4uLnNvdXJjZXNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChPYmplY3QuYXNzaWduKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBbdGFyZ2V0XS5jb25jYXQoc291cmNlcykpO1xuICB9XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVhY2goc291cmNlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBvYmplY3Qgb2YgYW55IGtpbmQgLSBpbmNsdWRpbmcgRE9NIG5vZGVzLFxuICogYXJyYXlzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBldGMuIE5vdCBmdW5jdGlvbnMsIHRob3VnaC5cbiAqXG4gKiBUaGlzIGF2b2lkcyB0aGUgZ290Y2hhIHdoZXJlIHVzaW5nIGB0eXBlb2ZgIG9uIGEgYG51bGxgIHZhbHVlXG4gKiByZXN1bHRzIGluIGAnb2JqZWN0J2AuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBhcHBlYXJzIHRvIGJlIGEgXCJwbGFpblwiIG9iamVjdCAtIHRoYXQgaXMsIGFcbiAqIGRpcmVjdCBpbnN0YW5jZSBvZiBgT2JqZWN0YC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc1BsYWluKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5cbi8qKlxuICogQGZpbGUgbG9nLmpzXG4gKiBAbW9kdWxlIGxvZ1xuICovXG52YXIgbG9nID0gdm9pZCAwO1xuXG4vLyBUaGlzIGlzIHRoZSBwcml2YXRlIHRyYWNraW5nIHZhcmlhYmxlIGZvciBsb2dnaW5nIGxldmVsLlxudmFyIGxldmVsID0gJ2FsbCc7XG5cbi8vIFRoaXMgaXMgdGhlIHByaXZhdGUgdHJhY2tpbmcgdmFyaWFibGUgZm9yIHRoZSBsb2dnaW5nIGhpc3RvcnkuXG52YXIgaGlzdG9yeSA9IFtdO1xuXG4vKipcbiAqIExvZyBtZXNzYWdlcyB0byB0aGUgY29uc29sZSBhbmQgaGlzdG9yeSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBtZXNzYWdlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZVxuICogICAgICAgICBUaGUgbmFtZSBvZiB0aGUgY29uc29sZSBtZXRob2QgdG8gdXNlLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBhcmdzXG4gKiAgICAgICAgIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBtYXRjaGluZyBjb25zb2xlIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gIHtib29sZWFufSBbc3RyaW5naWZ5XVxuICogICAgICAgICBCeSBkZWZhdWx0LCBvbmx5IG9sZCBJRXMgc2hvdWxkIGdldCBjb25zb2xlIGFyZ3VtZW50IHN0cmluZ2lmaWNhdGlvbixcbiAqICAgICAgICAgYnV0IHRoaXMgaXMgZXhwb3NlZCBhcyBhIHBhcmFtZXRlciB0byBmYWNpbGl0YXRlIHRlc3RpbmcuXG4gKi9cbnZhciBsb2dCeVR5cGUgPSBmdW5jdGlvbiBsb2dCeVR5cGUodHlwZSwgYXJncykge1xuICB2YXIgc3RyaW5naWZ5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAhIUlFX1ZFUlNJT04gJiYgSUVfVkVSU0lPTiA8IDExO1xuXG4gIHZhciBsdmwgPSBsb2cubGV2ZWxzW2xldmVsXTtcbiAgdmFyIGx2bFJlZ0V4cCA9IG5ldyBSZWdFeHAoJ14oJyArIGx2bCArICcpJCcpO1xuXG4gIGlmICh0eXBlICE9PSAnbG9nJykge1xuXG4gICAgLy8gQWRkIHRoZSB0eXBlIHRvIHRoZSBmcm9udCBvZiB0aGUgbWVzc2FnZSB3aGVuIGl0J3Mgbm90IFwibG9nXCIuXG4gICAgYXJncy51bnNoaWZ0KHR5cGUudG9VcHBlckNhc2UoKSArICc6Jyk7XG4gIH1cblxuICAvLyBBZGQgYSBjbG9uZSBvZiB0aGUgYXJncyBhdCB0aGlzIHBvaW50IHRvIGhpc3RvcnkuXG4gIGlmIChoaXN0b3J5KSB7XG4gICAgaGlzdG9yeS5wdXNoKFtdLmNvbmNhdChhcmdzKSk7XG4gIH1cblxuICAvLyBBZGQgY29uc29sZSBwcmVmaXggYWZ0ZXIgYWRkaW5nIHRvIGhpc3RvcnkuXG4gIGFyZ3MudW5zaGlmdCgnVklERU9KUzonKTtcblxuICAvLyBJZiB0aGVyZSdzIG5vIGNvbnNvbGUgdGhlbiBkb24ndCB0cnkgdG8gb3V0cHV0IG1lc3NhZ2VzLCBidXQgdGhleSB3aWxsXG4gIC8vIHN0aWxsIGJlIHN0b3JlZCBpbiBoaXN0b3J5LlxuICAvL1xuICAvLyBXYXMgc2V0dGluZyB0aGVzZSBvbmNlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbiwgYnV0IGNvbnRhaW5pbmcgdGhlbVxuICAvLyBpbiB0aGUgZnVuY3Rpb24gbWFrZXMgaXQgZWFzaWVyIHRvIHRlc3QgY2FzZXMgd2hlcmUgY29uc29sZSBkb2Vzbid0IGV4aXN0XG4gIC8vIHdoZW4gdGhlIG1vZHVsZSBpcyBleGVjdXRlZC5cbiAgdmFyIGZuID0gd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGVbdHlwZV07XG5cbiAgLy8gQmFpbCBvdXQgaWYgdGhlcmUncyBubyBjb25zb2xlIG9yIGlmIHRoaXMgdHlwZSBpcyBub3QgYWxsb3dlZCBieSB0aGVcbiAgLy8gY3VycmVudCBsb2dnaW5nIGxldmVsLlxuICBpZiAoIWZuIHx8ICFsdmwgfHwgIWx2bFJlZ0V4cC50ZXN0KHR5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSUVzIHByZXZpb3VzIHRvIDExIGxvZyBvYmplY3RzIHVzZWxlc3NseSBhcyBcIltvYmplY3QgT2JqZWN0XVwiOyBzbywgSlNPTmlmeVxuICAvLyBvYmplY3RzIGFuZCBhcnJheXMgZm9yIHRob3NlIGxlc3MtY2FwYWJsZSBicm93c2Vycy5cbiAgaWYgKHN0cmluZ2lmeSkge1xuICAgIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGEpIHx8IEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENhc3QgdG8gc3RyaW5nIGJlZm9yZSBqb2luaW5nLCBzbyB3ZSBnZXQgbnVsbCBhbmQgdW5kZWZpbmVkIGV4cGxpY2l0bHlcbiAgICAgIC8vIGluY2x1ZGVkIGluIG91dHB1dCAoYXMgd2Ugd291bGQgaW4gYSBtb2Rlcm4gY29uc29sZSkuXG4gICAgICByZXR1cm4gU3RyaW5nKGEpO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuXG4gIC8vIE9sZCBJRSB2ZXJzaW9ucyBkbyBub3QgYWxsb3cgLmFwcGx5KCkgZm9yIGNvbnNvbGUgbWV0aG9kcyAodGhleSBhcmVcbiAgLy8gcmVwb3J0ZWQgYXMgb2JqZWN0cyByYXRoZXIgdGhhbiBmdW5jdGlvbnMpLlxuICBpZiAoIWZuLmFwcGx5KSB7XG4gICAgZm4oYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgZm5bQXJyYXkuaXNBcnJheShhcmdzKSA/ICdhcHBseScgOiAnY2FsbCddKHdpbmRvdy5jb25zb2xlLCBhcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMb2dzIHBsYWluIGRlYnVnIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0gICAge01peGVkW119IGFyZ3NcbiAqICAgICAgICAgICBPbmUgb3IgbW9yZSBtZXNzYWdlcyBvciBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIGxvZ2dlZC5cbiAqL1xubG9nID0gZnVuY3Rpb24gbG9nKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBsb2dCeVR5cGUoJ2xvZycsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBhdmFpbGFibGUgbG9nZ2luZyBsZXZlbHMsIHdoZXJlIHRoZSBrZXlzIGFyZSB0aGUgbGV2ZWwgbmFtZXNcbiAqIGFuZCB0aGUgdmFsdWVzIGFyZSBgfGAtc2VwYXJhdGVkIHN0cmluZ3MgY29udGFpbmluZyBsb2dnaW5nIG1ldGhvZHMgYWxsb3dlZFxuICogaW4gdGhhdCBsb2dnaW5nIGxldmVsLiBUaGVzZSBzdHJpbmdzIGFyZSB1c2VkIHRvIGNyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICogbWF0Y2hpbmcgdGhlIGZ1bmN0aW9uIG5hbWUgYmVpbmcgY2FsbGVkLlxuICpcbiAqIExldmVscyBwcm92aWRlZCBieSB2aWRlby5qcyBhcmU6XG4gKlxuICogLSBgb2ZmYDogTWF0Y2hlcyBubyBjYWxscy4gQW55IHZhbHVlIHRoYXQgY2FuIGJlIGNhc3QgdG8gYGZhbHNlYCB3aWxsIGhhdmVcbiAqICAgdGhpcyBlZmZlY3QuIFRoZSBtb3N0IHJlc3RyaWN0aXZlLlxuICogLSBgYWxsYCAoZGVmYXVsdCk6IE1hdGNoZXMgb25seSBWaWRlby5qcy1wcm92aWRlZCBmdW5jdGlvbnMgKGBsb2dgLFxuICogICBgbG9nLndhcm5gLCBhbmQgYGxvZy5lcnJvcmApLlxuICogLSBgd2FybmA6IE1hdGNoZXMgYGxvZy53YXJuYCBhbmQgYGxvZy5lcnJvcmAgY2FsbHMuXG4gKiAtIGBlcnJvcmA6IE1hdGNoZXMgb25seSBgbG9nLmVycm9yYCBjYWxscy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5sb2cubGV2ZWxzID0ge1xuICBhbGw6ICdsb2d8d2FybnxlcnJvcicsXG4gIGVycm9yOiAnZXJyb3InLFxuICBvZmY6ICcnLFxuICB3YXJuOiAnd2FybnxlcnJvcicsXG4gIERFRkFVTFQ6IGxldmVsXG59O1xuXG4vKipcbiAqIEdldCBvciBzZXQgdGhlIGN1cnJlbnQgbG9nZ2luZyBsZXZlbC4gSWYgYSBzdHJpbmcgbWF0Y2hpbmcgYSBrZXkgZnJvbVxuICoge0BsaW5rIGxvZy5sZXZlbHN9IGlzIHByb3ZpZGVkLCBhY3RzIGFzIGEgc2V0dGVyLiBSZWdhcmRsZXNzIG9mIGFyZ3VtZW50LFxuICogcmV0dXJucyB0aGUgY3VycmVudCBsb2dnaW5nIGxldmVsLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gW2x2bF1cbiAqICAgICAgICAgUGFzcyB0byBzZXQgYSBuZXcgbG9nZ2luZyBsZXZlbC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFRoZSBjdXJyZW50IGxvZ2dpbmcgbGV2ZWwuXG4gKi9cbmxvZy5sZXZlbCA9IGZ1bmN0aW9uIChsdmwpIHtcbiAgaWYgKHR5cGVvZiBsdmwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFsb2cubGV2ZWxzLmhhc093blByb3BlcnR5KGx2bCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgbHZsICsgJ1wiIGluIG5vdCBhIHZhbGlkIGxvZyBsZXZlbCcpO1xuICAgIH1cbiAgICBsZXZlbCA9IGx2bDtcbiAgfVxuICByZXR1cm4gbGV2ZWw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBldmVyeXRoaW5nIHRoYXQgaGFzIGJlZW4gbG9nZ2VkIHRvIHRoZSBoaXN0b3J5LlxuICpcbiAqIFRoaXMgYXJyYXkgaXMgYSBzaGFsbG93IGNsb25lIG9mIHRoZSBpbnRlcm5hbCBoaXN0b3J5IHJlY29yZC4gSG93ZXZlciwgaXRzXG4gKiBjb250ZW50cyBhcmUgX25vdF8gY2xvbmVkOyBzbywgbXV0YXRpbmcgb2JqZWN0cyBpbnNpZGUgdGhpcyBhcnJheSB3aWxsXG4gKiBtdXRhdGUgdGhlbSBpbiBoaXN0b3J5LlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5sb2cuaGlzdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGhpc3RvcnkgPyBbXS5jb25jYXQoaGlzdG9yeSkgOiBbXTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBpbnRlcm5hbCBoaXN0b3J5IHRyYWNraW5nLCBidXQgZG9lcyBub3QgcHJldmVudCBmdXJ0aGVyIGhpc3RvcnlcbiAqIHRyYWNraW5nLlxuICovXG5sb2cuaGlzdG9yeS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGhpc3RvcnkpIHtcbiAgICBoaXN0b3J5Lmxlbmd0aCA9IDA7XG4gIH1cbn07XG5cbi8qKlxuICogRGlzYWJsZSBoaXN0b3J5IHRyYWNraW5nIGlmIGl0IGlzIGN1cnJlbnRseSBlbmFibGVkLlxuICovXG5sb2cuaGlzdG9yeS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaGlzdG9yeSAhPT0gbnVsbCkge1xuICAgIGhpc3RvcnkubGVuZ3RoID0gMDtcbiAgICBoaXN0b3J5ID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmFibGUgaGlzdG9yeSB0cmFja2luZyBpZiBpdCBpcyBjdXJyZW50bHkgZGlzYWJsZWQuXG4gKi9cbmxvZy5oaXN0b3J5LmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGhpc3RvcnkgPT09IG51bGwpIHtcbiAgICBoaXN0b3J5ID0gW107XG4gIH1cbn07XG5cbi8qKlxuICogTG9ncyBlcnJvciBtZXNzYWdlcy4gU2ltaWxhciB0byBgY29uc29sZS5lcnJvcmAuXG4gKlxuICogQHBhcmFtIHtNaXhlZFtdfSBhcmdzXG4gKiAgICAgICAgT25lIG9yIG1vcmUgbWVzc2FnZXMgb3Igb2JqZWN0cyB0aGF0IHNob3VsZCBiZSBsb2dnZWQgYXMgYW4gZXJyb3JcbiAqL1xubG9nLmVycm9yID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIHJldHVybiBsb2dCeVR5cGUoJ2Vycm9yJywgYXJncyk7XG59O1xuXG4vKipcbiAqIExvZ3Mgd2FybmluZyBtZXNzYWdlcy4gU2ltaWxhciB0byBgY29uc29sZS53YXJuYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkW119IGFyZ3NcbiAqICAgICAgICBPbmUgb3IgbW9yZSBtZXNzYWdlcyBvciBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIGxvZ2dlZCBhcyBhIHdhcm5pbmcuXG4gKi9cbmxvZy53YXJuID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIHJldHVybiBsb2dCeVR5cGUoJ3dhcm4nLCBhcmdzKTtcbn07XG5cbnZhciBsb2ckMSA9IGxvZztcblxuLyoqXG4gKiBAZmlsZSBjb21wdXRlZC1zdHlsZS5qc1xuICogQG1vZHVsZSBjb21wdXRlZC1zdHlsZVxuICovXG4vKipcbiAqIEEgc2FmZSBnZXRDb21wdXRlZFN0eWxlIHdpdGggYW4gSUU4IGZhbGxiYWNrLlxuICpcbiAqIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgaW4gRmlyZWZveCwgaWYgdGhlIHBsYXllciBpcyBsb2FkZWQgaW4gYW4gaWZyYW1lIHdpdGhcbiAqIGBkaXNwbGF5Om5vbmVgLCB0aGVuIGBnZXRDb21wdXRlZFN0eWxlYCByZXR1cm5zIGBudWxsYCwgc28sIHdlIGRvIGEgbnVsbC1jaGVjayB0b1xuICogbWFrZSBzdXJlICB0aGF0IHRoZSBwbGF5ZXIgZG9lc24ndCBicmVhayBpbiB0aGVzZSBjYXNlcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgVGhlIGVsZW1lbnQgeW91IHdhbnQgdGhlIGNvbXB1dGVkIHN0eWxlIG9mXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqICAgICAgICBUaGUgcHJvcGVydHkgbmFtZSB5b3Ugd2FudFxuICpcbiAqIEBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVkU3R5bGUoZWwsIHByb3ApIHtcbiAgaWYgKCFlbCB8fCAhcHJvcCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93LmdldENvbXB1dGVkU3R5bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cbiAgICByZXR1cm4gY3MgPyBjc1twcm9wXSA6ICcnO1xuICB9XG5cbiAgcmV0dXJuIGVsLmN1cnJlbnRTdHlsZVtwcm9wXSB8fCAnJztcbn1cblxudmFyIF90ZW1wbGF0ZU9iamVjdCA9IHRhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFsnU2V0dGluZyBhdHRyaWJ1dGVzIGluIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgY3JlYXRlRWwoKVxcbiAgICAgICAgICAgICAgICBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgdGhlIHRoaXJkIGFyZ3VtZW50IGluc3RlYWQuXFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsKHR5cGUsIHByb3BlcnRpZXMsIGF0dHJpYnV0ZXMpLiBBdHRlbXB0aW5nIHRvIHNldCAnLCAnIHRvICcsICcuJ10sIFsnU2V0dGluZyBhdHRyaWJ1dGVzIGluIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgY3JlYXRlRWwoKVxcbiAgICAgICAgICAgICAgICBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgdGhlIHRoaXJkIGFyZ3VtZW50IGluc3RlYWQuXFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsKHR5cGUsIHByb3BlcnRpZXMsIGF0dHJpYnV0ZXMpLiBBdHRlbXB0aW5nIHRvIHNldCAnLCAnIHRvICcsICcuJ10pO1xuXG4vKipcbiAqIEBmaWxlIGRvbS5qc1xuICogQG1vZHVsZSBkb21cbiAqL1xuLyoqXG4gKiBEZXRlY3QgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZyB3aXRoIGFueSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqICAgICAgICBUaGUgc3RyaW5nIHRvIGNoZWNrXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgbm9uLWJsYW5rXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKlxuICovXG5mdW5jdGlvbiBpc05vbkJsYW5rU3RyaW5nKHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgL1xcUy8udGVzdChzdHIpO1xufVxuXG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcGFzc2VkIHN0cmluZyBoYXMgd2hpdGVzcGFjZS4gVGhpcyBpcyB1c2VkIGJ5XG4gKiBjbGFzcyBtZXRob2RzIHRvIGJlIHJlbGF0aXZlbHkgY29uc2lzdGVudCB3aXRoIHRoZSBjbGFzc0xpc3QgQVBJLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqICAgICAgICAgVGhlIHN0cmluZyB0byBjaGVjayBmb3Igd2hpdGVzcGFjZS5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqICAgICAgICAgVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGlzIHdoaXRlc3BhY2UgaW4gdGhlIHN0cmluZy5cbiAqXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZXaGl0ZXNwYWNlKHN0cikge1xuICBpZiAoL1xccy8udGVzdChzdHIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGFzcyBoYXMgaWxsZWdhbCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMnKTtcbiAgfVxufVxuXG4vKipcbiAqIFByb2R1Y2UgYSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIGEgY2xhc3NOYW1lIHdpdGhpbiBhbiBlbGVtZW50cyBjbGFzc05hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICogICAgICAgICBUaGUgY2xhc3NOYW1lIHRvIGdlbmVyYXRlIHRoZSBSZWdFeHAgZm9yLlxuICpcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqICAgICAgICAgVGhlIFJlZ0V4cCB0aGF0IHdpbGwgY2hlY2sgZm9yIGEgc3BlY2lmaWMgYGNsYXNzTmFtZWAgaW4gYW4gZWxlbWVudHNcbiAqICAgICAgICAgY2xhc3NOYW1lLlxuICovXG5mdW5jdGlvbiBjbGFzc1JlZ0V4cChjbGFzc05hbWUpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBjbGFzc05hbWUgKyAnKCR8XFxcXHMpJyk7XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgY3VycmVudCBET00gaW50ZXJmYWNlIGFwcGVhcnMgdG8gYmUgcmVhbC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc1JlYWwoKSB7XG4gIHJldHVybiAoXG5cbiAgICAvLyBCb3RoIGRvY3VtZW50IGFuZCB3aW5kb3cgd2lsbCBuZXZlciBiZSB1bmRlZmluZWQgdGhhbmtzIHRvIGBnbG9iYWxgLlxuICAgIGRvY3VtZW50ID09PSB3aW5kb3cuZG9jdW1lbnQgJiZcblxuICAgIC8vIEluIElFIDwgOSwgRE9NIG1ldGhvZHMgcmV0dXJuIFwib2JqZWN0XCIgYXMgdGhlaXIgdHlwZSwgc28gYWxsIHdlIGNhblxuICAgIC8vIGNvbmZpZGVudGx5IGNoZWNrIGlzIHRoYXQgaXQgZXhpc3RzLlxuICAgIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIERPTSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiAgICAgICAgVGhlIHRoaW5nIHRvIGNoZWNrXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIGl0IGlzIGEgRE9NIGVsZW1lbnRcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNFbCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgZnVuY3Rpb25zIHRvIHF1ZXJ5IHRoZSBET00gdXNpbmcgYSBnaXZlbiBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICogICAgICAgICBUaGUgbWV0aG9kIHRvIGNyZWF0ZSB0aGUgcXVlcnkgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqICAgICAgICAgVGhlIHF1ZXJ5IG1ldGhvZFxuICovXG5mdW5jdGlvbiBjcmVhdGVRdWVyaWVyKG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpc05vbkJsYW5rU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50W21ldGhvZF0obnVsbCk7XG4gICAgfVxuICAgIGlmIChpc05vbkJsYW5rU3RyaW5nKGNvbnRleHQpKSB7XG4gICAgICBjb250ZXh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250ZXh0KTtcbiAgICB9XG5cbiAgICB2YXIgY3R4ID0gaXNFbChjb250ZXh0KSA/IGNvbnRleHQgOiBkb2N1bWVudDtcblxuICAgIHJldHVybiBjdHhbbWV0aG9kXSAmJiBjdHhbbWV0aG9kXShzZWxlY3Rvcik7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbGVtZW50IGFuZCBhcHBsaWVzIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFt0YWdOYW1lPSdkaXYnXVxuICogICAgICAgICBOYW1lIG9mIHRhZyB0byBiZSBjcmVhdGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV1cbiAqICAgICAgICAgRWxlbWVudCBwcm9wZXJ0aWVzIHRvIGJlIGFwcGxpZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzPXt9XVxuICogICAgICAgICBFbGVtZW50IGF0dHJpYnV0ZXMgdG8gYmUgYXBwbGllZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fFRleHROb2RlfEFycmF5fEZ1bmN0aW9ufSBbY29udGVudF1cbiAqICAgICAgICAgQ29udGVudHMgZm9yIHRoZSBlbGVtZW50IChzZWU6IHtAbGluayBkb206bm9ybWFsaXplQ29udGVudH0pXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gIHZhciB0YWdOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnZGl2JztcbiAgdmFyIHByb3BlcnRpZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBjb250ZW50ID0gYXJndW1lbnRzWzNdO1xuXG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICB2YXIgdmFsID0gcHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAvLyBTZWUgIzIxNzZcbiAgICAvLyBXZSBvcmlnaW5hbGx5IHdlcmUgYWNjZXB0aW5nIGJvdGggcHJvcGVydGllcyBhbmQgYXR0cmlidXRlcyBpbiB0aGVcbiAgICAvLyBzYW1lIG9iamVjdCwgYnV0IHRoYXQgZG9lc24ndCB3b3JrIHNvIHdlbGwuXG4gICAgaWYgKHByb3BOYW1lLmluZGV4T2YoJ2FyaWEtJykgIT09IC0xIHx8IHByb3BOYW1lID09PSAncm9sZScgfHwgcHJvcE5hbWUgPT09ICd0eXBlJykge1xuICAgICAgbG9nJDEud2Fybih0c21sKF90ZW1wbGF0ZU9iamVjdCwgcHJvcE5hbWUsIHZhbCkpO1xuICAgICAgZWwuc2V0QXR0cmlidXRlKHByb3BOYW1lLCB2YWwpO1xuXG4gICAgICAvLyBIYW5kbGUgdGV4dENvbnRlbnQgc2luY2UgaXQncyBub3Qgc3VwcG9ydGVkIGV2ZXJ5d2hlcmUgYW5kIHdlIGhhdmUgYVxuICAgICAgLy8gbWV0aG9kIGZvciBpdC5cbiAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSAndGV4dENvbnRlbnQnKSB7XG4gICAgICB0ZXh0Q29udGVudChlbCwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxbcHJvcE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJpYnV0ZXNbYXR0ck5hbWVdKTtcbiAgfSk7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBhcHBlbmRDb250ZW50KGVsLCBjb250ZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBJbmplY3RzIHRleHQgaW50byBhbiBlbGVtZW50LCByZXBsYWNpbmcgYW55IGV4aXN0aW5nIGNvbnRlbnRzIGVudGlyZWx5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byBhZGQgdGV4dCBjb250ZW50IGludG9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogICAgICAgIFRoZSB0ZXh0IGNvbnRlbnQgdG8gYWRkLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHdpdGggYWRkZWQgdGV4dCBjb250ZW50LlxuICovXG5mdW5jdGlvbiB0ZXh0Q29udGVudChlbCwgdGV4dCkge1xuICBpZiAodHlwZW9mIGVsLnRleHRDb250ZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIGVsLmlubmVyVGV4dCA9IHRleHQ7XG4gIH0gZWxzZSB7XG4gICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBJbnNlcnQgYW4gZWxlbWVudCBhcyB0aGUgZmlyc3QgY2hpbGQgbm9kZSBvZiBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBjaGlsZFxuICogICAgICAgIEVsZW1lbnQgdG8gaW5zZXJ0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAqICAgICAgICBFbGVtZW50IHRvIGluc2VydCBjaGlsZCBpbnRvXG4gKi9cbmZ1bmN0aW9uIHByZXBlbmRUbyhjaGlsZCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHBhcmVudC5maXJzdENoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBoYXMgYSBDU1MgY2xhc3NcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgICAgICBFbGVtZW50IHRvIGNoZWNrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9DaGVja1xuICogICAgICAgIENsYXNzIG5hbWUgdG8gY2hlY2sgZm9yXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBlbGVtZW50IGhhZCB0aGUgY2xhc3NcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHRocm93cyB7RXJyb3J9XG4gKiAgICAgICAgIFRocm93cyBhbiBlcnJvciBpZiBgY2xhc3NUb0NoZWNrYCBoYXMgd2hpdGUgc3BhY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzVG9DaGVjaykge1xuICB0aHJvd0lmV2hpdGVzcGFjZShjbGFzc1RvQ2hlY2spO1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NUb0NoZWNrKTtcbiAgfVxuICByZXR1cm4gY2xhc3NSZWdFeHAoY2xhc3NUb0NoZWNrKS50ZXN0KGVsZW1lbnQuY2xhc3NOYW1lKTtcbn1cblxuLyoqXG4gKiBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgICAgICAgRWxlbWVudCB0byBhZGQgY2xhc3MgbmFtZSB0by5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb0FkZFxuICogICAgICAgIENsYXNzIG5hbWUgdG8gYWRkLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBkb20gZWxlbWVudCB3aXRoIHRoZSBhZGRlZCBjbGFzcyBuYW1lLlxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc1RvQWRkKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc1RvQWRkKTtcblxuICAgIC8vIERvbid0IG5lZWQgdG8gYHRocm93SWZXaGl0ZXNwYWNlYCBoZXJlIGJlY2F1c2UgYGhhc0VsQ2xhc3NgIHdpbGwgZG8gaXRcbiAgICAvLyBpbiB0aGUgY2FzZSBvZiBjbGFzc0xpc3Qgbm90IGJlaW5nIHN1cHBvcnRlZC5cbiAgfSBlbHNlIGlmICghaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb0FkZCkpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IChlbGVtZW50LmNsYXNzTmFtZSArICcgJyArIGNsYXNzVG9BZGQpLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICAgICAgIEVsZW1lbnQgdG8gcmVtb3ZlIGEgY2xhc3MgbmFtZSBmcm9tLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvUmVtb3ZlXG4gKiAgICAgICAgQ2xhc3MgbmFtZSB0byByZW1vdmVcbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZG9tIGVsZW1lbnQgd2l0aCBjbGFzcyBuYW1lIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzVG9SZW1vdmUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzVG9SZW1vdmUpO1xuICB9IGVsc2Uge1xuICAgIHRocm93SWZXaGl0ZXNwYWNlKGNsYXNzVG9SZW1vdmUpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoL1xccysvKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjICE9PSBjbGFzc1RvUmVtb3ZlO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIFRoZSBjYWxsYmFjayBkZWZpbml0aW9uIGZvciB0b2dnbGVFbENsYXNzLlxuICpcbiAqIEBjYWxsYmFjayBEb21+UHJlZGljYXRlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICAgICAgIFRoZSBET00gZWxlbWVudCBvZiB0aGUgQ29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvVG9nZ2xlXG4gKiAgICAgICAgVGhlIGBjbGFzc05hbWVgIHRoYXQgd2FudHMgdG8gYmUgdG9nZ2xlZFxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxuICogICAgICAgICAtIElmIHRydWUgdGhlIGBjbGFzc1RvVG9nZ2xlYCB3aWxsIGdldCBhZGRlZCB0byBgZWxlbWVudGAuXG4gKiAgICAgICAgIC0gSWYgZmFsc2UgdGhlIGBjbGFzc1RvVG9nZ2xlYCB3aWxsIGdldCByZW1vdmVkIGZyb20gYGVsZW1lbnRgLlxuICogICAgICAgICAtIElmIHVuZGVmaW5lZCB0aGlzIGNhbGxiYWNrIHdpbGwgYmUgaWdub3JlZFxuICovXG5cbi8qKlxuICogQWRkcyBvciByZW1vdmVzIGEgQ1NTIGNsYXNzIG5hbWUgb24gYW4gZWxlbWVudCBkZXBlbmRpbmcgb24gYW4gb3B0aW9uYWxcbiAqIGNvbmRpdGlvbiBvciB0aGUgcHJlc2VuY2UvYWJzZW5jZSBvZiB0aGUgY2xhc3MgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byB0b2dnbGUgYSBjbGFzcyBuYW1lIG9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvVG9nZ2xlXG4gKiAgICAgICAgVGhlIGNsYXNzIHRoYXQgc2hvdWxkIGJlIHRvZ2dsZWRcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW58UHJlZGljYXRlQ2FsbGJhY2t9IFtwcmVkaWNhdGVdXG4gKiAgICAgICAgU2VlIHRoZSByZXR1cm4gdmFsdWUgZm9yIHtAbGluayBEb21+UHJlZGljYXRlQ2FsbGJhY2t9XG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgd2l0aCBhIGNsYXNzIHRoYXQgaGFzIGJlZW4gdG9nZ2xlZC5cbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSwgcHJlZGljYXRlKSB7XG5cbiAgLy8gVGhpcyBDQU5OT1QgdXNlIGBjbGFzc0xpc3RgIGludGVybmFsbHkgYmVjYXVzZSBJRSBkb2VzIG5vdCBzdXBwb3J0IHRoZVxuICAvLyBzZWNvbmQgcGFyYW1ldGVyIHRvIHRoZSBgY2xhc3NMaXN0LnRvZ2dsZSgpYCBtZXRob2QhIFdoaWNoIGlzIGZpbmUgYmVjYXVzZVxuICAvLyBgY2xhc3NMaXN0YCB3aWxsIGJlIHVzZWQgYnkgdGhlIGFkZC9yZW1vdmUgZnVuY3Rpb25zLlxuICB2YXIgaGFzID0gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XG5cbiAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcmVkaWNhdGUgPSBwcmVkaWNhdGUoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcHJlZGljYXRlID0gIWhhcztcbiAgfVxuXG4gIC8vIElmIHRoZSBuZWNlc3NhcnkgY2xhc3Mgb3BlcmF0aW9uIG1hdGNoZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlXG4gIC8vIGVsZW1lbnQsIG5vIGFjdGlvbiBpcyByZXF1aXJlZC5cbiAgaWYgKHByZWRpY2F0ZSA9PT0gaGFzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByZWRpY2F0ZSkge1xuICAgIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzVG9Ub2dnbGUpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzVG9Ub2dnbGUpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQXBwbHkgYXR0cmlidXRlcyB0byBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgdG8gYWRkIGF0dHJpYnV0ZXMgdG8uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXVxuICogICAgICAgIEF0dHJpYnV0ZXMgdG8gYmUgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbCwgYXR0cmlidXRlcykge1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyaWJ1dGVzW2F0dHJOYW1lXTtcblxuICAgIGlmIChhdHRyVmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIGF0dHJWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXR0clZhbHVlID09PSBmYWxzZSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUgPT09IHRydWUgPyAnJyA6IGF0dHJWYWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZSB2YWx1ZXMsIGFzIGRlZmluZWQgb24gdGhlIEhUTUwgdGFnXG4gKiBBdHRyaWJ1dGVzIGFyZSBub3QgdGhlIHNhbWUgYXMgcHJvcGVydGllcy4gVGhleSdyZSBkZWZpbmVkIG9uIHRoZSB0YWdcbiAqIG9yIHdpdGggc2V0QXR0cmlidXRlICh3aGljaCBzaG91bGRuJ3QgYmUgdXNlZCB3aXRoIEhUTUwpXG4gKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgb3IgZmFsc2UgZm9yIGJvb2xlYW4gYXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhZ1xuICogICAgICAgIEVsZW1lbnQgZnJvbSB3aGljaCB0byBnZXQgdGFnIGF0dHJpYnV0ZXMuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBBbGwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyh0YWcpIHtcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIC8vIGtub3duIGJvb2xlYW4gYXR0cmlidXRlc1xuICAvLyB3ZSBjYW4gY2hlY2sgZm9yIG1hdGNoaW5nIGJvb2xlYW4gcHJvcGVydGllcywgYnV0IG9sZGVyIGJyb3dzZXJzXG4gIC8vIHdvbid0IGtub3cgYWJvdXQgSFRNTDUgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXQgd2Ugc3RpbGwgcmVhZCBmcm9tXG4gIHZhciBrbm93bkJvb2xlYW5zID0gJywnICsgJ2F1dG9wbGF5LGNvbnRyb2xzLGxvb3AsbXV0ZWQsZGVmYXVsdCcgKyAnLCc7XG5cbiAgaWYgKHRhZyAmJiB0YWcuYXR0cmlidXRlcyAmJiB0YWcuYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGF0dHJzID0gdGFnLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKHZhciBpID0gYXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhdHRyTmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICB2YXIgYXR0clZhbCA9IGF0dHJzW2ldLnZhbHVlO1xuXG4gICAgICAvLyBjaGVjayBmb3Iga25vd24gYm9vbGVhbnNcbiAgICAgIC8vIHRoZSBtYXRjaGluZyBlbGVtZW50IHByb3BlcnR5IHdpbGwgcmV0dXJuIGEgdmFsdWUgZm9yIHR5cGVvZlxuICAgICAgaWYgKHR5cGVvZiB0YWdbYXR0ck5hbWVdID09PSAnYm9vbGVhbicgfHwga25vd25Cb29sZWFucy5pbmRleE9mKCcsJyArIGF0dHJOYW1lICsgJywnKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gdGhlIHZhbHVlIG9mIGFuIGluY2x1ZGVkIGJvb2xlYW4gYXR0cmlidXRlIGlzIHR5cGljYWxseSBhbiBlbXB0eVxuICAgICAgICAvLyBzdHJpbmcgKCcnKSB3aGljaCB3b3VsZCBlcXVhbCBmYWxzZSBpZiB3ZSBqdXN0IGNoZWNrIGZvciBhIGZhbHNlIHZhbHVlLlxuICAgICAgICAvLyB3ZSBhbHNvIGRvbid0IHdhbnQgc3VwcG9ydCBiYWQgY29kZSBsaWtlIGF1dG9wbGF5PSdmYWxzZSdcbiAgICAgICAgYXR0clZhbCA9IGF0dHJWYWwgIT09IG51bGwgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG9ialthdHRyTmFtZV0gPSBhdHRyVmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhbiBlbGVtZW50J3MgYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEEgRE9NIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiAgICAgICAgQXR0cmlidXRlIHRvIGdldCB0aGUgdmFsdWUgb2ZcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGVsLCBhdHRyaWJ1dGUpIHtcbiAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBBIERPTSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogICAgICAgIEF0dHJpYnV0ZSB0byBzZXRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqICAgICAgICBWYWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZSB0b1xuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZWwsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgZWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbiBlbGVtZW50J3MgYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEEgRE9NIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiAgICAgICAgQXR0cmlidXRlIHRvIHJlbW92ZVxuICovXG5mdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoZWwsIGF0dHJpYnV0ZSkge1xuICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGJsb2NrIHRoZSBhYmlsaXR5IHRvIHNlbGVjdCB0ZXh0IHdoaWxlIGRyYWdnaW5nIGNvbnRyb2xzXG4gKi9cbmZ1bmN0aW9uIGJsb2NrVGV4dFNlbGVjdGlvbigpIHtcbiAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICBkb2N1bWVudC5vbnNlbGVjdHN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJuIG9mZiB0ZXh0IHNlbGVjdGlvbiBibG9ja2luZ1xuICovXG5mdW5jdGlvbiB1bmJsb2NrVGV4dFNlbGVjdGlvbigpIHtcbiAgZG9jdW1lbnQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBJZGVudGljYWwgdG8gdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBmdW5jdGlvbiwgYnV0IGVuc3VyZXMgdGhhdFxuICogdGhlIG1ldGhvZCBpcyBzdXBwb3J0ZWQgYXQgYWxsIChpdCBpcyBpbiBhbGwgYnJvd3NlcnMgd2UgY2xhaW0gdG8gc3VwcG9ydClcbiAqIGFuZCB0aGF0IHRoZSBlbGVtZW50IGlzIGluIHRoZSBET00gYmVmb3JlIGNvbnRpbnVpbmcuXG4gKlxuICogVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGFsc28gc2hpbXMgcHJvcGVydGllcyB3aGljaCBhcmUgbm90IHByb3ZpZGVkIGJ5IHNvbWVcbiAqIG9sZGVyIGJyb3dzZXJzIChuYW1lbHksIElFOCkuXG4gKlxuICogQWRkaXRpb25hbGx5LCBzb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGFkZGluZyBwcm9wZXJ0aWVzIHRvIGFcbiAqIGBDbGllbnRSZWN0YC9gRE9NUmVjdGAgb2JqZWN0OyBzbywgd2Ugc2hhbGxvdy1jb3B5IGl0IHdpdGggdGhlIHN0YW5kYXJkXG4gKiBwcm9wZXJ0aWVzIChleGNlcHQgYHhgIGFuZCBgeWAgd2hpY2ggYXJlIG5vdCB3aWRlbHkgc3VwcG9ydGVkKS4gVGhpcyBoZWxwc1xuICogYXZvaWQgaW1wbGVtZW50YXRpb25zIHdoZXJlIGtleXMgYXJlIG5vbi1lbnVtZXJhYmxlLlxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgIEVsZW1lbnQgd2hvc2UgYENsaWVudFJlY3RgIHdlIHdhbnQgdG8gY2FsY3VsYXRlLlxuICpcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKiAgICAgICAgIEFsd2F5cyByZXR1cm5zIGEgcGxhaW5cbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gIGlmIChlbCAmJiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgZWwucGFyZW50Tm9kZSkge1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgWydib3R0b20nLCAnaGVpZ2h0JywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ3dpZHRoJ10uZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKHJlY3Rba10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHRba10gPSByZWN0W2tdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXN1bHQuaGVpZ2h0KSB7XG4gICAgICByZXN1bHQuaGVpZ2h0ID0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlKGVsLCAnaGVpZ2h0JykpO1xuICAgIH1cblxuICAgIGlmICghcmVzdWx0LndpZHRoKSB7XG4gICAgICByZXN1bHQud2lkdGggPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUoZWwsICd3aWR0aCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogVGhlIHBvc3Rpb24gb2YgYSBET00gZWxlbWVudCBvbiB0aGUgcGFnZS5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6ZG9tflBvc2l0aW9uXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnRcbiAqICAgICAgICAgICBQaXhlbHMgdG8gdGhlIGxlZnRcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gdG9wXG4gKiAgICAgICAgICAgUGl4ZWxzIG9uIHRvcFxuICovXG5cbi8qKlxuICogT2Zmc2V0IExlZnQuXG4gKiBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdGVjaG5pcXVlIGZyb21cbiAqIEpvaG4gUmVzaWdcbiAqXG4gKiBAc2VlIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9nZXRib3VuZGluZ2NsaWVudHJlY3QtaXMtYXdlc29tZS9cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCBmcm9tIHdoaWNoIHRvIGdldCBvZmZzZXRcbiAqXG4gKiBAcmV0dXJuIHttb2R1bGU6ZG9tflBvc2l0aW9ufVxuICogICAgICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIGluLlxuICovXG5mdW5jdGlvbiBmaW5kUG9zaXRpb24oZWwpIHtcbiAgdmFyIGJveCA9IHZvaWQgMDtcblxuICBpZiAoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICBib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuXG4gIGlmICghYm94KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICB9XG5cbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cbiAgdmFyIGNsaWVudExlZnQgPSBkb2NFbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBib2R5LnNjcm9sbExlZnQ7XG4gIHZhciBsZWZ0ID0gYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdDtcblxuICB2YXIgY2xpZW50VG9wID0gZG9jRWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgYm9keS5zY3JvbGxUb3A7XG4gIHZhciB0b3AgPSBib3gudG9wICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wO1xuXG4gIC8vIEFuZHJvaWQgc29tZXRpbWVzIHJldHVybnMgc2xpZ2h0bHkgb2ZmIGRlY2ltYWwgdmFsdWVzLCBzbyBuZWVkIHRvIHJvdW5kXG4gIHJldHVybiB7XG4gICAgbGVmdDogTWF0aC5yb3VuZChsZWZ0KSxcbiAgICB0b3A6IE1hdGgucm91bmQodG9wKVxuICB9O1xufVxuXG4vKipcbiAqIHggYW5kIHkgY29vcmRpbmF0ZXMgZm9yIGEgZG9tIGVsZW1lbnQgb3IgbW91c2UgcG9pbnRlclxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERvbX5Db29yZGluYXRlc1xuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4XG4gKiAgICAgICAgICAgeCBjb29yZGluYXRlIGluIHBpeGVsc1xuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5XG4gKiAgICAgICAgICAgeSBjb29yZGluYXRlIGluIHBpeGVsc1xuICovXG5cbi8qKlxuICogR2V0IHBvaW50ZXIgcG9zaXRpb24gaW4gZWxlbWVudFxuICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzLlxuICogVGhlIGJhc2Ugb24gdGhlIGNvb3JkaW5hdGVzIGFyZSB0aGUgYm90dG9tIGxlZnQgb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgb24gd2hpY2ggdG8gZ2V0IHRoZSBwb2ludGVyIHBvc2l0aW9uIG9uXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAqICAgICAgICBFdmVudCBvYmplY3RcbiAqXG4gKiBAcmV0dXJuIHtEb21+Q29vcmRpbmF0ZXN9XG4gKiAgICAgICAgIEEgQ29vcmRpbmF0ZXMgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1vdXNlIHBvc2l0aW9uLlxuICpcbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRlclBvc2l0aW9uKGVsLCBldmVudCkge1xuICB2YXIgcG9zaXRpb24gPSB7fTtcbiAgdmFyIGJveCA9IGZpbmRQb3NpdGlvbihlbCk7XG4gIHZhciBib3hXID0gZWwub2Zmc2V0V2lkdGg7XG4gIHZhciBib3hIID0gZWwub2Zmc2V0SGVpZ2h0O1xuXG4gIHZhciBib3hZID0gYm94LnRvcDtcbiAgdmFyIGJveFggPSBib3gubGVmdDtcbiAgdmFyIHBhZ2VZID0gZXZlbnQucGFnZVk7XG4gIHZhciBwYWdlWCA9IGV2ZW50LnBhZ2VYO1xuXG4gIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgIHBhZ2VYID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgcGFnZVkgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcbiAgfVxuXG4gIHBvc2l0aW9uLnkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoYm94WSAtIHBhZ2VZICsgYm94SCkgLyBib3hIKSk7XG4gIHBvc2l0aW9uLnggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAocGFnZVggLSBib3hYKSAvIGJveFcpKTtcblxuICByZXR1cm4gcG9zaXRpb247XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcywgdmlhIGR1Y2sgdHlwaW5nLCB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgdGV4dCBub2RlLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiAgICAgICAgQ2hlY2sgaWYgdGhpcyB2YWx1ZSBpcyBhIHRleHQgbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgaXQgaXMgYSB0ZXh0IG5vZGVcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAzO1xufVxuXG4vKipcbiAqIEVtcHRpZXMgdGhlIGNvbnRlbnRzIG9mIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBlbGVtZW50IHRvIGVtcHR5IGNoaWxkcmVuIGZyb21cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIG5vIGNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uIGVtcHR5RWwoZWwpIHtcbiAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBjb250ZW50IGZvciBldmVudHVhbCBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICpcbiAqIFRoaXMgYWxsb3dzIGEgd2lkZSByYW5nZSBvZiBjb250ZW50IGRlZmluaXRpb24gbWV0aG9kcywgYnV0IHByb3RlY3RzXG4gKiBmcm9tIGZhbGxpbmcgaW50byB0aGUgdHJhcCBvZiBzaW1wbHkgd3JpdGluZyB0byBgaW5uZXJIVE1MYCwgd2hpY2ggaXNcbiAqIGFuIFhTUyBjb25jZXJuLlxuICpcbiAqIFRoZSBjb250ZW50IGZvciBhbiBlbGVtZW50IGNhbiBiZSBwYXNzZWQgaW4gbXVsdGlwbGUgdHlwZXMgYW5kXG4gKiBjb21iaW5hdGlvbnMsIHdob3NlIGJlaGF2aW9yIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gY29udGVudFxuICogICAgICAgIC0gU3RyaW5nOiBOb3JtYWxpemVkIGludG8gYSB0ZXh0IG5vZGUuXG4gKiAgICAgICAgLSBFbGVtZW50L1RleHROb2RlOiBQYXNzZWQgdGhyb3VnaC5cbiAqICAgICAgICAtIEFycmF5OiBBIG9uZS1kaW1lbnNpb25hbCBhcnJheSBvZiBzdHJpbmdzLCBlbGVtZW50cywgbm9kZXMsIG9yIGZ1bmN0aW9uc1xuICogICAgICAgICAgKHdoaWNoIHJldHVybiBzaW5nbGUgc3RyaW5ncywgZWxlbWVudHMsIG9yIG5vZGVzKS5cbiAqICAgICAgICAtIEZ1bmN0aW9uOiBJZiB0aGUgc29sZSBhcmd1bWVudCwgaXMgZXhwZWN0ZWQgdG8gcHJvZHVjZSBhIHN0cmluZywgZWxlbWVudCxcbiAqICAgICAgICAgIG5vZGUsIG9yIGFycmF5IGFzIGRlZmluZWQgYWJvdmUuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiAgICAgICAgIEFsbCBvZiB0aGUgY29udGVudCB0aGF0IHdhcyBwYXNzZWQgaW4gbm9ybWFsaXplZC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQ29udGVudChjb250ZW50KSB7XG5cbiAgLy8gRmlyc3QsIGludm9rZSBjb250ZW50IGlmIGl0IGlzIGEgZnVuY3Rpb24uIElmIGl0IHByb2R1Y2VzIGFuIGFycmF5LFxuICAvLyB0aGF0IG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgbm9ybWFsaXphdGlvbi5cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQoKTtcbiAgfVxuXG4gIC8vIE5leHQgdXAsIG5vcm1hbGl6ZSB0byBhbiBhcnJheSwgc28gb25lIG9yIG1hbnkgaXRlbXMgY2FuIGJlIG5vcm1hbGl6ZWQsXG4gIC8vIGZpbHRlcmVkLCBhbmQgcmV0dXJuZWQuXG4gIHJldHVybiAoQXJyYXkuaXNBcnJheShjb250ZW50KSA/IGNvbnRlbnQgOiBbY29udGVudF0pLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIC8vIEZpcnN0LCBpbnZva2UgdmFsdWUgaWYgaXQgaXMgYSBmdW5jdGlvbiB0byBwcm9kdWNlIGEgbmV3IHZhbHVlLFxuICAgIC8vIHdoaWNoIHdpbGwgYmUgc3Vic2VxdWVudGx5IG5vcm1hbGl6ZWQgdG8gYSBOb2RlIG9mIHNvbWUga2luZC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRWwodmFsdWUpIHx8IGlzVGV4dE5vZGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgL1xcUy8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG4gICAgfVxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIGFuZCBhcHBlbmRzIGNvbnRlbnQgdG8gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCB0byBhcHBlbmQgbm9ybWFsaXplZCBjb250ZW50IHRvLlxuICpcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fFRleHROb2RlfEFycmF5fEZ1bmN0aW9ufSBjb250ZW50XG4gKiAgICAgICAgU2VlIHRoZSBgY29udGVudGAgYXJndW1lbnQgb2Yge0BsaW5rIGRvbTpub3JtYWxpemVDb250ZW50fVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHdpdGggYXBwZW5kZWQgbm9ybWFsaXplZCBjb250ZW50LlxuICovXG5mdW5jdGlvbiBhcHBlbmRDb250ZW50KGVsLCBjb250ZW50KSB7XG4gIG5vcm1hbGl6ZUNvbnRlbnQoY29udGVudCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgfSk7XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIGFuZCBpbnNlcnRzIGNvbnRlbnQgaW50byBhbiBlbGVtZW50OyB0aGlzIGlzIGlkZW50aWNhbCB0b1xuICogYGFwcGVuZENvbnRlbnQoKWAsIGV4Y2VwdCBpdCBlbXB0aWVzIHRoZSBlbGVtZW50IGZpcnN0LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBFbGVtZW50IHRvIGluc2VydCBub3JtYWxpemVkIGNvbnRlbnQgaW50by5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fFRleHROb2RlfEFycmF5fEZ1bmN0aW9ufSBjb250ZW50XG4gKiAgICAgICAgU2VlIHRoZSBgY29udGVudGAgYXJndW1lbnQgb2Yge0BsaW5rIGRvbTpub3JtYWxpemVDb250ZW50fVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHdpdGggaW5zZXJ0ZWQgbm9ybWFsaXplZCBjb250ZW50LlxuICpcbiAqL1xuZnVuY3Rpb24gaW5zZXJ0Q29udGVudChlbCwgY29udGVudCkge1xuICByZXR1cm4gYXBwZW5kQ29udGVudChlbXB0eUVsKGVsKSwgY29udGVudCk7XG59XG5cbi8qKlxuICogRmluZHMgYSBzaW5nbGUgRE9NIGVsZW1lbnQgbWF0Y2hpbmcgYHNlbGVjdG9yYCB3aXRoaW4gdGhlIG9wdGlvbmFsXG4gKiBgY29udGV4dGAgb2YgYW5vdGhlciBET00gZWxlbWVudCAoZGVmYXVsdGluZyB0byBgZG9jdW1lbnRgKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IFtjb250ZXh0PWRvY3VtZW50XVxuICogICAgICAgIEEgRE9NIGVsZW1lbnQgd2l0aGluIHdoaWNoIHRvIHF1ZXJ5LiBDYW4gYWxzbyBiZSBhIHNlbGVjdG9yXG4gKiAgICAgICAgc3RyaW5nIGluIHdoaWNoIGNhc2UgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgd2lsbCBiZSB1c2VkXG4gKiAgICAgICAgYXMgY29udGV4dC4gSWYgbWlzc2luZyAob3Igbm8gZWxlbWVudCBtYXRjaGVzIHNlbGVjdG9yKSwgZmFsbHNcbiAqICAgICAgICBiYWNrIHRvIGBkb2N1bWVudGAuXG4gKlxuICogQHJldHVybiB7RWxlbWVudHxudWxsfVxuICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBmb3VuZCBvciBudWxsLlxuICovXG52YXIgJCA9IGNyZWF0ZVF1ZXJpZXIoJ3F1ZXJ5U2VsZWN0b3InKTtcblxuLyoqXG4gKiBGaW5kcyBhIGFsbCBET00gZWxlbWVudHMgbWF0Y2hpbmcgYHNlbGVjdG9yYCB3aXRoaW4gdGhlIG9wdGlvbmFsXG4gKiBgY29udGV4dGAgb2YgYW5vdGhlciBET00gZWxlbWVudCAoZGVmYXVsdGluZyB0byBgZG9jdW1lbnRgKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqICAgICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JBbGxgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IFtjb250ZXh0PWRvY3VtZW50XVxuICogICAgICAgICAgIEEgRE9NIGVsZW1lbnQgd2l0aGluIHdoaWNoIHRvIHF1ZXJ5LiBDYW4gYWxzbyBiZSBhIHNlbGVjdG9yXG4gKiAgICAgICAgICAgc3RyaW5nIGluIHdoaWNoIGNhc2UgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgd2lsbCBiZSB1c2VkXG4gKiAgICAgICAgICAgYXMgY29udGV4dC4gSWYgbWlzc2luZyAob3Igbm8gZWxlbWVudCBtYXRjaGVzIHNlbGVjdG9yKSwgZmFsbHNcbiAqICAgICAgICAgICBiYWNrIHRvIGBkb2N1bWVudGAuXG4gKlxuICogQHJldHVybiB7Tm9kZUxpc3R9XG4gKiAgICAgICAgIEEgZWxlbWVudCBsaXN0IG9mIGVsZW1lbnRzIHRoYXQgd2VyZSBmb3VuZC4gV2lsbCBiZSBlbXB0eSBpZiBub25lIHdlcmUgZm91bmQuXG4gKlxuICovXG52YXIgJCQgPSBjcmVhdGVRdWVyaWVyKCdxdWVyeVNlbGVjdG9yQWxsJyk7XG5cblxuXG52YXIgRG9tID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdGlzUmVhbDogaXNSZWFsLFxuXHRpc0VsOiBpc0VsLFxuXHRjcmVhdGVFbDogY3JlYXRlRWwsXG5cdHRleHRDb250ZW50OiB0ZXh0Q29udGVudCxcblx0cHJlcGVuZFRvOiBwcmVwZW5kVG8sXG5cdGhhc0NsYXNzOiBoYXNDbGFzcyxcblx0YWRkQ2xhc3M6IGFkZENsYXNzLFxuXHRyZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG5cdHRvZ2dsZUNsYXNzOiB0b2dnbGVDbGFzcyxcblx0c2V0QXR0cmlidXRlczogc2V0QXR0cmlidXRlcyxcblx0Z2V0QXR0cmlidXRlczogZ2V0QXR0cmlidXRlcyxcblx0Z2V0QXR0cmlidXRlOiBnZXRBdHRyaWJ1dGUsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlLFxuXHRyZW1vdmVBdHRyaWJ1dGU6IHJlbW92ZUF0dHJpYnV0ZSxcblx0YmxvY2tUZXh0U2VsZWN0aW9uOiBibG9ja1RleHRTZWxlY3Rpb24sXG5cdHVuYmxvY2tUZXh0U2VsZWN0aW9uOiB1bmJsb2NrVGV4dFNlbGVjdGlvbixcblx0Z2V0Qm91bmRpbmdDbGllbnRSZWN0OiBnZXRCb3VuZGluZ0NsaWVudFJlY3QsXG5cdGZpbmRQb3NpdGlvbjogZmluZFBvc2l0aW9uLFxuXHRnZXRQb2ludGVyUG9zaXRpb246IGdldFBvaW50ZXJQb3NpdGlvbixcblx0aXNUZXh0Tm9kZTogaXNUZXh0Tm9kZSxcblx0ZW1wdHlFbDogZW1wdHlFbCxcblx0bm9ybWFsaXplQ29udGVudDogbm9ybWFsaXplQ29udGVudCxcblx0YXBwZW5kQ29udGVudDogYXBwZW5kQ29udGVudCxcblx0aW5zZXJ0Q29udGVudDogaW5zZXJ0Q29udGVudCxcblx0JDogJCxcblx0JCQ6ICQkXG59KTtcblxuLyoqXG4gKiBAZmlsZSBndWlkLmpzXG4gKiBAbW9kdWxlIGd1aWRcbiAqL1xuXG4vKipcbiAqIFVuaXF1ZSBJRCBmb3IgYW4gZWxlbWVudCBvciBmdW5jdGlvblxuICogQHR5cGUge051bWJlcn1cbiAqL1xudmFyIF9ndWlkID0gMTtcblxuLyoqXG4gKiBHZXQgYSB1bmlxdWUgYXV0by1pbmNyZW1lbnRpbmcgSUQgYnkgbnVtYmVyIHRoYXQgaGFzIG5vdCBiZWVuIHJldHVybmVkIGJlZm9yZS5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIEEgbmV3IHVuaXF1ZSBJRC5cbiAqL1xuZnVuY3Rpb24gbmV3R1VJRCgpIHtcbiAgcmV0dXJuIF9ndWlkKys7XG59XG5cbi8qKlxuICogQGZpbGUgZG9tLWRhdGEuanNcbiAqIEBtb2R1bGUgZG9tLWRhdGFcbiAqL1xuLyoqXG4gKiBFbGVtZW50IERhdGEgU3RvcmUuXG4gKlxuICogQWxsb3dzIGZvciBiaW5kaW5nIGRhdGEgdG8gYW4gZWxlbWVudCB3aXRob3V0IHB1dHRpbmcgaXQgZGlyZWN0bHkgb24gdGhlXG4gKiBlbGVtZW50LiBFeC4gRXZlbnQgbGlzdGVuZXJzIGFyZSBzdG9yZWQgaGVyZS5cbiAqIChhbHNvIGZyb20ganNuaW5qYS5jb20sIHNsaWdodGx5IG1vZGlmaWVkIGFuZCB1cGRhdGVkIGZvciBjbG9zdXJlIGNvbXBpbGVyKVxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZWxEYXRhID0ge307XG5cbi8qXG4gKiBVbmlxdWUgYXR0cmlidXRlIG5hbWUgdG8gc3RvcmUgYW4gZWxlbWVudCdzIGd1aWQgaW5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGNvbnN0YW50XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZWxJZEF0dHIgPSAndmRhdGEnICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY2FjaGUgb2JqZWN0IHdoZXJlIGRhdGEgZm9yIGFuIGVsZW1lbnQgaXMgc3RvcmVkXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgdG8gc3RvcmUgZGF0YSBmb3IuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBUaGUgY2FjaGUgb2JqZWN0IGZvciB0aGF0IGVsIHRoYXQgd2FzIHBhc3NlZCBpbi5cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YShlbCkge1xuICB2YXIgaWQgPSBlbFtlbElkQXR0cl07XG5cbiAgaWYgKCFpZCkge1xuICAgIGlkID0gZWxbZWxJZEF0dHJdID0gbmV3R1VJRCgpO1xuICB9XG5cbiAgaWYgKCFlbERhdGFbaWRdKSB7XG4gICAgZWxEYXRhW2lkXSA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIGVsRGF0YVtpZF07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBlbGVtZW50IGhhcyBjYWNoZWQgZGF0YVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBDaGVjayBpZiB0aGlzIGVsZW1lbnQgaGFzIGNhY2hlZCBkYXRhLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgRE9NIGVsZW1lbnQgaGFzIGNhY2hlZCBkYXRhLlxuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaGFzRGF0YShlbCkge1xuICB2YXIgaWQgPSBlbFtlbElkQXR0cl07XG5cbiAgaWYgKCFpZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVsRGF0YVtpZF0pLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBEZWxldGUgZGF0YSBmb3IgdGhlIGVsZW1lbnQgZnJvbSB0aGUgY2FjaGUgYW5kIHRoZSBndWlkIGF0dHIgZnJvbSBnZXRFbGVtZW50QnlJZFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBSZW1vdmUgY2FjaGVkIGRhdGEgZm9yIHRoaXMgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRGF0YShlbCkge1xuICB2YXIgaWQgPSBlbFtlbElkQXR0cl07XG5cbiAgaWYgKCFpZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJlbW92ZSBhbGwgc3RvcmVkIGRhdGFcbiAgZGVsZXRlIGVsRGF0YVtpZF07XG5cbiAgLy8gUmVtb3ZlIHRoZSBlbElkQXR0ciBwcm9wZXJ0eSBmcm9tIHRoZSBET00gbm9kZVxuICB0cnkge1xuICAgIGRlbGV0ZSBlbFtlbElkQXR0cl07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZWwucmVtb3ZlQXR0cmlidXRlKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoZWxJZEF0dHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSBkb2Vzbid0IGFwcGVhciB0byBzdXBwb3J0IHJlbW92ZUF0dHJpYnV0ZSBvbiB0aGUgZG9jdW1lbnQgZWxlbWVudFxuICAgICAgZWxbZWxJZEF0dHJdID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAZmlsZSBldmVudHMuanMuIEFuIEV2ZW50IFN5c3RlbSAoSm9obiBSZXNpZyAtIFNlY3JldHMgb2YgYSBKUyBOaW5qYSBodHRwOi8vanNuaW5qYS5jb20vKVxuICogKE9yaWdpbmFsIGJvb2sgdmVyc2lvbiB3YXNuJ3QgY29tcGxldGVseSB1c2FibGUsIHNvIGZpeGVkIHNvbWUgdGhpbmdzIGFuZCBtYWRlIENsb3N1cmUgQ29tcGlsZXIgY29tcGF0aWJsZSlcbiAqIFRoaXMgc2hvdWxkIHdvcmsgdmVyeSBzaW1pbGFybHkgdG8galF1ZXJ5J3MgZXZlbnRzLCBob3dldmVyIGl0J3MgYmFzZWQgb2ZmIHRoZSBib29rIHZlcnNpb24gd2hpY2ggaXNuJ3QgYXNcbiAqIHJvYnVzdCBhcyBqcXVlcnkncywgc28gdGhlcmUncyBwcm9iYWJseSBzb21lIGRpZmZlcmVuY2VzLlxuICpcbiAqIEBtb2R1bGUgZXZlbnRzXG4gKi9cblxuLyoqXG4gKiBDbGVhbiB1cCB0aGUgbGlzdGVuZXIgY2FjaGUgYW5kIGRpc3BhdGNoZXJzXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxuICogICAgICAgIEVsZW1lbnQgdG8gY2xlYW4gdXBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFR5cGUgb2YgZXZlbnQgdG8gY2xlYW4gdXBcbiAqL1xuZnVuY3Rpb24gX2NsZWFuVXBFdmVudHMoZWxlbSwgdHlwZSkge1xuICB2YXIgZGF0YSA9IGdldERhdGEoZWxlbSk7XG5cbiAgLy8gUmVtb3ZlIHRoZSBldmVudHMgb2YgYSBwYXJ0aWN1bGFyIHR5cGUgaWYgdGhlcmUgYXJlIG5vbmUgbGVmdFxuICBpZiAoZGF0YS5oYW5kbGVyc1t0eXBlXS5sZW5ndGggPT09IDApIHtcbiAgICBkZWxldGUgZGF0YS5oYW5kbGVyc1t0eXBlXTtcbiAgICAvLyBkYXRhLmhhbmRsZXJzW3R5cGVdID0gbnVsbDtcbiAgICAvLyBTZXR0aW5nIHRvIG51bGwgd2FzIGNhdXNpbmcgYW4gZXJyb3Igd2l0aCBkYXRhLmhhbmRsZXJzXG5cbiAgICAvLyBSZW1vdmUgdGhlIG1ldGEtaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGRhdGEuZGlzcGF0Y2hlciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5kZXRhY2hFdmVudCkge1xuICAgICAgZWxlbS5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgZGF0YS5kaXNwYXRjaGVyKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgdGhlIGV2ZW50cyBvYmplY3QgaWYgdGhlcmUgYXJlIG5vIHR5cGVzIGxlZnRcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRhdGEuaGFuZGxlcnMpLmxlbmd0aCA8PSAwKSB7XG4gICAgZGVsZXRlIGRhdGEuaGFuZGxlcnM7XG4gICAgZGVsZXRlIGRhdGEuZGlzcGF0Y2hlcjtcbiAgICBkZWxldGUgZGF0YS5kaXNhYmxlZDtcbiAgfVxuXG4gIC8vIEZpbmFsbHkgcmVtb3ZlIHRoZSBlbGVtZW50IGRhdGEgaWYgdGhlcmUgaXMgbm8gZGF0YSBsZWZ0XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICByZW1vdmVEYXRhKGVsZW0pO1xuICB9XG59XG5cbi8qKlxuICogTG9vcHMgdGhyb3VnaCBhbiBhcnJheSBvZiBldmVudCB0eXBlcyBhbmQgY2FsbHMgdGhlIHJlcXVlc3RlZCBtZXRob2QgZm9yIGVhY2ggdHlwZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogICAgICAgIFRoZSBldmVudCBtZXRob2Qgd2Ugd2FudCB0byB1c2UuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxuICogICAgICAgIEVsZW1lbnQgb3Igb2JqZWN0IHRvIGJpbmQgbGlzdGVuZXJzIHRvXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICBUeXBlIG9mIGV2ZW50IHRvIGJpbmQgdG8uXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBjYWxsYmFja1xuICogICAgICAgIEV2ZW50IGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBfaGFuZGxlTXVsdGlwbGVFdmVudHMoZm4sIGVsZW0sIHR5cGVzLCBjYWxsYmFjaykge1xuICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgLy8gQ2FsbCB0aGUgZXZlbnQgbWV0aG9kIGZvciBlYWNoIG9uZSBvZiB0aGUgdHlwZXNcbiAgICBmbihlbGVtLCB0eXBlLCBjYWxsYmFjayk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEZpeCBhIG5hdGl2ZSBldmVudCB0byBoYXZlIHN0YW5kYXJkIHByb3BlcnR5IHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICogICAgICAgIEV2ZW50IG9iamVjdCB0byBmaXguXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBGaXhlZCBldmVudCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGZpeEV2ZW50KGV2ZW50KSB7XG5cbiAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgaWYgZml4aW5nIHVwIGlzIG5lZWRlZFxuICAvLyBVc2VkIHRvIGNoZWNrIGlmICFldmVudC5zdG9wUHJvcGFnYXRpb24gaW5zdGVhZCBvZiBpc1Byb3BhZ2F0aW9uU3RvcHBlZFxuICAvLyBCdXQgbmF0aXZlIGV2ZW50cyByZXR1cm4gdHJ1ZSBmb3Igc3RvcFByb3BhZ2F0aW9uLCBidXQgZG9uJ3QgaGF2ZVxuICAvLyBvdGhlciBleHBlY3RlZCBtZXRob2RzIGxpa2UgaXNQcm9wYWdhdGlvblN0b3BwZWQuIFNlZW1zIHRvIGJlIGEgcHJvYmxlbVxuICAvLyB3aXRoIHRoZSBKYXZhc2NyaXB0IE5pbmphIGNvZGUuIFNvIHdlJ3JlIGp1c3Qgb3ZlcnJpZGluZyBhbGwgZXZlbnRzIG5vdy5cbiAgaWYgKCFldmVudCB8fCAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQpIHtcbiAgICB2YXIgb2xkID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgZXZlbnQgPSB7fTtcbiAgICAvLyBDbG9uZSB0aGUgb2xkIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBtb2RpZnkgdGhlIHZhbHVlcyBldmVudCA9IHt9O1xuICAgIC8vIElFOCBEb2Vzbid0IGxpa2Ugd2hlbiB5b3UgbWVzcyB3aXRoIG5hdGl2ZSBldmVudCBwcm9wZXJ0aWVzXG4gICAgLy8gRmlyZWZveCByZXR1cm5zIGZhbHNlIGZvciBldmVudC5oYXNPd25Qcm9wZXJ0eSgndHlwZScpIGFuZCBvdGhlciBwcm9wc1xuICAgIC8vICB3aGljaCBtYWtlcyBjb3B5aW5nIG1vcmUgZGlmZmljdWx0LlxuICAgIC8vIFRPRE86IFByb2JhYmx5IGJlc3QgdG8gY3JlYXRlIGEgd2hpdGVsaXN0IG9mIGV2ZW50IHByb3BzXG4gICAgZm9yICh2YXIga2V5IGluIG9sZCkge1xuICAgICAgLy8gU2FmYXJpIDYuMC4zIHdhcm5zIHlvdSBpZiB5b3UgdHJ5IHRvIGNvcHkgZGVwcmVjYXRlZCBsYXllclgvWVxuICAgICAgLy8gQ2hyb21lIHdhcm5zIHlvdSBpZiB5b3UgdHJ5IHRvIGNvcHkgZGVwcmVjYXRlZCBrZXlib2FyZEV2ZW50LmtleUxvY2F0aW9uXG4gICAgICAvLyBhbmQgd2Via2l0TW92ZW1lbnRYL1lcbiAgICAgIGlmIChrZXkgIT09ICdsYXllclgnICYmIGtleSAhPT0gJ2xheWVyWScgJiYga2V5ICE9PSAna2V5TG9jYXRpb24nICYmIGtleSAhPT0gJ3dlYmtpdE1vdmVtZW50WCcgJiYga2V5ICE9PSAnd2Via2l0TW92ZW1lbnRZJykge1xuICAgICAgICAvLyBDaHJvbWUgMzIrIHdhcm5zIGlmIHlvdSB0cnkgdG8gY29weSBkZXByZWNhdGVkIHJldHVyblZhbHVlLCBidXRcbiAgICAgICAgLy8gd2Ugc3RpbGwgd2FudCB0byBpZiBwcmV2ZW50RGVmYXVsdCBpc24ndCBzdXBwb3J0ZWQgKElFOCkuXG4gICAgICAgIGlmICghKGtleSA9PT0gJ3JldHVyblZhbHVlJyAmJiBvbGQucHJldmVudERlZmF1bHQpKSB7XG4gICAgICAgICAgZXZlbnRba2V5XSA9IG9sZFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGV2ZW50IG9jY3VycmVkIG9uIHRoaXMgZWxlbWVudFxuICAgIGlmICghZXZlbnQudGFyZ2V0KSB7XG4gICAgICBldmVudC50YXJnZXQgPSBldmVudC5zcmNFbGVtZW50IHx8IGRvY3VtZW50O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB3aGljaCBvdGhlciBlbGVtZW50IHRoZSBldmVudCBpcyByZWxhdGVkIHRvXG4gICAgaWYgKCFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICBldmVudC5yZWxhdGVkVGFyZ2V0ID0gZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnRhcmdldCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50O1xuICAgIH1cblxuICAgIC8vIFN0b3AgdGhlIGRlZmF1bHQgYnJvd3NlciBhY3Rpb25cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvbGQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgb2xkLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgb2xkLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICBldmVudC5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXG4gICAgLy8gU3RvcCB0aGUgZXZlbnQgZnJvbSBidWJibGluZ1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvbGQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgIG9sZC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICBvbGQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICB9O1xuXG4gICAgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5GYWxzZTtcblxuICAgIC8vIFN0b3AgdGhlIGV2ZW50IGZyb20gYnViYmxpbmcgYW5kIGV4ZWN1dGluZyBvdGhlciBoYW5kbGVyc1xuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvbGQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKSB7XG4gICAgICAgIG9sZC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG5cbiAgICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVybkZhbHNlO1xuXG4gICAgLy8gSGFuZGxlIG1vdXNlIHBvc2l0aW9uXG4gICAgaWYgKGV2ZW50LmNsaWVudFggIT09IG51bGwgJiYgZXZlbnQuY2xpZW50WCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXG4gICAgICBldmVudC5wYWdlWCA9IGV2ZW50LmNsaWVudFggKyAoZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwKTtcbiAgICAgIGV2ZW50LnBhZ2VZID0gZXZlbnQuY2xpZW50WSArIChkb2MgJiYgZG9jLnNjcm9sbFRvcCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wIHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50VG9wIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgfHwgMCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGtleSBwcmVzc2VzXG4gICAgZXZlbnQud2hpY2ggPSBldmVudC5jaGFyQ29kZSB8fCBldmVudC5rZXlDb2RlO1xuXG4gICAgLy8gRml4IGJ1dHRvbiBmb3IgbW91c2UgY2xpY2tzOlxuICAgIC8vIDAgPT0gbGVmdDsgMSA9PSBtaWRkbGU7IDIgPT0gcmlnaHRcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSBudWxsICYmIGV2ZW50LmJ1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgZGlzYWJsZWQgYmVjYXVzZSBpdCBkb2VzIG5vdCBwYXNzIHZpZGVvanMtc3RhbmRhcmRcbiAgICAgIC8vIGFuZC4uLiB5aWtlcy5cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgICBldmVudC5idXR0b24gPSBldmVudC5idXR0b24gJiAxID8gMCA6IGV2ZW50LmJ1dHRvbiAmIDQgPyAxIDogZXZlbnQuYnV0dG9uICYgMiA/IDIgOiAwO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgZml4ZWQtdXAgaW5zdGFuY2VcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIFdoZXRoZXIgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMgYXJlIHN1cHBvcnRlZFxuICovXG52YXIgX3N1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBfc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBkaXNyZWdhcmRcbiAgfVxufSkoKTtcblxuLyoqXG4gKiBUb3VjaCBldmVudHMgQ2hyb21lIGV4cGVjdHMgdG8gYmUgcGFzc2l2ZVxuICovXG52YXIgcGFzc2l2ZUV2ZW50cyA9IFsndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnXTtcblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gZWxlbWVudFxuICogSXQgc3RvcmVzIHRoZSBoYW5kbGVyIGZ1bmN0aW9uIGluIGEgc2VwYXJhdGUgY2FjaGUgb2JqZWN0XG4gKiBhbmQgYWRkcyBhIGdlbmVyaWMgaGFuZGxlciB0byB0aGUgZWxlbWVudCdzIGV2ZW50LFxuICogYWxvbmcgd2l0aCBhIHVuaXF1ZSBpZCAoZ3VpZCkgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxuICogICAgICAgIEVsZW1lbnQgb3Igb2JqZWN0IHRvIGJpbmQgbGlzdGVuZXJzIHRvXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHR5cGVcbiAqICAgICAgICBUeXBlIG9mIGV2ZW50IHRvIGJpbmQgdG8uXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmblxuICogICAgICAgIEV2ZW50IGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBvbihlbGVtLCB0eXBlLCBmbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob24sIGVsZW0sIHR5cGUsIGZuKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtKTtcblxuICAvLyBXZSBuZWVkIGEgcGxhY2UgdG8gc3RvcmUgYWxsIG91ciBoYW5kbGVyIGRhdGFcbiAgaWYgKCFkYXRhLmhhbmRsZXJzKSB7XG4gICAgZGF0YS5oYW5kbGVycyA9IHt9O1xuICB9XG5cbiAgaWYgKCFkYXRhLmhhbmRsZXJzW3R5cGVdKSB7XG4gICAgZGF0YS5oYW5kbGVyc1t0eXBlXSA9IFtdO1xuICB9XG5cbiAgaWYgKCFmbi5ndWlkKSB7XG4gICAgZm4uZ3VpZCA9IG5ld0dVSUQoKTtcbiAgfVxuXG4gIGRhdGEuaGFuZGxlcnNbdHlwZV0ucHVzaChmbik7XG5cbiAgaWYgKCFkYXRhLmRpc3BhdGNoZXIpIHtcbiAgICBkYXRhLmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICBkYXRhLmRpc3BhdGNoZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGhhc2gpIHtcblxuICAgICAgaWYgKGRhdGEuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudCA9IGZpeEV2ZW50KGV2ZW50KTtcblxuICAgICAgdmFyIGhhbmRsZXJzID0gZGF0YS5oYW5kbGVyc1tldmVudC50eXBlXTtcblxuICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgIC8vIENvcHkgaGFuZGxlcnMgc28gaWYgaGFuZGxlcnMgYXJlIGFkZGVkL3JlbW92ZWQgZHVyaW5nIHRoZSBwcm9jZXNzIGl0IGRvZXNuJ3QgdGhyb3cgZXZlcnl0aGluZyBvZmYuXG4gICAgICAgIHZhciBoYW5kbGVyc0NvcHkgPSBoYW5kbGVycy5zbGljZSgwKTtcblxuICAgICAgICBmb3IgKHZhciBtID0gMCwgbiA9IGhhbmRsZXJzQ29weS5sZW5ndGg7IG0gPCBuOyBtKyspIHtcbiAgICAgICAgICBpZiAoZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGhhbmRsZXJzQ29weVttXS5jYWxsKGVsZW0sIGV2ZW50LCBoYXNoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgbG9nJDEuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmIChkYXRhLmhhbmRsZXJzW3R5cGVdLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHZhciBvcHRpb25zID0gZmFsc2U7XG5cbiAgICAgIGlmIChfc3VwcG9ydHNQYXNzaXZlICYmIHBhc3NpdmVFdmVudHMuaW5kZXhPZih0eXBlKSA+IC0xKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICAgIH1cbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBkYXRhLmRpc3BhdGNoZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudCkge1xuICAgICAgZWxlbS5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZGF0YS5kaXNwYXRjaGVyKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBmcm9tIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXG4gKiAgICAgICAgT2JqZWN0IHRvIHJlbW92ZSBsaXN0ZW5lcnMgZnJvbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3R5cGVdXG4gKiAgICAgICAgVHlwZSBvZiBsaXN0ZW5lciB0byByZW1vdmUuIERvbid0IGluY2x1ZGUgdG8gcmVtb3ZlIGFsbCBldmVudHMgZnJvbSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gW2ZuXVxuICogICAgICAgIFNwZWNpZmljIGxpc3RlbmVyIHRvIHJlbW92ZS4gRG9uJ3QgaW5jbHVkZSB0byByZW1vdmUgbGlzdGVuZXJzIGZvciBhbiBldmVudFxuICogICAgICAgIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIG9mZihlbGVtLCB0eXBlLCBmbikge1xuICAvLyBEb24ndCB3YW50IHRvIGFkZCBhIGNhY2hlIG9iamVjdCB0aHJvdWdoIGdldEVsRGF0YSBpZiBub3QgbmVlZGVkXG4gIGlmICghaGFzRGF0YShlbGVtKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtKTtcblxuICAvLyBJZiBubyBldmVudHMgZXhpc3QsIG5vdGhpbmcgdG8gdW5iaW5kXG4gIGlmICghZGF0YS5oYW5kbGVycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgcmV0dXJuIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhvZmYsIGVsZW0sIHR5cGUsIGZuKTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25cbiAgdmFyIHJlbW92ZVR5cGUgPSBmdW5jdGlvbiByZW1vdmVUeXBlKHQpIHtcbiAgICBkYXRhLmhhbmRsZXJzW3RdID0gW107XG4gICAgX2NsZWFuVXBFdmVudHMoZWxlbSwgdCk7XG4gIH07XG5cbiAgLy8gQXJlIHdlIHJlbW92aW5nIGFsbCBib3VuZCBldmVudHM/XG4gIGlmICghdHlwZSkge1xuICAgIGZvciAodmFyIHQgaW4gZGF0YS5oYW5kbGVycykge1xuICAgICAgcmVtb3ZlVHlwZSh0KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZGF0YS5oYW5kbGVyc1t0eXBlXTtcblxuICAvLyBJZiBubyBoYW5kbGVycyBleGlzdCwgbm90aGluZyB0byB1bmJpbmRcbiAgaWYgKCFoYW5kbGVycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIG5vIGxpc3RlbmVyIHdhcyBwcm92aWRlZCwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHR5cGVcbiAgaWYgKCFmbikge1xuICAgIHJlbW92ZVR5cGUodHlwZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV2UncmUgb25seSByZW1vdmluZyBhIHNpbmdsZSBoYW5kbGVyXG4gIGlmIChmbi5ndWlkKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBoYW5kbGVycy5sZW5ndGg7IG4rKykge1xuICAgICAgaWYgKGhhbmRsZXJzW25dLmd1aWQgPT09IGZuLmd1aWQpIHtcbiAgICAgICAgaGFuZGxlcnMuc3BsaWNlKG4tLSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NsZWFuVXBFdmVudHMoZWxlbSwgdHlwZSk7XG59XG5cbi8qKlxuICogVHJpZ2dlciBhbiBldmVudCBmb3IgYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgb25cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fHN0cmluZ30gZXZlbnRcbiAqICAgICAgICBBIHN0cmluZyAodGhlIHR5cGUpIG9yIGFuIGV2ZW50IG9iamVjdCB3aXRoIGEgdHlwZSBhdHRyaWJ1dGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2hhc2hdXG4gKiAgICAgICAgZGF0YSBoYXNoIHRvIHBhc3MgYWxvbmcgd2l0aCB0aGUgZXZlbnRcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAqICAgICAgICAgLSBSZXR1cm5zIHRoZSBvcHBvc2l0ZSBvZiBgZGVmYXVsdFByZXZlbnRlZGAgaWYgZGVmYXVsdCB3YXMgcHJldmVudGVkXG4gKiAgICAgICAgIC0gT3RoZXJ3aXNlIHJldHVybnMgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXIoZWxlbSwgZXZlbnQsIGhhc2gpIHtcbiAgLy8gRmV0Y2hlcyBlbGVtZW50IGRhdGEgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgKGZvciBidWJibGluZykuXG4gIC8vIERvbid0IHdhbnQgdG8gYWRkIGEgZGF0YSBvYmplY3QgdG8gY2FjaGUgZm9yIGV2ZXJ5IHBhcmVudCxcbiAgLy8gc28gY2hlY2tpbmcgaGFzRWxEYXRhIGZpcnN0LlxuICB2YXIgZWxlbURhdGEgPSBoYXNEYXRhKGVsZW0pID8gZ2V0RGF0YShlbGVtKSA6IHt9O1xuICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlIHx8IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgLy8gdHlwZSA9IGV2ZW50LnR5cGUgfHwgZXZlbnQsXG4gIC8vIGhhbmRsZXI7XG5cbiAgLy8gSWYgYW4gZXZlbnQgbmFtZSB3YXMgcGFzc2VkIGFzIGEgc3RyaW5nLCBjcmVhdGVzIGFuIGV2ZW50IG91dCBvZiBpdFxuICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgIGV2ZW50ID0geyB0eXBlOiBldmVudCwgdGFyZ2V0OiBlbGVtIH07XG4gIH1cbiAgLy8gTm9ybWFsaXplcyB0aGUgZXZlbnQgcHJvcGVydGllcy5cbiAgZXZlbnQgPSBmaXhFdmVudChldmVudCk7XG5cbiAgLy8gSWYgdGhlIHBhc3NlZCBlbGVtZW50IGhhcyBhIGRpc3BhdGNoZXIsIGV4ZWN1dGVzIHRoZSBlc3RhYmxpc2hlZCBoYW5kbGVycy5cbiAgaWYgKGVsZW1EYXRhLmRpc3BhdGNoZXIpIHtcbiAgICBlbGVtRGF0YS5kaXNwYXRjaGVyLmNhbGwoZWxlbSwgZXZlbnQsIGhhc2gpO1xuICB9XG5cbiAgLy8gVW5sZXNzIGV4cGxpY2l0bHkgc3RvcHBlZCBvciB0aGUgZXZlbnQgZG9lcyBub3QgYnViYmxlIChlLmcuIG1lZGlhIGV2ZW50cylcbiAgLy8gcmVjdXJzaXZlbHkgY2FsbHMgdGhpcyBmdW5jdGlvbiB0byBidWJibGUgdGhlIGV2ZW50IHVwIHRoZSBET00uXG4gIGlmIChwYXJlbnQgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgJiYgZXZlbnQuYnViYmxlcyA9PT0gdHJ1ZSkge1xuICAgIHRyaWdnZXIuY2FsbChudWxsLCBwYXJlbnQsIGV2ZW50LCBoYXNoKTtcblxuICAgIC8vIElmIGF0IHRoZSB0b3Agb2YgdGhlIERPTSwgdHJpZ2dlcnMgdGhlIGRlZmF1bHQgYWN0aW9uIHVubGVzcyBkaXNhYmxlZC5cbiAgfSBlbHNlIGlmICghcGFyZW50ICYmICFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdmFyIHRhcmdldERhdGEgPSBnZXREYXRhKGV2ZW50LnRhcmdldCk7XG5cbiAgICAvLyBDaGVja3MgaWYgdGhlIHRhcmdldCBoYXMgYSBkZWZhdWx0IGFjdGlvbiBmb3IgdGhpcyBldmVudC5cbiAgICBpZiAoZXZlbnQudGFyZ2V0W2V2ZW50LnR5cGVdKSB7XG4gICAgICAvLyBUZW1wb3JhcmlseSBkaXNhYmxlcyBldmVudCBkaXNwYXRjaGluZyBvbiB0aGUgdGFyZ2V0IGFzIHdlIGhhdmUgYWxyZWFkeSBleGVjdXRlZCB0aGUgaGFuZGxlci5cbiAgICAgIHRhcmdldERhdGEuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgLy8gRXhlY3V0ZXMgdGhlIGRlZmF1bHQgYWN0aW9uLlxuICAgICAgaWYgKHR5cGVvZiBldmVudC50YXJnZXRbZXZlbnQudHlwZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXZlbnQudGFyZ2V0W2V2ZW50LnR5cGVdKCk7XG4gICAgICB9XG4gICAgICAvLyBSZS1lbmFibGVzIGV2ZW50IGRpc3BhdGNoaW5nLlxuICAgICAgdGFyZ2V0RGF0YS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluZm9ybSB0aGUgdHJpZ2dlcmVyIGlmIHRoZSBkZWZhdWx0IHdhcyBwcmV2ZW50ZWQgYnkgcmV0dXJuaW5nIGZhbHNlXG4gIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGEgbGlzdGVuZXIgb25seSBvbmNlIGZvciBhbiBldmVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IG9yIG9iamVjdCB0byBiaW5kIHRvLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXG4gKiAgICAgICAgTmFtZS90eXBlIG9mIGV2ZW50XG4gKlxuICogQHBhcmFtIHtFdmVudH5FdmVudExpc3RlbmVyfSBmblxuICogICAgICAgIEV2ZW50IExpc3RlbmVyIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG9uZShlbGVtLCB0eXBlLCBmbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob25lLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cbiAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKCkge1xuICAgIG9mZihlbGVtLCB0eXBlLCBmdW5jKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIGNvcHkgdGhlIGd1aWQgdG8gdGhlIG5ldyBmdW5jdGlvbiBzbyBpdCBjYW4gcmVtb3ZlZCB1c2luZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24ncyBJRFxuICBmdW5jLmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBuZXdHVUlEKCk7XG4gIG9uKGVsZW0sIHR5cGUsIGZ1bmMpO1xufVxuXG52YXIgRXZlbnRzID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdGZpeEV2ZW50OiBmaXhFdmVudCxcblx0b246IG9uLFxuXHRvZmY6IG9mZixcblx0dHJpZ2dlcjogdHJpZ2dlcixcblx0b25lOiBvbmVcbn0pO1xuXG4vKipcbiAqIEBmaWxlIHNldHVwLmpzIC0gRnVuY3Rpb25zIGZvciBzZXR0aW5nIHVwIGEgcGxheWVyIHdpdGhvdXRcbiAqIHVzZXIgaW50ZXJhY3Rpb24gYmFzZWQgb24gdGhlIGRhdGEtc2V0dXAgYGF0dHJpYnV0ZWAgb2YgdGhlIHZpZGVvIHRhZy5cbiAqXG4gKiBAbW9kdWxlIHNldHVwXG4gKi9cbnZhciBfd2luZG93TG9hZGVkID0gZmFsc2U7XG52YXIgdmlkZW9qcyQyID0gdm9pZCAwO1xuXG4vKipcbiAqIFNldCB1cCBhbnkgdGFncyB0aGF0IGhhdmUgYSBkYXRhLXNldHVwIGBhdHRyaWJ1dGVgIHdoZW4gdGhlIHBsYXllciBpcyBzdGFydGVkLlxuICovXG52YXIgYXV0b1NldHVwID0gZnVuY3Rpb24gYXV0b1NldHVwKCkge1xuXG4gIC8vIFByb3RlY3QgYWdhaW5zdCBicmVha2FnZSBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMuXG4gIGlmICghaXNSZWFsKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBPbmUgZGF5LCB3aGVuIHdlIHN0b3Agc3VwcG9ydGluZyBJRTgsIGdvIGJhY2sgdG8gdGhpcywgYnV0IGluIHRoZSBtZWFudGltZS4uLipoYWNrIGhhY2sgaGFjaypcbiAgLy8gdmFyIHZpZHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKSk7XG4gIC8vIHZhciBhdWRpb3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYXVkaW8nKSk7XG4gIC8vIHZhciBtZWRpYUVscyA9IHZpZHMuY29uY2F0KGF1ZGlvcyk7XG5cbiAgLy8gQmVjYXVzZSBJRTggZG9lc24ndCBzdXBwb3J0IGNhbGxpbmcgc2xpY2Ugb24gYSBub2RlIGxpc3QsIHdlIG5lZWQgdG8gbG9vcFxuICAvLyB0aHJvdWdoIGVhY2ggbGlzdCBvZiBlbGVtZW50cyB0byBidWlsZCB1cCBhIG5ldywgY29tYmluZWQgbGlzdCBvZiBlbGVtZW50cy5cbiAgdmFyIHZpZHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKTtcbiAgdmFyIGF1ZGlvcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhdWRpbycpO1xuICB2YXIgbWVkaWFFbHMgPSBbXTtcblxuICBpZiAodmlkcyAmJiB2aWRzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZSA9IHZpZHMubGVuZ3RoOyBpIDwgZTsgaSsrKSB7XG4gICAgICBtZWRpYUVscy5wdXNoKHZpZHNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhdWRpb3MgJiYgYXVkaW9zLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9lID0gYXVkaW9zLmxlbmd0aDsgX2kgPCBfZTsgX2krKykge1xuICAgICAgbWVkaWFFbHMucHVzaChhdWRpb3NbX2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpZiBhbnkgbWVkaWEgZWxlbWVudHMgZXhpc3RcbiAgaWYgKG1lZGlhRWxzICYmIG1lZGlhRWxzLmxlbmd0aCA+IDApIHtcblxuICAgIGZvciAodmFyIF9pMiA9IDAsIF9lMiA9IG1lZGlhRWxzLmxlbmd0aDsgX2kyIDwgX2UyOyBfaTIrKykge1xuICAgICAgdmFyIG1lZGlhRWwgPSBtZWRpYUVsc1tfaTJdO1xuXG4gICAgICAvLyBDaGVjayBpZiBlbGVtZW50IGV4aXN0cywgaGFzIGdldEF0dHJpYnV0ZSBmdW5jLlxuICAgICAgLy8gSUUgc2VlbXMgdG8gY29uc2lkZXIgdHlwZW9mIGVsLmdldEF0dHJpYnV0ZSA9PSAnb2JqZWN0JyBpbnN0ZWFkIG9mXG4gICAgICAvLyAnZnVuY3Rpb24nIGxpa2UgZXhwZWN0ZWQsIGF0IGxlYXN0IHdoZW4gbG9hZGluZyB0aGUgcGxheWVyIGltbWVkaWF0ZWx5LlxuICAgICAgaWYgKG1lZGlhRWwgJiYgbWVkaWFFbC5nZXRBdHRyaWJ1dGUpIHtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhpcyBwbGF5ZXIgaGFzbid0IGFscmVhZHkgYmVlbiBzZXQgdXAuXG4gICAgICAgIGlmIChtZWRpYUVsLnBsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBtZWRpYUVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zZXR1cCcpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgZGF0YS1zZXR1cCBhdHRyIGV4aXN0cy5cbiAgICAgICAgICAvLyBXZSBvbmx5IGF1dG8tc2V0dXAgaWYgdGhleSd2ZSBhZGRlZCB0aGUgZGF0YS1zZXR1cCBhdHRyLlxuICAgICAgICAgIGlmIChvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgbmV3IHZpZGVvLmpzIGluc3RhbmNlLlxuICAgICAgICAgICAgdmlkZW9qcyQyKG1lZGlhRWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGdldEF0dHJpYnV0ZSBpc24ndCBkZWZpbmVkLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBET00uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdXRvU2V0dXBUaW1lb3V0KDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyB2aWRlb3Mgd2VyZSBmb3VuZCwgc28ga2VlcCBsb29waW5nIHVubGVzcyBwYWdlIGlzIGZpbmlzaGVkIGxvYWRpbmcuXG4gIH0gZWxzZSBpZiAoIV93aW5kb3dMb2FkZWQpIHtcbiAgICBhdXRvU2V0dXBUaW1lb3V0KDEpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhaXQgdW50aWwgdGhlIHBhZ2UgaXMgbG9hZGVkIGJlZm9yZSBydW5uaW5nIGF1dG9TZXR1cC4gVGhpcyB3aWxsIGJlIGNhbGxlZCBpblxuICogYXV0b1NldHVwIGlmIGBoYXNMb2FkZWRgIHJldHVybnMgZmFsc2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdhaXRcbiAqICAgICAgICBIb3cgbG9uZyB0byB3YWl0IGluIG1zXG4gKlxuICogQHBhcmFtIHttb2R1bGU6dmlkZW9qc30gW3Zqc11cbiAqICAgICAgICBUaGUgdmlkZW9qcyBsaWJyYXJ5IGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGF1dG9TZXR1cFRpbWVvdXQod2FpdCwgdmpzKSB7XG4gIGlmICh2anMpIHtcbiAgICB2aWRlb2pzJDIgPSB2anM7XG4gIH1cblxuICB3aW5kb3cuc2V0VGltZW91dChhdXRvU2V0dXAsIHdhaXQpO1xufVxuXG5pZiAoaXNSZWFsKCkgJiYgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICBfd2luZG93TG9hZGVkID0gdHJ1ZTtcbn0gZWxzZSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIHRoZSBsb2FkIGV2ZW50IG9uIHdpbmRvdywgYW5kIHNldCBfd2luZG93TG9hZGVkIHRvIHRydWUuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGxvYWRcbiAgICovXG4gIG9uZSh3aW5kb3csICdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgIF93aW5kb3dMb2FkZWQgPSB0cnVlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAZmlsZSBzdHlsZXNoZWV0LmpzXG4gKiBAbW9kdWxlIHN0eWxlc2hlZXRcbiAqL1xuLyoqXG4gKiBDcmVhdGUgYSBET00gc3lsZSBlbGVtZW50IGdpdmVuIGEgY2xhc3NOYW1lIGZvciBpdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gKiAgICAgICAgVGhlIGNsYXNzTmFtZSB0byBhZGQgdG8gdGhlIGNyZWF0ZWQgc3R5bGUgZWxlbWVudC5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICovXG52YXIgY3JlYXRlU3R5bGVFbGVtZW50ID0gZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KGNsYXNzTmFtZSkge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXG4gIHN0eWxlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG4vKipcbiAqIEFkZCB0ZXh0IHRvIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBFbGVtZW50IHRvIGFkZCB0ZXh0IGNvbnRlbnQgdG8uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqICAgICAgICBUaGUgdGV4dCB0byBhZGQgdG8gdGhlIGVsZW1lbnQuXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIHNldFRleHRDb250ZW50KGVsLCBjb250ZW50KSB7XG4gIGlmIChlbC5zdHlsZVNoZWV0KSB7XG4gICAgZWwuc3R5bGVTaGVldC5jc3NUZXh0ID0gY29udGVudDtcbiAgfSBlbHNlIHtcbiAgICBlbC50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gIH1cbn07XG5cbi8qKlxuICogQGZpbGUgZm4uanNcbiAqIEBtb2R1bGUgZm5cbiAqL1xuLyoqXG4gKiBCaW5kIChhLmsuYSBwcm94eSBvciBDb250ZXh0KS4gQSBzaW1wbGUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgY29udGV4dCBvZiBhIGZ1bmN0aW9uXG4gKiBJdCBhbHNvIHN0b3JlcyBhIHVuaXF1ZSBpZCBvbiB0aGUgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGVhc2lseSByZW1vdmVkIGZyb20gZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHRcbiAqICAgICAgICBUaGUgb2JqZWN0IHRvIGJpbmQgYXMgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gYmUgYm91bmQgdG8gYSBzY29wZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3VpZF1cbiAqICAgICAgICBBbiBvcHRpb25hbCB1bmlxdWUgSUQgZm9yIHRoZSBmdW5jdGlvbiB0byBiZSBzZXRcbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqICAgICAgICAgVGhlIG5ldyBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYm91bmQgaW50byB0aGUgY29udGV4dCBnaXZlblxuICovXG52YXIgYmluZCA9IGZ1bmN0aW9uIGJpbmQoY29udGV4dCwgZm4sIHVpZCkge1xuICAvLyBNYWtlIHN1cmUgdGhlIGZ1bmN0aW9uIGhhcyBhIHVuaXF1ZSBJRFxuICBpZiAoIWZuLmd1aWQpIHtcbiAgICBmbi5ndWlkID0gbmV3R1VJRCgpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIHRoZSBuZXcgZnVuY3Rpb24gdGhhdCBjaGFuZ2VzIHRoZSBjb250ZXh0XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEFsbG93IGZvciB0aGUgYWJpbGl0eSB0byBpbmRpdmlkdWFsaXplIHRoaXMgZnVuY3Rpb25cbiAgLy8gTmVlZGVkIGluIHRoZSBjYXNlIHdoZXJlIG11bHRpcGxlIG9iamVjdHMgbWlnaHQgc2hhcmUgdGhlIHNhbWUgcHJvdG90eXBlXG4gIC8vIElGIGJvdGggaXRlbXMgYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHdpdGggdGhlIHNhbWUgZnVuY3Rpb24sIHRoZW4geW91IHRyeSB0byByZW1vdmUganVzdCBvbmVcbiAgLy8gaXQgd2lsbCByZW1vdmUgYm90aCBiZWNhdXNlIHRoZXkgYm90aCBoYXZlIHRoZSBzYW1lIGd1aWQuXG4gIC8vIHdoZW4gdXNpbmcgdGhpcywgeW91IG5lZWQgdG8gdXNlIHRoZSBiaW5kIG1ldGhvZCB3aGVuIHlvdSByZW1vdmUgdGhlIGxpc3RlbmVyIGFzIHdlbGwuXG4gIC8vIGN1cnJlbnRseSB1c2VkIGluIHRleHQgdHJhY2tzXG4gIGJvdW5kLmd1aWQgPSB1aWQgPyB1aWQgKyAnXycgKyBmbi5ndWlkIDogZm4uZ3VpZDtcblxuICByZXR1cm4gYm91bmQ7XG59O1xuXG4vKipcbiAqIFdyYXBzIHRoZSBnaXZlbiBmdW5jdGlvbiwgYGZuYCwgd2l0aCBhIG5ldyBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZm5gXG4gKiBhdCBtb3N0IG9uY2UgcGVyIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiAgICAgICAgIFRoZSBmdW5jdGlvbiB0byBiZSB0aHJvdHRsZWQuXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSAgIHdhaXRcbiAqICAgICAgICAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYnkgd2hpY2ggdG8gdGhyb3R0bGUuXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnZhciB0aHJvdHRsZSA9IGZ1bmN0aW9uIHRocm90dGxlKGZuLCB3YWl0KSB7XG4gIHZhciBsYXN0ID0gRGF0ZS5ub3coKTtcblxuICB2YXIgdGhyb3R0bGVkID0gZnVuY3Rpb24gdGhyb3R0bGVkKCkge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgaWYgKG5vdyAtIGxhc3QgPj0gd2FpdCkge1xuICAgICAgZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgbGFzdCA9IG5vdztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRocm90dGxlZDtcbn07XG5cbi8qKlxuICogQGZpbGUgc3JjL2pzL2V2ZW50LXRhcmdldC5qc1xuICovXG4vKipcbiAqIGBFdmVudFRhcmdldGAgaXMgYSBjbGFzcyB0aGF0IGNhbiBoYXZlIHRoZSBzYW1lIEFQSSBhcyB0aGUgRE9NIGBFdmVudFRhcmdldGAuIEl0XG4gKiBhZGRzIHNob3J0aGFuZCBmdW5jdGlvbnMgdGhhdCB3cmFwIGFyb3VuZCBsZW5ndGh5IGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gKiB0aGUgYG9uYCBmdW5jdGlvbiBpcyBhIHdyYXBwZXIgYXJvdW5kIGBhZGRFdmVudExpc3RlbmVyYC5cbiAqXG4gKiBAc2VlIFtFdmVudFRhcmdldCBTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItRXZlbnRzL2V2ZW50cy5odG1sI0V2ZW50cy1FdmVudFRhcmdldH1cbiAqIEBjbGFzcyBFdmVudFRhcmdldFxuICovXG52YXIgRXZlbnRUYXJnZXQgPSBmdW5jdGlvbiBFdmVudFRhcmdldCgpIHt9O1xuXG4vKipcbiAqIEEgQ3VzdG9tIERPTSBldmVudC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFdmVudFRhcmdldH5FdmVudFxuICogQHNlZSBbUHJvcGVydGllc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50fVxuICovXG5cbi8qKlxuICogQWxsIGV2ZW50IGxpc3RlbmVycyBzaG91bGQgZm9sbG93IHRoZSBmb2xsb3dpbmcgZm9ybWF0LlxuICpcbiAqIEBjYWxsYmFjayBFdmVudFRhcmdldH5FdmVudExpc3RlbmVyXG4gKiBAdGhpcyB7RXZlbnRUYXJnZXR9XG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAqICAgICAgICB0aGUgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGFzaF1cbiAqICAgICAgICBoYXNoIG9mIGRhdGEgc2VudCBkdXJpbmcgdGhlIGV2ZW50XG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyBldmVudCBuYW1lcyBhcyBrZXlzIGFuZCBib29sZWFucyBhcyB2YWx1ZXMuXG4gKlxuICogPiBOT1RFOiBJZiBhbiBldmVudCBuYW1lIGlzIHNldCB0byBhIHRydWUgdmFsdWUgaGVyZSB7QGxpbmsgRXZlbnRUYXJnZXQjdHJpZ2dlcn1cbiAqICAgICAgICAgd2lsbCBoYXZlIGV4dHJhIGZ1bmN0aW9uYWxpdHkuIFNlZSB0aGF0IGZ1bmN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwcm9wZXJ0eSBFdmVudFRhcmdldC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c19cbiAqIEBwcml2YXRlXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXyA9IHt9O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50IGxpc3RlbmVyYCB0byBhbiBpbnN0YW5jZSBvZiBhbiBgRXZlbnRUYXJnZXRgLiBBbiBgZXZlbnQgbGlzdGVuZXJgIGlzIGFcbiAqIGZ1bmN0aW9uIHRoYXQgd2lsbCBnZXQgY2FsbGVkIHdoZW4gYW4gZXZlbnQgd2l0aCBhIGNlcnRhaW4gbmFtZSBnZXRzIHRyaWdnZXJlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdHlwZVxuICogICAgICAgIEFuIGV2ZW50IG5hbWUgb3IgYW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMuXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmblxuICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdpdGggYEV2ZW50VGFyZ2V0YHNcbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gIC8vIFJlbW92ZSB0aGUgYWRkRXZlbnRMaXN0ZW5lciBhbGlhcyBiZWZvcmUgY2FsbGluZyBFdmVudHMub25cbiAgLy8gc28gd2UgZG9uJ3QgZ2V0IGludG8gYW4gaW5maW5pdGUgdHlwZSBsb29wXG4gIHZhciBhZWwgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkge307XG4gIG9uKHRoaXMsIHR5cGUsIGZuKTtcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gYWVsO1xufTtcblxuLyoqXG4gKiBBbiBhbGlhcyBvZiB7QGxpbmsgRXZlbnRUYXJnZXQjb259LiBBbGxvd3MgYEV2ZW50VGFyZ2V0YCB0byBtaW1pY1xuICogdGhlIHN0YW5kYXJkIERPTSBBUEkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAc2VlIHtAbGluayBFdmVudFRhcmdldCNvbn1cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUub247XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBgZXZlbnQgbGlzdGVuZXJgIGZvciBhIHNwZWNpZmljIGV2ZW50IGZyb20gYW4gaW5zdGFuY2Ugb2YgYEV2ZW50VGFyZ2V0YC5cbiAqIFRoaXMgbWFrZXMgaXQgc28gdGhhdCB0aGUgYGV2ZW50IGxpc3RlbmVyYCB3aWxsIG5vIGxvbmdlciBnZXQgY2FsbGVkIHdoZW4gdGhlXG4gKiBuYW1lZCBldmVudCBoYXBwZW5zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXG4gKiAgICAgICAgQW4gZXZlbnQgbmFtZSBvciBhbiBhcnJheSBvZiBldmVudCBuYW1lcy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZuXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIHJlbW92ZS5cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICBvZmYodGhpcywgdHlwZSwgZm4pO1xufTtcblxuLyoqXG4gKiBBbiBhbGlhcyBvZiB7QGxpbmsgRXZlbnRUYXJnZXQjb2ZmfS4gQWxsb3dzIGBFdmVudFRhcmdldGAgdG8gbWltaWNcbiAqIHRoZSBzdGFuZGFyZCBET00gQVBJLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHNlZSB7QGxpbmsgRXZlbnRUYXJnZXQjb2ZmfVxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vZmY7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFkZCBhbiBgZXZlbnQgbGlzdGVuZXJgIHRoYXQgZ2V0cyB0cmlnZ2VyZWQgb25seSBvbmNlLiBBZnRlciB0aGVcbiAqIGZpcnN0IHRyaWdnZXIgaXQgd2lsbCBnZXQgcmVtb3ZlZC4gVGhpcyBpcyBsaWtlIGFkZGluZyBhbiBgZXZlbnQgbGlzdGVuZXJgXG4gKiB3aXRoIHtAbGluayBFdmVudFRhcmdldCNvbn0gdGhhdCBjYWxscyB7QGxpbmsgRXZlbnRUYXJnZXQjb2ZmfSBvbiBpdHNlbGYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHR5cGVcbiAqICAgICAgICBBbiBldmVudCBuYW1lIG9yIGFuIGFycmF5IG9mIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm5cbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgZm9yIGVhY2ggZXZlbnQgbmFtZS5cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLm9uZSA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAvLyBSZW1vdmUgdGhlIGFkZEV2ZW50TGlzdGVuZXIgYWxpYWxpbmcgRXZlbnRzLm9uXG4gIC8vIHNvIHdlIGRvbid0IGdldCBpbnRvIGFuIGluZmluaXRlIHR5cGUgbG9vcFxuICB2YXIgYWVsID0gdGhpcy5hZGRFdmVudExpc3RlbmVyO1xuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHt9O1xuICBvbmUodGhpcywgdHlwZSwgZm4pO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZWw7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2F1c2VzIGFuIGV2ZW50IHRvIGhhcHBlbi4gVGhpcyB3aWxsIHRoZW4gY2F1c2UgYW55IGBldmVudCBsaXN0ZW5lcnNgXG4gKiB0aGF0IGFyZSB3YWl0aW5nIGZvciB0aGF0IGV2ZW50LCB0byBnZXQgY2FsbGVkLiBJZiB0aGVyZSBhcmUgbm8gYGV2ZW50IGxpc3RlbmVyc2BcbiAqIGZvciBhbiBldmVudCB0aGVuIG5vdGhpbmcgd2lsbCBoYXBwZW4uXG4gKlxuICogSWYgdGhlIG5hbWUgb2YgdGhlIGBFdmVudGAgdGhhdCBpcyBiZWluZyB0cmlnZ2VyZWQgaXMgaW4gYEV2ZW50VGFyZ2V0LmFsbG93ZWRFdmVudHNfYC5cbiAqIFRyaWdnZXIgd2lsbCBhbHNvIGNhbGwgdGhlIGBvbmAgKyBgdXBwZXJjYXNlRXZlbnROYW1lYCBmdW5jdGlvbi5cbiAqXG4gKiBFeGFtcGxlOlxuICogJ2NsaWNrJyBpcyBpbiBgRXZlbnRUYXJnZXQuYWxsb3dlZEV2ZW50c19gLCBzbywgdHJpZ2dlciB3aWxsIGF0dGVtcHQgdG8gY2FsbFxuICogYG9uQ2xpY2tgIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xFdmVudFRhcmdldH5FdmVudHxPYmplY3R9IGV2ZW50XG4gKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LCBhbiBgRXZlbnRgLCBvciBhbiBvYmplY3Qgd2l0aCBhIGtleSBvZiB0eXBlIHNldCB0b1xuICogICAgICAgIGFuIGV2ZW50IG5hbWUuXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCBldmVudDtcblxuICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgIGV2ZW50ID0geyB0eXBlOiB0eXBlIH07XG4gIH1cbiAgZXZlbnQgPSBmaXhFdmVudChldmVudCk7XG5cbiAgaWYgKHRoaXMuYWxsb3dlZEV2ZW50c19bdHlwZV0gJiYgdGhpc1snb24nICsgdHlwZV0pIHtcbiAgICB0aGlzWydvbicgKyB0eXBlXShldmVudCk7XG4gIH1cblxuICB0cmlnZ2VyKHRoaXMsIGV2ZW50KTtcbn07XG5cbi8qKlxuICogQW4gYWxpYXMgb2Yge0BsaW5rIEV2ZW50VGFyZ2V0I3RyaWdnZXJ9LiBBbGxvd3MgYEV2ZW50VGFyZ2V0YCB0byBtaW1pY1xuICogdGhlIHN0YW5kYXJkIERPTSBBUEkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAc2VlIHtAbGluayBFdmVudFRhcmdldCN0cmlnZ2VyfVxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS50cmlnZ2VyO1xuXG4vKipcbiAqIEBmaWxlIG1peGlucy9ldmVudGVkLmpzXG4gKiBAbW9kdWxlIGV2ZW50ZWRcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBoYXMgaGFkIHRoZSBldmVudGVkIG1peGluIGFwcGxpZWQuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvYmplY3RcbiAqICAgICAgICAgQW4gb2JqZWN0IHRvIHRlc3QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBhcHBlYXJzIHRvIGJlIGV2ZW50ZWQuXG4gKi9cbnZhciBpc0V2ZW50ZWQgPSBmdW5jdGlvbiBpc0V2ZW50ZWQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBFdmVudFRhcmdldCB8fCAhIW9iamVjdC5ldmVudEJ1c0VsXyAmJiBbJ29uJywgJ29uZScsICdvZmYnLCAndHJpZ2dlciddLmV2ZXJ5KGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3Rba10gPT09ICdmdW5jdGlvbic7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBXaGV0aGVyIGEgdmFsdWUgaXMgYSB2YWxpZCBldmVudCB0eXBlIC0gbm9uLWVtcHR5IHN0cmluZyBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7c3RyaW5nfEFycmF5fSB0eXBlXG4gKiAgICAgICAgIFRoZSB0eXBlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdGhlIHR5cGUgaXMgYSB2YWxpZCBldmVudCB0eXBlLlxuICovXG52YXIgaXNWYWxpZEV2ZW50VHlwZSA9IGZ1bmN0aW9uIGlzVmFsaWRFdmVudFR5cGUodHlwZSkge1xuICByZXR1cm4gKFxuICAgIC8vIFRoZSByZWdleCBoZXJlIHZlcmlmaWVzIHRoYXQgdGhlIGB0eXBlYCBjb250YWlucyBhdCBsZWFzdCBvbmUgbm9uLVxuICAgIC8vIHdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyAmJiAvXFxTLy50ZXN0KHR5cGUpIHx8IEFycmF5LmlzQXJyYXkodHlwZSkgJiYgISF0eXBlLmxlbmd0aFxuICApO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB2YWx1ZSB0byBkZXRlcm1pbmUgaWYgaXQgaXMgYSB2YWxpZCBldmVudCB0YXJnZXQuIFRocm93cyBpZiBub3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogICAgICAgICBJZiB0aGUgdGFyZ2V0IGRvZXMgbm90IGFwcGVhciB0byBiZSBhIHZhbGlkIGV2ZW50IHRhcmdldC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICogICAgICAgICBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKi9cbnZhciB2YWxpZGF0ZVRhcmdldCA9IGZ1bmN0aW9uIHZhbGlkYXRlVGFyZ2V0KHRhcmdldCkge1xuICBpZiAoIXRhcmdldC5ub2RlTmFtZSAmJiAhaXNFdmVudGVkKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFyZ2V0OyBtdXN0IGJlIGEgRE9NIG5vZGUgb3IgZXZlbnRlZCBvYmplY3QuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgdmFsdWUgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGEgdmFsaWQgZXZlbnQgdGFyZ2V0LiBUaHJvd3MgaWYgbm90LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqICAgICAgICAgSWYgdGhlIHR5cGUgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgdmFsaWQgZXZlbnQgdHlwZS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl9IHR5cGVcbiAqICAgICAgICAgVGhlIHR5cGUgdG8gdGVzdC5cbiAqL1xudmFyIHZhbGlkYXRlRXZlbnRUeXBlID0gZnVuY3Rpb24gdmFsaWRhdGVFdmVudFR5cGUodHlwZSkge1xuICBpZiAoIWlzVmFsaWRFdmVudFR5cGUodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZXZlbnQgdHlwZTsgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYXJyYXkuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgdmFsdWUgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGEgdmFsaWQgbGlzdGVuZXIuIFRocm93cyBpZiBub3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogICAgICAgICBJZiB0aGUgbGlzdGVuZXIgaXMgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKiAgICAgICAgIFRoZSBsaXN0ZW5lciB0byB0ZXN0LlxuICovXG52YXIgdmFsaWRhdGVMaXN0ZW5lciA9IGZ1bmN0aW9uIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0ZW5lcjsgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBnaXZlbiB0byBgb24oKWAgb3IgYG9uZSgpYCwgdmFsaWRhdGVzIHRoZW0sIGFuZFxuICogbm9ybWFsaXplcyB0aGVtIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtPYmplY3R9IHNlbGZcbiAqICAgICAgICAgVGhlIGV2ZW50ZWQgb2JqZWN0IG9uIHdoaWNoIGBvbigpYCBvciBgb25lKClgIHdhcyBjYWxsZWQuIFRoaXNcbiAqICAgICAgICAgb2JqZWN0IHdpbGwgYmUgYm91bmQgYXMgdGhlIGB0aGlzYCB2YWx1ZSBmb3IgdGhlIGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBhcmdzXG4gKiAgICAgICAgIEFuIGFycmF5IG9mIGFyZ3VtZW50cyBwYXNzZWQgdG8gYG9uKClgIG9yIGBvbmUoKWAuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyB1c2VmdWwgdmFsdWVzIGZvciBgb24oKWAgb3IgYG9uZSgpYCBjYWxscy5cbiAqL1xudmFyIG5vcm1hbGl6ZUxpc3RlbkFyZ3MgPSBmdW5jdGlvbiBub3JtYWxpemVMaXN0ZW5BcmdzKHNlbGYsIGFyZ3MpIHtcblxuICAvLyBJZiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpcyBsZXNzIHRoYW4gMywgdGhlIHRhcmdldCBpcyBhbHdheXMgdGhlXG4gIC8vIGV2ZW50ZWQgb2JqZWN0IGl0c2VsZi5cbiAgdmFyIGlzVGFyZ2V0aW5nU2VsZiA9IGFyZ3MubGVuZ3RoIDwgMyB8fCBhcmdzWzBdID09PSBzZWxmIHx8IGFyZ3NbMF0gPT09IHNlbGYuZXZlbnRCdXNFbF87XG4gIHZhciB0YXJnZXQgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gdm9pZCAwO1xuICB2YXIgbGlzdGVuZXIgPSB2b2lkIDA7XG5cbiAgaWYgKGlzVGFyZ2V0aW5nU2VsZikge1xuICAgIHRhcmdldCA9IHNlbGYuZXZlbnRCdXNFbF87XG5cbiAgICAvLyBEZWFsIHdpdGggY2FzZXMgd2hlcmUgd2UgZ290IDMgYXJndW1lbnRzLCBidXQgd2UgYXJlIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHRoZSBldmVudGVkIG9iamVjdCBpdHNlbGYuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID49IDMpIHtcbiAgICAgIGFyZ3Muc2hpZnQoKTtcbiAgICB9XG5cbiAgICB0eXBlID0gYXJnc1swXTtcbiAgICBsaXN0ZW5lciA9IGFyZ3NbMV07XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gYXJnc1swXTtcbiAgICB0eXBlID0gYXJnc1sxXTtcbiAgICBsaXN0ZW5lciA9IGFyZ3NbMl07XG4gIH1cblxuICB2YWxpZGF0ZVRhcmdldCh0YXJnZXQpO1xuICB2YWxpZGF0ZUV2ZW50VHlwZSh0eXBlKTtcbiAgdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgbGlzdGVuZXIgPSBiaW5kKHNlbGYsIGxpc3RlbmVyKTtcblxuICByZXR1cm4geyBpc1RhcmdldGluZ1NlbGY6IGlzVGFyZ2V0aW5nU2VsZiwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xufTtcblxuLyoqXG4gKiBBZGRzIHRoZSBsaXN0ZW5lciB0byB0aGUgZXZlbnQgdHlwZShzKSBvbiB0aGUgdGFyZ2V0LCBub3JtYWxpemluZyBmb3JcbiAqIHRoZSB0eXBlIG9mIHRhcmdldC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7RWxlbWVudHxPYmplY3R9IHRhcmdldFxuICogICAgICAgICBBIERPTSBub2RlIG9yIGV2ZW50ZWQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbWV0aG9kXG4gKiAgICAgICAgIFRoZSBldmVudCBiaW5kaW5nIG1ldGhvZCB0byB1c2UgKFwib25cIiBvciBcIm9uZVwiKS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl9IHR5cGVcbiAqICAgICAgICAgT25lIG9yIG1vcmUgZXZlbnQgdHlwZShzKS5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqICAgICAgICAgQSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqL1xudmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIG1ldGhvZCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFsaWRhdGVUYXJnZXQodGFyZ2V0KTtcblxuICBpZiAodGFyZ2V0Lm5vZGVOYW1lKSB7XG4gICAgRXZlbnRzW21ldGhvZF0odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W21ldGhvZF0odHlwZSwgbGlzdGVuZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnRhaW5zIG1ldGhvZHMgdGhhdCBwcm92aWRlIGV2ZW50IGNhcGFiaWxpdGVzIHRvIGFuIG9iamVjdCB3aGljaCBpcyBwYXNzZWRcbiAqIHRvIHtAbGluayBtb2R1bGU6ZXZlbnRlZHxldmVudGVkfS5cbiAqXG4gKiBAbWl4aW4gRXZlbnRlZE1peGluXG4gKi9cbnZhciBFdmVudGVkTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEFkZCBhIGxpc3RlbmVyIHRvIGFuIGV2ZW50IChvciBldmVudHMpIG9uIHRoaXMgb2JqZWN0IG9yIGFub3RoZXIgZXZlbnRlZFxuICAgKiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxFbGVtZW50fE9iamVjdH0gdGFyZ2V0T3JUeXBlXG4gICAqICAgICAgICAgSWYgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSwgaXQgcmVwcmVzZW50cyB0aGUgZXZlbnQgdHlwZShzKVxuICAgKiAgICAgICAgIHRoYXQgd2lsbCB0cmlnZ2VyIHRoZSBsaXN0ZW5lci5cbiAgICpcbiAgICogICAgICAgICBBbm90aGVyIGV2ZW50ZWQgb2JqZWN0IGNhbiBiZSBwYXNzZWQgaGVyZSBpbnN0ZWFkLCB3aGljaCB3aWxsXG4gICAqICAgICAgICAgY2F1c2UgdGhlIGxpc3RlbmVyIHRvIGxpc3RlbiBmb3IgZXZlbnRzIG9uIF90aGF0XyBvYmplY3QuXG4gICAqXG4gICAqICAgICAgICAgSW4gZWl0aGVyIGNhc2UsIHRoZSBsaXN0ZW5lcidzIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIGJvdW5kIHRvXG4gICAqICAgICAgICAgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxGdW5jdGlvbn0gdHlwZU9yTGlzdGVuZXJcbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGEgc3RyaW5nIG9yIGFycmF5LCB0aGlzIHNob3VsZCBiZSB0aGVcbiAgICogICAgICAgICBsaXN0ZW5lciBmdW5jdGlvbi4gT3RoZXJ3aXNlLCB0aGlzIGlzIGEgc3RyaW5nIG9yIGFycmF5IG9mIGV2ZW50XG4gICAqICAgICAgICAgdHlwZShzKS5cbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtsaXN0ZW5lcl1cbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGFub3RoZXIgZXZlbnRlZCBvYmplY3QsIHRoaXMgd2lsbCBiZVxuICAgKiAgICAgICAgIHRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICovXG4gIG9uOiBmdW5jdGlvbiBvbiQkMSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIF9ub3JtYWxpemVMaXN0ZW5BcmdzID0gbm9ybWFsaXplTGlzdGVuQXJncyh0aGlzLCBhcmdzKSxcbiAgICAgICAgaXNUYXJnZXRpbmdTZWxmID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MuaXNUYXJnZXRpbmdTZWxmLFxuICAgICAgICB0YXJnZXQgPSBfbm9ybWFsaXplTGlzdGVuQXJncy50YXJnZXQsXG4gICAgICAgIHR5cGUgPSBfbm9ybWFsaXplTGlzdGVuQXJncy50eXBlLFxuICAgICAgICBsaXN0ZW5lciA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzLmxpc3RlbmVyO1xuXG4gICAgbGlzdGVuKHRhcmdldCwgJ29uJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gICAgLy8gSWYgdGhpcyBvYmplY3QgaXMgbGlzdGVuaW5nIHRvIGFub3RoZXIgZXZlbnRlZCBvYmplY3QuXG4gICAgaWYgKCFpc1RhcmdldGluZ1NlbGYpIHtcblxuICAgICAgLy8gSWYgdGhpcyBvYmplY3QgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAgICB2YXIgcmVtb3ZlTGlzdGVuZXJPbkRpc3Bvc2UgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLm9mZih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFVzZSB0aGUgc2FtZSBmdW5jdGlvbiBJRCBhcyB0aGUgbGlzdGVuZXIgc28gd2UgY2FuIHJlbW92ZSBpdCBsYXRlciBpdFxuICAgICAgLy8gdXNpbmcgdGhlIElEIG9mIHRoZSBvcmlnaW5hbCBsaXN0ZW5lci5cbiAgICAgIHJlbW92ZUxpc3RlbmVyT25EaXNwb3NlLmd1aWQgPSBsaXN0ZW5lci5ndWlkO1xuXG4gICAgICAvLyBBZGQgYSBsaXN0ZW5lciB0byB0aGUgdGFyZ2V0J3MgZGlzcG9zZSBldmVudCBhcyB3ZWxsLiBUaGlzIGVuc3VyZXNcbiAgICAgIC8vIHRoYXQgaWYgdGhlIHRhcmdldCBpcyBkaXNwb3NlZCBCRUZPUkUgdGhpcyBvYmplY3QsIHdlIHJlbW92ZSB0aGVcbiAgICAgIC8vIHJlbW92YWwgbGlzdGVuZXIgdGhhdCB3YXMganVzdCBhZGRlZC4gT3RoZXJ3aXNlLCB3ZSBjcmVhdGUgYSBtZW1vcnkgbGVhay5cbiAgICAgIHZhciByZW1vdmVSZW1vdmVyT25UYXJnZXREaXNwb3NlID0gZnVuY3Rpb24gcmVtb3ZlUmVtb3Zlck9uVGFyZ2V0RGlzcG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLm9mZignZGlzcG9zZScsIHJlbW92ZUxpc3RlbmVyT25EaXNwb3NlKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFVzZSB0aGUgc2FtZSBmdW5jdGlvbiBJRCBhcyB0aGUgbGlzdGVuZXIgc28gd2UgY2FuIHJlbW92ZSBpdCBsYXRlclxuICAgICAgLy8gaXQgdXNpbmcgdGhlIElEIG9mIHRoZSBvcmlnaW5hbCBsaXN0ZW5lci5cbiAgICAgIHJlbW92ZVJlbW92ZXJPblRhcmdldERpc3Bvc2UuZ3VpZCA9IGxpc3RlbmVyLmd1aWQ7XG5cbiAgICAgIGxpc3Rlbih0aGlzLCAnb24nLCAnZGlzcG9zZScsIHJlbW92ZUxpc3RlbmVyT25EaXNwb3NlKTtcbiAgICAgIGxpc3Rlbih0YXJnZXQsICdvbicsICdkaXNwb3NlJywgcmVtb3ZlUmVtb3Zlck9uVGFyZ2V0RGlzcG9zZSk7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEFkZCBhIGxpc3RlbmVyIHRvIGFuIGV2ZW50IChvciBldmVudHMpIG9uIHRoaXMgb2JqZWN0IG9yIGFub3RoZXIgZXZlbnRlZFxuICAgKiBvYmplY3QuIFRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgYmUgY2FsbGVkIG9uY2UgYW5kIHRoZW4gcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEVsZW1lbnR8T2JqZWN0fSB0YXJnZXRPclR5cGVcbiAgICogICAgICAgICBJZiB0aGlzIGlzIGEgc3RyaW5nIG9yIGFycmF5LCBpdCByZXByZXNlbnRzIHRoZSBldmVudCB0eXBlKHMpXG4gICAqICAgICAgICAgdGhhdCB3aWxsIHRyaWdnZXIgdGhlIGxpc3RlbmVyLlxuICAgKlxuICAgKiAgICAgICAgIEFub3RoZXIgZXZlbnRlZCBvYmplY3QgY2FuIGJlIHBhc3NlZCBoZXJlIGluc3RlYWQsIHdoaWNoIHdpbGxcbiAgICogICAgICAgICBjYXVzZSB0aGUgbGlzdGVuZXIgdG8gbGlzdGVuIGZvciBldmVudHMgb24gX3RoYXRfIG9iamVjdC5cbiAgICpcbiAgICogICAgICAgICBJbiBlaXRoZXIgY2FzZSwgdGhlIGxpc3RlbmVyJ3MgYHRoaXNgIHZhbHVlIHdpbGwgYmUgYm91bmQgdG9cbiAgICogICAgICAgICB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEZ1bmN0aW9ufSB0eXBlT3JMaXN0ZW5lclxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYSBzdHJpbmcgb3IgYXJyYXksIHRoaXMgc2hvdWxkIGJlIHRoZVxuICAgKiAgICAgICAgIGxpc3RlbmVyIGZ1bmN0aW9uLiBPdGhlcndpc2UsIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXkgb2YgZXZlbnRcbiAgICogICAgICAgICB0eXBlKHMpLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2xpc3RlbmVyXVxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYW5vdGhlciBldmVudGVkIG9iamVjdCwgdGhpcyB3aWxsIGJlXG4gICAqICAgICAgICAgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgb25lOiBmdW5jdGlvbiBvbmUkJDEoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHZhciBfbm9ybWFsaXplTGlzdGVuQXJnczIgPSBub3JtYWxpemVMaXN0ZW5BcmdzKHRoaXMsIGFyZ3MpLFxuICAgICAgICBpc1RhcmdldGluZ1NlbGYgPSBfbm9ybWFsaXplTGlzdGVuQXJnczIuaXNUYXJnZXRpbmdTZWxmLFxuICAgICAgICB0YXJnZXQgPSBfbm9ybWFsaXplTGlzdGVuQXJnczIudGFyZ2V0LFxuICAgICAgICB0eXBlID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MyLnR5cGUsXG4gICAgICAgIGxpc3RlbmVyID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MyLmxpc3RlbmVyO1xuXG4gICAgLy8gVGFyZ2V0aW5nIHRoaXMgZXZlbnRlZCBvYmplY3QuXG5cblxuICAgIGlmIChpc1RhcmdldGluZ1NlbGYpIHtcbiAgICAgIGxpc3Rlbih0YXJnZXQsICdvbmUnLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFRhcmdldGluZyBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LlxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgbGFyZ3MgPSBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgIGxhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczIub2ZmKHRhcmdldCwgdHlwZSwgd3JhcHBlcik7XG4gICAgICAgIGxpc3RlbmVyLmFwcGx5KG51bGwsIGxhcmdzKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFVzZSB0aGUgc2FtZSBmdW5jdGlvbiBJRCBhcyB0aGUgbGlzdGVuZXIgc28gd2UgY2FuIHJlbW92ZSBpdCBsYXRlclxuICAgICAgLy8gaXQgdXNpbmcgdGhlIElEIG9mIHRoZSBvcmlnaW5hbCBsaXN0ZW5lci5cbiAgICAgIHdyYXBwZXIuZ3VpZCA9IGxpc3RlbmVyLmd1aWQ7XG4gICAgICBsaXN0ZW4odGFyZ2V0LCAnb25lJywgdHlwZSwgd3JhcHBlcik7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgbGlzdGVuZXIocykgZnJvbSBldmVudChzKSBvbiBhbiBldmVudGVkIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEVsZW1lbnR8T2JqZWN0fSBbdGFyZ2V0T3JUeXBlXVxuICAgKiAgICAgICAgIElmIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXksIGl0IHJlcHJlc2VudHMgdGhlIGV2ZW50IHR5cGUocykuXG4gICAqXG4gICAqICAgICAgICAgQW5vdGhlciBldmVudGVkIG9iamVjdCBjYW4gYmUgcGFzc2VkIGhlcmUgaW5zdGVhZCwgaW4gd2hpY2ggY2FzZVxuICAgKiAgICAgICAgIEFMTCAzIGFyZ3VtZW50cyBhcmUgX3JlcXVpcmVkXy5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEZ1bmN0aW9ufSBbdHlwZU9yTGlzdGVuZXJdXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhIHN0cmluZyBvciBhcnJheSwgdGhpcyBtYXkgYmUgdGhlXG4gICAqICAgICAgICAgbGlzdGVuZXIgZnVuY3Rpb24uIE90aGVyd2lzZSwgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSBvZiBldmVudFxuICAgKiAgICAgICAgIHR5cGUocykuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbbGlzdGVuZXJdXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LCB0aGlzIHdpbGwgYmVcbiAgICogICAgICAgICB0aGUgbGlzdGVuZXIgZnVuY3Rpb247IG90aGVyd2lzZSwgX2FsbF8gbGlzdGVuZXJzIGJvdW5kIHRvIHRoZVxuICAgKiAgICAgICAgIGV2ZW50IHR5cGUocykgd2lsbCBiZSByZW1vdmVkLlxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmYkJDEodGFyZ2V0T3JUeXBlLCB0eXBlT3JMaXN0ZW5lciwgbGlzdGVuZXIpIHtcblxuICAgIC8vIFRhcmdldGluZyB0aGlzIGV2ZW50ZWQgb2JqZWN0LlxuICAgIGlmICghdGFyZ2V0T3JUeXBlIHx8IGlzVmFsaWRFdmVudFR5cGUodGFyZ2V0T3JUeXBlKSkge1xuICAgICAgb2ZmKHRoaXMuZXZlbnRCdXNFbF8sIHRhcmdldE9yVHlwZSwgdHlwZU9yTGlzdGVuZXIpO1xuXG4gICAgICAvLyBUYXJnZXRpbmcgYW5vdGhlciBldmVudGVkIG9iamVjdC5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhcmdldCA9IHRhcmdldE9yVHlwZTtcbiAgICAgIHZhciB0eXBlID0gdHlwZU9yTGlzdGVuZXI7XG5cbiAgICAgIC8vIEZhaWwgZmFzdCBhbmQgaW4gYSBtZWFuaW5nZnVsIHdheSFcbiAgICAgIHZhbGlkYXRlVGFyZ2V0KHRhcmdldCk7XG4gICAgICB2YWxpZGF0ZUV2ZW50VHlwZSh0eXBlKTtcbiAgICAgIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICAvLyBFbnN1cmUgdGhlcmUncyBhdCBsZWFzdCBhIGd1aWQsIGV2ZW4gaWYgdGhlIGZ1bmN0aW9uIGhhc24ndCBiZWVuIHVzZWRcbiAgICAgIGxpc3RlbmVyID0gYmluZCh0aGlzLCBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgZGlzcG9zZSBsaXN0ZW5lciBvbiB0aGlzIGV2ZW50ZWQgb2JqZWN0LCB3aGljaCB3YXMgZ2l2ZW5cbiAgICAgIC8vIHRoZSBzYW1lIGd1aWQgYXMgdGhlIGV2ZW50IGxpc3RlbmVyIGluIG9uKCkuXG4gICAgICB0aGlzLm9mZignZGlzcG9zZScsIGxpc3RlbmVyKTtcblxuICAgICAgaWYgKHRhcmdldC5ub2RlTmFtZSkge1xuICAgICAgICBvZmYodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIG9mZih0YXJnZXQsICdkaXNwb3NlJywgbGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIGlmIChpc0V2ZW50ZWQodGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQub2ZmKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgdGFyZ2V0Lm9mZignZGlzcG9zZScsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cblxuICAvKipcbiAgICogRmlyZSBhbiBldmVudCBvbiB0aGlzIGV2ZW50ZWQgb2JqZWN0LCBjYXVzaW5nIGl0cyBsaXN0ZW5lcnMgdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfE9iamVjdH0gZXZlbnRcbiAgICogICAgICAgICAgQW4gZXZlbnQgdHlwZSBvciBhbiBvYmplY3Qgd2l0aCBhIHR5cGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9IFtoYXNoXVxuICAgKiAgICAgICAgICBBbiBhZGRpdGlvbmFsIG9iamVjdCB0byBwYXNzIGFsb25nIHRvIGxpc3RlbmVycy5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdhcyBwcmV2ZW50ZWQuXG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyJCQxKGV2ZW50LCBoYXNoKSB7XG4gICAgcmV0dXJuIHRyaWdnZXIodGhpcy5ldmVudEJ1c0VsXywgZXZlbnQsIGhhc2gpO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGxpZXMge0BsaW5rIG1vZHVsZTpldmVudGVkfkV2ZW50ZWRNaXhpbnxFdmVudGVkTWl4aW59IHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICogICAgICAgICBUaGUgb2JqZWN0IHRvIHdoaWNoIHRvIGFkZCBldmVudCBtZXRob2RzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnM9e31dXG4gKiAgICAgICAgIE9wdGlvbnMgZm9yIGN1c3RvbWl6aW5nIHRoZSBtaXhpbiBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLmV2ZW50QnVzS2V5XVxuICogICAgICAgICBCeSBkZWZhdWx0LCBhZGRzIGEgYGV2ZW50QnVzRWxfYCBET00gZWxlbWVudCB0byB0aGUgdGFyZ2V0IG9iamVjdCxcbiAqICAgICAgICAgd2hpY2ggaXMgdXNlZCBhcyBhbiBldmVudCBidXMuIElmIHRoZSB0YXJnZXQgb2JqZWN0IGFscmVhZHkgaGFzIGFcbiAqICAgICAgICAgRE9NIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCwgcGFzcyBpdHMga2V5IGhlcmUuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBUaGUgdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXZlbnRlZCh0YXJnZXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgZXZlbnRCdXNLZXkgPSBvcHRpb25zLmV2ZW50QnVzS2V5O1xuXG4gIC8vIFNldCBvciBjcmVhdGUgdGhlIGV2ZW50QnVzRWxfLlxuXG4gIGlmIChldmVudEJ1c0tleSkge1xuICAgIGlmICghdGFyZ2V0W2V2ZW50QnVzS2V5XS5ub2RlTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZXZlbnRCdXNLZXkgXCInICsgZXZlbnRCdXNLZXkgKyAnXCIgZG9lcyBub3QgcmVmZXIgdG8gYW4gZWxlbWVudC4nKTtcbiAgICB9XG4gICAgdGFyZ2V0LmV2ZW50QnVzRWxfID0gdGFyZ2V0W2V2ZW50QnVzS2V5XTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuZXZlbnRCdXNFbF8gPSBjcmVhdGVFbCgnc3BhbicsIHsgY2xhc3NOYW1lOiAndmpzLWV2ZW50LWJ1cycgfSk7XG4gIH1cblxuICBhc3NpZ24odGFyZ2V0LCBFdmVudGVkTWl4aW4pO1xuXG4gIC8vIFdoZW4gYW55IGV2ZW50ZWQgb2JqZWN0IGlzIGRpc3Bvc2VkLCBpdCByZW1vdmVzIGFsbCBpdHMgbGlzdGVuZXJzLlxuICB0YXJnZXQub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRhcmdldC5vZmYoKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAZmlsZSBtaXhpbnMvc3RhdGVmdWwuanNcbiAqIEBtb2R1bGUgc3RhdGVmdWxcbiAqL1xuLyoqXG4gKiBDb250YWlucyBtZXRob2RzIHRoYXQgcHJvdmlkZSBzdGF0ZWZ1bG5lc3MgdG8gYW4gb2JqZWN0IHdoaWNoIGlzIHBhc3NlZFxuICogdG8ge0BsaW5rIG1vZHVsZTpzdGF0ZWZ1bH0uXG4gKlxuICogQG1peGluIFN0YXRlZnVsTWl4aW5cbiAqL1xudmFyIFN0YXRlZnVsTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEEgaGFzaCBjb250YWluaW5nIGFyYml0cmFyeSBrZXlzIGFuZCB2YWx1ZXMgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZlxuICAgKiB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGU6IHt9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0YXRlIG9mIGFuIG9iamVjdCBieSBtdXRhdGluZyBpdHNcbiAgICoge0BsaW5rIG1vZHVsZTpzdGF0ZWZ1bH5TdGF0ZWZ1bE1peGluLnN0YXRlfHN0YXRlfSBvYmplY3QgaW4gcGxhY2UuXG4gICAqXG4gICAqIEBmaXJlcyAgIG1vZHVsZTpzdGF0ZWZ1bH5TdGF0ZWZ1bE1peGluI3N0YXRlY2hhbmdlZFxuICAgKiBAcGFyYW0gICB7T2JqZWN0fEZ1bmN0aW9ufSBzdGF0ZVVwZGF0ZXNcbiAgICogICAgICAgICAgQSBuZXcgc2V0IG9mIHByb3BlcnRpZXMgdG8gc2hhbGxvdy1tZXJnZSBpbnRvIHRoZSBwbHVnaW4gc3RhdGUuXG4gICAqICAgICAgICAgIENhbiBiZSBhIHBsYWluIG9iamVjdCBvciBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHBsYWluIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIGNoYW5nZXMgdGhhdCBvY2N1cnJlZC4gSWYgbm8gY2hhbmdlc1xuICAgKiAgICAgICAgICBvY2N1cnJlZCwgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICovXG4gIHNldFN0YXRlOiBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZVVwZGF0ZXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gU3VwcG9ydCBwcm92aWRpbmcgdGhlIGBzdGF0ZVVwZGF0ZXNgIHN0YXRlIGFzIGEgZnVuY3Rpb24uXG4gICAgaWYgKHR5cGVvZiBzdGF0ZVVwZGF0ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlVXBkYXRlcyA9IHN0YXRlVXBkYXRlcygpO1xuICAgIH1cblxuICAgIHZhciBjaGFuZ2VzID0gdm9pZCAwO1xuXG4gICAgZWFjaChzdGF0ZVVwZGF0ZXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhbmdlIGlmIHRoZSB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSB3aGF0J3MgaW4gdGhlXG4gICAgICAvLyBjdXJyZW50IHN0YXRlLlxuICAgICAgaWYgKF90aGlzLnN0YXRlW2tleV0gIT09IHZhbHVlKSB7XG4gICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzIHx8IHt9O1xuICAgICAgICBjaGFuZ2VzW2tleV0gPSB7XG4gICAgICAgICAgZnJvbTogX3RoaXMuc3RhdGVba2V5XSxcbiAgICAgICAgICB0bzogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc3RhdGVba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgLy8gT25seSB0cmlnZ2VyIFwic3RhdGVjaGFuZ2VcIiBpZiB0aGVyZSB3ZXJlIGNoYW5nZXMgQU5EIHdlIGhhdmUgYSB0cmlnZ2VyXG4gICAgLy8gZnVuY3Rpb24uIFRoaXMgYWxsb3dzIHVzIHRvIG5vdCByZXF1aXJlIHRoYXQgdGhlIHRhcmdldCBvYmplY3QgYmUgYW5cbiAgICAvLyBldmVudGVkIG9iamVjdC5cbiAgICBpZiAoY2hhbmdlcyAmJiBpc0V2ZW50ZWQodGhpcykpIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbiBldmVudCB0cmlnZ2VyZWQgb24gYW4gb2JqZWN0IHRoYXQgaXMgYm90aFxuICAgICAgICoge0BsaW5rIG1vZHVsZTpzdGF0ZWZ1bHxzdGF0ZWZ1bH0gYW5kIHtAbGluayBtb2R1bGU6ZXZlbnRlZHxldmVudGVkfVxuICAgICAgICogaW5kaWNhdGluZyB0aGF0IGl0cyBzdGF0ZSBoYXMgY2hhbmdlZC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgICAgbW9kdWxlOnN0YXRlZnVsflN0YXRlZnVsTWl4aW4jc3RhdGVjaGFuZ2VkXG4gICAgICAgKiBAdHlwZSAgICAge09iamVjdH1cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjaGFuZ2VzXG4gICAgICAgKiAgICAgICAgICAgQSBoYXNoIGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGNoYW5nZWQgYW5kXG4gICAgICAgKiAgICAgICAgICAgdGhlIHZhbHVlcyB0aGV5IHdlcmUgY2hhbmdlZCBgZnJvbWAgYW5kIGB0b2AuXG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcih7XG4gICAgICAgIGNoYW5nZXM6IGNoYW5nZXMsXG4gICAgICAgIHR5cGU6ICdzdGF0ZWNoYW5nZWQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIHtAbGluayBtb2R1bGU6c3RhdGVmdWx+U3RhdGVmdWxNaXhpbnxTdGF0ZWZ1bE1peGlufSB0byBhIHRhcmdldFxuICogb2JqZWN0LlxuICpcbiAqIElmIHRoZSB0YXJnZXQgb2JqZWN0IGlzIHtAbGluayBtb2R1bGU6ZXZlbnRlZHxldmVudGVkfSBhbmQgaGFzIGFcbiAqIGBoYW5kbGVTdGF0ZUNoYW5nZWRgIG1ldGhvZCwgdGhhdCBtZXRob2Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kIHRvIHRoZVxuICogYHN0YXRlY2hhbmdlZGAgZXZlbnQgb24gaXRzZWxmLlxuICpcbiAqIEBwYXJhbSAgIHtPYmplY3R9IHRhcmdldFxuICogICAgICAgICAgVGhlIG9iamVjdCB0byBiZSBtYWRlIHN0YXRlZnVsLlxuICpcbiAqIEBwYXJhbSAgIHtPYmplY3R9IFtkZWZhdWx0U3RhdGVdXG4gKiAgICAgICAgICBBIGRlZmF1bHQgc2V0IG9mIHByb3BlcnRpZXMgdG8gcG9wdWxhdGUgdGhlIG5ld2x5LXN0YXRlZnVsIG9iamVjdCdzXG4gKiAgICAgICAgICBgc3RhdGVgIHByb3BlcnR5LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiAgICAgICAgICBSZXR1cm5zIHRoZSBgdGFyZ2V0YC5cbiAqL1xuZnVuY3Rpb24gc3RhdGVmdWwodGFyZ2V0LCBkZWZhdWx0U3RhdGUpIHtcbiAgYXNzaWduKHRhcmdldCwgU3RhdGVmdWxNaXhpbik7XG5cbiAgLy8gVGhpcyBoYXBwZW5zIGFmdGVyIHRoZSBtaXhpbmctaW4gYmVjYXVzZSB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIGBzdGF0ZWBcbiAgLy8gYWRkZWQgaW4gdGhhdCBzdGVwLlxuICB0YXJnZXQuc3RhdGUgPSBhc3NpZ24oe30sIHRhcmdldC5zdGF0ZSwgZGVmYXVsdFN0YXRlKTtcblxuICAvLyBBdXRvLWJpbmQgdGhlIGBoYW5kbGVTdGF0ZUNoYW5nZWRgIG1ldGhvZCBvZiB0aGUgdGFyZ2V0IG9iamVjdCBpZiBpdCBleGlzdHMuXG4gIGlmICh0eXBlb2YgdGFyZ2V0LmhhbmRsZVN0YXRlQ2hhbmdlZCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0V2ZW50ZWQodGFyZ2V0KSkge1xuICAgIHRhcmdldC5vbignc3RhdGVjaGFuZ2VkJywgdGFyZ2V0LmhhbmRsZVN0YXRlQ2hhbmdlZCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEBmaWxlIHRvLXRpdGxlLWNhc2UuanNcbiAqIEBtb2R1bGUgdG8tdGl0bGUtY2FzZVxuICovXG5cbi8qKlxuICogVXBwZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogICAgICAgIFN0cmluZyB0byBiZSB1cHBlcmNhc2VkXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgc3RyaW5nIHdpdGggYW4gdXBwZXJjYXNlZCBmaXJzdCBsZXR0ZXJcbiAqL1xuZnVuY3Rpb24gdG9UaXRsZUNhc2Uoc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHRoZSBUaXRsZUNhc2UgdmVyc2lvbnMgb2YgdGhlIHR3byBzdHJpbmdzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyMVxuICogICAgICAgIFRoZSBmaXJzdCBzdHJpbmcgdG8gY29tcGFyZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIyXG4gKiAgICAgICAgVGhlIHNlY29uZCBzdHJpbmcgdG8gY29tcGFyZVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgdGhlIFRpdGxlQ2FzZSB2ZXJzaW9ucyBvZiB0aGUgc3RyaW5ncyBhcmUgZXF1YWxcbiAqL1xuZnVuY3Rpb24gdGl0bGVDYXNlRXF1YWxzKHN0cjEsIHN0cjIpIHtcbiAgcmV0dXJuIHRvVGl0bGVDYXNlKHN0cjEpID09PSB0b1RpdGxlQ2FzZShzdHIyKTtcbn1cblxuLyoqXG4gKiBAZmlsZSBtZXJnZS1vcHRpb25zLmpzXG4gKiBAbW9kdWxlIG1lcmdlLW9wdGlvbnNcbiAqL1xuLyoqXG4gKiBEZWVwLW1lcmdlIG9uZSBvciBtb3JlIG9wdGlvbnMgb2JqZWN0cywgcmVjdXJzaXZlbHkgbWVyZ2luZyAqKm9ubHkqKiBwbGFpblxuICogb2JqZWN0IHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtICAge09iamVjdFtdfSBzb3VyY2VzXG4gKiAgICAgICAgICBPbmUgb3IgbW9yZSBvYmplY3RzIHRvIG1lcmdlIGludG8gYSBuZXcgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiAgICAgICAgICBBIG5ldyBvYmplY3QgdGhhdCBpcyB0aGUgbWVyZ2VkIHJlc3VsdCBvZiBhbGwgc291cmNlcy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVhY2goc291cmNlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgaWYgKCFpc1BsYWluKHZhbHVlKSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNQbGFpbihyZXN1bHRba2V5XSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZU9wdGlvbnMocmVzdWx0W2tleV0sIHZhbHVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBQbGF5ZXIgQ29tcG9uZW50IC0gQmFzZSBjbGFzcyBmb3IgYWxsIFVJIG9iamVjdHNcbiAqXG4gKiBAZmlsZSBjb21wb25lbnQuanNcbiAqL1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgVUkgQ29tcG9uZW50cy5cbiAqIENvbXBvbmVudHMgYXJlIFVJIG9iamVjdHMgd2hpY2ggcmVwcmVzZW50IGJvdGggYSBqYXZhc2NyaXB0IG9iamVjdCBhbmQgYW4gZWxlbWVudFxuICogaW4gdGhlIERPTS4gVGhleSBjYW4gYmUgY2hpbGRyZW4gb2Ygb3RoZXIgY29tcG9uZW50cywgYW5kIGNhbiBoYXZlXG4gKiBjaGlsZHJlbiB0aGVtc2VsdmVzLlxuICpcbiAqIENvbXBvbmVudHMgY2FuIGFsc28gdXNlIG1ldGhvZHMgZnJvbSB7QGxpbmsgRXZlbnRUYXJnZXR9XG4gKi9cblxudmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlYWR5LiBEb2VzIG5vdCBoYXZlIGFueVxuICAgKiBwYXJhbXRlcnMgYW5kIGFueSBjYWxsYmFjayB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQuXG4gICAqXG4gICAqIEBjYWxsYmFjayBDb21wb25lbnR+UmVhZHlDYWxsYmFja1xuICAgKiBAdGhpcyBDb21wb25lbnRcbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IFtvcHRpb25zLmNoaWxkcmVuXVxuICAgKiAgICAgICAgQW4gYXJyYXkgb2YgY2hpbGRyZW4gb2JqZWN0cyB0byBpbnRpYWxpemUgdGhpcyBjb21wb25lbnQgd2l0aC4gQ2hpbGRyZW4gb2JqZWN0cyBoYXZlXG4gICAqICAgICAgICBhIG5hbWUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIHVzZWQgaWYgbW9yZSB0aGFuIG9uZSBjb21wb25lbnQgb2YgdGhlIHNhbWUgdHlwZSBuZWVkcyB0byBiZVxuICAgKiAgICAgICAgYWRkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIEZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgYENvbXBvbmVudGAgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBDb21wb25lbnQocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBvbmVudCk7XG5cblxuICAgIC8vIFRoZSBjb21wb25lbnQgbWlnaHQgYmUgdGhlIHBsYXllciBpdHNlbGYgYW5kIHdlIGNhbid0IHBhc3MgYHRoaXNgIHRvIHN1cGVyXG4gICAgaWYgKCFwbGF5ZXIgJiYgdGhpcy5wbGF5KSB7XG4gICAgICB0aGlzLnBsYXllcl8gPSBwbGF5ZXIgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXyA9IHBsYXllcjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGEgY29weSBvZiBwcm90b3R5cGUub3B0aW9uc18gdG8gcHJvdGVjdCBhZ2FpbnN0IG92ZXJyaWRpbmcgZGVmYXVsdHNcbiAgICB0aGlzLm9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKHt9LCB0aGlzLm9wdGlvbnNfKTtcblxuICAgIC8vIFVwZGF0ZWQgb3B0aW9ucyB3aXRoIHN1cHBsaWVkIG9wdGlvbnNcbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnNfLCBvcHRpb25zKTtcblxuICAgIC8vIEdldCBJRCBmcm9tIG9wdGlvbnMgb3Igb3B0aW9ucyBlbGVtZW50IGlmIG9uZSBpcyBzdXBwbGllZFxuICAgIHRoaXMuaWRfID0gb3B0aW9ucy5pZCB8fCBvcHRpb25zLmVsICYmIG9wdGlvbnMuZWwuaWQ7XG5cbiAgICAvLyBJZiB0aGVyZSB3YXMgbm8gSUQgZnJvbSB0aGUgb3B0aW9ucywgZ2VuZXJhdGUgb25lXG4gICAgaWYgKCF0aGlzLmlkXykge1xuICAgICAgLy8gRG9uJ3QgcmVxdWlyZSB0aGUgcGxheWVyIElEIGZ1bmN0aW9uIGluIHRoZSBjYXNlIG9mIG1vY2sgcGxheWVyc1xuICAgICAgdmFyIGlkID0gcGxheWVyICYmIHBsYXllci5pZCAmJiBwbGF5ZXIuaWQoKSB8fCAnbm9fcGxheWVyJztcblxuICAgICAgdGhpcy5pZF8gPSBpZCArICdfY29tcG9uZW50XycgKyBuZXdHVUlEKCk7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lXyA9IG9wdGlvbnMubmFtZSB8fCBudWxsO1xuXG4gICAgLy8gQ3JlYXRlIGVsZW1lbnQgaWYgb25lIHdhc24ndCBwcm92aWRlZCBpbiBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMuZWwpIHtcbiAgICAgIHRoaXMuZWxfID0gb3B0aW9ucy5lbDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY3JlYXRlRWwgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmVsXyA9IHRoaXMuY3JlYXRlRWwoKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHRoaXMgYW4gZXZlbnRlZCBvYmplY3QgYW5kIHVzZSBgZWxfYCwgaWYgYXZhaWxhYmxlLCBhcyBpdHMgZXZlbnQgYnVzXG4gICAgZXZlbnRlZCh0aGlzLCB7IGV2ZW50QnVzS2V5OiB0aGlzLmVsXyA/ICdlbF8nIDogbnVsbCB9KTtcbiAgICBzdGF0ZWZ1bCh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRTdGF0ZSk7XG5cbiAgICB0aGlzLmNoaWxkcmVuXyA9IFtdO1xuICAgIHRoaXMuY2hpbGRJbmRleF8gPSB7fTtcbiAgICB0aGlzLmNoaWxkTmFtZUluZGV4XyA9IHt9O1xuXG4gICAgLy8gQWRkIGFueSBjaGlsZCBjb21wb25lbnRzIGluIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5pbml0Q2hpbGRyZW4gIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmluaXRDaGlsZHJlbigpO1xuICAgIH1cblxuICAgIHRoaXMucmVhZHkocmVhZHkpO1xuICAgIC8vIERvbid0IHdhbnQgdG8gdHJpZ2dlciByZWFkeSBoZXJlIG9yIGl0IHdpbGwgYmVmb3JlIGluaXQgaXMgYWN0dWFsbHlcbiAgICAvLyBmaW5pc2hlZCBmb3IgYWxsIGNoaWxkcmVuIHRoYXQgcnVuIHRoaXMgY29uc3RydWN0b3JcblxuICAgIGlmIChvcHRpb25zLnJlcG9ydFRvdWNoQWN0aXZpdHkgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmVuYWJsZVRvdWNoQWN0aXZpdHkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZSBvZiB0aGUgYENvbXBvbmVudGAgYW5kIGFsbCBjaGlsZCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAZmlyZXMgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSBgQ29tcG9uZW50YCBpcyBkaXNwb3NlZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBDb21wb25lbnQjZGlzcG9zZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdXG4gICAgICogICAgICAgICAgIHNldCB0byBmYWxzZSBzbyB0aGF0IHRoZSBjbG9zZSBldmVudCBkb2VzIG5vdFxuICAgICAqICAgICAgICAgICBidWJibGUgdXBcbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoeyB0eXBlOiAnZGlzcG9zZScsIGJ1YmJsZXM6IGZhbHNlIH0pO1xuXG4gICAgLy8gRGlzcG9zZSBhbGwgY2hpbGRyZW4uXG4gICAgaWYgKHRoaXMuY2hpbGRyZW5fKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5jaGlsZHJlbl8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fW2ldLmRpc3Bvc2UpIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuX1tpXS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWxldGUgY2hpbGQgcmVmZXJlbmNlc1xuICAgIHRoaXMuY2hpbGRyZW5fID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkSW5kZXhfID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkTmFtZUluZGV4XyA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5lbF8pIHtcbiAgICAgIC8vIFJlbW92ZSBlbGVtZW50IGZyb20gRE9NXG4gICAgICBpZiAodGhpcy5lbF8ucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmVsXy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWxfKTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlRGF0YSh0aGlzLmVsXyk7XG4gICAgICB0aGlzLmVsXyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHtAbGluayBQbGF5ZXJ9IHRoYXQgdGhlIGBDb21wb25lbnRgIGhhcyBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHJldHVybiB7UGxheWVyfVxuICAgKiAgICAgICAgIFRoZSBwbGF5ZXIgdGhhdCB0aGlzIGBDb21wb25lbnRgIGhhcyBhdHRhY2hlZCB0by5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnBsYXllciA9IGZ1bmN0aW9uIHBsYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWVwIG1lcmdlIG9mIG9wdGlvbnMgb2JqZWN0cyB3aXRoIG5ldyBvcHRpb25zLlxuICAgKiA+IE5vdGU6IFdoZW4gYm90aCBgb2JqYCBhbmQgYG9wdGlvbnNgIGNvbnRhaW4gcHJvcGVydGllcyB3aG9zZSB2YWx1ZXMgYXJlIG9iamVjdHMuXG4gICAqICAgICAgICAgVGhlIHR3byBwcm9wZXJ0aWVzIGdldCBtZXJnZWQgdXNpbmcge0BsaW5rIG1vZHVsZTptZXJnZU9wdGlvbnN9XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogICAgICAgIFRoZSBvYmplY3QgdGhhdCBjb250YWlucyBuZXcgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEEgbmV3IG9iamVjdCBvZiBgdGhpcy5vcHRpb25zX2AgYW5kIGBvYmpgIG1lcmdlZCB0b2dldGhlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24gb3B0aW9ucyhvYmopIHtcbiAgICBsb2ckMS53YXJuKCd0aGlzLm9wdGlvbnMoKSBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIG1vdmVkIHRvIHRoZSBjb25zdHJ1Y3RvciBpbiA2LjAnKTtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zXztcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9uc18sIG9iaik7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYENvbXBvbmVudGBzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIERPTSBlbGVtZW50IGZvciB0aGlzIGBDb21wb25lbnRgLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZWwgPSBmdW5jdGlvbiBlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF87XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhZ05hbWVdXG4gICAqICAgICAgICBFbGVtZW50J3MgRE9NIG5vZGUgdHlwZS4gZS5nLiAnZGl2J1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc11cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHNldC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEodGFnTmFtZSwgcHJvcGVydGllcywgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjcmVhdGVFbCh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9jYWxpemUgYSBzdHJpbmcgZ2l2ZW4gdGhlIHN0cmluZyBpbiBlbmdsaXNoLlxuICAgKlxuICAgKiBJZiB0b2tlbnMgYXJlIHByb3ZpZGVkLCBpdCdsbCB0cnkgYW5kIHJ1biBhIHNpbXBsZSB0b2tlbiByZXBsYWNlbWVudCBvbiB0aGUgcHJvdmlkZWQgc3RyaW5nLlxuICAgKiBUaGUgdG9rZW5zIGl0IGxvb29rcyBmb3IgbG9vayBsaWtlIGB7MX1gIHdpdGggdGhlIGluZGV4IGJlaW5nIDEtaW5kZXhlZCBpbnRvIHRoZSB0b2tlbnMgYXJyYXkuXG4gICAqXG4gICAqIElmIGEgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGl0J2xsIHVzZSB0aGF0IG92ZXIgYHN0cmluZ2AsXG4gICAqIGlmIGEgdmFsdWUgaXNuJ3QgZm91bmQgaW4gcHJvdmlkZWQgbGFuZ3VhZ2UgZmlsZXMuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGhhdmUgYSBkZXNjcmlwdGl2ZSBrZXkgZm9yIHRva2VuIHJlcGxhY2VtZW50XG4gICAqIGJ1dCBoYXZlIGEgc3VjY2luY3QgbG9jYWxpemVkIHN0cmluZyBhbmQgbm90IHJlcXVpcmUgYGVuLmpzb25gIHRvIGJlIGluY2x1ZGVkLlxuICAgKlxuICAgKiBDdXJyZW50bHksIGl0IGlzIHVzZWQgZm9yIHRoZSBwcm9ncmVzcyBiYXIgdGltaW5nLlxuICAgKiBgYGBqc1xuICAgKiB7XG4gICAqICAgXCJwcm9ncmVzcyBiYXIgdGltaW5nOiBjdXJyZW50VGltZT17MX0gZHVyYXRpb249ezJ9XCI6IFwiezF9IG9mIHsyfVwiXG4gICAqIH1cbiAgICogYGBgXG4gICAqIEl0IGlzIHRoZW4gdXNlZCBsaWtlIHNvOlxuICAgKiBgYGBqc1xuICAgKiB0aGlzLmxvY2FsaXplKCdwcm9ncmVzcyBiYXIgdGltaW5nOiBjdXJyZW50VGltZT17MX0gZHVyYXRpb257Mn0nLFxuICAgKiAgICAgICAgICAgICAgIFt0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKSwgdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCldLFxuICAgKiAgICAgICAgICAgICAgICd7MX0gb2YgezJ9Jyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBXaGljaCBvdXRwdXRzIHNvbWV0aGluZyBsaWtlOiBgMDE6MjMgb2YgMjQ6NTZgLlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAqICAgICAgICBUaGUgc3RyaW5nIHRvIGxvY2FsaXplIGFuZCB0aGUga2V5IHRvIGxvb2t1cCBpbiB0aGUgbGFuZ3VhZ2UgZmlsZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFt0b2tlbnNdXG4gICAqICAgICAgICBJZiB0aGUgY3VycmVudCBpdGVtIGhhcyB0b2tlbiByZXBsYWNlbWVudHMsIHByb3ZpZGUgdGhlIHRva2VucyBoZXJlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RlZmF1bHRWYWx1ZV1cbiAgICogICAgICAgIERlZmF1bHRzIHRvIGBzdHJpbmdgLiBDYW4gYmUgYSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBmb3IgdG9rZW4gcmVwbGFjZW1lbnRcbiAgICogICAgICAgIGlmIHRoZSBsb29rdXAga2V5IGlzIG5lZWRlZCB0byBiZSBzZXBhcmF0ZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBsb2NhbGl6ZWQgc3RyaW5nIG9yIGlmIG5vIGxvY2FsaXphdGlvbiBleGlzdHMgdGhlIGVuZ2xpc2ggc3RyaW5nLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUubG9jYWxpemUgPSBmdW5jdGlvbiBsb2NhbGl6ZShzdHJpbmcsIHRva2Vucykge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHN0cmluZztcblxuICAgIHZhciBjb2RlID0gdGhpcy5wbGF5ZXJfLmxhbmd1YWdlICYmIHRoaXMucGxheWVyXy5sYW5ndWFnZSgpO1xuICAgIHZhciBsYW5ndWFnZXMgPSB0aGlzLnBsYXllcl8ubGFuZ3VhZ2VzICYmIHRoaXMucGxheWVyXy5sYW5ndWFnZXMoKTtcbiAgICB2YXIgbGFuZ3VhZ2UgPSBsYW5ndWFnZXMgJiYgbGFuZ3VhZ2VzW2NvZGVdO1xuICAgIHZhciBwcmltYXJ5Q29kZSA9IGNvZGUgJiYgY29kZS5zcGxpdCgnLScpWzBdO1xuICAgIHZhciBwcmltYXJ5TGFuZyA9IGxhbmd1YWdlcyAmJiBsYW5ndWFnZXNbcHJpbWFyeUNvZGVdO1xuXG4gICAgdmFyIGxvY2FsaXplZFN0cmluZyA9IGRlZmF1bHRWYWx1ZTtcblxuICAgIGlmIChsYW5ndWFnZSAmJiBsYW5ndWFnZVtzdHJpbmddKSB7XG4gICAgICBsb2NhbGl6ZWRTdHJpbmcgPSBsYW5ndWFnZVtzdHJpbmddO1xuICAgIH0gZWxzZSBpZiAocHJpbWFyeUxhbmcgJiYgcHJpbWFyeUxhbmdbc3RyaW5nXSkge1xuICAgICAgbG9jYWxpemVkU3RyaW5nID0gcHJpbWFyeUxhbmdbc3RyaW5nXTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICBsb2NhbGl6ZWRTdHJpbmcgPSBsb2NhbGl6ZWRTdHJpbmcucmVwbGFjZSgvXFx7KFxcZCspXFx9L2csIGZ1bmN0aW9uIChtYXRjaCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdG9rZW5zW2luZGV4IC0gMV07XG4gICAgICAgIHZhciByZXQgPSB2YWx1ZTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldCA9IG1hdGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsb2NhbGl6ZWRTdHJpbmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYENvbXBvbmVudGBzIERPTSBlbGVtZW50LiBUaGlzIGlzIHdoZXJlIGNoaWxkcmVuIGdldCBpbnNlcnRlZC5cbiAgICogVGhpcyB3aWxsIHVzdWFsbHkgYmUgdGhlIHRoZSBzYW1lIGFzIHRoZSBlbGVtZW50IHJldHVybmVkIGluIHtAbGluayBDb21wb25lbnQjZWx9LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBjb250ZW50IGVsZW1lbnQgZm9yIHRoaXMgYENvbXBvbmVudGAuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jb250ZW50RWwgPSBmdW5jdGlvbiBjb250ZW50RWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudEVsXyB8fCB0aGlzLmVsXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoaXMgYENvbXBvbmVudGBzIElEXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgaWQgb2YgdGhpcyBgQ29tcG9uZW50YFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pZF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYENvbXBvbmVudGBzIG5hbWUuIFRoZSBuYW1lIGdldHMgdXNlZCB0byByZWZlcmVuY2UgdGhlIGBDb21wb25lbnRgXG4gICAqIGFuZCBpcyBzZXQgZHVyaW5nIHJlZ2lzdHJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBuYW1lIG9mIHRoaXMgYENvbXBvbmVudGAuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIGFycmF5IG9mIGFsbCBjaGlsZCBjb21wb25lbnRzXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiAgICAgICAgIFRoZSBjaGlsZHJlblxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbiBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNoaWxkIGBDb21wb25lbnRgIHdpdGggdGhlIGdpdmVuIGBpZGAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKiAgICAgICAgVGhlIGlkIG9mIHRoZSBjaGlsZCBgQ29tcG9uZW50YCB0byBnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgVGhlIGNoaWxkIGBDb21wb25lbnRgIHdpdGggdGhlIGdpdmVuIGBpZGAgb3IgdW5kZWZpbmVkLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q2hpbGRCeUlkID0gZnVuY3Rpb24gZ2V0Q2hpbGRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRJbmRleF9baWRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBgQ29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBgbmFtZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgY2hpbGQgYENvbXBvbmVudGAgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFRoZSBjaGlsZCBgQ29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBgbmFtZWAgb3IgdW5kZWZpbmVkLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiBnZXRDaGlsZChuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xuXG4gICAgcmV0dXJuIHRoaXMuY2hpbGROYW1lSW5kZXhfW25hbWVdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjaGlsZCBgQ29tcG9uZW50YCBpbnNpZGUgdGhlIGN1cnJlbnQgYENvbXBvbmVudGAuXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfENvbXBvbmVudH0gY2hpbGRcbiAgICogICAgICAgIFRoZSBuYW1lIG9yIGluc3RhbmNlIG9mIGEgY2hpbGQgdG8gYWRkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIG9wdGlvbnMgdGhhdCB3aWxsIGdldCBwYXNzZWQgdG8gY2hpbGRyZW4gb2ZcbiAgICogICAgICAgIHRoZSBjaGlsZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD10aGlzLmNoaWxkcmVuXy5sZW5ndGhdXG4gICAqICAgICAgICBUaGUgaW5kZXggdG8gYXR0ZW1wdCB0byBhZGQgYSBjaGlsZCBpbnRvLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqICAgICAgICAgVGhlIGBDb21wb25lbnRgIHRoYXQgZ2V0cyBhZGRlZCBhcyBhIGNoaWxkLiBXaGVuIHVzaW5nIGEgc3RyaW5nIHRoZVxuICAgKiAgICAgICAgIGBDb21wb25lbnRgIHdpbGwgZ2V0IGNyZWF0ZWQgYnkgdGhpcyBwcm9jZXNzLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZChjaGlsZCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuY2hpbGRyZW5fLmxlbmd0aDtcblxuICAgIHZhciBjb21wb25lbnQgPSB2b2lkIDA7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSB2b2lkIDA7XG5cbiAgICAvLyBJZiBjaGlsZCBpcyBhIHN0cmluZywgY3JlYXRlIGNvbXBvbmVudCB3aXRoIG9wdGlvbnNcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgY29tcG9uZW50TmFtZSA9IHRvVGl0bGVDYXNlKGNoaWxkKTtcblxuICAgICAgdmFyIGNvbXBvbmVudENsYXNzTmFtZSA9IG9wdGlvbnMuY29tcG9uZW50Q2xhc3MgfHwgY29tcG9uZW50TmFtZTtcblxuICAgICAgLy8gU2V0IG5hbWUgdGhyb3VnaCBvcHRpb25zXG4gICAgICBvcHRpb25zLm5hbWUgPSBjb21wb25lbnROYW1lO1xuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0ICYgZWxlbWVudCBmb3IgdGhpcyBjb250cm9scyBzZXRcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gLnBsYXllcl8sIHRoaXMgaXMgYSBwbGF5ZXJcbiAgICAgIHZhciBDb21wb25lbnRDbGFzcyA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoY29tcG9uZW50Q2xhc3NOYW1lKTtcblxuICAgICAgaWYgKCFDb21wb25lbnRDbGFzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCAnICsgY29tcG9uZW50Q2xhc3NOYW1lICsgJyBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBkYXRhIHN0b3JlZCBkaXJlY3RseSBvbiB0aGUgdmlkZW9qcyBvYmplY3QgbWF5IGJlXG4gICAgICAvLyBtaXNpZGVudGlmaWVkIGFzIGEgY29tcG9uZW50IHRvIHJldGFpblxuICAgICAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2l0aCA0LnguIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGVcbiAgICAgIC8vIGNvbXBvbmVudCBjbGFzcyBjYW4gYmUgaW5zdGFudGlhdGVkLlxuICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudENsYXNzKHRoaXMucGxheWVyXyB8fCB0aGlzLCBvcHRpb25zKTtcblxuICAgICAgLy8gY2hpbGQgaXMgYSBjb21wb25lbnQgaW5zdGFuY2VcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50ID0gY2hpbGQ7XG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZHJlbl8uc3BsaWNlKGluZGV4LCAwLCBjb21wb25lbnQpO1xuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQuaWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY2hpbGRJbmRleF9bY29tcG9uZW50LmlkKCldID0gY29tcG9uZW50O1xuICAgIH1cblxuICAgIC8vIElmIGEgbmFtZSB3YXNuJ3QgdXNlZCB0byBjcmVhdGUgdGhlIGNvbXBvbmVudCwgY2hlY2sgaWYgd2UgY2FuIHVzZSB0aGVcbiAgICAvLyBuYW1lIGZ1bmN0aW9uIG9mIHRoZSBjb21wb25lbnRcbiAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBjb21wb25lbnQubmFtZSAmJiB0b1RpdGxlQ2FzZShjb21wb25lbnQubmFtZSgpKTtcblxuICAgIGlmIChjb21wb25lbnROYW1lKSB7XG4gICAgICB0aGlzLmNoaWxkTmFtZUluZGV4X1tjb21wb25lbnROYW1lXSA9IGNvbXBvbmVudDtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIFVJIG9iamVjdCdzIGVsZW1lbnQgdG8gdGhlIGNvbnRhaW5lciBkaXYgKGJveClcbiAgICAvLyBIYXZpbmcgYW4gZWxlbWVudCBpcyBub3QgcmVxdWlyZWRcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudC5lbCA9PT0gJ2Z1bmN0aW9uJyAmJiBjb21wb25lbnQuZWwoKSkge1xuICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLmNvbnRlbnRFbCgpLmNoaWxkcmVuO1xuICAgICAgdmFyIHJlZk5vZGUgPSBjaGlsZE5vZGVzW2luZGV4XSB8fCBudWxsO1xuXG4gICAgICB0aGlzLmNvbnRlbnRFbCgpLmluc2VydEJlZm9yZShjb21wb25lbnQuZWwoKSwgcmVmTm9kZSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHNvIGl0IGNhbiBzdG9yZWQgb24gcGFyZW50IG9iamVjdCBpZiBkZXNpcmVkLlxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNoaWxkIGBDb21wb25lbnRgIGZyb20gdGhpcyBgQ29tcG9uZW50YHMgbGlzdCBvZiBjaGlsZHJlbi4gQWxzbyByZW1vdmVzXG4gICAqIHRoZSBjaGlsZCBgQ29tcG9uZW50YHMgZWxlbWVudCBmcm9tIHRoaXMgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wb25lbnRcbiAgICogICAgICAgIFRoZSBjaGlsZCBgQ29tcG9uZW50YCB0byByZW1vdmUuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNvbXBvbmVudCkge1xuICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgY29tcG9uZW50ID0gdGhpcy5nZXRDaGlsZChjb21wb25lbnQpO1xuICAgIH1cblxuICAgIGlmICghY29tcG9uZW50IHx8ICF0aGlzLmNoaWxkcmVuXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjaGlsZEZvdW5kID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gdGhpcy5jaGlsZHJlbl8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuX1tpXSA9PT0gY29tcG9uZW50KSB7XG4gICAgICAgIGNoaWxkRm91bmQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuXy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2hpbGRGb3VuZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRJbmRleF9bY29tcG9uZW50LmlkKCldID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkTmFtZUluZGV4X1tjb21wb25lbnQubmFtZSgpXSA9IG51bGw7XG5cbiAgICB2YXIgY29tcEVsID0gY29tcG9uZW50LmVsKCk7XG5cbiAgICBpZiAoY29tcEVsICYmIGNvbXBFbC5wYXJlbnROb2RlID09PSB0aGlzLmNvbnRlbnRFbCgpKSB7XG4gICAgICB0aGlzLmNvbnRlbnRFbCgpLnJlbW92ZUNoaWxkKGNvbXBvbmVudC5lbCgpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbmQgaW5pdGlhbGl6ZSBkZWZhdWx0IGNoaWxkIGBDb21wb25lbnRgcyBiYXNlZCB1cG9uIG9wdGlvbnMuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5pbml0Q2hpbGRyZW4gPSBmdW5jdGlvbiBpbml0Q2hpbGRyZW4oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMub3B0aW9uc18uY2hpbGRyZW47XG5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIC8vIGB0aGlzYCBpcyBgcGFyZW50YFxuICAgICAgdmFyIHBhcmVudE9wdGlvbnMgPSB0aGlzLm9wdGlvbnNfO1xuXG4gICAgICB2YXIgaGFuZGxlQWRkID0gZnVuY3Rpb24gaGFuZGxlQWRkKGNoaWxkKSB7XG4gICAgICAgIHZhciBuYW1lID0gY2hpbGQubmFtZTtcbiAgICAgICAgdmFyIG9wdHMgPSBjaGlsZC5vcHRzO1xuXG4gICAgICAgIC8vIEFsbG93IG9wdGlvbnMgZm9yIGNoaWxkcmVuIHRvIGJlIHNldCBhdCB0aGUgcGFyZW50IG9wdGlvbnNcbiAgICAgICAgLy8gZS5nLiB2aWRlb2pzKGlkLCB7IGNvbnRyb2xCYXI6IGZhbHNlIH0pO1xuICAgICAgICAvLyBpbnN0ZWFkIG9mIHZpZGVvanMoaWQsIHsgY2hpbGRyZW46IHsgY29udHJvbEJhcjogZmFsc2UgfSk7XG4gICAgICAgIGlmIChwYXJlbnRPcHRpb25zW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRzID0gcGFyZW50T3B0aW9uc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IGZvciBkaXNhYmxpbmcgZGVmYXVsdCBjb21wb25lbnRzXG4gICAgICAgIC8vIGUuZy4gb3B0aW9uc1snY2hpbGRyZW4nXVsncG9zdGVySW1hZ2UnXSA9IGZhbHNlXG4gICAgICAgIGlmIChvcHRzID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IG9wdGlvbnMgdG8gYmUgcGFzc2VkIGFzIGEgc2ltcGxlIGJvb2xlYW4gaWYgbm8gY29uZmlndXJhdGlvblxuICAgICAgICAvLyBpcyBuZWNlc3NhcnkuXG4gICAgICAgIGlmIChvcHRzID09PSB0cnVlKSB7XG4gICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgYWxzbyB3YW50IHRvIHBhc3MgdGhlIG9yaWdpbmFsIHBsYXllciBvcHRpb25zXG4gICAgICAgIC8vIHRvIGVhY2ggY29tcG9uZW50IGFzIHdlbGwgc28gdGhleSBkb24ndCBuZWVkIHRvXG4gICAgICAgIC8vIHJlYWNoIGJhY2sgaW50byB0aGUgcGxheWVyIGZvciBvcHRpb25zIGxhdGVyLlxuICAgICAgICBvcHRzLnBsYXllck9wdGlvbnMgPSBfdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHRoZSBjaGlsZCBjb21wb25lbnQuXG4gICAgICAgIC8vIEFkZCBhIGRpcmVjdCByZWZlcmVuY2UgdG8gdGhlIGNoaWxkIGJ5IG5hbWUgb24gdGhlIHBhcmVudCBpbnN0YW5jZS5cbiAgICAgICAgLy8gSWYgdHdvIG9mIHRoZSBzYW1lIGNvbXBvbmVudCBhcmUgdXNlZCwgZGlmZmVyZW50IG5hbWVzIHNob3VsZCBiZSBzdXBwbGllZFxuICAgICAgICAvLyBmb3IgZWFjaFxuICAgICAgICB2YXIgbmV3Q2hpbGQgPSBfdGhpcy5hZGRDaGlsZChuYW1lLCBvcHRzKTtcblxuICAgICAgICBpZiAobmV3Q2hpbGQpIHtcbiAgICAgICAgICBfdGhpc1tuYW1lXSA9IG5ld0NoaWxkO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBBbGxvdyBmb3IgYW4gYXJyYXkgb2YgY2hpbGRyZW4gZGV0YWlscyB0byBwYXNzZWQgaW4gdGhlIG9wdGlvbnNcbiAgICAgIHZhciB3b3JraW5nQ2hpbGRyZW4gPSB2b2lkIDA7XG4gICAgICB2YXIgVGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoJ1RlY2gnKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIHdvcmtpbmdDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd29ya2luZ0NoaWxkcmVuID0gT2JqZWN0LmtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICB3b3JraW5nQ2hpbGRyZW5cbiAgICAgIC8vIGNoaWxkcmVuIHRoYXQgYXJlIGluIHRoaXMub3B0aW9uc18gYnV0IGFsc28gaW4gd29ya2luZ0NoaWxkcmVuICB3b3VsZFxuICAgICAgLy8gZ2l2ZSB1cyBleHRyYSBjaGlsZHJlbiB3ZSBkbyBub3Qgd2FudC4gU28sIHdlIHdhbnQgdG8gZmlsdGVyIHRoZW0gb3V0LlxuICAgICAgLmNvbmNhdChPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnNfKS5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiAhd29ya2luZ0NoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKHdjaGlsZCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2NoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkID09PSB3Y2hpbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gd2NoaWxkLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgfSkpLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBvcHRzID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbmFtZSA9IGNoaWxkO1xuICAgICAgICAgIG9wdHMgPSBjaGlsZHJlbltuYW1lXSB8fCBfdGhpcy5vcHRpb25zX1tuYW1lXSB8fCB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gY2hpbGQubmFtZTtcbiAgICAgICAgICBvcHRzID0gY2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBuYW1lOiBuYW1lLCBvcHRzOiBvcHRzIH07XG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgY2hpbGQubmFtZSBpc24ndCBpbiB0aGUgdGVjaE9yZGVyIHNpbmNlXG4gICAgICAgIC8vIHRlY2hzIGFyZSByZWdpc3RlcmQgYXMgQ29tcG9uZW50cyBidXQgY2FuJ3QgYXJlbid0IGNvbXBhdGlibGVcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8yNzcyXG4gICAgICAgIHZhciBjID0gQ29tcG9uZW50LmdldENvbXBvbmVudChjaGlsZC5vcHRzLmNvbXBvbmVudENsYXNzIHx8IHRvVGl0bGVDYXNlKGNoaWxkLm5hbWUpKTtcblxuICAgICAgICByZXR1cm4gYyAmJiAhVGVjaC5pc1RlY2goYyk7XG4gICAgICB9KS5mb3JFYWNoKGhhbmRsZUFkZCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGNsYXNzIG5hbWUuIFNob3VsZCBiZSBvdmVycmlkZW4gYnkgc3ViLWNvbXBvbmVudHMuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGNsYXNzIG5hbWUgZm9yIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIC8vIENoaWxkIGNsYXNzZXMgY2FuIGluY2x1ZGUgYSBmdW5jdGlvbiB0aGF0IGRvZXM6XG4gICAgLy8gcmV0dXJuICdDTEFTUyBOQU1FJyArIHRoaXMuX3N1cGVyKCk7XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCaW5kIGEgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJlYWR5IHN0YXRlLlxuICAgKiBEaWZmZXJlbnQgZnJvbSBldmVudCBsaXN0ZW5lcnMgaW4gdGhhdCBpZiB0aGUgcmVhZHkgZXZlbnQgaGFzIGFscmVhZHkgaGFwcGVuZWRcbiAgICogaXQgd2lsbCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBpbW1lZGlhdGVseS5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiAgICAgICAgIFJldHVybnMgaXRzZWxmOyBtZXRob2QgY2FuIGJlIGNoYWluZWQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uIHJlYWR5KGZuKSB7XG4gICAgdmFyIHN5bmMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgaWYgKGZuKSB7XG4gICAgICBpZiAodGhpcy5pc1JlYWR5Xykge1xuICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgIGZuLmNhbGwodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2FsbCB0aGUgZnVuY3Rpb24gYXN5bmNocm9ub3VzbHkgYnkgZGVmYXVsdCBmb3IgY29uc2lzdGVuY3lcbiAgICAgICAgICB0aGlzLnNldFRpbWVvdXQoZm4sIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlYWR5UXVldWVfID0gdGhpcy5yZWFkeVF1ZXVlXyB8fCBbXTtcbiAgICAgICAgdGhpcy5yZWFkeVF1ZXVlXy5wdXNoKGZuKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYWxsIHRoZSByZWFkeSBsaXN0ZW5lcnMgZm9yIHRoaXMgYENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaXJlcyBDb21wb25lbnQjcmVhZHlcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnRyaWdnZXJSZWFkeSA9IGZ1bmN0aW9uIHRyaWdnZXJSZWFkeSgpIHtcbiAgICB0aGlzLmlzUmVhZHlfID0gdHJ1ZTtcblxuICAgIC8vIEVuc3VyZSByZWFkeSBpcyB0cmlnZ2VyZCBhc3luY2hyb25vdXNseVxuICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVhZHlRdWV1ZSA9IHRoaXMucmVhZHlRdWV1ZV87XG5cbiAgICAgIC8vIFJlc2V0IFJlYWR5IFF1ZXVlXG4gICAgICB0aGlzLnJlYWR5UXVldWVfID0gW107XG5cbiAgICAgIGlmIChyZWFkeVF1ZXVlICYmIHJlYWR5UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICByZWFkeVF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgZm4uY2FsbCh0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbG93IGZvciB1c2luZyBldmVudCBsaXN0ZW5lcnMgYWxzb1xuICAgICAgLyoqXG4gICAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGBDb21wb25lbnRgIGlzIHJlYWR5LlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBDb21wb25lbnQjcmVhZHlcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdyZWFkeScpO1xuICAgIH0sIDEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIGEgc2luZ2xlIERPTSBlbGVtZW50IG1hdGNoaW5nIGEgYHNlbGVjdG9yYC4gVGhpcyBjYW4gYmUgd2l0aGluIHRoZSBgQ29tcG9uZW50YHNcbiAgICogYGNvbnRlbnRFbCgpYCBvciBhbm90aGVyIGN1c3RvbSBjb250ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAgICogICAgICAgIEEgdmFsaWQgQ1NTIHNlbGVjdG9yLCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBgcXVlcnlTZWxlY3RvcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IFtjb250ZXh0PXRoaXMuY29udGVudEVsKCldXG4gICAqICAgICAgICBBIERPTSBlbGVtZW50IHdpdGhpbiB3aGljaCB0byBxdWVyeS4gQ2FuIGFsc28gYmUgYSBzZWxlY3RvciBzdHJpbmcgaW5cbiAgICogICAgICAgIHdoaWNoIGNhc2UgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgd2lsbCBnZXQgdXNlZCBhcyBjb250ZXh0LiBJZlxuICAgKiAgICAgICAgbWlzc2luZyBgdGhpcy5jb250ZW50RWwoKWAgZ2V0cyB1c2VkLiBJZiAgYHRoaXMuY29udGVudEVsKClgIHJldHVybnNcbiAgICogICAgICAgIG5vdGhpbmcgaXQgZmFsbHMgYmFjayB0byBgZG9jdW1lbnRgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fG51bGx9XG4gICAqICAgICAgICAgdGhlIGRvbSBlbGVtZW50IHRoYXQgd2FzIGZvdW5kLCBvciBudWxsXG4gICAqXG4gICAqIEBzZWUgW0luZm9ybWF0aW9uIG9uIENTUyBTZWxlY3RvcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0NTUy9HZXR0aW5nX1N0YXJ0ZWQvU2VsZWN0b3JzKVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuJCA9IGZ1bmN0aW9uICQkJDEoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gJChzZWxlY3RvciwgY29udGV4dCB8fCB0aGlzLmNvbnRlbnRFbCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZHMgYWxsIERPTSBlbGVtZW50IG1hdGNoaW5nIGEgYHNlbGVjdG9yYC4gVGhpcyBjYW4gYmUgd2l0aGluIHRoZSBgQ29tcG9uZW50YHNcbiAgICogYGNvbnRlbnRFbCgpYCBvciBhbm90aGVyIGN1c3RvbSBjb250ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAgICogICAgICAgIEEgdmFsaWQgQ1NTIHNlbGVjdG9yLCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBgcXVlcnlTZWxlY3RvckFsbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IFtjb250ZXh0PXRoaXMuY29udGVudEVsKCldXG4gICAqICAgICAgICBBIERPTSBlbGVtZW50IHdpdGhpbiB3aGljaCB0byBxdWVyeS4gQ2FuIGFsc28gYmUgYSBzZWxlY3RvciBzdHJpbmcgaW5cbiAgICogICAgICAgIHdoaWNoIGNhc2UgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgd2lsbCBnZXQgdXNlZCBhcyBjb250ZXh0LiBJZlxuICAgKiAgICAgICAgbWlzc2luZyBgdGhpcy5jb250ZW50RWwoKWAgZ2V0cyB1c2VkLiBJZiAgYHRoaXMuY29udGVudEVsKClgIHJldHVybnNcbiAgICogICAgICAgIG5vdGhpbmcgaXQgZmFsbHMgYmFjayB0byBgZG9jdW1lbnRgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlTGlzdH1cbiAgICogICAgICAgICBhIGxpc3Qgb2YgZG9tIGVsZW1lbnRzIHRoYXQgd2VyZSBmb3VuZFxuICAgKlxuICAgKiBAc2VlIFtJbmZvcm1hdGlvbiBvbiBDU1MgU2VsZWN0b3JzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9DU1MvR2V0dGluZ19TdGFydGVkL1NlbGVjdG9ycylcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLiQkID0gZnVuY3Rpb24gJCQkJDEoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gJCQoc2VsZWN0b3IsIGNvbnRleHQgfHwgdGhpcy5jb250ZW50RWwoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgY29tcG9uZW50J3MgZWxlbWVudCBoYXMgYSBDU1MgY2xhc3MgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9DaGVja1xuICAgKiAgICAgICAgQ1NTIGNsYXNzIG5hbWUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBgQ29tcG9uZW50YCBoYXMgdGhlIGNsYXNzLlxuICAgKiAgICAgICAgIC0gRmFsc2UgaWYgdGhlIGBDb21wb25lbnRgIGRvZXMgbm90IGhhdmUgdGhlIGNsYXNzYFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaGFzQ2xhc3MgPSBmdW5jdGlvbiBoYXNDbGFzcyQkMShjbGFzc1RvQ2hlY2spIHtcbiAgICByZXR1cm4gaGFzQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9DaGVjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIENTUyBjbGFzcyBuYW1lIHRvIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9BZGRcbiAgICogICAgICAgIENTUyBjbGFzcyBuYW1lIHRvIGFkZFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiBhZGRDbGFzcyQkMShjbGFzc1RvQWRkKSB7XG4gICAgYWRkQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9BZGQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBDU1MgY2xhc3MgbmFtZSBmcm9tIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9SZW1vdmVcbiAgICogICAgICAgIENTUyBjbGFzcyBuYW1lIHRvIHJlbW92ZVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyQkMShjbGFzc1RvUmVtb3ZlKSB7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9SZW1vdmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgb3IgcmVtb3ZlIGEgQ1NTIGNsYXNzIG5hbWUgZnJvbSB0aGUgY29tcG9uZW50J3MgZWxlbWVudC5cbiAgICogLSBgY2xhc3NUb1RvZ2dsZWAgZ2V0cyBhZGRlZCB3aGVuIHtAbGluayBDb21wb25lbnQjaGFzQ2xhc3N9IHdvdWxkIHJldHVybiBmYWxzZS5cbiAgICogLSBgY2xhc3NUb1RvZ2dsZWAgZ2V0cyByZW1vdmVkIHdoZW4ge0BsaW5rIENvbXBvbmVudCNoYXNDbGFzc30gd291bGQgcmV0dXJuIHRydWUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY2xhc3NUb1RvZ2dsZVxuICAgKiAgICAgICAgIFRoZSBjbGFzcyB0byBhZGQgb3IgcmVtb3ZlIGJhc2VkIG9uIChAbGluayBDb21wb25lbnQjaGFzQ2xhc3N9XG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW58RG9tfnByZWRpY2F0ZX0gW3ByZWRpY2F0ZV1cbiAgICogICAgICAgICBBbiB7QGxpbmsgRG9tfnByZWRpY2F0ZX0gZnVuY3Rpb24gb3IgYSBib29sZWFuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS50b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzJCQxKGNsYXNzVG9Ub2dnbGUsIHByZWRpY2F0ZSkge1xuICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWxfLCBjbGFzc1RvVG9nZ2xlLCBwcmVkaWNhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudCBpZiBpdCBpcyBoaWRkZW4gYnkgcmVtb3ZpbmcgdGhlXG4gICAqICd2anMtaGlkZGVuJyBjbGFzcyBuYW1lIGZyb20gaXQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGlkZGVuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGBDb21wb25lbnRgcyBlbGVtZW50IGlmIGl0IGlzIGN1cnJlbnRseSBzaG93aW5nIGJ5IGFkZGluZyB0aGVcbiAgICogJ3Zqcy1oaWRkZW5gIGNsYXNzIG5hbWUgdG8gaXQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvY2sgYSBgQ29tcG9uZW50YHMgZWxlbWVudCBpbiBpdHMgdmlzaWJsZSBzdGF0ZSBieSBhZGRpbmcgdGhlICd2anMtbG9jay1zaG93aW5nJ1xuICAgKiBjbGFzcyBuYW1lIHRvIGl0LiBVc2VkIGR1cmluZyBmYWRlSW4vZmFkZU91dC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmxvY2tTaG93aW5nID0gZnVuY3Rpb24gbG9ja1Nob3dpbmcoKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWxvY2stc2hvd2luZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbmxvY2sgYSBgQ29tcG9uZW50YHMgZWxlbWVudCBmcm9tIGl0cyB2aXNpYmxlIHN0YXRlIGJ5IHJlbW92aW5nIHRoZSAndmpzLWxvY2stc2hvd2luZydcbiAgICogY2xhc3MgbmFtZSBmcm9tIGl0LiBVc2VkIGR1cmluZyBmYWRlSW4vZmFkZU91dC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnVubG9ja1Nob3dpbmcgPSBmdW5jdGlvbiB1bmxvY2tTaG93aW5nKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1sb2NrLXNob3dpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gdGhlIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gICAqICAgICAgICBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAgICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIHRoYXQgd2FzIGFza2VkIGZvci5cbiAgICogICAgICAgICAtIENhbiBiZSBhbiBlbXB0eSBzdHJpbmcgb24gc29tZSBicm93c2VycyBpZiB0aGUgYXR0cmlidXRlIGRvZXMgbm90IGV4aXN0XG4gICAqICAgICAgICAgICBvciBoYXMgbm8gdmFsdWVcbiAgICogICAgICAgICAtIE1vc3QgYnJvd3NlcnMgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgYXR0aWJ1dGUgZG9lcyBub3QgZXhpc3Qgb3IgaGFzXG4gICAqICAgICAgICAgICBubyB2YWx1ZS5cbiAgICpcbiAgICogQHNlZSBbRE9NIEFQSV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0QXR0cmlidXRlfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gZ2V0QXR0cmlidXRlJCQxKGF0dHJpYnV0ZSkge1xuICAgIHJldHVybiBnZXRBdHRyaWJ1dGUodGhpcy5lbF8sIGF0dHJpYnV0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIHRoZSBgQ29tcG9uZW50YCdzIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICAgKiAgICAgICAgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICBWYWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZSB0by5cbiAgICpcbiAgICogQHNlZSBbRE9NIEFQSV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvc2V0QXR0cmlidXRlfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlJCQxKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5lbF8sIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gICAqICAgICAgICBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gcmVtb3ZlLlxuICAgKlxuICAgKiBAc2VlIFtET00gQVBJXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9yZW1vdmVBdHRyaWJ1dGV9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUkJDEoYXR0cmlidXRlKSB7XG4gICAgcmVtb3ZlQXR0cmlidXRlKHRoaXMuZWxfLCBhdHRyaWJ1dGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSB3aWR0aCBvZiB0aGUgY29tcG9uZW50IGJhc2VkIHVwb24gdGhlIENTUyBzdHlsZXMuXG4gICAqIFNlZSB7QGxpbmsgQ29tcG9uZW50I2RpbWVuc2lvbn0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW251bV1cbiAgICogICAgICAgIFRoZSB3aWR0aCB0aGF0IHlvdSB3YW50IHRvIHNldCBwb3N0Zml4ZWQgd2l0aCAnJScsICdweCcgb3Igbm90aGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcExpc3RlbmVyc11cbiAgICogICAgICAgIFNraXAgdGhlIGNvbXBvbmVudHJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIHdpZHRoIHdoZW4gZ2V0dGluZywgemVybyBpZiB0aGVyZSBpcyBubyB3aWR0aC4gQ2FuIGJlIGEgc3RyaW5nXG4gICAqICAgICAgICAgICBwb3N0cGl4ZWQgd2l0aCAnJScgb3IgJ3B4Jy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gd2lkdGgobnVtLCBza2lwTGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCd3aWR0aCcsIG51bSwgc2tpcExpc3RlbmVycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50IGJhc2VkIHVwb24gdGhlIENTUyBzdHlsZXMuXG4gICAqIFNlZSB7QGxpbmsgQ29tcG9uZW50I2RpbWVuc2lvbn0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW251bV1cbiAgICogICAgICAgIFRoZSBoZWlnaHQgdGhhdCB5b3Ugd2FudCB0byBzZXQgcG9zdGZpeGVkIHdpdGggJyUnLCAncHgnIG9yIG5vdGhpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBMaXN0ZW5lcnNdXG4gICAqICAgICAgICBTa2lwIHRoZSBjb21wb25lbnRyZXNpemUgZXZlbnQgdHJpZ2dlclxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSB3aWR0aCB3aGVuIGdldHRpbmcsIHplcm8gaWYgdGhlcmUgaXMgbm8gd2lkdGguIENhbiBiZSBhIHN0cmluZ1xuICAgKiAgICAgICAgIHBvc3RwaXhlZCB3aXRoICclJyBvciAncHgnLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gaGVpZ2h0KG51bSwgc2tpcExpc3RlbmVycykge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignaGVpZ2h0JywgbnVtLCBza2lwTGlzdGVuZXJzKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGJvdGggdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgIGVsZW1lbnQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ30gd2lkdGhcbiAgICogICAgICAgICBXaWR0aCB0byBzZXQgdGhlIGBDb21wb25lbnRgcyBlbGVtZW50IHRvLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ8c3RyaW5nfSBoZWlnaHRcbiAgICogICAgICAgICBIZWlnaHQgdG8gc2V0IHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudCB0by5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmRpbWVuc2lvbnMgPSBmdW5jdGlvbiBkaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBTa2lwIGNvbXBvbmVudHJlc2l6ZSBsaXN0ZW5lcnMgb24gd2lkdGggZm9yIG9wdGltaXphdGlvblxuICAgIHRoaXMud2lkdGgod2lkdGgsIHRydWUpO1xuICAgIHRoaXMuaGVpZ2h0KGhlaWdodCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgd2lkdGggb3IgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YCBlbGVtZW50LiBUaGlzIGlzIHRoZSBzaGFyZWQgY29kZVxuICAgKiBmb3IgdGhlIHtAbGluayBDb21wb25lbnQjd2lkdGh9IGFuZCB7QGxpbmsgQ29tcG9uZW50I2hlaWdodH0uXG4gICAqXG4gICAqIFRoaW5ncyB0byBrbm93OlxuICAgKiAtIElmIHRoZSB3aWR0aCBvciBoZWlnaHQgaW4gYW4gbnVtYmVyIHRoaXMgd2lsbCByZXR1cm4gdGhlIG51bWJlciBwb3N0Zml4ZWQgd2l0aCAncHgnLlxuICAgKiAtIElmIHRoZSB3aWR0aC9oZWlnaHQgaXMgYSBwZXJjZW50IHRoaXMgd2lsbCByZXR1cm4gdGhlIHBlcmNlbnQgcG9zdGZpeGVkIHdpdGggJyUnXG4gICAqIC0gSGlkZGVuIGVsZW1lbnRzIGhhdmUgYSB3aWR0aCBvZiAwIHdpdGggYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC4gVGhpcyBmdW5jdGlvblxuICAgKiAgIGRlZmF1bHRzIHRvIHRoZSBgQ29tcG9uZW50YHMgYHN0eWxlLndpZHRoYCBhbmQgZmFsbHMgYmFjayB0byBgd2luZG93LmdldENvbXB1dGVkU3R5bGVgLlxuICAgKiAgIFNlZSBbdGhpc117QGxpbmsgaHR0cDovL3d3dy5mb2xpb3Rlay5jb20vZGV2YmxvZy9nZXR0aW5nLXRoZS13aWR0aC1vZi1hLWhpZGRlbi1lbGVtZW50LXdpdGgtanF1ZXJ5LXVzaW5nLXdpZHRoL31cbiAgICogICBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICAgKiAtIElmIHlvdSB3YW50IHRoZSBjb21wdXRlZCBzdHlsZSBvZiB0aGUgY29tcG9uZW50LCB1c2Uge0BsaW5rIENvbXBvbmVudCNjdXJyZW50V2lkdGh9XG4gICAqICAgYW5kIHtAbGluayB7Q29tcG9uZW50I2N1cnJlbnRIZWlnaHR9XG4gICAqXG4gICAqIEBmaXJlcyBDb21wb25lbnQjY29tcG9uZW50cmVzaXplXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aE9ySGVpZ2h0XG4gICA4ICAgICAgICAnd2lkdGgnIG9yICdoZWlnaHQnXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcnxzdHJpbmd9IFtudW1dXG4gICA4ICAgICAgICAgTmV3IGRpbWVuc2lvblxuICAgKlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbc2tpcExpc3RlbmVyc11cbiAgICogICAgICAgICBTa2lwIGNvbXBvbmVudHJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZGltZW5zaW9uIHdoZW4gZ2V0dGluZyBvciAwIGlmIHVuc2V0XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5kaW1lbnNpb24gPSBmdW5jdGlvbiBkaW1lbnNpb24od2lkdGhPckhlaWdodCwgbnVtLCBza2lwTGlzdGVuZXJzKSB7XG4gICAgaWYgKG51bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBTZXQgdG8gemVybyBpZiBudWxsIG9yIGxpdGVyYWxseSBOYU4gKE5hTiAhPT0gTmFOKVxuICAgICAgaWYgKG51bSA9PT0gbnVsbCB8fCBudW0gIT09IG51bSkge1xuICAgICAgICBudW0gPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB1c2luZyBjc3Mgd2lkdGgvaGVpZ2h0ICglIG9yIHB4KSBhbmQgYWRqdXN0XG4gICAgICBpZiAoKCcnICsgbnVtKS5pbmRleE9mKCclJykgIT09IC0xIHx8ICgnJyArIG51bSkuaW5kZXhPZigncHgnKSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF0gPSBudW07XG4gICAgICB9IGVsc2UgaWYgKG51bSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XSA9IG51bSArICdweCc7XG4gICAgICB9XG5cbiAgICAgIC8vIHNraXBMaXN0ZW5lcnMgYWxsb3dzIHVzIHRvIGF2b2lkIHRyaWdnZXJpbmcgdGhlIHJlc2l6ZSBldmVudCB3aGVuIHNldHRpbmcgYm90aCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICBpZiAoIXNraXBMaXN0ZW5lcnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlc2l6ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBDb21wb25lbnQjY29tcG9uZW50cmVzaXplXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlcignY29tcG9uZW50cmVzaXplJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOb3Qgc2V0dGluZyBhIHZhbHVlLCBzbyBnZXR0aW5nIGl0XG4gICAgLy8gTWFrZSBzdXJlIGVsZW1lbnQgZXhpc3RzXG4gICAgaWYgKCF0aGlzLmVsXykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gR2V0IGRpbWVuc2lvbiB2YWx1ZSBmcm9tIHN0eWxlXG4gICAgdmFyIHZhbCA9IHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdO1xuICAgIHZhciBweEluZGV4ID0gdmFsLmluZGV4T2YoJ3B4Jyk7XG5cbiAgICBpZiAocHhJbmRleCAhPT0gLTEpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgcGl4ZWwgdmFsdWUgd2l0aCBubyAncHgnXG4gICAgICByZXR1cm4gcGFyc2VJbnQodmFsLnNsaWNlKDAsIHB4SW5kZXgpLCAxMCk7XG4gICAgfVxuXG4gICAgLy8gTm8gcHggc28gdXNpbmcgJSBvciBubyBzdHlsZSB3YXMgc2V0LCBzbyBmYWxsaW5nIGJhY2sgdG8gb2Zmc2V0V2lkdGgvaGVpZ2h0XG4gICAgLy8gSWYgY29tcG9uZW50IGhhcyBkaXNwbGF5Om5vbmUsIG9mZnNldCB3aWxsIHJldHVybiAwXG4gICAgLy8gVE9ETzogaGFuZGxlIGRpc3BsYXk6bm9uZSBhbmQgbm8gZGltZW5zaW9uIHN0eWxlIHVzaW5nIHB4XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZWxfWydvZmZzZXQnICsgdG9UaXRsZUNhc2Uod2lkdGhPckhlaWdodCldLCAxMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2lkdGggb3IgdGhlIGhlaWdodCBvZiB0aGUgYENvbXBvbmVudGAgZWxlbWVudHMgY29tcHV0ZWQgc3R5bGUuIFVzZXNcbiAgICogYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHdpZHRoT3JIZWlnaHRcbiAgICogICAgICAgIEEgc3RyaW5nIGNvbnRhaW5pbmcgJ3dpZHRoJyBvciAnaGVpZ2h0Jy4gV2hpY2hldmVyIG9uZSB5b3Ugd2FudCB0byBnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZGltZW5zaW9uIHRoYXQgZ2V0cyBhc2tlZCBmb3Igb3IgMCBpZiBub3RoaW5nIHdhcyBzZXRcbiAgICogICAgICAgICBmb3IgdGhhdCBkaW1lbnNpb24uXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jdXJyZW50RGltZW5zaW9uID0gZnVuY3Rpb24gY3VycmVudERpbWVuc2lvbih3aWR0aE9ySGVpZ2h0KSB7XG4gICAgdmFyIGNvbXB1dGVkV2lkdGhPckhlaWdodCA9IDA7XG5cbiAgICBpZiAod2lkdGhPckhlaWdodCAhPT0gJ3dpZHRoJyAmJiB3aWR0aE9ySGVpZ2h0ICE9PSAnaGVpZ2h0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50RGltZW5zaW9uIG9ubHkgYWNjZXB0cyB3aWR0aCBvciBoZWlnaHQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxfKTtcblxuICAgICAgY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHdpZHRoT3JIZWlnaHQpIHx8IGNvbXB1dGVkU3R5bGVbd2lkdGhPckhlaWdodF07XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlICdweCcgZnJvbSB2YXJpYWJsZSBhbmQgcGFyc2UgYXMgaW50ZWdlclxuICAgIGNvbXB1dGVkV2lkdGhPckhlaWdodCA9IHBhcnNlRmxvYXQoY29tcHV0ZWRXaWR0aE9ySGVpZ2h0KTtcblxuICAgIC8vIGlmIHRoZSBjb21wdXRlZCB2YWx1ZSBpcyBzdGlsbCAwLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGJyb3dzZXIgaXMgbHlpbmdcbiAgICAvLyBhbmQgd2Ugd2FudCB0byBjaGVjayB0aGUgb2Zmc2V0IHZhbHVlcy5cbiAgICAvLyBUaGlzIGNvZGUgYWxzbyBydW5zIG9uIElFOCBhbmQgd2hlcmV2ZXIgZ2V0Q29tcHV0ZWRTdHlsZSBkb2Vzbid0IGV4aXN0LlxuICAgIGlmIChjb21wdXRlZFdpZHRoT3JIZWlnaHQgPT09IDApIHtcbiAgICAgIHZhciBydWxlID0gJ29mZnNldCcgKyB0b1RpdGxlQ2FzZSh3aWR0aE9ySGVpZ2h0KTtcblxuICAgICAgY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID0gdGhpcy5lbF9bcnVsZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXB1dGVkV2lkdGhPckhlaWdodDtcbiAgfTtcblxuICAvKipcbiAgICogQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgb2YgdGhlIGBDb21wb25lbnRgc1xuICAgKiBjb21wdXRlZCBzdHlsZS4gVXNlcyBgd2luZG93LmdldENvbXB1dGVkU3R5bGVgLlxuICAgKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBDb21wb25lbnR+RGltZW5zaW9uT2JqZWN0XG4gICAqXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aFxuICAgKiAgICAgICAgICAgVGhlIHdpZHRoIG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuXG4gICAqXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHRcbiAgICogICAgICAgICAgIFRoZSBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgcyBjb21wdXRlZCBzdHlsZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCBhbiBvYmplY3QgdGhhdCBjb250YWlucyB3aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcyBvZiB0aGUgYENvbXBvbmVudGBzXG4gICAqIGNvbXB1dGVkIHN0eWxlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR+RGltZW5zaW9uT2JqZWN0fVxuICAgKiAgICAgICAgIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBjb21wb25lbnRzIGVsZW1lbnRcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmN1cnJlbnREaW1lbnNpb25zID0gZnVuY3Rpb24gY3VycmVudERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ3dpZHRoJyksXG4gICAgICBoZWlnaHQ6IHRoaXMuY3VycmVudERpbWVuc2lvbignaGVpZ2h0JylcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuIFVzZXMgYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSB3aWR0aFxuICAgKiAgICAgICAgICAgVGhlIHdpZHRoIG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jdXJyZW50V2lkdGggPSBmdW5jdGlvbiBjdXJyZW50V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudERpbWVuc2lvbignd2lkdGgnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgcyBjb21wdXRlZCBzdHlsZS4gVXNlcyBgd2luZG93LmdldENvbXB1dGVkU3R5bGVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGhlaWdodFxuICAgKiAgICAgICAgICAgVGhlIGhlaWdodCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudEhlaWdodCA9IGZ1bmN0aW9uIGN1cnJlbnRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudERpbWVuc2lvbignaGVpZ2h0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZm9jdXMgdG8gdGhpcyBjb21wb25lbnRcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgdGhpcy5lbF8uZm9jdXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBmb2N1cyBmcm9tIHRoaXMgY29tcG9uZW50XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gYmx1cigpIHtcbiAgICB0aGlzLmVsXy5ibHVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtaXQgYSAndGFwJyBldmVudHMgd2hlbiB0b3VjaCBldmVudCBzdXBwb3J0IGdldHMgZGV0ZWN0ZWQuIFRoaXMgZ2V0cyB1c2VkIHRvXG4gICAqIHN1cHBvcnQgdG9nZ2xpbmcgdGhlIGNvbnRyb2xzIHRocm91Z2ggYSB0YXAgb24gdGhlIHZpZGVvLiBUaGV5IGdldCBlbmFibGVkXG4gICAqIGJlY2F1c2UgZXZlcnkgc3ViLWNvbXBvbmVudCB3b3VsZCBoYXZlIGV4dHJhIG92ZXJoZWFkIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzIENvbXBvbmVudCN0YXBcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoc3RhcnRcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNobW92ZVxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hsZWF2ZVxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hjYW5jZWxcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoZW5kXG4gICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZW1pdFRhcEV2ZW50cyA9IGZ1bmN0aW9uIGVtaXRUYXBFdmVudHMoKSB7XG4gICAgLy8gVHJhY2sgdGhlIHN0YXJ0IHRpbWUgc28gd2UgY2FuIGRldGVybWluZSBob3cgbG9uZyB0aGUgdG91Y2ggbGFzdGVkXG4gICAgdmFyIHRvdWNoU3RhcnQgPSAwO1xuICAgIHZhciBmaXJzdFRvdWNoID0gbnVsbDtcblxuICAgIC8vIE1heGltdW0gbW92ZW1lbnQgYWxsb3dlZCBkdXJpbmcgYSB0b3VjaCBldmVudCB0byBzdGlsbCBiZSBjb25zaWRlcmVkIGEgdGFwXG4gICAgLy8gT3RoZXIgcG9wdWxhciBsaWJzIHVzZSBhbnl3aGVyZSBmcm9tIDIgKGhhbW1lci5qcykgdG8gMTUsXG4gICAgLy8gc28gMTAgc2VlbXMgbGlrZSBhIG5pY2UsIHJvdW5kIG51bWJlci5cbiAgICB2YXIgdGFwTW92ZW1lbnRUaHJlc2hvbGQgPSAxMDtcblxuICAgIC8vIFRoZSBtYXhpbXVtIGxlbmd0aCBhIHRvdWNoIGNhbiBiZSB3aGlsZSBzdGlsbCBiZWluZyBjb25zaWRlcmVkIGEgdGFwXG4gICAgdmFyIHRvdWNoVGltZVRocmVzaG9sZCA9IDIwMDtcblxuICAgIHZhciBjb3VsZEJlVGFwID0gdm9pZCAwO1xuXG4gICAgdGhpcy5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIsIGRvbid0IGNvbnNpZGVyIHRyZWF0aW5nIHRoaXMgYXMgYSBjbGlja1xuICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIENvcHkgcGFnZVgvcGFnZVkgZnJvbSB0aGUgb2JqZWN0XG4gICAgICAgIGZpcnN0VG91Y2ggPSB7XG4gICAgICAgICAgcGFnZVg6IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgICAgcGFnZVk6IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVlcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVjb3JkIHN0YXJ0IHRpbWUgc28gd2UgY2FuIGRldGVjdCBhIHRhcCB2cy4gXCJ0b3VjaCBhbmQgaG9sZFwiXG4gICAgICAgIHRvdWNoU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgLy8gUmVzZXQgY291bGRCZVRhcCB0cmFja2luZ1xuICAgICAgICBjb3VsZEJlVGFwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMub24oJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIsIGRvbid0IGNvbnNpZGVyIHRyZWF0aW5nIHRoaXMgYXMgYSBjbGlja1xuICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0VG91Y2gpIHtcbiAgICAgICAgLy8gU29tZSBkZXZpY2VzIHdpbGwgdGhyb3cgdG91Y2htb3ZlcyBmb3IgYWxsIGJ1dCB0aGUgc2xpZ2h0ZXN0IG9mIHRhcHMuXG4gICAgICAgIC8vIFNvLCBpZiB3ZSBtb3ZlZCBvbmx5IGEgc21hbGwgZGlzdGFuY2UsIHRoaXMgY291bGQgc3RpbGwgYmUgYSB0YXBcbiAgICAgICAgdmFyIHhkaWZmID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIGZpcnN0VG91Y2gucGFnZVg7XG4gICAgICAgIHZhciB5ZGlmZiA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBmaXJzdFRvdWNoLnBhZ2VZO1xuICAgICAgICB2YXIgdG91Y2hEaXN0YW5jZSA9IE1hdGguc3FydCh4ZGlmZiAqIHhkaWZmICsgeWRpZmYgKiB5ZGlmZik7XG5cbiAgICAgICAgaWYgKHRvdWNoRGlzdGFuY2UgPiB0YXBNb3ZlbWVudFRocmVzaG9sZCkge1xuICAgICAgICAgIGNvdWxkQmVUYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIG5vVGFwID0gZnVuY3Rpb24gbm9UYXAoKSB7XG4gICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IExpc3RlbiB0byB0aGUgb3JpZ2luYWwgdGFyZ2V0LiBodHRwOi8veW91dHUuYmUvRHVqZnBYT0tVcDg/dD0xM204c1xuICAgIHRoaXMub24oJ3RvdWNobGVhdmUnLCBub1RhcCk7XG4gICAgdGhpcy5vbigndG91Y2hjYW5jZWwnLCBub1RhcCk7XG5cbiAgICAvLyBXaGVuIHRoZSB0b3VjaCBlbmRzLCBtZWFzdXJlIGhvdyBsb25nIGl0IHRvb2sgYW5kIHRyaWdnZXIgdGhlIGFwcHJvcHJpYXRlXG4gICAgLy8gZXZlbnRcbiAgICB0aGlzLm9uKCd0b3VjaGVuZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZmlyc3RUb3VjaCA9IG51bGw7XG4gICAgICAvLyBQcm9jZWVkIG9ubHkgaWYgdGhlIHRvdWNobW92ZS9sZWF2ZS9jYW5jZWwgZXZlbnQgZGlkbid0IGhhcHBlblxuICAgICAgaWYgKGNvdWxkQmVUYXAgPT09IHRydWUpIHtcbiAgICAgICAgLy8gTWVhc3VyZSBob3cgbG9uZyB0aGUgdG91Y2ggbGFzdGVkXG4gICAgICAgIHZhciB0b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRvdWNoU3RhcnQ7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB0b3VjaCB3YXMgbGVzcyB0aGFuIHRoZSB0aHJlc2hvbGQgdG8gYmUgY29uc2lkZXJlZCBhIHRhcFxuICAgICAgICBpZiAodG91Y2hUaW1lIDwgdG91Y2hUaW1lVGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgbGV0IGJyb3dzZXIgdHVybiB0aGlzIGludG8gYSBjbGlja1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVHJpZ2dlcmVkIHdoZW4gYSBgQ29tcG9uZW50YCBpcyB0YXBwZWQuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAZXZlbnQgQ29tcG9uZW50I3RhcFxuICAgICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RhcCcpO1xuICAgICAgICAgIC8vIEl0IG1heSBiZSBnb29kIHRvIGNvcHkgdGhlIHRvdWNoZW5kIGV2ZW50IG9iamVjdCBhbmQgY2hhbmdlIHRoZVxuICAgICAgICAgIC8vIHR5cGUgdG8gdGFwLCBpZiB0aGUgb3RoZXIgZXZlbnQgcHJvcGVydGllcyBhcmVuJ3QgZXhhY3QgYWZ0ZXJcbiAgICAgICAgICAvLyBFdmVudHMuZml4RXZlbnQgcnVucyAoZS5nLiBldmVudC50YXJnZXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiByZXBvcnRzIHVzZXIgYWN0aXZpdHkgd2hlbmV2ZXIgdG91Y2ggZXZlbnRzIGhhcHBlbi4gVGhpcyBjYW4gZ2V0XG4gICAqIHR1cm5lZCBvZmYgYnkgYW55IHN1Yi1jb21wb25lbnRzIHRoYXQgd2FudHMgdG91Y2ggZXZlbnRzIHRvIGFjdCBhbm90aGVyIHdheS5cbiAgICpcbiAgICogUmVwb3J0IHVzZXIgdG91Y2ggYWN0aXZpdHkgd2hlbiB0b3VjaCBldmVudHMgb2NjdXIuIFVzZXIgYWN0aXZpdHkgZ2V0cyB1c2VkIHRvXG4gICAqIGRldGVybWluZSB3aGVuIGNvbnRyb2xzIHNob3VsZCBzaG93L2hpZGUuIEl0IGlzIHNpbXBsZSB3aGVuIGl0IGNvbWVzIHRvIG1vdXNlXG4gICAqIGV2ZW50cywgYmVjYXVzZSBhbnkgbW91c2UgZXZlbnQgc2hvdWxkIHNob3cgdGhlIGNvbnRyb2xzLiBTbyB3ZSBjYXB0dXJlIG1vdXNlXG4gICAqIGV2ZW50cyB0aGF0IGJ1YmJsZSB1cCB0byB0aGUgcGxheWVyIGFuZCByZXBvcnQgYWN0aXZpdHkgd2hlbiB0aGF0IGhhcHBlbnMuXG4gICAqIFdpdGggdG91Y2ggZXZlbnRzIGl0IGlzbid0IGFzIGVhc3kgYXMgYHRvdWNoc3RhcnRgIGFuZCBgdG91Y2hlbmRgIHRvZ2dsZSBwbGF5ZXJcbiAgICogY29udHJvbHMuIFNvIHRvdWNoIGV2ZW50cyBjYW4ndCBoZWxwIHVzIGF0IHRoZSBwbGF5ZXIgbGV2ZWwgZWl0aGVyLlxuICAgKlxuICAgKiBVc2VyIGFjdGl2aXR5IGdldHMgY2hlY2tlZCBhc3luY2hyb25vdXNseS4gU28gd2hhdCBjb3VsZCBoYXBwZW4gaXMgYSB0YXAgZXZlbnRcbiAgICogb24gdGhlIHZpZGVvIHR1cm5zIHRoZSBjb250cm9scyBvZmYuIFRoZW4gdGhlIGB0b3VjaGVuZGAgZXZlbnQgYnViYmxlcyB1cCB0b1xuICAgKiB0aGUgcGxheWVyLiBXaGljaCwgaWYgaXQgcmVwb3J0ZWQgdXNlciBhY3Rpdml0eSwgd291bGQgdHVybiB0aGUgY29udHJvbHMgcmlnaHRcbiAgICogYmFjayBvbi4gV2UgYWxzbyBkb24ndCB3YW50IHRvIGNvbXBsZXRlbHkgYmxvY2sgdG91Y2ggZXZlbnRzIGZyb20gYnViYmxpbmcgdXAuXG4gICAqIEZ1cnRoZXJtb3JlIGEgYHRvdWNobW92ZWAgZXZlbnQgYW5kIGFueXRoaW5nIG90aGVyIHRoYW4gYSB0YXAsIHNob3VsZCBub3QgdHVyblxuICAgKiBjb250cm9scyBiYWNrIG9uLlxuICAgKlxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hzdGFydFxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2htb3ZlXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaGVuZFxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hjYW5jZWxcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmVuYWJsZVRvdWNoQWN0aXZpdHkgPSBmdW5jdGlvbiBlbmFibGVUb3VjaEFjdGl2aXR5KCkge1xuICAgIC8vIERvbid0IGNvbnRpbnVlIGlmIHRoZSByb290IHBsYXllciBkb2Vzbid0IHN1cHBvcnQgcmVwb3J0aW5nIHVzZXIgYWN0aXZpdHlcbiAgICBpZiAoIXRoaXMucGxheWVyKCkgfHwgIXRoaXMucGxheWVyKCkucmVwb3J0VXNlckFjdGl2aXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbGlzdGVuZXIgZm9yIHJlcG9ydGluZyB0aGF0IHRoZSB1c2VyIGlzIGFjdGl2ZVxuICAgIHZhciByZXBvcnQgPSBiaW5kKHRoaXMucGxheWVyKCksIHRoaXMucGxheWVyKCkucmVwb3J0VXNlckFjdGl2aXR5KTtcblxuICAgIHZhciB0b3VjaEhvbGRpbmcgPSB2b2lkIDA7XG5cbiAgICB0aGlzLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgcmVwb3J0KCk7XG4gICAgICAvLyBGb3IgYXMgbG9uZyBhcyB0aGUgdGhleSBhcmUgdG91Y2hpbmcgdGhlIGRldmljZSBvciBoYXZlIHRoZWlyIG1vdXNlIGRvd24sXG4gICAgICAvLyB3ZSBjb25zaWRlciB0aGVtIGFjdGl2ZSBldmVuIGlmIHRoZXkncmUgbm90IG1vdmluZyB0aGVpciBmaW5nZXIgb3IgbW91c2UuXG4gICAgICAvLyBTbyB3ZSB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSB0aGF0IHRoZXkgYXJlIGFjdGl2ZVxuICAgICAgdGhpcy5jbGVhckludGVydmFsKHRvdWNoSG9sZGluZyk7XG4gICAgICAvLyByZXBvcnQgYXQgdGhlIHNhbWUgaW50ZXJ2YWwgYXMgYWN0aXZpdHlDaGVja1xuICAgICAgdG91Y2hIb2xkaW5nID0gdGhpcy5zZXRJbnRlcnZhbChyZXBvcnQsIDI1MCk7XG4gICAgfSk7XG5cbiAgICB2YXIgdG91Y2hFbmQgPSBmdW5jdGlvbiB0b3VjaEVuZChldmVudCkge1xuICAgICAgcmVwb3J0KCk7XG4gICAgICAvLyBzdG9wIHRoZSBpbnRlcnZhbCB0aGF0IG1haW50YWlucyBhY3Rpdml0eSBpZiB0aGUgdG91Y2ggaXMgaG9sZGluZ1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKHRvdWNoSG9sZGluZyk7XG4gICAgfTtcblxuICAgIHRoaXMub24oJ3RvdWNobW92ZScsIHJlcG9ydCk7XG4gICAgdGhpcy5vbigndG91Y2hlbmQnLCB0b3VjaEVuZCk7XG4gICAgdGhpcy5vbigndG91Y2hjYW5jZWwnLCB0b3VjaEVuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgY2FsbGJhY2sgdGhhdCBoYXMgbm8gcGFyYW1ldGVycyBhbmQgaXMgYm91bmQgaW50byBgQ29tcG9uZW50YHMgY29udGV4dC5cbiAgICpcbiAgICogQGNhbGxiYWNrIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2tcbiAgICogQHRoaXMgQ29tcG9uZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBydW5zIGFmdGVyIGFuIGB4YCBtaWxsaXNlY29uZCB0aW1lb3V0LiBUaGlzIGZ1bmN0aW9uIGlzIGFcbiAgICogd3JhcHBlciBhcm91bmQgYHdpbmRvdy5zZXRUaW1lb3V0YC4gVGhlcmUgYXJlIGEgZmV3IHJlYXNvbnMgdG8gdXNlIHRoaXMgb25lXG4gICAqIGluc3RlYWQgdGhvdWdoOlxuICAgKiAxLiBJdCBnZXRzIGNsZWFyZWQgdmlhICB7QGxpbmsgQ29tcG9uZW50I2NsZWFyVGltZW91dH0gd2hlblxuICAgKiAgICB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IGdldHMgY2FsbGVkLlxuICAgKiAyLiBUaGUgZnVuY3Rpb24gY2FsbGJhY2sgd2lsbCBnZXRzIHR1cm5lZCBpbnRvIGEge0BsaW5rIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9XG4gICAqXG4gICAqID4gTm90ZTogWW91IGNhbiB1c2UgYHdpbmRvdy5jbGVhclRpbWVvdXRgIG9uIHRoZSBpZCByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uLiBUaGlzXG4gICAqICAgICAgICAgd2lsbCBjYXVzZSBpdHMgZGlzcG9zZSBsaXN0ZW5lciBub3QgdG8gZ2V0IGNsZWFuZWQgdXAhIFBsZWFzZSB1c2VcbiAgICogICAgICAgICB7QGxpbmsgQ29tcG9uZW50I2NsZWFyVGltZW91dH0gb3Ige0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfS5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfSBmblxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBydW4gYWZ0ZXIgYHRpbWVvdXRgLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICAgKiAgICAgICAgVGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgYmVmb3JlIGV4ZWN1dGluZyB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgUmV0dXJucyBhIHRpbWVvdXQgSUQgdGhhdCBnZXRzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHRpbWVvdXQuIEl0IGNhbiBhbHNvXG4gICAqICAgICAgICAgZ2V0IHVzZWQgaW4ge0BsaW5rIENvbXBvbmVudCNjbGVhclRpbWVvdXR9IHRvIGNsZWFyIHRoZSB0aW1lb3V0IHRoYXRcbiAgICogICAgICAgICB3YXMgc2V0LlxuICAgKlxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjZGlzcG9zZVxuICAgKiBAc2VlIFtTaW1pbGFyIHRvXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93VGltZXJzL3NldFRpbWVvdXR9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gc2V0VGltZW91dChmbiwgdGltZW91dCkge1xuICAgIGZuID0gYmluZCh0aGlzLCBmbik7XG5cbiAgICB2YXIgdGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVvdXQpO1xuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7XG4gICAgICB0aGlzLmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH07XG5cbiAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtdGltZW91dC0nICsgdGltZW91dElkO1xuXG4gICAgdGhpcy5vbignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICByZXR1cm4gdGltZW91dElkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgYSB0aW1lb3V0IHRoYXQgZ2V0cyBjcmVhdGVkIHZpYSBgd2luZG93LnNldFRpbWVvdXRgIG9yXG4gICAqIHtAbGluayBDb21wb25lbnQjc2V0VGltZW91dH0uIElmIHlvdSBzZXQgYSB0aW1lb3V0IHZpYSB7QGxpbmsgQ29tcG9uZW50I3NldFRpbWVvdXR9XG4gICAqIHVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgYHdpbmRvdy5jbGVhclRpbW91dGAuIElmIHlvdSBkb24ndCB5b3VyIGRpc3Bvc2VcbiAgICogbGlzdGVuZXIgd2lsbCBub3QgZ2V0IGNsZWFuZWQgdXAgdW50aWwge0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfSFcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRJZFxuICAgKiAgICAgICAgVGhlIGlkIG9mIHRoZSB0aW1lb3V0IHRvIGNsZWFyLiBUaGUgcmV0dXJuIHZhbHVlIG9mXG4gICAqICAgICAgICB7QGxpbmsgQ29tcG9uZW50I3NldFRpbWVvdXR9IG9yIGB3aW5kb3cuc2V0VGltZW91dGAuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIHRoZSB0aW1lb3V0IGlkIHRoYXQgd2FzIGNsZWFyZWQuXG4gICAqXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dUaW1lcnMvY2xlYXJUaW1lb3V0fVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCkge1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcblxuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7fTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy10aW1lb3V0LScgKyB0aW1lb3V0SWQ7XG5cbiAgICB0aGlzLm9mZignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICByZXR1cm4gdGltZW91dElkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIHJ1biBldmVyeSBgeGAgbWlsbGlzZWNvbmRzLiBUaGlzIGZ1bmN0aW9uIGlzIGEgd3JhcHBlclxuICAgKiBhcm91bmQgYHdpbmRvdy5zZXRJbnRlcnZhbGAuIFRoZXJlIGFyZSBhIGZldyByZWFzb25zIHRvIHVzZSB0aGlzIG9uZSBpbnN0ZWFkIHRob3VnaC5cbiAgICogMS4gSXQgZ2V0cyBjbGVhcmVkIHZpYSAge0BsaW5rIENvbXBvbmVudCNjbGVhckludGVydmFsfSB3aGVuXG4gICAqICAgIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0gZ2V0cyBjYWxsZWQuXG4gICAqIDIuIFRoZSBmdW5jdGlvbiBjYWxsYmFjayB3aWxsIGJlIGEge0BsaW5rIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9XG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fkdlbmVyaWNDYWxsYmFja30gZm5cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBydW4gZXZlcnkgYHhgIHNlY29uZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbFxuICAgKiAgICAgICAgRXhlY3V0ZSB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGV2ZXJ5IGB4YCBtaWxsaXNlY29uZHMuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIGFuIGlkIHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGludGVydmFsLiBJdCBjYW4gYWxzbyBiZSBiZSB1c2VkIGluXG4gICAqICAgICAgICAge0BsaW5rIENvbXBvbmVudCNjbGVhckludGVydmFsfSB0byBjbGVhciB0aGUgaW50ZXJ2YWwuXG4gICAqXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCNkaXNwb3NlXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dUaW1lcnMvc2V0SW50ZXJ2YWx9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIHNldEludGVydmFsKGZuLCBpbnRlcnZhbCkge1xuICAgIGZuID0gYmluZCh0aGlzLCBmbik7XG5cbiAgICB2YXIgaW50ZXJ2YWxJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbChmbiwgaW50ZXJ2YWwpO1xuXG4gICAgdmFyIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uIGRpc3Bvc2VGbigpIHtcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICB9O1xuXG4gICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLWludGVydmFsLScgKyBpbnRlcnZhbElkO1xuXG4gICAgdGhpcy5vbignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICByZXR1cm4gaW50ZXJ2YWxJZDtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXJzIGFuIGludGVydmFsIHRoYXQgZ2V0cyBjcmVhdGVkIHZpYSBgd2luZG93LnNldEludGVydmFsYCBvclxuICAgKiB7QGxpbmsgQ29tcG9uZW50I3NldEludGVydmFsfS4gSWYgeW91IHNldCBhbiBpbnRldmFsIHZpYSB7QGxpbmsgQ29tcG9uZW50I3NldEludGVydmFsfVxuICAgKiB1c2UgdGhpcyBmdW5jdGlvbiBpbnN0ZWFkIG9mIGB3aW5kb3cuY2xlYXJJbnRlcnZhbGAuIElmIHlvdSBkb24ndCB5b3VyIGRpc3Bvc2VcbiAgICogbGlzdGVuZXIgd2lsbCBub3QgZ2V0IGNsZWFuZWQgdXAgdW50aWwge0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfSFcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsSWRcbiAgICogICAgICAgIFRoZSBpZCBvZiB0aGUgaW50ZXJ2YWwgdG8gY2xlYXIuIFRoZSByZXR1cm4gdmFsdWUgb2ZcbiAgICogICAgICAgIHtAbGluayBDb21wb25lbnQjc2V0SW50ZXJ2YWx9IG9yIGB3aW5kb3cuc2V0SW50ZXJ2YWxgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgUmV0dXJucyB0aGUgaW50ZXJ2YWwgaWQgdGhhdCB3YXMgY2xlYXJlZC5cbiAgICpcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd1RpbWVycy9jbGVhckludGVydmFsfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCkge1xuICAgIHdpbmRvdy5jbGVhckludGVydmFsKGludGVydmFsSWQpO1xuXG4gICAgdmFyIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uIGRpc3Bvc2VGbigpIHt9O1xuXG4gICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLWludGVydmFsLScgKyBpbnRlcnZhbElkO1xuXG4gICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgcmV0dXJuIGludGVydmFsSWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFF1ZXVlcyB1cCBhIGNhbGxiYWNrIHRvIGJlIHBhc3NlZCB0byByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKHJBRiksIGJ1dFxuICAgKiB3aXRoIGEgZmV3IGV4dHJhIGJvbnVzZXM6XG4gICAqXG4gICAqIC0gU3VwcG9ydHMgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCByQUYgYnkgZmFsbGluZyBiYWNrIHRvXG4gICAqICAge0BsaW5rIENvbXBvbmVudCNzZXRUaW1lb3V0fS5cbiAgICpcbiAgICogLSBUaGUgY2FsbGJhY2sgaXMgdHVybmVkIGludG8gYSB7QGxpbmsgQ29tcG9uZW50fkdlbmVyaWNDYWxsYmFja30gKGkuZS5cbiAgICogICBib3VuZCB0byB0aGUgY29tcG9uZW50KS5cbiAgICpcbiAgICogLSBBdXRvbWF0aWMgY2FuY2VsbGF0aW9uIG9mIHRoZSByQUYgY2FsbGJhY2sgaXMgaGFuZGxlZCBpZiB0aGUgY29tcG9uZW50XG4gICAqICAgaXMgZGlzcG9zZWQgYmVmb3JlIGl0IGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtICB7Q29tcG9uZW50fkdlbmVyaWNDYWxsYmFja30gZm5cbiAgICogICAgICAgICBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBib3VuZCB0byB0aGlzIGNvbXBvbmVudCBhbmQgZXhlY3V0ZWQganVzdFxuICAgKiAgICAgICAgIGJlZm9yZSB0aGUgYnJvd3NlcidzIG5leHQgcmVwYWludC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgYW4gckFGIElEIHRoYXQgZ2V0cyB1c2VkIHRvIGlkZW50aWZ5IHRoZSB0aW1lb3V0LiBJdCBjYW5cbiAgICogICAgICAgICBhbHNvIGJlIHVzZWQgaW4ge0BsaW5rIENvbXBvbmVudCNjYW5jZWxBbmltYXRpb25GcmFtZX0gdG8gY2FuY2VsXG4gICAqICAgICAgICAgdGhlIGFuaW1hdGlvbiBmcmFtZSBjYWxsYmFjay5cbiAgICpcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWV9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICh0aGlzLnN1cHBvcnRzUmFmXykge1xuICAgICAgZm4gPSBiaW5kKHRoaXMsIGZuKTtcblxuICAgICAgdmFyIGlkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICAgIH07XG5cbiAgICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy1yYWYtJyArIGlkO1xuICAgICAgdGhpcy5vbignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICAvLyBGYWxsIGJhY2sgdG8gdXNpbmcgYSB0aW1lci5cbiAgICByZXR1cm4gdGhpcy5zZXRUaW1lb3V0KGZuLCAxMDAwIC8gNjApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcXVldWVkIGNhbGxiYWNrIHBhc3NlZCB0byB7QGxpbmsgQ29tcG9uZW50I3JlcXVlc3RBbmltYXRpb25GcmFtZX1cbiAgICogKHJBRikuXG4gICAqXG4gICAqIElmIHlvdSBxdWV1ZSBhbiByQUYgY2FsbGJhY2sgdmlhIHtAbGluayBDb21wb25lbnQjcmVxdWVzdEFuaW1hdGlvbkZyYW1lfSxcbiAgICogdXNlIHRoaXMgZnVuY3Rpb24gaW5zdGVhZCBvZiBgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lYC4gSWYgeW91IGRvbid0LFxuICAgKiB5b3VyIGRpc3Bvc2UgbGlzdGVuZXIgd2lsbCBub3QgZ2V0IGNsZWFuZWQgdXAgdW50aWwge0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfSFcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGlkXG4gICAqICAgICAgICBUaGUgckFGIElEIHRvIGNsZWFyLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHtAbGluayBDb21wb25lbnQjcmVxdWVzdEFuaW1hdGlvbkZyYW1lfS5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgdGhlIHJBRiBJRCB0aGF0IHdhcyBjbGVhcmVkLlxuICAgKlxuICAgKiBAc2VlIFtTaW1pbGFyIHRvXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiBjYW5jZWxBbmltYXRpb25GcmFtZShpZCkge1xuICAgIGlmICh0aGlzLnN1cHBvcnRzUmFmXykge1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcblxuICAgICAgdmFyIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uIGRpc3Bvc2VGbigpIHt9O1xuXG4gICAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtcmFmLScgKyBpZDtcblxuICAgICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgLy8gRmFsbCBiYWNrIHRvIHVzaW5nIGEgdGltZXIuXG4gICAgcmV0dXJuIHRoaXMuY2xlYXJUaW1lb3V0KGlkKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBgQ29tcG9uZW50YCB3aXRoIGB2aWRlb2pzYCBnaXZlbiB0aGUgbmFtZSBhbmQgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogPiBOT1RFOiB7QGxpbmsgVGVjaH1zIHNob3VsZCBub3QgYmUgcmVnaXN0ZXJlZCBhcyBhIGBDb21wb25lbnRgLiB7QGxpbmsgVGVjaH1zXG4gICAqICAgICAgICAgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgdXNpbmcge0BsaW5rIFRlY2gucmVnaXN0ZXJUZWNofSBvclxuICAgKiAgICAgICAgIHtAbGluayB2aWRlb2pzOnZpZGVvanMucmVnaXN0ZXJUZWNofS5cbiAgICpcbiAgICogPiBOT1RFOiBUaGlzIGZ1bmN0aW9uIGNhbiBhbHNvIGJlIHNlZW4gb24gdmlkZW9qcyBhc1xuICAgKiAgICAgICAgIHtAbGluayB2aWRlb2pzOnZpZGVvanMucmVnaXN0ZXJDb21wb25lbnR9LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGBDb21wb25lbnRgIHRvIHJlZ2lzdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gQ29tcG9uZW50VG9SZWdpc3RlclxuICAgKiAgICAgICAgVGhlIGBDb21wb25lbnRgIGNsYXNzIHRvIHJlZ2lzdGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqICAgICAgICAgVGhlIGBDb21wb25lbnRgIHRoYXQgd2FzIHJlZ2lzdGVyZWQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnQobmFtZSwgQ29tcG9uZW50VG9SZWdpc3Rlcikge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBjb21wb25lbnQgbmFtZSwgXCInICsgbmFtZSArICdcIjsgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuJyk7XG4gICAgfVxuXG4gICAgdmFyIFRlY2ggPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdUZWNoJyk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGlzIGNoZWNrIGlzIG9ubHkgZG9uZSBpZiBUZWNoIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXG4gICAgdmFyIGlzVGVjaCA9IFRlY2ggJiYgVGVjaC5pc1RlY2goQ29tcG9uZW50VG9SZWdpc3Rlcik7XG4gICAgdmFyIGlzQ29tcCA9IENvbXBvbmVudCA9PT0gQ29tcG9uZW50VG9SZWdpc3RlciB8fCBDb21wb25lbnQucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoQ29tcG9uZW50VG9SZWdpc3Rlci5wcm90b3R5cGUpO1xuXG4gICAgaWYgKGlzVGVjaCB8fCAhaXNDb21wKSB7XG4gICAgICB2YXIgcmVhc29uID0gdm9pZCAwO1xuXG4gICAgICBpZiAoaXNUZWNoKSB7XG4gICAgICAgIHJlYXNvbiA9ICd0ZWNocyBtdXN0IGJlIHJlZ2lzdGVyZWQgdXNpbmcgVGVjaC5yZWdpc3RlclRlY2goKSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWFzb24gPSAnbXVzdCBiZSBhIENvbXBvbmVudCBzdWJjbGFzcyc7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBjb21wb25lbnQsIFwiJyArIG5hbWUgKyAnXCI7ICcgKyByZWFzb24gKyAnLicpO1xuICAgIH1cblxuICAgIG5hbWUgPSB0b1RpdGxlQ2FzZShuYW1lKTtcblxuICAgIGlmICghQ29tcG9uZW50LmNvbXBvbmVudHNfKSB7XG4gICAgICBDb21wb25lbnQuY29tcG9uZW50c18gPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgUGxheWVyID0gQ29tcG9uZW50LmdldENvbXBvbmVudCgnUGxheWVyJyk7XG5cbiAgICBpZiAobmFtZSA9PT0gJ1BsYXllcicgJiYgUGxheWVyICYmIFBsYXllci5wbGF5ZXJzKSB7XG4gICAgICB2YXIgcGxheWVycyA9IFBsYXllci5wbGF5ZXJzO1xuICAgICAgdmFyIHBsYXllck5hbWVzID0gT2JqZWN0LmtleXMocGxheWVycyk7XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgcGxheWVycyB0aGF0IHdlcmUgZGlzcG9zZWQsIHRoZW4gdGhlaXIgbmFtZSB3aWxsIHN0aWxsIGJlXG4gICAgICAvLyBpbiBQbGF5ZXJzLnBsYXllcnMuIFNvLCB3ZSBtdXN0IGxvb3AgdGhyb3VnaCBhbmQgdmVyaWZ5IHRoYXQgdGhlIHZhbHVlXG4gICAgICAvLyBmb3IgZWFjaCBpdGVtIGlzIG5vdCBudWxsLiBUaGlzIGFsbG93cyByZWdpc3RyYXRpb24gb2YgdGhlIFBsYXllciBjb21wb25lbnRcbiAgICAgIC8vIGFmdGVyIGFsbCBwbGF5ZXJzIGhhdmUgYmVlbiBkaXNwb3NlZCBvciBiZWZvcmUgYW55IHdlcmUgY3JlYXRlZC5cbiAgICAgIGlmIChwbGF5ZXJzICYmIHBsYXllck5hbWVzLmxlbmd0aCA+IDAgJiYgcGxheWVyTmFtZXMubWFwKGZ1bmN0aW9uIChwbmFtZSkge1xuICAgICAgICByZXR1cm4gcGxheWVyc1twbmFtZV07XG4gICAgICB9KS5ldmVyeShCb29sZWFuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgcmVnaXN0ZXIgUGxheWVyIGNvbXBvbmVudCBhZnRlciBwbGF5ZXIgaGFzIGJlZW4gY3JlYXRlZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV0gPSBDb21wb25lbnRUb1JlZ2lzdGVyO1xuXG4gICAgcmV0dXJuIENvbXBvbmVudFRvUmVnaXN0ZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIGBDb21wb25lbnRgIGJhc2VkIG9uIHRoZSBuYW1lIGl0IHdhcyByZWdpc3RlcmVkIHdpdGguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBUaGUgTmFtZSBvZiB0aGUgY29tcG9uZW50IHRvIGdldC5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiAgICAgICAgIFRoZSBgQ29tcG9uZW50YCB0aGF0IGdvdCByZWdpc3RlcmVkIHVuZGVyIHRoZSBnaXZlbiBuYW1lLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbiBgdmlkZW9qc2AgNiB0aGlzIHdpbGwgbm90IHJldHVybiBgQ29tcG9uZW50YHMgdGhhdCB3ZXJlIG5vdFxuICAgKiAgICAgICAgICAgICByZWdpc3RlcmVkIHVzaW5nIHtAbGluayBDb21wb25lbnQucmVnaXN0ZXJDb21wb25lbnR9LiBDdXJyZW50bHkgd2VcbiAgICogICAgICAgICAgICAgY2hlY2sgdGhlIGdsb2JhbCBgdmlkZW9qc2Agb2JqZWN0IGZvciBhIGBDb21wb25lbnRgIG5hbWUgYW5kXG4gICAqICAgICAgICAgICAgIHJldHVybiB0aGF0IGlmIGl0IGV4aXN0cy5cbiAgICovXG5cblxuICBDb21wb25lbnQuZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24gZ2V0Q29tcG9uZW50KG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuYW1lID0gdG9UaXRsZUNhc2UobmFtZSk7XG5cbiAgICBpZiAoQ29tcG9uZW50LmNvbXBvbmVudHNfICYmIENvbXBvbmVudC5jb21wb25lbnRzX1tuYW1lXSkge1xuICAgICAgcmV0dXJuIENvbXBvbmVudC5jb21wb25lbnRzX1tuYW1lXTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENvbXBvbmVudDtcbn0oKTtcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvbmVudCBzdXBwb3J0cyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC5cbiAqXG4gKiBUaGlzIGlzIGV4cG9zZWQgcHJpbWFyaWx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc3VwcG9ydHNSYWZfID0gdHlwZW9mIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDb21wb25lbnQnLCBDb21wb25lbnQpO1xuXG4vKipcbiAqIEBmaWxlIHRpbWUtcmFuZ2VzLmpzXG4gKiBAbW9kdWxlIHRpbWUtcmFuZ2VzXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0aW1lIGZvciB0aGUgc3BlY2lmaWVkIGluZGV4IGF0IHRoZSBzdGFydCBvciBlbmRcbiAqIG9mIGEgVGltZVJhbmdlIG9iamVjdC5cbiAqXG4gKiBAZnVuY3Rpb24gdGltZS1yYW5nZXM6aW5kZXhGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF1cbiAqICAgICAgICBUaGUgcmFuZ2UgbnVtYmVyIHRvIHJldHVybiB0aGUgdGltZSBmb3IuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdGltZSB0aGF0IG9mZnNldCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICpcbiAqIEBkZXByaWNhdGVkIGluZGV4IG11c3QgYmUgc2V0IHRvIGEgdmFsdWUsIGluIHRoZSBmdXR1cmUgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yLlxuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgcmFuZ2VzIG9mIHRpbWUgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUaW1lUmFuZ2VcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGVuZ3RoXG4gKiAgICAgICAgICAgVGhlIG51bWJlciBvZiB0aW1lIHJhbmdlcyByZXByZXNlbnRlZCBieSB0aGlzIE9iamVjdFxuICpcbiAqIEBwcm9wZXJ0eSB7dGltZS1yYW5nZXM6aW5kZXhGdW5jdGlvbn0gc3RhcnRcbiAqICAgICAgICAgICBSZXR1cm5zIHRoZSB0aW1lIG9mZnNldCBhdCB3aGljaCBhIHNwZWNpZmllZCB0aW1lIHJhbmdlIGJlZ2lucy5cbiAqXG4gKiBAcHJvcGVydHkge3RpbWUtcmFuZ2VzOmluZGV4RnVuY3Rpb259IGVuZFxuICogICAgICAgICAgIFJldHVybnMgdGhlIHRpbWUgb2Zmc2V0IGF0IHdoaWNoIGEgc3BlY2lmaWVkIHRpbWUgcmFuZ2UgYmVnaW5zLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RpbWVSYW5nZXNcbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGFueSBvZiB0aGUgdGltZSByYW5nZXMgYXJlIG92ZXIgdGhlIG1heGltdW0gaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICogICAgICAgIFRoZSBmdW5jdGlvbiBuYW1lIHRvIHVzZSBmb3IgbG9nZ2luZ1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogICAgICAgIFRoZSBpbmRleCB0byBjaGVja1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhJbmRleFxuICogICAgICAgIFRoZSBtYXhpbXVtIHBvc3NpYmxlIGluZGV4XG4gKlxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSB0aW1lUmFuZ2VzIHByb3ZpZGVkIGFyZSBvdmVyIHRoZSBtYXhJbmRleFxuICovXG5mdW5jdGlvbiByYW5nZUNoZWNrKGZuTmFtZSwgaW5kZXgsIG1heEluZGV4KSB7XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInIHx8IGluZGV4IDwgMCB8fCBpbmRleCA+IG1heEluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZXhlY3V0ZSBcXCcnICsgZm5OYW1lICsgJ1xcJyBvbiBcXCdUaW1lUmFuZ2VzXFwnOiBUaGUgaW5kZXggcHJvdmlkZWQgKCcgKyBpbmRleCArICcpIGlzIG5vbi1udW1lcmljIG9yIG91dCBvZiBib3VuZHMgKDAtJyArIG1heEluZGV4ICsgJykuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbnkgb2YgdGhlIHRpbWUgcmFuZ2VzIGFyZSBvdmVyIHRoZSBtYXhpbXVtIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAqICAgICAgICBUaGUgZnVuY3Rpb24gbmFtZSB0byB1c2UgZm9yIGxvZ2dpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVJbmRleFxuICogICAgICAgIFRoZSBwcm9wcmV0eSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGdldCB0aGUgdGltZS4gc2hvdWxkIGJlICdzdGFydCcgb3IgJ2VuZCdcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSByYW5nZXNcbiAqICAgICAgICBBbiBhcnJheSBvZiB0aW1lIHJhbmdlc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IFtyYW5nZUluZGV4PTBdXG4gKiAgICAgICAgVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2ggYXRcbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB0aW1lIHRoYXQgb2Zmc2V0IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gKlxuICpcbiAqIEBkZXByaWNhdGVkIHJhbmdlSW5kZXggbXVzdCBiZSBzZXQgdG8gYSB2YWx1ZSwgaW4gdGhlIGZ1dHVyZSB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgcmFuZ2VJbmRleCBpcyBtb3JlIHRoYW4gdGhlIGxlbmd0aCBvZiByYW5nZXNcbiAqL1xuZnVuY3Rpb24gZ2V0UmFuZ2UoZm5OYW1lLCB2YWx1ZUluZGV4LCByYW5nZXMsIHJhbmdlSW5kZXgpIHtcbiAgcmFuZ2VDaGVjayhmbk5hbWUsIHJhbmdlSW5kZXgsIHJhbmdlcy5sZW5ndGggLSAxKTtcbiAgcmV0dXJuIHJhbmdlc1tyYW5nZUluZGV4XVt2YWx1ZUluZGV4XTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSB0aW1lIHJhbmdlIG9iamVjdCBnaXZlbnQgcmFuZ2VzIG9mIHRpbWUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gW3Jhbmdlc11cbiAqICAgICAgICBBbiBhcnJheSBvZiB0aW1lIHJhbmdlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGltZVJhbmdlc09iaihyYW5nZXMpIHtcbiAgaWYgKHJhbmdlcyA9PT0gdW5kZWZpbmVkIHx8IHJhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVuZ3RoOiAwLFxuICAgICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgVGltZVJhbmdlcyBvYmplY3QgaXMgZW1wdHknKTtcbiAgICAgIH0sXG4gICAgICBlbmQ6IGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIFRpbWVSYW5nZXMgb2JqZWN0IGlzIGVtcHR5Jyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxlbmd0aDogcmFuZ2VzLmxlbmd0aCxcbiAgICBzdGFydDogZ2V0UmFuZ2UuYmluZChudWxsLCAnc3RhcnQnLCAwLCByYW5nZXMpLFxuICAgIGVuZDogZ2V0UmFuZ2UuYmluZChudWxsLCAnZW5kJywgMSwgcmFuZ2VzKVxuICB9O1xufVxuXG4vKipcbiAqIFNob3VsZCBjcmVhdGUgYSBmYWtlIGBUaW1lUmFuZ2VgIG9iamVjdCB3aGljaCBtaW1pY3MgYW4gSFRNTDUgdGltZSByYW5nZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcnxBcnJheX0gc3RhcnRcbiAqICAgICAgICBUaGUgc3RhcnQgb2YgYSBzaW5nbGUgcmFuZ2Ugb3IgYW4gYXJyYXkgb2YgcmFuZ2VzXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICogICAgICAgIFRoZSBlbmQgb2YgYSBzaW5nbGUgcmFuZ2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGltZVJhbmdlcyhzdGFydCwgZW5kKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0YXJ0KSkge1xuICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzT2JqKHN0YXJ0KTtcbiAgfSBlbHNlIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXNPYmooKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlVGltZVJhbmdlc09iaihbW3N0YXJ0LCBlbmRdXSk7XG59XG5cbi8qKlxuICogQGZpbGUgYnVmZmVyLmpzXG4gKiBAbW9kdWxlIGJ1ZmZlclxuICovXG4vKipcbiAqIENvbXB1dGUgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIG1lZGlhIHRoYXQgaGFzIGJlZW4gYnVmZmVyZWQuXG4gKlxuICogQHBhcmFtIHtUaW1lUmFuZ2V9IGJ1ZmZlcmVkXG4gKiAgICAgICAgVGhlIGN1cnJlbnQgYFRpbWVSYW5nZWAgb2JqZWN0IHJlcHJlc2VudGluZyBidWZmZXJlZCB0aW1lIHJhbmdlc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuICogICAgICAgIFRvdGFsIGR1cmF0aW9uIG9mIHRoZSBtZWRpYVxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgUGVyY2VudCBidWZmZXJlZCBvZiB0aGUgdG90YWwgZHVyYXRpb24gaW4gZGVjaW1hbCBmb3JtLlxuICovXG5mdW5jdGlvbiBidWZmZXJlZFBlcmNlbnQoYnVmZmVyZWQsIGR1cmF0aW9uKSB7XG4gIHZhciBidWZmZXJlZER1cmF0aW9uID0gMDtcbiAgdmFyIHN0YXJ0ID0gdm9pZCAwO1xuICB2YXIgZW5kID0gdm9pZCAwO1xuXG4gIGlmICghZHVyYXRpb24pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmICghYnVmZmVyZWQgfHwgIWJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgIGJ1ZmZlcmVkID0gY3JlYXRlVGltZVJhbmdlcygwLCAwKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgIGVuZCA9IGJ1ZmZlcmVkLmVuZChpKTtcblxuICAgIC8vIGJ1ZmZlcmVkIGVuZCBjYW4gYmUgYmlnZ2VyIHRoYW4gZHVyYXRpb24gYnkgYSB2ZXJ5IHNtYWxsIGZyYWN0aW9uXG4gICAgaWYgKGVuZCA+IGR1cmF0aW9uKSB7XG4gICAgICBlbmQgPSBkdXJhdGlvbjtcbiAgICB9XG5cbiAgICBidWZmZXJlZER1cmF0aW9uICs9IGVuZCAtIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcmVkRHVyYXRpb24gLyBkdXJhdGlvbjtcbn1cblxuLyoqXG4gKiBAZmlsZSBmdWxsc2NyZWVuLWFwaS5qc1xuICogQG1vZHVsZSBmdWxsc2NyZWVuLWFwaVxuICogQHByaXZhdGVcbiAqL1xuLyoqXG4gKiBTdG9yZSB0aGUgYnJvd3Nlci1zcGVjaWZpYyBtZXRob2RzIGZvciB0aGUgZnVsbHNjcmVlbiBBUEkuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBzZWUgW1NwZWNpZmljYXRpb25de0BsaW5rIGh0dHBzOi8vZnVsbHNjcmVlbi5zcGVjLndoYXR3Zy5vcmd9XG4gKiBAc2VlIFtNYXAgQXBwcm9hY2ggRnJvbSBTY3JlZW5mdWxsLmpzXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3NjcmVlbmZ1bGwuanN9XG4gKi9cbnZhciBGdWxsc2NyZWVuQXBpID0ge307XG5cbi8vIGJyb3dzZXIgQVBJIG1ldGhvZHNcbnZhciBhcGlNYXAgPSBbWydyZXF1ZXN0RnVsbHNjcmVlbicsICdleGl0RnVsbHNjcmVlbicsICdmdWxsc2NyZWVuRWxlbWVudCcsICdmdWxsc2NyZWVuRW5hYmxlZCcsICdmdWxsc2NyZWVuY2hhbmdlJywgJ2Z1bGxzY3JlZW5lcnJvciddLFxuLy8gV2ViS2l0XG5bJ3dlYmtpdFJlcXVlc3RGdWxsc2NyZWVuJywgJ3dlYmtpdEV4aXRGdWxsc2NyZWVuJywgJ3dlYmtpdEZ1bGxzY3JlZW5FbGVtZW50JywgJ3dlYmtpdEZ1bGxzY3JlZW5FbmFibGVkJywgJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLCAnd2Via2l0ZnVsbHNjcmVlbmVycm9yJ10sXG4vLyBPbGQgV2ViS2l0IChTYWZhcmkgNS4xKVxuWyd3ZWJraXRSZXF1ZXN0RnVsbFNjcmVlbicsICd3ZWJraXRDYW5jZWxGdWxsU2NyZWVuJywgJ3dlYmtpdEN1cnJlbnRGdWxsU2NyZWVuRWxlbWVudCcsICd3ZWJraXRDYW5jZWxGdWxsU2NyZWVuJywgJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLCAnd2Via2l0ZnVsbHNjcmVlbmVycm9yJ10sXG4vLyBNb3ppbGxhXG5bJ21velJlcXVlc3RGdWxsU2NyZWVuJywgJ21vekNhbmNlbEZ1bGxTY3JlZW4nLCAnbW96RnVsbFNjcmVlbkVsZW1lbnQnLCAnbW96RnVsbFNjcmVlbkVuYWJsZWQnLCAnbW96ZnVsbHNjcmVlbmNoYW5nZScsICdtb3pmdWxsc2NyZWVuZXJyb3InXSxcbi8vIE1pY3Jvc29mdFxuWydtc1JlcXVlc3RGdWxsc2NyZWVuJywgJ21zRXhpdEZ1bGxzY3JlZW4nLCAnbXNGdWxsc2NyZWVuRWxlbWVudCcsICdtc0Z1bGxzY3JlZW5FbmFibGVkJywgJ01TRnVsbHNjcmVlbkNoYW5nZScsICdNU0Z1bGxzY3JlZW5FcnJvciddXTtcblxudmFyIHNwZWNBcGkgPSBhcGlNYXBbMF07XG52YXIgYnJvd3NlckFwaSA9IHZvaWQgMDtcblxuLy8gZGV0ZXJtaW5lIHRoZSBzdXBwb3J0ZWQgc2V0IG9mIGZ1bmN0aW9uc1xuZm9yICh2YXIgaSA9IDA7IGkgPCBhcGlNYXAubGVuZ3RoOyBpKyspIHtcbiAgLy8gY2hlY2sgZm9yIGV4aXRGdWxsc2NyZWVuIGZ1bmN0aW9uXG4gIGlmIChhcGlNYXBbaV1bMV0gaW4gZG9jdW1lbnQpIHtcbiAgICBicm93c2VyQXBpID0gYXBpTWFwW2ldO1xuICAgIGJyZWFrO1xuICB9XG59XG5cbi8vIG1hcCB0aGUgYnJvd3NlciBBUEkgbmFtZXMgdG8gdGhlIHNwZWMgQVBJIG5hbWVzXG5pZiAoYnJvd3NlckFwaSkge1xuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYnJvd3NlckFwaS5sZW5ndGg7IF9pKyspIHtcbiAgICBGdWxsc2NyZWVuQXBpW3NwZWNBcGlbX2ldXSA9IGJyb3dzZXJBcGlbX2ldO1xuICB9XG59XG5cbi8qKlxuICogQGZpbGUgbWVkaWEtZXJyb3IuanNcbiAqL1xuLyoqXG4gKiBBIEN1c3RvbSBgTWVkaWFFcnJvcmAgY2xhc3Mgd2hpY2ggbWltaWNzIHRoZSBzdGFuZGFyZCBIVE1MNSBgTWVkaWFFcnJvcmAgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfE9iamVjdHxNZWRpYUVycm9yfSB2YWx1ZVxuICogICAgICAgIFRoaXMgY2FuIGJlIG9mIG11bHRpcGxlIHR5cGVzOlxuICogICAgICAgIC0gbnVtYmVyOiBzaG91bGQgYmUgYSBzdGFuZGFyZCBlcnJvciBjb2RlXG4gKiAgICAgICAgLSBzdHJpbmc6IGFuIGVycm9yIG1lc3NhZ2UgKHRoZSBjb2RlIHdpbGwgYmUgMClcbiAqICAgICAgICAtIE9iamVjdDogYXJiaXRyYXJ5IHByb3BlcnRpZXNcbiAqICAgICAgICAtIGBNZWRpYUVycm9yYCAobmF0aXZlKTogdXNlZCB0byBwb3B1bGF0ZSBhIHZpZGVvLmpzIGBNZWRpYUVycm9yYCBvYmplY3RcbiAqICAgICAgICAtIGBNZWRpYUVycm9yYCAodmlkZW8uanMpOiB3aWxsIHJldHVybiBpdHNlbGYgaWYgaXQncyBhbHJlYWR5IGFcbiAqICAgICAgICAgIHZpZGVvLmpzIGBNZWRpYUVycm9yYCBvYmplY3QuXG4gKlxuICogQHNlZSBbTWVkaWFFcnJvciBTcGVjXXtAbGluayBodHRwczovL2Rldi53My5vcmcvaHRtbDUvc3BlYy1hdXRob3Itdmlldy92aWRlby5odG1sI21lZGlhZXJyb3J9XG4gKiBAc2VlIFtFbmNyeXB0ZWQgTWVkaWFFcnJvciBTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1lbmNyeXB0ZWQtbWVkaWEtMjAxMzA1MTAvI2Vycm9yLWNvZGVzfVxuICpcbiAqIEBjbGFzcyBNZWRpYUVycm9yXG4gKi9cbmZ1bmN0aW9uIE1lZGlhRXJyb3IodmFsdWUpIHtcblxuICAvLyBBbGxvdyByZWR1bmRhbnQgY2FsbHMgdG8gdGhpcyBjb25zdHJ1Y3RvciB0byBhdm9pZCBoYXZpbmcgYGluc3RhbmNlb2ZgXG4gIC8vIGNoZWNrcyBwZXBwZXJlZCBhcm91bmQgdGhlIGNvZGUuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1lZGlhRXJyb3IpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMuY29kZSA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBkZWZhdWx0IGNvZGUgaXMgemVybywgc28gdGhpcyBpcyBhIGN1c3RvbSBlcnJvclxuICAgIHRoaXMubWVzc2FnZSA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuXG4gICAgLy8gV2UgYXNzaWduIHRoZSBgY29kZWAgcHJvcGVydHkgbWFudWFsbHkgYmVjYXVzZSBuYXRpdmUgYE1lZGlhRXJyb3JgIG9iamVjdHNcbiAgICAvLyBkbyBub3QgZXhwb3NlIGl0IGFzIGFuIG93bi9lbnVtZXJhYmxlIHByb3BlcnR5IG9mIHRoZSBvYmplY3QuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5jb2RlID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5jb2RlID0gdmFsdWUuY29kZTtcbiAgICB9XG5cbiAgICBhc3NpZ24odGhpcywgdmFsdWUpO1xuICB9XG5cbiAgaWYgKCF0aGlzLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBNZWRpYUVycm9yLmRlZmF1bHRNZXNzYWdlc1t0aGlzLmNvZGVdIHx8ICcnO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGVycm9yIGNvZGUgdGhhdCByZWZlcnMgdHdvIG9uZSBvZiB0aGUgZGVmaW5lZCBgTWVkaWFFcnJvcmAgdHlwZXNcbiAqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5NZWRpYUVycm9yLnByb3RvdHlwZS5jb2RlID0gMDtcblxuLyoqXG4gKiBBbiBvcHRpb25hbCBtZXNzYWdlIHRoYXQgdG8gc2hvdyB3aXRoIHRoZSBlcnJvci4gTWVzc2FnZSBpcyBub3QgcGFydCBvZiB0aGUgSFRNTDVcbiAqIHZpZGVvIHNwZWMgYnV0IGFsbG93cyBmb3IgbW9yZSBpbmZvcm1hdGl2ZSBjdXN0b20gZXJyb3JzLlxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbk1lZGlhRXJyb3IucHJvdG90eXBlLm1lc3NhZ2UgPSAnJztcblxuLyoqXG4gKiBBbiBvcHRpb25hbCBzdGF0dXMgY29kZSB0aGF0IGNhbiBiZSBzZXQgYnkgcGx1Z2lucyB0byBhbGxvdyBldmVuIG1vcmUgZGV0YWlsIGFib3V0XG4gKiB0aGUgZXJyb3IuIEZvciBleGFtcGxlIGEgcGx1Z2luIG1pZ2h0IHByb3ZpZGUgYSBzcGVjaWZpYyBIVFRQIHN0YXR1cyBjb2RlIGFuZCBhblxuICogZXJyb3IgbWVzc2FnZSBmb3IgdGhhdCBjb2RlLiBUaGVuIHdoZW4gdGhlIHBsdWdpbiBnZXRzIHRoYXQgZXJyb3IgdGhpcyBjbGFzcyB3aWxsXG4gKiBrbm93IGhvdyB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2UgZm9yIGl0LiBUaGlzIGFsbG93cyBhIGN1c3RvbSBtZXNzYWdlIHRvIHNob3dcbiAqIHVwIG9uIHRoZSBgUGxheWVyYCBlcnJvciBvdmVybGF5LlxuICpcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuTWVkaWFFcnJvci5wcm90b3R5cGUuc3RhdHVzID0gbnVsbDtcblxuLyoqXG4gKiBFcnJvcnMgaW5kZXhlZCBieSB0aGUgVzNDIHN0YW5kYXJkLiBUaGUgb3JkZXIgKipDQU5OT1QgQ0hBTkdFKiohIFNlZSB0aGVcbiAqIHNwZWNpZmljYXRpb24gbGlzdGVkIHVuZGVyIHtAbGluayBNZWRpYUVycm9yfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZW51bSB7YXJyYXl9XG4gKiBAcmVhZG9ubHlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAwIC0gTUVESUFfRVJSX0NVU1RPTVxuICogQHByb3BlcnR5IHtzdHJpbmd9IDEgLSBNRURJQV9FUlJfQ1VTVE9NXG4gKiBAcHJvcGVydHkge3N0cmluZ30gMiAtIE1FRElBX0VSUl9BQk9SVEVEXG4gKiBAcHJvcGVydHkge3N0cmluZ30gMyAtIE1FRElBX0VSUl9ORVRXT1JLXG4gKiBAcHJvcGVydHkge3N0cmluZ30gNCAtIE1FRElBX0VSUl9TUkNfTk9UX1NVUFBPUlRFRFxuICogQHByb3BlcnR5IHtzdHJpbmd9IDUgLSBNRURJQV9FUlJfRU5DUllQVEVEXG4gKi9cbk1lZGlhRXJyb3IuZXJyb3JUeXBlcyA9IFsnTUVESUFfRVJSX0NVU1RPTScsICdNRURJQV9FUlJfQUJPUlRFRCcsICdNRURJQV9FUlJfTkVUV09SSycsICdNRURJQV9FUlJfREVDT0RFJywgJ01FRElBX0VSUl9TUkNfTk9UX1NVUFBPUlRFRCcsICdNRURJQV9FUlJfRU5DUllQVEVEJ107XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgYE1lZGlhRXJyb3JgIG1lc3NhZ2VzIGJhc2VkIG9uIHRoZSB7QGxpbmsgTWVkaWFFcnJvci5lcnJvclR5cGVzfS5cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAY29uc3RhbnRcbiAqL1xuTWVkaWFFcnJvci5kZWZhdWx0TWVzc2FnZXMgPSB7XG4gIDE6ICdZb3UgYWJvcnRlZCB0aGUgbWVkaWEgcGxheWJhY2snLFxuICAyOiAnQSBuZXR3b3JrIGVycm9yIGNhdXNlZCB0aGUgbWVkaWEgZG93bmxvYWQgdG8gZmFpbCBwYXJ0LXdheS4nLFxuICAzOiAnVGhlIG1lZGlhIHBsYXliYWNrIHdhcyBhYm9ydGVkIGR1ZSB0byBhIGNvcnJ1cHRpb24gcHJvYmxlbSBvciBiZWNhdXNlIHRoZSBtZWRpYSB1c2VkIGZlYXR1cmVzIHlvdXIgYnJvd3NlciBkaWQgbm90IHN1cHBvcnQuJyxcbiAgNDogJ1RoZSBtZWRpYSBjb3VsZCBub3QgYmUgbG9hZGVkLCBlaXRoZXIgYmVjYXVzZSB0aGUgc2VydmVyIG9yIG5ldHdvcmsgZmFpbGVkIG9yIGJlY2F1c2UgdGhlIGZvcm1hdCBpcyBub3Qgc3VwcG9ydGVkLicsXG4gIDU6ICdUaGUgbWVkaWEgaXMgZW5jcnlwdGVkIGFuZCB3ZSBkbyBub3QgaGF2ZSB0aGUga2V5cyB0byBkZWNyeXB0IGl0Lidcbn07XG5cbi8vIEFkZCB0eXBlcyBhcyBwcm9wZXJ0aWVzIG9uIE1lZGlhRXJyb3Jcbi8vIGUuZy4gTWVkaWFFcnJvci5NRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURUQgPSA0O1xuZm9yICh2YXIgZXJyTnVtID0gMDsgZXJyTnVtIDwgTWVkaWFFcnJvci5lcnJvclR5cGVzLmxlbmd0aDsgZXJyTnVtKyspIHtcbiAgTWVkaWFFcnJvcltNZWRpYUVycm9yLmVycm9yVHlwZXNbZXJyTnVtXV0gPSBlcnJOdW07XG4gIC8vIHZhbHVlcyBzaG91bGQgYmUgYWNjZXNzaWJsZSBvbiBib3RoIHRoZSBjbGFzcyBhbmQgaW5zdGFuY2VcbiAgTWVkaWFFcnJvci5wcm90b3R5cGVbTWVkaWFFcnJvci5lcnJvclR5cGVzW2Vyck51bV1dID0gZXJyTnVtO1xufVxuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stbGlzdC1jb252ZXJ0ZXIuanMgVXRpbGl0aWVzIGZvciBjYXB0dXJpbmcgdGV4dCB0cmFjayBzdGF0ZSBhbmRcbiAqIHJlLWNyZWF0aW5nIHRyYWNrcyBiYXNlZCBvbiBhIGNhcHR1cmUuXG4gKlxuICogQG1vZHVsZSB0ZXh0LXRyYWNrLWxpc3QtY29udmVydGVyXG4gKi9cblxuLyoqXG4gKiBFeGFtaW5lIGEgc2luZ2xlIHtAbGluayBUZXh0VHJhY2t9IGFuZCByZXR1cm4gYSBKU09OLWNvbXBhdGlibGUgamF2YXNjcmlwdCBvYmplY3QgdGhhdFxuICogcmVwcmVzZW50cyB0aGUge0BsaW5rIFRleHRUcmFja30ncyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAqICAgICAgICBUaGUgdGV4dCB0cmFjayB0byBxdWVyeS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIEEgc2VyaWFsaXphYmxlIGphdmFzY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIFRleHRUcmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB0cmFja1RvSnNvbl8gPSBmdW5jdGlvbiB0cmFja1RvSnNvbl8odHJhY2spIHtcbiAgdmFyIHJldCA9IFsna2luZCcsICdsYWJlbCcsICdsYW5ndWFnZScsICdpZCcsICdpbkJhbmRNZXRhZGF0YVRyYWNrRGlzcGF0Y2hUeXBlJywgJ21vZGUnLCAnc3JjJ10ucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3AsIGkpIHtcblxuICAgIGlmICh0cmFja1twcm9wXSkge1xuICAgICAgYWNjW3Byb3BdID0gdHJhY2tbcHJvcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge1xuICAgIGN1ZXM6IHRyYWNrLmN1ZXMgJiYgQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHRyYWNrLmN1ZXMsIGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0VGltZTogY3VlLnN0YXJ0VGltZSxcbiAgICAgICAgZW5kVGltZTogY3VlLmVuZFRpbWUsXG4gICAgICAgIHRleHQ6IGN1ZS50ZXh0LFxuICAgICAgICBpZDogY3VlLmlkXG4gICAgICB9O1xuICAgIH0pXG4gIH0pO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIEV4YW1pbmUgYSB7QGxpbmsgVGVjaH0gYW5kIHJldHVybiBhIEpTT04tY29tcGF0aWJsZSBqYXZhc2NyaXB0IGFycmF5IHRoYXQgcmVwcmVzZW50cyB0aGVcbiAqIHN0YXRlIG9mIGFsbCB7QGxpbmsgVGV4dFRyYWNrfXMgY3VycmVudGx5IGNvbmZpZ3VyZWQuIFRoZSByZXR1cm4gYXJyYXkgaXMgY29tcGF0aWJsZSB3aXRoXG4gKiB7QGxpbmsgdGV4dC10cmFjay1saXN0LWNvbnZlcnRlcjpqc29uVG9UZXh0VHJhY2tzfS5cbiAqXG4gKiBAcGFyYW0ge1RlY2h9IHRlY2hcbiAqICAgICAgICBUaGUgdGVjaCBvYmplY3QgdG8gcXVlcnlcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqICAgICAgICAgQSBzZXJpYWxpemFibGUgamF2YXNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGUge0BsaW5rIFRlY2h9c1xuICogICAgICAgICB7QGxpbmsgVGV4dFRyYWNrTGlzdH0uXG4gKi9cbnZhciB0ZXh0VHJhY2tzVG9Kc29uID0gZnVuY3Rpb24gdGV4dFRyYWNrc1RvSnNvbih0ZWNoKSB7XG5cbiAgdmFyIHRyYWNrRWxzID0gdGVjaC4kJCgndHJhY2snKTtcblxuICB2YXIgdHJhY2tPYmpzID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHRyYWNrRWxzLCBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LnRyYWNrO1xuICB9KTtcbiAgdmFyIHRyYWNrcyA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh0cmFja0VscywgZnVuY3Rpb24gKHRyYWNrRWwpIHtcbiAgICB2YXIganNvbiA9IHRyYWNrVG9Kc29uXyh0cmFja0VsLnRyYWNrKTtcblxuICAgIGlmICh0cmFja0VsLnNyYykge1xuICAgICAganNvbi5zcmMgPSB0cmFja0VsLnNyYztcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG4gIH0pO1xuXG4gIHJldHVybiB0cmFja3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbCh0ZWNoLnRleHRUcmFja3MoKSwgZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgcmV0dXJuIHRyYWNrT2Jqcy5pbmRleE9mKHRyYWNrKSA9PT0gLTE7XG4gIH0pLm1hcCh0cmFja1RvSnNvbl8pKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgc2V0IG9mIHJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfXMgb24gYSB7QGxpbmsgVGVjaH0gYmFzZWQgb24gYW4gYXJyYXkgb2YgamF2YXNjcmlwdFxuICogb2JqZWN0IHtAbGluayBUZXh0VHJhY2t9IHJlcHJlc2VudGF0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBqc29uXG4gKiAgICAgICAgQW4gYXJyYXkgb2YgYFRleHRUcmFja2AgcmVwcmVzZW50YXRpb24gb2JqZWN0cywgbGlrZSB0aG9zZSB0aGF0IHdvdWxkIGJlXG4gKiAgICAgICAgcHJvZHVjZWQgYnkgYHRleHRUcmFja3NUb0pzb25gLlxuICpcbiAqIEBwYXJhbSB7VGVjaH0gdGVjaFxuICogICAgICAgIFRoZSBgVGVjaGAgdG8gY3JlYXRlIHRoZSBgVGV4dFRyYWNrYHMgb24uXG4gKi9cbnZhciBqc29uVG9UZXh0VHJhY2tzID0gZnVuY3Rpb24ganNvblRvVGV4dFRyYWNrcyhqc29uLCB0ZWNoKSB7XG4gIGpzb24uZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICB2YXIgYWRkZWRUcmFjayA9IHRlY2guYWRkUmVtb3RlVGV4dFRyYWNrKHRyYWNrKS50cmFjaztcblxuICAgIGlmICghdHJhY2suc3JjICYmIHRyYWNrLmN1ZXMpIHtcbiAgICAgIHRyYWNrLmN1ZXMuZm9yRWFjaChmdW5jdGlvbiAoY3VlKSB7XG4gICAgICAgIHJldHVybiBhZGRlZFRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGVjaC50ZXh0VHJhY2tzKCk7XG59O1xuXG52YXIgdGV4dFRyYWNrQ29udmVydGVyID0geyB0ZXh0VHJhY2tzVG9Kc29uOiB0ZXh0VHJhY2tzVG9Kc29uLCBqc29uVG9UZXh0VHJhY2tzOiBqc29uVG9UZXh0VHJhY2tzLCB0cmFja1RvSnNvbl86IHRyYWNrVG9Kc29uXyB9O1xuXG4vKipcbiAqIEBmaWxlIG1vZGFsLWRpYWxvZy5qc1xuICovXG52YXIgTU9EQUxfQ0xBU1NfTkFNRSA9ICd2anMtbW9kYWwtZGlhbG9nJztcbnZhciBFU0MgPSAyNztcblxuLyoqXG4gKiBUaGUgYE1vZGFsRGlhbG9nYCBkaXNwbGF5cyBvdmVyIHRoZSB2aWRlbyBhbmQgaXRzIGNvbnRyb2xzLCB3aGljaCBibG9ja3NcbiAqIGludGVyYWN0aW9uIHdpdGggdGhlIHBsYXllciB1bnRpbCBpdCBpcyBjbG9zZWQuXG4gKlxuICogTW9kYWwgZGlhbG9ncyBpbmNsdWRlIGEgXCJDbG9zZVwiIGJ1dHRvbiBhbmQgd2lsbCBjbG9zZSB3aGVuIHRoYXQgYnV0dG9uXG4gKiBpcyBhY3RpdmF0ZWQgLSBvciB3aGVuIEVTQyBpcyBwcmVzc2VkIGFueXdoZXJlLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBNb2RhbERpYWxvZyA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1vZGFsRGlhbG9nLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBbb3B0aW9ucy5jb250ZW50PXVuZGVmaW5lZF1cbiAgICogICAgICAgIFByb3ZpZGUgY3VzdG9taXplZCBjb250ZW50IGZvciB0aGlzIG1vZGFsLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGVzY3JpcHRpb25dXG4gICAqICAgICAgICBBIHRleHQgZGVzY3JpcHRpb24gZm9yIHRoZSBtb2RhbCwgcHJpbWFyaWx5IGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZpbGxBbHdheXM9ZmFsc2VdXG4gICAqICAgICAgICBOb3JtYWxseSwgbW9kYWxzIGFyZSBhdXRvbWF0aWNhbGx5IGZpbGxlZCBvbmx5IHRoZSBmaXJzdCB0aW1lXG4gICAqICAgICAgICB0aGV5IG9wZW4uIFRoaXMgdGVsbHMgdGhlIG1vZGFsIHRvIHJlZnJlc2ggaXRzIGNvbnRlbnRcbiAgICogICAgICAgIGV2ZXJ5IHRpbWUgaXQgb3BlbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbF1cbiAgICogICAgICAgIEEgdGV4dCBsYWJlbCBmb3IgdGhlIG1vZGFsLCBwcmltYXJpbHkgZm9yIGFjY2Vzc2liaWxpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGVtcG9yYXJ5PXRydWVdXG4gICAqICAgICAgICBJZiBgdHJ1ZWAsIHRoZSBtb2RhbCBjYW4gb25seSBiZSBvcGVuZWQgb25jZTsgaXQgd2lsbCBiZVxuICAgKiAgICAgICAgZGlzcG9zZWQgYXMgc29vbiBhcyBpdCdzIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51bmNsb3NlYWJsZT1mYWxzZV1cbiAgICogICAgICAgIElmIGB0cnVlYCwgdGhlIHVzZXIgd2lsbCBub3QgYmUgYWJsZSB0byBjbG9zZSB0aGUgbW9kYWxcbiAgICogICAgICAgIHRocm91Z2ggdGhlIFVJIGluIHRoZSBub3JtYWwgd2F5cy4gUHJvZ3JhbW1hdGljIGNsb3NpbmcgaXNcbiAgICogICAgICAgIHN0aWxsIHBvc3NpYmxlLlxuICAgKi9cbiAgZnVuY3Rpb24gTW9kYWxEaWFsb2cocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kYWxEaWFsb2cpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vcGVuZWRfID0gX3RoaXMuaGFzQmVlbk9wZW5lZF8gPSBfdGhpcy5oYXNCZWVuRmlsbGVkXyA9IGZhbHNlO1xuXG4gICAgX3RoaXMuY2xvc2VhYmxlKCFfdGhpcy5vcHRpb25zXy51bmNsb3NlYWJsZSk7XG4gICAgX3RoaXMuY29udGVudChfdGhpcy5vcHRpb25zXy5jb250ZW50KTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgY29udGVudEVsIGlzIGRlZmluZWQgQUZURVIgYW55IGNoaWxkcmVuIGFyZSBpbml0aWFsaXplZFxuICAgIC8vIGJlY2F1c2Ugd2Ugb25seSB3YW50IHRoZSBjb250ZW50cyBvZiB0aGUgbW9kYWwgaW4gdGhlIGNvbnRlbnRFbFxuICAgIC8vIChub3QgdGhlIFVJIGVsZW1lbnRzIGxpa2UgdGhlIGNsb3NlIGJ1dHRvbikuXG4gICAgX3RoaXMuY29udGVudEVsXyA9IGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IE1PREFMX0NMQVNTX05BTUUgKyAnLWNvbnRlbnQnXG4gICAgfSwge1xuICAgICAgcm9sZTogJ2RvY3VtZW50J1xuICAgIH0pO1xuXG4gICAgX3RoaXMuZGVzY0VsXyA9IGNyZWF0ZUVsKCdwJywge1xuICAgICAgY2xhc3NOYW1lOiBNT0RBTF9DTEFTU19OQU1FICsgJy1kZXNjcmlwdGlvbiB2anMtY29udHJvbC10ZXh0JyxcbiAgICAgIGlkOiBfdGhpcy5lbCgpLmdldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpXG4gICAgfSk7XG5cbiAgICB0ZXh0Q29udGVudChfdGhpcy5kZXNjRWxfLCBfdGhpcy5kZXNjcmlwdGlvbigpKTtcbiAgICBfdGhpcy5lbF8uYXBwZW5kQ2hpbGQoX3RoaXMuZGVzY0VsXyk7XG4gICAgX3RoaXMuZWxfLmFwcGVuZENoaWxkKF90aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBNb2RhbERpYWxvZ2AncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBET00gZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKSxcbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0sIHtcbiAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogdGhpcy5pZCgpICsgJ19kZXNjcmlwdGlvbicsXG4gICAgICAnYXJpYS1oaWRkZW4nOiAndHJ1ZScsXG4gICAgICAnYXJpYS1sYWJlbCc6IHRoaXMubGFiZWwoKSxcbiAgICAgICdyb2xlJzogJ2RpYWxvZydcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gTU9EQUxfQ0xBU1NfTkFNRSArICcgdmpzLWhpZGRlbiAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGBrZXlkb3duYCBldmVudHMgb24gdGhlIGRvY3VtZW50LCBsb29raW5nIGZvciBFU0MsIHdoaWNoIGNsb3Nlc1xuICAgKiB0aGUgbW9kYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGVcbiAgICogICAgICAgIFRoZSBrZXlwcmVzcyB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZSkge1xuICAgIGlmIChlLndoaWNoID09PSBFU0MgJiYgdGhpcy5jbG9zZWFibGUoKSkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGFiZWwgc3RyaW5nIGZvciB0aGlzIG1vZGFsLiBQcmltYXJpbHkgdXNlZCBmb3IgYWNjZXNzaWJpbGl0eS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIHRoZSBsb2NhbGl6ZWQgb3IgcmF3IGxhYmVsIG9mIHRoaXMgbW9kYWwuXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmxhYmVsID0gZnVuY3Rpb24gbGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5sYWJlbCB8fCAnTW9kYWwgV2luZG93Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlc2NyaXB0aW9uIHN0cmluZyBmb3IgdGhpcyBtb2RhbC4gUHJpbWFyaWx5IHVzZWQgZm9yXG4gICAqIGFjY2Vzc2liaWxpdHkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgbG9jYWxpemVkIG9yIHJhdyBkZXNjcmlwdGlvbiBvZiB0aGlzIG1vZGFsLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgIHZhciBkZXNjID0gdGhpcy5vcHRpb25zXy5kZXNjcmlwdGlvbiB8fCB0aGlzLmxvY2FsaXplKCdUaGlzIGlzIGEgbW9kYWwgd2luZG93LicpO1xuXG4gICAgLy8gQXBwZW5kIGEgdW5pdmVyc2FsIGNsb3NlYWJpbGl0eSBtZXNzYWdlIGlmIHRoZSBtb2RhbCBpcyBjbG9zZWFibGUuXG4gICAgaWYgKHRoaXMuY2xvc2VhYmxlKCkpIHtcbiAgICAgIGRlc2MgKz0gJyAnICsgdGhpcy5sb2NhbGl6ZSgnVGhpcyBtb2RhbCBjYW4gYmUgY2xvc2VkIGJ5IHByZXNzaW5nIHRoZSBFc2NhcGUga2V5IG9yIGFjdGl2YXRpbmcgdGhlIGNsb3NlIGJ1dHRvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzYztcbiAgfTtcblxuICAvKipcbiAgICogT3BlbnMgdGhlIG1vZGFsLlxuICAgKlxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxvcGVuXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNtb2RhbG9wZW5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgaWYgKCF0aGlzLm9wZW5lZF8pIHtcbiAgICAgIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllcigpO1xuXG4gICAgICAvKipcbiAgICAgICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBhIGBNb2RhbERpYWxvZ2AgaXMgb3BlbmVkLlxuICAgICAgICAqXG4gICAgICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsb3BlblxuICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxvcGVuJyk7XG4gICAgICB0aGlzLm9wZW5lZF8gPSB0cnVlO1xuXG4gICAgICAvLyBGaWxsIGNvbnRlbnQgaWYgdGhlIG1vZGFsIGhhcyBuZXZlciBvcGVuZWQgYmVmb3JlIGFuZFxuICAgICAgLy8gbmV2ZXIgYmVlbiBmaWxsZWQuXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy5maWxsQWx3YXlzIHx8ICF0aGlzLmhhc0JlZW5PcGVuZWRfICYmICF0aGlzLmhhc0JlZW5GaWxsZWRfKSB7XG4gICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgcGxheWVyIHdhcyBwbGF5aW5nLCBwYXVzZSBpdCBhbmQgdGFrZSBub3RlIG9mIGl0cyBwcmV2aW91c2x5XG4gICAgICAvLyBwbGF5aW5nIHN0YXRlLlxuICAgICAgdGhpcy53YXNQbGF5aW5nXyA9ICFwbGF5ZXIucGF1c2VkKCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnBhdXNlT25PcGVuICYmIHRoaXMud2FzUGxheWluZ18pIHtcbiAgICAgICAgcGxheWVyLnBhdXNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsb3NlYWJsZSgpKSB7XG4gICAgICAgIHRoaXMub24odGhpcy5lbF8ub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgICAgIH1cblxuICAgICAgcGxheWVyLmNvbnRyb2xzKGZhbHNlKTtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgdGhpcy5jb25kaXRpb25hbEZvY3VzXygpO1xuICAgICAgdGhpcy5lbCgpLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgLyoqXG4gICAgICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgb3BlbmVkLlxuICAgICAgICAqXG4gICAgICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI21vZGFsb3BlblxuICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignbW9kYWxvcGVuJyk7XG4gICAgICB0aGlzLmhhc0JlZW5PcGVuZWRfID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElmIHRoZSBgTW9kYWxEaWFsb2dgIGlzIGN1cnJlbnRseSBvcGVuIG9yIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW3ZhbHVlXVxuICAgKiAgICAgICAgIElmIGdpdmVuLCBpdCB3aWxsIG9wZW4gKGB0cnVlYCkgb3IgY2xvc2UgKGBmYWxzZWApIHRoZSBtb2RhbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICB0aGUgY3VycmVudCBvcGVuIHN0YXRlIG9mIHRoZSBtb2RhbGRpYWxvZ1xuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5vcGVuZWQgPSBmdW5jdGlvbiBvcGVuZWQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXNbdmFsdWUgPyAnb3BlbicgOiAnY2xvc2UnXSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcGVuZWRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG1vZGFsLCBkb2VzIG5vdGhpbmcgaWYgdGhlIGBNb2RhbERpYWxvZ2AgaXNcbiAgICogbm90IG9wZW4uXG4gICAqXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGNsb3NlXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNtb2RhbGNsb3NlXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLm9wZW5lZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBsYXllciA9IHRoaXMucGxheWVyKCk7XG5cbiAgICAvKipcbiAgICAgICogRmlyZWQganVzdCBiZWZvcmUgYSBgTW9kYWxEaWFsb2dgIGlzIGNsb3NlZC5cbiAgICAgICpcbiAgICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsY2xvc2VcbiAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZW1vZGFsY2xvc2UnKTtcbiAgICB0aGlzLm9wZW5lZF8gPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLndhc1BsYXlpbmdfICYmIHRoaXMub3B0aW9uc18ucGF1c2VPbk9wZW4pIHtcbiAgICAgIHBsYXllci5wbGF5KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xvc2VhYmxlKCkpIHtcbiAgICAgIHRoaXMub2ZmKHRoaXMuZWxfLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gICAgfVxuXG4gICAgcGxheWVyLmNvbnRyb2xzKHRydWUpO1xuICAgIHRoaXMuaGlkZSgpO1xuICAgIHRoaXMuZWwoKS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgIC8qKlxuICAgICAgKiBGaXJlZCBqdXN0IGFmdGVyIGEgYE1vZGFsRGlhbG9nYCBpcyBjbG9zZWQuXG4gICAgICAqXG4gICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNtb2RhbGNsb3NlXG4gICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdtb2RhbGNsb3NlJyk7XG4gICAgdGhpcy5jb25kaXRpb25hbEJsdXJfKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zXy50ZW1wb3JhcnkpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBgTW9kYWxEaWFsb2dgIGlzIGNsb3NlYWJsZSB2aWEgdGhlIFVJLlxuICAgKlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAgSWYgZ2l2ZW4gYXMgYSBib29sZWFuLCBpdCB3aWxsIHNldCB0aGUgYGNsb3NlYWJsZWAgb3B0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFJldHVybnMgdGhlIGZpbmFsIHZhbHVlIG9mIHRoZSBjbG9zYWJsZSBvcHRpb24uXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNsb3NlYWJsZSA9IGZ1bmN0aW9uIGNsb3NlYWJsZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdmFyIGNsb3NlYWJsZSA9IHRoaXMuY2xvc2VhYmxlXyA9ICEhdmFsdWU7XG4gICAgICB2YXIgY2xvc2UgPSB0aGlzLmdldENoaWxkKCdjbG9zZUJ1dHRvbicpO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGJlaW5nIG1hZGUgY2xvc2VhYmxlIGFuZCBoYXMgbm8gY2xvc2UgYnV0dG9uLCBhZGQgb25lLlxuICAgICAgaWYgKGNsb3NlYWJsZSAmJiAhY2xvc2UpIHtcblxuICAgICAgICAvLyBUaGUgY2xvc2UgYnV0dG9uIHNob3VsZCBiZSBhIGNoaWxkIG9mIHRoZSBtb2RhbCAtIG5vdCBpdHNcbiAgICAgICAgLy8gY29udGVudCBlbGVtZW50LCBzbyB0ZW1wb3JhcmlseSBjaGFuZ2UgdGhlIGNvbnRlbnQgZWxlbWVudC5cbiAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmNvbnRlbnRFbF87XG5cbiAgICAgICAgdGhpcy5jb250ZW50RWxfID0gdGhpcy5lbF87XG4gICAgICAgIGNsb3NlID0gdGhpcy5hZGRDaGlsZCgnY2xvc2VCdXR0b24nLCB7IGNvbnRyb2xUZXh0OiAnQ2xvc2UgTW9kYWwgRGlhbG9nJyB9KTtcbiAgICAgICAgdGhpcy5jb250ZW50RWxfID0gdGVtcDtcbiAgICAgICAgdGhpcy5vbihjbG9zZSwgJ2Nsb3NlJywgdGhpcy5jbG9zZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYmVpbmcgbWFkZSB1bmNsb3NlYWJsZSBhbmQgaGFzIGEgY2xvc2UgYnV0dG9uLCByZW1vdmUgaXQuXG4gICAgICBpZiAoIWNsb3NlYWJsZSAmJiBjbG9zZSkge1xuICAgICAgICB0aGlzLm9mZihjbG9zZSwgJ2Nsb3NlJywgdGhpcy5jbG9zZSk7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2xvc2UpO1xuICAgICAgICBjbG9zZS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb3NlYWJsZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbGwgdGhlIG1vZGFsJ3MgY29udGVudCBlbGVtZW50IHdpdGggdGhlIG1vZGFsJ3MgXCJjb250ZW50XCIgb3B0aW9uLlxuICAgKiBUaGUgY29udGVudCBlbGVtZW50IHdpbGwgYmUgZW1wdGllZCBiZWZvcmUgdGhpcyBjaGFuZ2UgdGFrZXMgcGxhY2UuXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsKCkge1xuICAgIHRoaXMuZmlsbFdpdGgodGhpcy5jb250ZW50KCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaWxsIHRoZSBtb2RhbCdzIGNvbnRlbnQgZWxlbWVudCB3aXRoIGFyYml0cmFyeSBjb250ZW50LlxuICAgKiBUaGUgY29udGVudCBlbGVtZW50IHdpbGwgYmUgZW1wdGllZCBiZWZvcmUgdGhpcyBjaGFuZ2UgdGFrZXMgcGxhY2UuXG4gICAqXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGZpbGxcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI21vZGFsZmlsbFxuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBbY29udGVudF1cbiAgICogICAgICAgIFRoZSBzYW1lIHJ1bGVzIGFwcGx5IHRvIHRoaXMgYXMgYXBwbHkgdG8gdGhlIGBjb250ZW50YCBvcHRpb24uXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmZpbGxXaXRoID0gZnVuY3Rpb24gZmlsbFdpdGgoY29udGVudCkge1xuICAgIHZhciBjb250ZW50RWwgPSB0aGlzLmNvbnRlbnRFbCgpO1xuICAgIHZhciBwYXJlbnRFbCA9IGNvbnRlbnRFbC5wYXJlbnROb2RlO1xuICAgIHZhciBuZXh0U2libGluZ0VsID0gY29udGVudEVsLm5leHRTaWJsaW5nO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQganVzdCBiZWZvcmUgYSBgTW9kYWxEaWFsb2dgIGlzIGZpbGxlZCB3aXRoIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxmaWxsXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxmaWxsJyk7XG4gICAgdGhpcy5oYXNCZWVuRmlsbGVkXyA9IHRydWU7XG5cbiAgICAvLyBEZXRhY2ggdGhlIGNvbnRlbnQgZWxlbWVudCBmcm9tIHRoZSBET00gYmVmb3JlIHBlcmZvcm1pbmdcbiAgICAvLyBtYW5pcHVsYXRpb24gdG8gYXZvaWQgbW9kaWZ5aW5nIHRoZSBsaXZlIERPTSBtdWx0aXBsZSB0aW1lcy5cbiAgICBwYXJlbnRFbC5yZW1vdmVDaGlsZChjb250ZW50RWwpO1xuICAgIHRoaXMuZW1wdHkoKTtcbiAgICBpbnNlcnRDb250ZW50KGNvbnRlbnRFbCwgY29udGVudCk7XG4gICAgLyoqXG4gICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgZmlsbGVkIHdpdGggY29udGVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNtb2RhbGZpbGxcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdtb2RhbGZpbGwnKTtcblxuICAgIC8vIFJlLWluamVjdCB0aGUgcmUtZmlsbGVkIGNvbnRlbnQgZWxlbWVudC5cbiAgICBpZiAobmV4dFNpYmxpbmdFbCkge1xuICAgICAgcGFyZW50RWwuaW5zZXJ0QmVmb3JlKGNvbnRlbnRFbCwgbmV4dFNpYmxpbmdFbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKGNvbnRlbnRFbCk7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIGNsb3NlIGJ1dHRvbiBpcyBsYXN0IGluIHRoZSBkaWFsb2cgRE9NXG4gICAgdmFyIGNsb3NlQnV0dG9uID0gdGhpcy5nZXRDaGlsZCgnY2xvc2VCdXR0b24nKTtcblxuICAgIGlmIChjbG9zZUJ1dHRvbikge1xuICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQoY2xvc2VCdXR0b24uZWxfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtcHRpZXMgdGhlIGNvbnRlbnQgZWxlbWVudC4gVGhpcyBoYXBwZW5zIGFueXRpbWUgdGhlIG1vZGFsIGlzIGZpbGxlZC5cbiAgICpcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsZW1wdHlcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI21vZGFsZW1wdHlcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICAvKipcbiAgICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBhIGBNb2RhbERpYWxvZ2AgaXMgZW1wdGllZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGVtcHR5XG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxlbXB0eScpO1xuICAgIGVtcHR5RWwodGhpcy5jb250ZW50RWwoKSk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBqdXN0IGFmdGVyIGEgYE1vZGFsRGlhbG9nYCBpcyBlbXB0aWVkLlxuICAgICAqXG4gICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI21vZGFsZW1wdHlcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdtb2RhbGVtcHR5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgbW9kYWwgY29udGVudCwgd2hpY2ggZ2V0cyBub3JtYWxpemVkIGJlZm9yZSBiZWluZ1xuICAgKiByZW5kZXJlZCBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIFRoaXMgZG9lcyBub3QgdXBkYXRlIHRoZSBET00gb3IgZmlsbCB0aGUgbW9kYWwsIGJ1dCBpdCBpcyBjYWxsZWQgZHVyaW5nXG4gICAqIHRoYXQgcHJvY2Vzcy5cbiAgICpcbiAgICogQHBhcmFtICB7TWl4ZWR9IFt2YWx1ZV1cbiAgICogICAgICAgICBJZiBkZWZpbmVkLCBzZXRzIHRoZSBpbnRlcm5hbCBjb250ZW50IHZhbHVlIHRvIGJlIHVzZWQgb24gdGhlXG4gICAqICAgICAgICAgbmV4dCBjYWxsKHMpIHRvIGBmaWxsYC4gVGhpcyB2YWx1ZSBpcyBub3JtYWxpemVkIGJlZm9yZSBiZWluZ1xuICAgKiAgICAgICAgIGluc2VydGVkLiBUbyBcImNsZWFyXCIgdGhlIGludGVybmFsIGNvbnRlbnQgdmFsdWUsIHBhc3MgYG51bGxgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBjb250ZW50IG9mIHRoZSBtb2RhbCBkaWFsb2dcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5jb250ZW50XyA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250ZW50XztcbiAgfTtcblxuICAvKipcbiAgICogY29uZGl0aW9uYWxseSBmb2N1cyB0aGUgbW9kYWwgZGlhbG9nIGlmIGZvY3VzIHdhcyBwcmV2aW91c2x5IG9uIHRoZSBwbGF5ZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNvbmRpdGlvbmFsRm9jdXNfID0gZnVuY3Rpb24gY29uZGl0aW9uYWxGb2N1c18oKSB7XG4gICAgdmFyIGFjdGl2ZUVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB2YXIgcGxheWVyRWwgPSB0aGlzLnBsYXllcl8uZWxfO1xuXG4gICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gbnVsbDtcblxuICAgIGlmIChwbGF5ZXJFbC5jb250YWlucyhhY3RpdmVFbCkgfHwgcGxheWVyRWwgPT09IGFjdGl2ZUVsKSB7XG4gICAgICB0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8gPSBhY3RpdmVFbDtcblxuICAgICAgdGhpcy5mb2N1cygpO1xuXG4gICAgICB0aGlzLm9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBjb25kaXRpb25hbGx5IGJsdXIgdGhlIGVsZW1lbnQgYW5kIHJlZm9jdXMgdGhlIGxhc3QgZm9jdXNlZCBlbGVtZW50XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNvbmRpdGlvbmFsQmx1cl8gPSBmdW5jdGlvbiBjb25kaXRpb25hbEJsdXJfKCkge1xuICAgIGlmICh0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8pIHtcbiAgICAgIHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXy5mb2N1cygpO1xuICAgICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBLZXlkb3duIGhhbmRsZXIuIEF0dGFjaGVkIHdoZW4gbW9kYWwgaXMgZm9jdXNlZC5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIC8vIGV4aXQgZWFybHkgaWYgaXQgaXNuJ3QgYSB0YWIga2V5XG4gICAgaWYgKGV2ZW50LndoaWNoICE9PSA5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZvY3VzYWJsZUVscyA9IHRoaXMuZm9jdXNhYmxlRWxzXygpO1xuICAgIHZhciBhY3RpdmVFbCA9IHRoaXMuZWxfLnF1ZXJ5U2VsZWN0b3IoJzpmb2N1cycpO1xuICAgIHZhciBmb2N1c0luZGV4ID0gdm9pZCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2N1c2FibGVFbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhY3RpdmVFbCA9PT0gZm9jdXNhYmxlRWxzW2ldKSB7XG4gICAgICAgIGZvY3VzSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5lbF8pIHtcbiAgICAgIGZvY3VzSW5kZXggPSAwO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zaGlmdEtleSAmJiBmb2N1c0luZGV4ID09PSAwKSB7XG4gICAgICBmb2N1c2FibGVFbHNbZm9jdXNhYmxlRWxzLmxlbmd0aCAtIDFdLmZvY3VzKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmIGZvY3VzSW5kZXggPT09IGZvY3VzYWJsZUVscy5sZW5ndGggLSAxKSB7XG4gICAgICBmb2N1c2FibGVFbHNbMF0uZm9jdXMoKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBnZXQgYWxsIGZvY3VzYWJsZSBlbGVtZW50c1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5mb2N1c2FibGVFbHNfID0gZnVuY3Rpb24gZm9jdXNhYmxlRWxzXygpIHtcbiAgICB2YXIgYWxsQ2hpbGRyZW4gPSB0aGlzLmVsXy5xdWVyeVNlbGVjdG9yQWxsKCcqJyk7XG5cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGFsbENoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiAoY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEFuY2hvckVsZW1lbnQgfHwgY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEFyZWFFbGVtZW50KSAmJiBjaGlsZC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKSB8fCAoY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElucHV0RWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MVGV4dEFyZWFFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxCdXR0b25FbGVtZW50KSAmJiAhY2hpbGQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxPYmplY3RFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxFbWJlZEVsZW1lbnQgfHwgY2hpbGQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpICYmIGNoaWxkLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSAhPT0gLTEgfHwgY2hpbGQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTW9kYWxEaWFsb2c7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBgTW9kYWxEaWFsb2dgIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cbk1vZGFsRGlhbG9nLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgcGF1c2VPbk9wZW46IHRydWUsXG4gIHRlbXBvcmFyeTogdHJ1ZVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNb2RhbERpYWxvZycsIE1vZGFsRGlhbG9nKTtcblxuLyoqXG4gKiBAZmlsZSB0cmFjay1saXN0LmpzXG4gKi9cbi8qKlxuICogQ29tbW9uIGZ1bmN0aW9uYWxpeSBiZXR3ZWVuIHtAbGluayBUZXh0VHJhY2tMaXN0fSwge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fSwgYW5kXG4gKiB7QGxpbmsgVmlkZW9UcmFja0xpc3R9XG4gKlxuICogQGV4dGVuZHMgRXZlbnRUYXJnZXRcbiAqL1xuXG52YXIgVHJhY2tMaXN0ID0gZnVuY3Rpb24gKF9FdmVudFRhcmdldCkge1xuICBpbmhlcml0cyhUcmFja0xpc3QsIF9FdmVudFRhcmdldCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhY2tbXX0gdHJhY2tzXG4gICAqICAgICAgICBBIGxpc3Qgb2YgdHJhY2tzIHRvIGluaXRpYWxpemUgdGhlIGxpc3Qgd2l0aC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtsaXN0XVxuICAgKiAgICAgICAgVGhlIGNoaWxkIG9iamVjdCB3aXRoIGluaGVyaXRhbmNlIGRvbmUgbWFudWFsbHkgZm9yIGllOC5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBmdW5jdGlvbiBUcmFja0xpc3QoKSB7XG4gICAgdmFyIHRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG5cbiAgICB2YXIgX3JldDtcblxuICAgIHZhciBsaXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNrTGlzdCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudFRhcmdldC5jYWxsKHRoaXMpKTtcblxuICAgIGlmICghbGlzdCkge1xuICAgICAgbGlzdCA9IF90aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpZiAoSVNfSUU4KSB7XG4gICAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBUcmFja0xpc3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgIGxpc3RbcHJvcF0gPSBUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QudHJhY2tzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRyYWNrTGlzdFxuICAgICAqIEBtZW1iZXIge251bWJlcn0gbGVuZ3RoXG4gICAgICogICAgICAgICBUaGUgY3VycmVudCBudW1iZXIgb2YgYFRyYWNrYHMgaW4gdGhlIHRoaXMgVHJhY2tpc3QuXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxpc3QsICdsZW5ndGgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzXy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdC5hZGRUcmFjayh0cmFja3NbaV0pO1xuICAgIH1cblxuICAgIC8vIG11c3QgcmV0dXJuIHRoZSBvYmplY3QsIGFzIGZvciBpZTggaXQgd2lsbCBub3QgYmUgdGhpc1xuICAgIC8vIGJ1dCBhIHJlZmVyZW5jZSB0byBhIGRvY3VtZW50IG9iamVjdFxuICAgIHJldHVybiBfcmV0ID0gbGlzdCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEge0BsaW5rIFRyYWNrfSB0byB0aGUgYFRyYWNrTGlzdGBcbiAgICpcbiAgICogQHBhcmFtIHtUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSBhdWRpbywgdmlkZW8sIG9yIHRleHQgdHJhY2sgdG8gYWRkIHRvIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I2FkZHRyYWNrXG4gICAqL1xuXG5cbiAgVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy50cmFja3NfLmxlbmd0aDtcblxuICAgIGlmICghKCcnICsgaW5kZXggaW4gdGhpcykpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbmRleCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFja3NfW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGFkZCBkdXBsaWNhdGUgdHJhY2tzXG4gICAgaWYgKHRoaXMudHJhY2tzXy5pbmRleE9mKHRyYWNrKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudHJhY2tzXy5wdXNoKHRyYWNrKTtcbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlcmVkIHdoZW4gYSB0cmFjayBpcyBhZGRlZCB0byBhIHRyYWNrIGxpc3QuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IFRyYWNrTGlzdCNhZGR0cmFja1xuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICogQHByb3BlcnR5IHtUcmFja30gdHJhY2tcbiAgICAgICAqICAgICAgICAgICBBIHJlZmVyZW5jZSB0byB0cmFjayB0aGF0IHdhcyBhZGRlZC5cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKHtcbiAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICB0eXBlOiAnYWRkdHJhY2snXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHtAbGluayBUcmFja30gZnJvbSB0aGUgYFRyYWNrTGlzdGBcbiAgICpcbiAgICogQHBhcmFtIHtUcmFja30gcnRyYWNrXG4gICAqICAgICAgICBUaGUgYXVkaW8sIHZpZGVvLCBvciB0ZXh0IHRyYWNrIHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I3JlbW92ZXRyYWNrXG4gICAqL1xuXG5cbiAgVHJhY2tMaXN0LnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHJ0cmFjaykge1xuICAgIHZhciB0cmFjayA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0aGlzW2ldID09PSBydHJhY2spIHtcbiAgICAgICAgdHJhY2sgPSB0aGlzW2ldO1xuICAgICAgICBpZiAodHJhY2sub2ZmKSB7XG4gICAgICAgICAgdHJhY2sub2ZmKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyYWNrc18uc3BsaWNlKGksIDEpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRyYWNrIGlzIHJlbW92ZWQgZnJvbSB0cmFjayBsaXN0LlxuICAgICAqXG4gICAgICogQGV2ZW50IFRyYWNrTGlzdCNyZW1vdmV0cmFja1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKiBAcHJvcGVydHkge1RyYWNrfSB0cmFja1xuICAgICAqICAgICAgICAgICBBIHJlZmVyZW5jZSB0byB0cmFjayB0aGF0IHdhcyByZW1vdmVkLlxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcih7XG4gICAgICB0cmFjazogdHJhY2ssXG4gICAgICB0eXBlOiAncmVtb3ZldHJhY2snXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIFRyYWNrIGZyb20gdGhlIFRyYWNrTGlzdCBieSBhIHRyYWNrcyBpZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSB0aGUgaWQgb2YgdGhlIHRyYWNrIHRvIGdldFxuICAgKiBAbWV0aG9kIGdldFRyYWNrQnlJZFxuICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUcmFja0xpc3QucHJvdG90eXBlLmdldFRyYWNrQnlJZCA9IGZ1bmN0aW9uIGdldFRyYWNrQnlJZChpZCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdGhpc1tpXTtcblxuICAgICAgaWYgKHRyYWNrLmlkID09PSBpZCkge1xuICAgICAgICByZXN1bHQgPSB0cmFjaztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gVHJhY2tMaXN0O1xufShFdmVudFRhcmdldCk7XG5cbi8qKlxuICogVHJpZ2dlcmVkIHdoZW4gYSBkaWZmZXJlbnQgdHJhY2sgaXMgc2VsZWN0ZWQvZW5hYmxlZC5cbiAqXG4gKiBAZXZlbnQgVHJhY2tMaXN0I2NoYW5nZVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogRXZlbnRzIHRoYXQgY2FuIGJlIGNhbGxlZCB3aXRoIG9uICsgZXZlbnROYW1lLiBTZWUge0BsaW5rIEV2ZW50SGFuZGxlcn0uXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFRyYWNrTGlzdCNhbGxvd2VkRXZlbnRzX1xuICogQHByaXZhdGVcbiAqL1xuXG5cblRyYWNrTGlzdC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7XG4gIGNoYW5nZTogJ2NoYW5nZScsXG4gIGFkZHRyYWNrOiAnYWRkdHJhY2snLFxuICByZW1vdmV0cmFjazogJ3JlbW92ZXRyYWNrJ1xufTtcblxuLy8gZW11bGF0ZSBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIHN1cHBvcnQgdG8gYWxsb3cgZm9yIGZlYXR1cmUgZGV0ZWN0aW9uXG5mb3IgKHZhciBldmVudCBpbiBUcmFja0xpc3QucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfKSB7XG4gIFRyYWNrTGlzdC5wcm90b3R5cGVbJ29uJyArIGV2ZW50XSA9IG51bGw7XG59XG5cbi8qKlxuICogQGZpbGUgYXVkaW8tdHJhY2stbGlzdC5qc1xuICovXG4vKipcbiAqIEFueXdoZXJlIHdlIGNhbGwgdGhpcyBmdW5jdGlvbiB3ZSBkaXZlcmdlIGZyb20gdGhlIHNwZWNcbiAqIGFzIHdlIG9ubHkgc3VwcG9ydCBvbmUgZW5hYmxlZCBhdWRpb3RyYWNrIGF0IGEgdGltZVxuICpcbiAqIEBwYXJhbSB7QXVkaW9UcmFja0xpc3R9IGxpc3RcbiAqICAgICAgICBsaXN0IHRvIHdvcmsgb25cbiAqXG4gKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IHRyYWNrXG4gKiAgICAgICAgVGhlIHRyYWNrIHRvIHNraXBcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZGlzYWJsZU90aGVycyA9IGZ1bmN0aW9uIGRpc2FibGVPdGhlcnMobGlzdCwgdHJhY2spIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFPYmplY3Qua2V5cyhsaXN0W2ldKS5sZW5ndGggfHwgdHJhY2suaWQgPT09IGxpc3RbaV0uaWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBhbm90aGVyIGF1ZGlvIHRyYWNrIGlzIGVuYWJsZWQsIGRpc2FibGUgaXRcbiAgICBsaXN0W2ldLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBBdWRpb1RyYWNrfSBmb3IgYSBtZWRpYSBmaWxlLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdWRpb3RyYWNrbGlzdH1cbiAqIEBleHRlbmRzIFRyYWNrTGlzdFxuICovXG5cbnZhciBBdWRpb1RyYWNrTGlzdCA9IGZ1bmN0aW9uIChfVHJhY2tMaXN0KSB7XG4gIGluaGVyaXRzKEF1ZGlvVHJhY2tMaXN0LCBfVHJhY2tMaXN0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja1tdfSBbdHJhY2tzPVtdXVxuICAgKiAgICAgICAgQSBsaXN0IG9mIGBBdWRpb1RyYWNrYCB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoLlxuICAgKi9cbiAgZnVuY3Rpb24gQXVkaW9UcmFja0xpc3QoKSB7XG4gICAgdmFyIF90aGlzLCBfcmV0O1xuXG4gICAgdmFyIHRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9UcmFja0xpc3QpO1xuXG4gICAgdmFyIGxpc3QgPSB2b2lkIDA7XG5cbiAgICAvLyBtYWtlIHN1cmUgb25seSAxIHRyYWNrIGlzIGVuYWJsZWRcbiAgICAvLyBzb3J0ZWQgZnJvbSBsYXN0IGluZGV4IHRvIGZpcnN0IGluZGV4XG4gICAgZm9yICh2YXIgaSA9IHRyYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRyYWNrc1tpXS5lbmFibGVkKSB7XG4gICAgICAgIGRpc2FibGVPdGhlcnModHJhY2tzLCB0cmFja3NbaV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTggZm9yY2VzIHVzIHRvIGltcGxlbWVudCBpbmhlcml0YW5jZSBvdXJzZWx2ZXNcbiAgICAvLyBhcyBpdCBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBwcm9wZXJseVxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBBdWRpb1RyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKF9wcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtfcHJvcF0gPSBBdWRpb1RyYWNrTGlzdC5wcm90b3R5cGVbX3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGlzdCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrTGlzdC5jYWxsKHRoaXMsIHRyYWNrcywgbGlzdCkpLCBfdGhpcyk7XG4gICAgbGlzdC5jaGFuZ2luZ18gPSBmYWxzZTtcblxuICAgIHJldHVybiBfcmV0ID0gbGlzdCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIHtAbGluayBBdWRpb1RyYWNrfSB0byB0aGUgYEF1ZGlvVHJhY2tMaXN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtBdWRpb1RyYWNrfSB0cmFja1xuICAgKiAgICAgICAgVGhlIEF1ZGlvVHJhY2sgdG8gYWRkIHRvIHRoZSBsaXN0XG4gICAqXG4gICAqIEBmaXJlcyBUcmFja0xpc3QjYWRkdHJhY2tcbiAgICovXG5cblxuICBBdWRpb1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKHRyYWNrLmVuYWJsZWQpIHtcbiAgICAgIGRpc2FibGVPdGhlcnModGhpcywgdHJhY2spO1xuICAgIH1cblxuICAgIF9UcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrLmNhbGwodGhpcywgdHJhY2spO1xuICAgIC8vIG5hdGl2ZSB0cmFja3MgZG9uJ3QgaGF2ZSB0aGlzXG4gICAgaWYgKCF0cmFjay5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpc3RlbnMgQXVkaW9UcmFjayNlbmFibGVkY2hhbmdlXG4gICAgICogQGZpcmVzIFRyYWNrTGlzdCNjaGFuZ2VcbiAgICAgKi9cbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmFibGVkY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gd2hlbiB3ZSBhcmUgZGlzYWJsaW5nIG90aGVyIHRyYWNrcyAoc2luY2Ugd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbW9yZSB0aGFuIG9uZSB0cmFjayBhdCBhIHRpbWUpIHdlIHdpbGwgc2V0IGNoYW5naW5nX1xuICAgICAgLy8gdG8gdHJ1ZSBzbyB0aGF0IHdlIGRvbid0IHRyaWdnZXIgYWRkaXRpb25hbCBjaGFuZ2UgZXZlbnRzXG4gICAgICBpZiAoX3RoaXMyLmNoYW5naW5nXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfdGhpczIuY2hhbmdpbmdfID0gdHJ1ZTtcbiAgICAgIGRpc2FibGVPdGhlcnMoX3RoaXMyLCB0cmFjayk7XG4gICAgICBfdGhpczIuY2hhbmdpbmdfID0gZmFsc2U7XG4gICAgICBfdGhpczIudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2tMaXN0O1xufShUcmFja0xpc3QpO1xuXG4vKipcbiAqIEBmaWxlIHZpZGVvLXRyYWNrLWxpc3QuanNcbiAqL1xuLyoqXG4gKiBVbi1zZWxlY3QgYWxsIG90aGVyIHtAbGluayBWaWRlb1RyYWNrfXMgdGhhdCBhcmUgc2VsZWN0ZWQuXG4gKlxuICogQHBhcmFtIHtWaWRlb1RyYWNrTGlzdH0gbGlzdFxuICogICAgICAgIGxpc3QgdG8gd29yayBvblxuICpcbiAqIEBwYXJhbSB7VmlkZW9UcmFja30gdHJhY2tcbiAqICAgICAgICBUaGUgdHJhY2sgdG8gc2tpcFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBkaXNhYmxlT3RoZXJzJDEgPSBmdW5jdGlvbiBkaXNhYmxlT3RoZXJzKGxpc3QsIHRyYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmtleXMobGlzdFtpXSkubGVuZ3RoIHx8IHRyYWNrLmlkID09PSBsaXN0W2ldLmlkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gYW5vdGhlciB2aWRlbyB0cmFjayBpcyBlbmFibGVkLCBkaXNhYmxlIGl0XG4gICAgbGlzdFtpXS5zZWxlY3RlZCA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIFZpZGVvVHJhY2t9IGZvciBhIHZpZGVvLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN2aWRlb3RyYWNrbGlzdH1cbiAqIEBleHRlbmRzIFRyYWNrTGlzdFxuICovXG5cbnZhciBWaWRlb1RyYWNrTGlzdCA9IGZ1bmN0aW9uIChfVHJhY2tMaXN0KSB7XG4gIGluaGVyaXRzKFZpZGVvVHJhY2tMaXN0LCBfVHJhY2tMaXN0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7VmlkZW9UcmFja1tdfSBbdHJhY2tzPVtdXVxuICAgKiAgICAgICAgQSBsaXN0IG9mIGBWaWRlb1RyYWNrYCB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoLlxuICAgKi9cbiAgZnVuY3Rpb24gVmlkZW9UcmFja0xpc3QoKSB7XG4gICAgdmFyIF90aGlzLCBfcmV0O1xuXG4gICAgdmFyIHRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlkZW9UcmFja0xpc3QpO1xuXG4gICAgdmFyIGxpc3QgPSB2b2lkIDA7XG5cbiAgICAvLyBtYWtlIHN1cmUgb25seSAxIHRyYWNrIGlzIGVuYWJsZWRcbiAgICAvLyBzb3J0ZWQgZnJvbSBsYXN0IGluZGV4IHRvIGZpcnN0IGluZGV4XG4gICAgZm9yICh2YXIgaSA9IHRyYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRyYWNrc1tpXS5zZWxlY3RlZCkge1xuICAgICAgICBkaXNhYmxlT3RoZXJzJDEodHJhY2tzLCB0cmFja3NbaV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTggZm9yY2VzIHVzIHRvIGltcGxlbWVudCBpbmhlcml0YW5jZSBvdXJzZWx2ZXNcbiAgICAvLyBhcyBpdCBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBwcm9wZXJseVxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBWaWRlb1RyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKF9wcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtfcHJvcF0gPSBWaWRlb1RyYWNrTGlzdC5wcm90b3R5cGVbX3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGlzdCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrTGlzdC5jYWxsKHRoaXMsIHRyYWNrcywgbGlzdCkpLCBfdGhpcyk7XG4gICAgbGlzdC5jaGFuZ2luZ18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gVmlkZW9UcmFja0xpc3Qjc2VsZWN0ZWRJbmRleFxuICAgICAqICAgICAgICAgVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIHtAbGluayBWaWRlb1RyYWNrYH0uXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxpc3QsICdzZWxlY3RlZEluZGV4Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGlmICh0aGlzW19pXS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoKSB7fVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9yZXQgPSBsaXN0LCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB7QGxpbmsgVmlkZW9UcmFja30gdG8gdGhlIGBWaWRlb1RyYWNrTGlzdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7VmlkZW9UcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSBWaWRlb1RyYWNrIHRvIGFkZCB0byB0aGUgbGlzdFxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I2FkZHRyYWNrXG4gICAqL1xuXG5cbiAgVmlkZW9UcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICh0cmFjay5zZWxlY3RlZCkge1xuICAgICAgZGlzYWJsZU90aGVycyQxKHRoaXMsIHRyYWNrKTtcbiAgICB9XG5cbiAgICBfVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrKTtcbiAgICAvLyBuYXRpdmUgdHJhY2tzIGRvbid0IGhhdmUgdGhpc1xuICAgIGlmICghdHJhY2suYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaXN0ZW5zIFZpZGVvVHJhY2sjc2VsZWN0ZWRjaGFuZ2VcbiAgICAgKiBAZmlyZXMgVHJhY2tMaXN0I2NoYW5nZVxuICAgICAqL1xuICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVkY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzMi5jaGFuZ2luZ18pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMyLmNoYW5naW5nXyA9IHRydWU7XG4gICAgICBkaXNhYmxlT3RoZXJzJDEoX3RoaXMyLCB0cmFjayk7XG4gICAgICBfdGhpczIuY2hhbmdpbmdfID0gZmFsc2U7XG4gICAgICBfdGhpczIudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFZpZGVvVHJhY2tMaXN0O1xufShUcmFja0xpc3QpO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stbGlzdC5qc1xuICovXG4vKipcbiAqIFRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIFRleHRUcmFja30gZm9yIGEgbWVkaWEgZmlsZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrbGlzdH1cbiAqIEBleHRlbmRzIFRyYWNrTGlzdFxuICovXG5cbnZhciBUZXh0VHJhY2tMaXN0ID0gZnVuY3Rpb24gKF9UcmFja0xpc3QpIHtcbiAgaW5oZXJpdHMoVGV4dFRyYWNrTGlzdCwgX1RyYWNrTGlzdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja1tdfSBbdHJhY2tzPVtdXVxuICAgKiAgICAgICAgQSBsaXN0IG9mIGBUZXh0VHJhY2tgIHRvIGluc3RhbnRpYXRlIHRoZSBsaXN0IHdpdGguXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tMaXN0KCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFja0xpc3QpO1xuXG4gICAgdmFyIGxpc3QgPSB2b2lkIDA7XG5cbiAgICAvLyBJRTggZm9yY2VzIHVzIHRvIGltcGxlbWVudCBpbmhlcml0YW5jZSBvdXJzZWx2ZXNcbiAgICAvLyBhcyBpdCBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBwcm9wZXJseVxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAoX3Byb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W19wcm9wXSA9IFRleHRUcmFja0xpc3QucHJvdG90eXBlW19wcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0xpc3QuY2FsbCh0aGlzLCB0cmFja3MsIGxpc3QpKSwgX3RoaXMpO1xuICAgIHJldHVybiBfcmV0ID0gbGlzdCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEge0BsaW5rIFRleHRUcmFja30gdG8gdGhlIGBUZXh0VHJhY2tMaXN0YFxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSB0ZXh0IHRyYWNrIHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICpcbiAgICogQGZpcmVzIFRyYWNrTGlzdCNhZGR0cmFja1xuICAgKi9cblxuXG4gIFRleHRUcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcbiAgICBfVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrKTtcblxuICAgIC8qKlxuICAgICAqIEBsaXN0ZW5zIFRleHRUcmFjayNtb2RlY2hhbmdlXG4gICAgICogQGZpcmVzIFRyYWNrTGlzdCNjaGFuZ2VcbiAgICAgKi9cbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH0pKTtcblxuICAgIHZhciBub25MYW5ndWFnZVRleHRUcmFja0tpbmQgPSBbJ21ldGFkYXRhJywgJ2NoYXB0ZXJzJ107XG5cbiAgICBpZiAobm9uTGFuZ3VhZ2VUZXh0VHJhY2tLaW5kLmluZGV4T2YodHJhY2sua2luZCkgPT09IC0xKSB7XG4gICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignc2VsZWN0ZWRsYW5ndWFnZWNoYW5nZScpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrTGlzdDtcbn0oVHJhY2tMaXN0KTtcblxuLyoqXG4gKiBAZmlsZSBodG1sLXRyYWNrLWVsZW1lbnQtbGlzdC5qc1xuICovXG5cbi8qKlxuICogVGhlIGN1cnJlbnQgbGlzdCBvZiB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH1zLlxuICovXG5cbnZhciBIdG1sVHJhY2tFbGVtZW50TGlzdCA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7SHRtbFRyYWNrRWxlbWVudFtdfSBbdHJhY2tzPVtdXVxuICAgKiAgICAgICAgQSBsaXN0IG9mIGBIdG1sVHJhY2tFbGVtZW50YCB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoLlxuICAgKi9cbiAgZnVuY3Rpb24gSHRtbFRyYWNrRWxlbWVudExpc3QoKSB7XG4gICAgdmFyIHRyYWNrRWxlbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEh0bWxUcmFja0VsZW1lbnRMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIEh0bWxUcmFja0VsZW1lbnRMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0LnRyYWNrRWxlbWVudHNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgSHRtbFRyYWNrRWxlbWVudExpc3RcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGxlbmd0aFxuICAgICAqICAgICAgICAgVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGBUcmFja2BzIGluIHRoZSB0aGlzIFRyYWNraXN0LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnbGVuZ3RoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrRWxlbWVudHNfLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0cmFja0VsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LmFkZFRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH0gdG8gdGhlIGBIdG1sVHJhY2tFbGVtZW50TGlzdGBcbiAgICpcbiAgICogQHBhcmFtIHtIdG1sVHJhY2tFbGVtZW50fSB0cmFja0VsZW1lbnRcbiAgICogICAgICAgIFRoZSB0cmFjayBlbGVtZW50IHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGUuYWRkVHJhY2tFbGVtZW50XyA9IGZ1bmN0aW9uIGFkZFRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy50cmFja0VsZW1lbnRzXy5sZW5ndGg7XG5cbiAgICBpZiAoISgnJyArIGluZGV4IGluIHRoaXMpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tFbGVtZW50c19baW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEbyBub3QgYWRkIGR1cGxpY2F0ZSBlbGVtZW50c1xuICAgIGlmICh0aGlzLnRyYWNrRWxlbWVudHNfLmluZGV4T2YodHJhY2tFbGVtZW50KSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudHJhY2tFbGVtZW50c18ucHVzaCh0cmFja0VsZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBIdG1sVHJhY2tFbGVtZW50fSBmcm9tIHRoZSBgSHRtbFRyYWNrRWxlbWVudExpc3RgIGdpdmVuIGFuXG4gICAqIHtAbGluayBUZXh0VHJhY2t9LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSB0cmFjayBhc3NvY2lhdGVkIHdpdGggYSB0cmFjayBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtIdG1sVHJhY2tFbGVtZW50fHVuZGVmaW5lZH1cbiAgICogICAgICAgICBUaGUgdHJhY2sgZWxlbWVudCB0aGF0IHdhcyBmb3VuZCBvciB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlLmdldFRyYWNrRWxlbWVudEJ5VHJhY2tfID0gZnVuY3Rpb24gZ2V0VHJhY2tFbGVtZW50QnlUcmFja18odHJhY2spIHtcbiAgICB2YXIgdHJhY2tFbGVtZW50XyA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnRyYWNrRWxlbWVudHNfLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJhY2sgPT09IHRoaXMudHJhY2tFbGVtZW50c19baV0udHJhY2spIHtcbiAgICAgICAgdHJhY2tFbGVtZW50XyA9IHRoaXMudHJhY2tFbGVtZW50c19baV07XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYWNrRWxlbWVudF87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHtAbGluayBIdG1sVHJhY2tFbGVtZW50fSBmcm9tIHRoZSBgSHRtbFRyYWNrRWxlbWVudExpc3RgXG4gICAqXG4gICAqIEBwYXJhbSB7SHRtbFRyYWNrRWxlbWVudH0gdHJhY2tFbGVtZW50XG4gICAqICAgICAgICBUaGUgdHJhY2sgZWxlbWVudCB0byByZW1vdmUgZnJvbSB0aGUgbGlzdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGUucmVtb3ZlVHJhY2tFbGVtZW50XyA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMudHJhY2tFbGVtZW50c18ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmFja0VsZW1lbnQgPT09IHRoaXMudHJhY2tFbGVtZW50c19baV0pIHtcbiAgICAgICAgdGhpcy50cmFja0VsZW1lbnRzXy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBIdG1sVHJhY2tFbGVtZW50TGlzdDtcbn0oKTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWN1ZS1saXN0LmpzXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGV4dFRyYWNrQ3VlTGlzdH5UZXh0VHJhY2tDdWVcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWRcbiAqICAgICAgICAgICBUaGUgdW5pcXVlIGlkIGZvciB0aGlzIHRleHQgdHJhY2sgY3VlXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0VGltZVxuICogICAgICAgICAgIFRoZSBzdGFydCB0aW1lIGZvciB0aGlzIHRleHQgdHJhY2sgY3VlXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZFRpbWVcbiAqICAgICAgICAgICBUaGUgZW5kIHRpbWUgZm9yIHRoaXMgdGV4dCB0cmFjayBjdWVcbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhdXNlT25FeGl0XG4gKiAgICAgICAgICAgUGF1c2Ugd2hlbiB0aGUgZW5kIHRpbWUgaXMgcmVhY2hlZCBpZiB0cnVlLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2tjdWV9XG4gKi9cblxuLyoqXG4gKiBBIExpc3Qgb2YgVGV4dFRyYWNrQ3Vlcy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrY3VlbGlzdH1cbiAqL1xuXG52YXIgVGV4dFRyYWNrQ3VlTGlzdCA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjdWVzXG4gICAqICAgICAgICBBIGxpc3Qgb2YgY3VlcyB0byBiZSBpbml0aWFsaXplZCB3aXRoXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tDdWVMaXN0KGN1ZXMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tDdWVMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtwcm9wXSA9IFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUuc2V0Q3Vlc18uY2FsbChsaXN0LCBjdWVzKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tDdWVMaXN0XG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IG51bWJlciBvZiBgVGV4dFRyYWNrQ3VlYHMgaW4gdGhlIFRleHRUcmFja0N1ZUxpc3QuXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxpc3QsICdsZW5ndGgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoXztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNldHRlciBmb3IgY3VlcyBpbiB0aGlzIGxpc3QuIENyZWF0ZXMgZ2V0dGVyc1xuICAgKiBhbiBhbiBpbmRleCBmb3IgdGhlIGN1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGN1ZXNcbiAgICogICAgICAgIEFuIGFycmF5IG9mIGN1ZXMgdG8gc2V0XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUuc2V0Q3Vlc18gPSBmdW5jdGlvbiBzZXRDdWVzXyhjdWVzKSB7XG4gICAgdmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsID0gY3Vlcy5sZW5ndGg7XG5cbiAgICB0aGlzLmN1ZXNfID0gY3VlcztcbiAgICB0aGlzLmxlbmd0aF8gPSBjdWVzLmxlbmd0aDtcblxuICAgIHZhciBkZWZpbmVQcm9wID0gZnVuY3Rpb24gZGVmaW5lUHJvcChpbmRleCkge1xuICAgICAgaWYgKCEoJycgKyBpbmRleCBpbiB0aGlzKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJycgKyBpbmRleCwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3Vlc19baW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChvbGRMZW5ndGggPCBsKSB7XG4gICAgICBpID0gb2xkTGVuZ3RoO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBkZWZpbmVQcm9wLmNhbGwodGhpcywgaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBgVGV4dFRyYWNrQ3VlYCB0aGF0IGlzIGN1cnJlbnRseSBpbiB0aGUgYFRleHRUcmFja0N1ZUxpc3RgIGJ5IGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICogICAgICAgIFRoZSBpZCBvZiB0aGUgY3VlIHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIGZvci5cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrQ3VlTGlzdH5UZXh0VHJhY2tDdWV8bnVsbH1cbiAgICogICAgICAgICBBIHNpbmdsZSBjdWUgb3IgbnVsbCBpZiBub25lIHdhcyBmb3VuZC5cbiAgICovXG5cblxuICBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZS5nZXRDdWVCeUlkID0gZnVuY3Rpb24gZ2V0Q3VlQnlJZChpZCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGN1ZSA9IHRoaXNbaV07XG5cbiAgICAgIGlmIChjdWUuaWQgPT09IGlkKSB7XG4gICAgICAgIHJlc3VsdCA9IGN1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrQ3VlTGlzdDtcbn0oKTtcblxuLyoqXG4gKiBAZmlsZSB0cmFjay1raW5kcy5qc1xuICovXG5cbi8qKlxuICogQWxsIHBvc3NpYmxlIGBWaWRlb1RyYWNrS2luZGBzXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLXZpZGVvdHJhY2sta2luZFxuICogQHR5cGVkZWYgVmlkZW9UcmFja35LaW5kXG4gKiBAZW51bVxuICovXG52YXIgVmlkZW9UcmFja0tpbmQgPSB7XG4gIGFsdGVybmF0aXZlOiAnYWx0ZXJuYXRpdmUnLFxuICBjYXB0aW9uczogJ2NhcHRpb25zJyxcbiAgbWFpbjogJ21haW4nLFxuICBzaWduOiAnc2lnbicsXG4gIHN1YnRpdGxlczogJ3N1YnRpdGxlcycsXG4gIGNvbW1lbnRhcnk6ICdjb21tZW50YXJ5J1xufTtcblxuLyoqXG4gKiBBbGwgcG9zc2libGUgYEF1ZGlvVHJhY2tLaW5kYHNcbiAqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tYXVkaW90cmFjay1raW5kXG4gKiBAdHlwZWRlZiBBdWRpb1RyYWNrfktpbmRcbiAqIEBlbnVtXG4gKi9cbnZhciBBdWRpb1RyYWNrS2luZCA9IHtcbiAgJ2FsdGVybmF0aXZlJzogJ2FsdGVybmF0aXZlJyxcbiAgJ2Rlc2NyaXB0aW9ucyc6ICdkZXNjcmlwdGlvbnMnLFxuICAnbWFpbic6ICdtYWluJyxcbiAgJ21haW4tZGVzYyc6ICdtYWluLWRlc2MnLFxuICAndHJhbnNsYXRpb24nOiAndHJhbnNsYXRpb24nLFxuICAnY29tbWVudGFyeSc6ICdjb21tZW50YXJ5J1xufTtcblxuLyoqXG4gKiBBbGwgcG9zc2libGUgYFRleHRUcmFja0tpbmRgc1xuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS10ZXh0dHJhY2sta2luZFxuICogQHR5cGVkZWYgVGV4dFRyYWNrfktpbmRcbiAqIEBlbnVtXG4gKi9cbnZhciBUZXh0VHJhY2tLaW5kID0ge1xuICBzdWJ0aXRsZXM6ICdzdWJ0aXRsZXMnLFxuICBjYXB0aW9uczogJ2NhcHRpb25zJyxcbiAgZGVzY3JpcHRpb25zOiAnZGVzY3JpcHRpb25zJyxcbiAgY2hhcHRlcnM6ICdjaGFwdGVycycsXG4gIG1ldGFkYXRhOiAnbWV0YWRhdGEnXG59O1xuXG4vKipcbiAqIEFsbCBwb3NzaWJsZSBgVGV4dFRyYWNrTW9kZWBzXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrbW9kZVxuICogQHR5cGVkZWYgVGV4dFRyYWNrfk1vZGVcbiAqIEBlbnVtXG4gKi9cbnZhciBUZXh0VHJhY2tNb2RlID0ge1xuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgc2hvd2luZzogJ3Nob3dpbmcnXG59O1xuXG4vKipcbiAqIEBmaWxlIHRyYWNrLmpzXG4gKi9cbi8qKlxuICogQSBUcmFjayBjbGFzcyB0aGF0IGNvbnRhaW5zIGFsbCBvZiB0aGUgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIHtAbGluayBBdWRpb1RyYWNrfSxcbiAqIHtAbGluayBWaWRlb1RyYWNrfSwgYW5kIHtAbGluayBUZXh0VHJhY2t9LlxuICpcbiAqID4gTm90ZTogVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHlcbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWx9XG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICogQGFic3RyYWN0XG4gKi9cblxudmFyIFRyYWNrID0gZnVuY3Rpb24gKF9FdmVudFRhcmdldCkge1xuICBpbmhlcml0cyhUcmFjaywgX0V2ZW50VGFyZ2V0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2luZD0nJ11cbiAgICogICAgICAgIEEgdmFsaWQga2luZCBmb3IgdGhlIHRyYWNrIHR5cGUgeW91IGFyZSBjcmVhdGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgQXVkaW9UcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsPScnXVxuICAgKiAgICAgICAgVGhlIG1lbnUgbGFiZWwgZm9yIHRoaXMgdHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGZ1bmN0aW9uIFRyYWNrKCkge1xuICAgIHZhciBfcmV0O1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNrKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50VGFyZ2V0LmNhbGwodGhpcykpO1xuXG4gICAgdmFyIHRyYWNrID0gX3RoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIHRyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRyYWNrLnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRyYWNrW3Byb3BdID0gVHJhY2sucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrUHJvcHMgPSB7XG4gICAgICBpZDogb3B0aW9ucy5pZCB8fCAndmpzX3RyYWNrXycgKyBuZXdHVUlEKCksXG4gICAgICBraW5kOiBvcHRpb25zLmtpbmQgfHwgJycsXG4gICAgICBsYWJlbDogb3B0aW9ucy5sYWJlbCB8fCAnJyxcbiAgICAgIGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlIHx8ICcnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUcmFja1xuICAgICAqIEBtZW1iZXIge3N0cmluZ30gaWRcbiAgICAgKiAgICAgICAgIFRoZSBpZCBvZiB0aGlzIHRyYWNrLiBDYW5ub3QgYmUgY2hhbmdlZCBhZnRlciBjcmVhdGlvbi5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRyYWNrXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBraW5kXG4gICAgICogICAgICAgICBUaGUga2luZCBvZiB0cmFjayB0aGF0IHRoaXMgaXMuIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyIGNyZWF0aW9uLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGxhYmVsXG4gICAgICogICAgICAgICBUaGUgbGFiZWwgb2YgdGhpcyB0cmFjay4gQ2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXIgY3JlYXRpb24uXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUcmFja1xuICAgICAqIEBtZW1iZXIge3N0cmluZ30gbGFuZ3VhZ2VcbiAgICAgKiAgICAgICAgIFRoZSB0d28gbGV0dGVyIGxhbmd1YWdlIGNvZGUgZm9yIHRoaXMgdHJhY2suIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyXG4gICAgICogICAgICAgICBjcmVhdGlvbi5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3Aoa2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2ssIGtleSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2tQcm9wc1trZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRyYWNrUHJvcHMpIHtcbiAgICAgIF9sb29wKGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSB0cmFjaywgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICByZXR1cm4gVHJhY2s7XG59KEV2ZW50VGFyZ2V0KTtcblxuLyoqXG4gKiBAZmlsZSB1cmwuanNcbiAqIEBtb2R1bGUgdXJsXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gdXJsOlVSTE9iamVjdFxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm90b2NvbFxuICogICAgICAgICAgIFRoZSBwcm90b2NvbCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaG9zdG5hbWVcbiAqICAgICAgICAgICBUaGUgaG9zdG5hbWUgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBvcnRcbiAqICAgICAgICAgICBUaGUgcG9ydCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF0aG5hbWVcbiAqICAgICAgICAgICBUaGUgcGF0aG5hbWUgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNlYXJjaFxuICogICAgICAgICAgIFRoZSBzZWFyY2ggcXVlcnkgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhhc2hcbiAqICAgICAgICAgICBUaGUgaGFzaCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaG9zdFxuICogICAgICAgICAgIFRoZSBob3N0IG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxuICovXG5cbi8qKlxuICogUmVzb2x2ZSBhbmQgcGFyc2UgdGhlIGVsZW1lbnRzIG9mIGEgVVJMLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdXJsXG4gKiAgICAgICAgIFRoZSB1cmwgdG8gcGFyc2VcbiAqXG4gKiBAcmV0dXJuIHt1cmw6VVJMT2JqZWN0fVxuICogICAgICAgICBBbiBvYmplY3Qgb2YgdXJsIGRldGFpbHNcbiAqL1xudmFyIHBhcnNlVXJsID0gZnVuY3Rpb24gcGFyc2VVcmwodXJsKSB7XG4gIHZhciBwcm9wcyA9IFsncHJvdG9jb2wnLCAnaG9zdG5hbWUnLCAncG9ydCcsICdwYXRobmFtZScsICdzZWFyY2gnLCAnaGFzaCcsICdob3N0J107XG5cbiAgLy8gYWRkIHRoZSB1cmwgdG8gYW4gYW5jaG9yIGFuZCBsZXQgdGhlIGJyb3dzZXIgcGFyc2UgdGhlIFVSTFxuICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICBhLmhyZWYgPSB1cmw7XG5cbiAgLy8gSUU4IChhbmQgOT8pIEZpeFxuICAvLyBpZTggZG9lc24ndCBwYXJzZSB0aGUgVVJMIGNvcnJlY3RseSB1bnRpbCB0aGUgYW5jaG9yIGlzIGFjdHVhbGx5XG4gIC8vIGFkZGVkIHRvIHRoZSBib2R5LCBhbmQgYW4gaW5uZXJIVE1MIGlzIG5lZWRlZCB0byB0cmlnZ2VyIHRoZSBwYXJzaW5nXG4gIHZhciBhZGRUb0JvZHkgPSBhLmhvc3QgPT09ICcnICYmIGEucHJvdG9jb2wgIT09ICdmaWxlOic7XG4gIHZhciBkaXYgPSB2b2lkIDA7XG5cbiAgaWYgKGFkZFRvQm9keSkge1xuICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5pbm5lckhUTUwgPSAnPGEgaHJlZj1cIicgKyB1cmwgKyAnXCI+PC9hPic7XG4gICAgYSA9IGRpdi5maXJzdENoaWxkO1xuICAgIC8vIHByZXZlbnQgdGhlIGRpdiBmcm9tIGFmZmVjdGluZyBsYXlvdXRcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5Om5vbmU7IHBvc2l0aW9uOmFic29sdXRlOycpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgfVxuXG4gIC8vIENvcHkgdGhlIHNwZWNpZmljIFVSTCBwcm9wZXJ0aWVzIHRvIGEgbmV3IG9iamVjdFxuICAvLyBUaGlzIGlzIGFsc28gbmVlZGVkIGZvciBJRTggYmVjYXVzZSB0aGUgYW5jaG9yIGxvc2VzIGl0c1xuICAvLyBwcm9wZXJ0aWVzIHdoZW4gaXQncyByZW1vdmVkIGZyb20gdGhlIGRvbVxuICB2YXIgZGV0YWlscyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXRhaWxzW3Byb3BzW2ldXSA9IGFbcHJvcHNbaV1dO1xuICB9XG5cbiAgLy8gSUU5IGFkZHMgdGhlIHBvcnQgdG8gdGhlIGhvc3QgcHJvcGVydHkgdW5saWtlIGV2ZXJ5b25lIGVsc2UuIElmXG4gIC8vIGEgcG9ydCBpZGVudGlmaWVyIGlzIGFkZGVkIGZvciBzdGFuZGFyZCBwb3J0cywgc3RyaXAgaXQuXG4gIGlmIChkZXRhaWxzLnByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgZGV0YWlscy5ob3N0ID0gZGV0YWlscy5ob3N0LnJlcGxhY2UoLzo4MCQvLCAnJyk7XG4gIH1cblxuICBpZiAoZGV0YWlscy5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBkZXRhaWxzLmhvc3QgPSBkZXRhaWxzLmhvc3QucmVwbGFjZSgvOjQ0MyQvLCAnJyk7XG4gIH1cblxuICBpZiAoYWRkVG9Cb2R5KSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICB9XG5cbiAgcmV0dXJuIGRldGFpbHM7XG59O1xuXG4vKipcbiAqIEdldCBhYnNvbHV0ZSB2ZXJzaW9uIG9mIHJlbGF0aXZlIFVSTC4gVXNlZCB0byB0ZWxsIGZsYXNoIGNvcnJlY3QgVVJMLlxuICpcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybFxuICogICAgICAgICBVUkwgdG8gbWFrZSBhYnNvbHV0ZVxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgQWJzb2x1dGUgVVJMXG4gKlxuICogQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ3MDgzMi9nZXR0aW5nLWFuLWFic29sdXRlLXVybC1mcm9tLWEtcmVsYXRpdmUtb25lLWllNi1pc3N1ZVxuICovXG52YXIgZ2V0QWJzb2x1dGVVUkwgPSBmdW5jdGlvbiBnZXRBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQ2hlY2sgaWYgYWJzb2x1dGUgVVJMXG4gIGlmICghdXJsLm1hdGNoKC9eaHR0cHM/OlxcL1xcLy8pKSB7XG4gICAgLy8gQ29udmVydCB0byBhYnNvbHV0ZSBVUkwuIEZsYXNoIGhvc3RlZCBvZmYtc2l0ZSBuZWVkcyBhbiBhYnNvbHV0ZSBVUkwuXG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgZGl2LmlubmVySFRNTCA9ICc8YSBocmVmPVwiJyArIHVybCArICdcIj54PC9hPic7XG4gICAgdXJsID0gZGl2LmZpcnN0Q2hpbGQuaHJlZjtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBvZiB0aGUgcGFzc2VkIGZpbGUgbmFtZS4gSXQgd2lsbCByZXR1cm4gYW4gZW1wdHkgc3RyaW5nXG4gKiBpZiBwYXNzZWQgYW4gaW52YWxpZCBwYXRoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiAgICAgICAgVGhlIGZpbGVOYW1lIHBhdGggbGlrZSAnL3BhdGgvdG8vZmlsZS5tcDQnXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgICAgICAgIFRoZSBleHRlbnNpb24gaW4gbG93ZXIgY2FzZSBvciBhbiBlbXB0eSBzdHJpbmcgaWYgbm9cbiAqICAgICAgICAgIGV4dGVuc2lvbiBjb3VsZCBiZSBmb3VuZC5cbiAqL1xudmFyIGdldEZpbGVFeHRlbnNpb24gPSBmdW5jdGlvbiBnZXRGaWxlRXh0ZW5zaW9uKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzcGxpdFBhdGhSZSA9IC9eKFxcLz8pKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/KShcXC4oW15cXC5cXC9cXD9dKykpKSg/OltcXC9dKnxbXFw/XS4qKSQvaTtcbiAgICB2YXIgcGF0aFBhcnRzID0gc3BsaXRQYXRoUmUuZXhlYyhwYXRoKTtcblxuICAgIGlmIChwYXRoUGFydHMpIHtcbiAgICAgIHJldHVybiBwYXRoUGFydHMucG9wKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgdXJsIHBhc3NlZCBpcyBhIGNyb3NzIGRvbWFpbiByZXF1ZXN0IG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiAgICAgICAgVGhlIHVybCB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBXaGV0aGVyIGl0IGlzIGEgY3Jvc3MgZG9tYWluIHJlcXVlc3Qgb3Igbm90LlxuICovXG52YXIgaXNDcm9zc09yaWdpbiA9IGZ1bmN0aW9uIGlzQ3Jvc3NPcmlnaW4odXJsKSB7XG4gIHZhciB3aW5Mb2MgPSB3aW5kb3cubG9jYXRpb247XG4gIHZhciB1cmxJbmZvID0gcGFyc2VVcmwodXJsKTtcblxuICAvLyBJRTggcHJvdG9jb2wgcmVsYXRpdmUgdXJscyB3aWxsIHJldHVybiAnOicgZm9yIHByb3RvY29sXG4gIHZhciBzcmNQcm90b2NvbCA9IHVybEluZm8ucHJvdG9jb2wgPT09ICc6JyA/IHdpbkxvYy5wcm90b2NvbCA6IHVybEluZm8ucHJvdG9jb2w7XG5cbiAgLy8gQ2hlY2sgaWYgdXJsIGlzIGZvciBhbm90aGVyIGRvbWFpbi9vcmlnaW5cbiAgLy8gSUU4IGRvZXNuJ3Qga25vdyBsb2NhdGlvbi5vcmlnaW4sIHNvIHdlIHdvbid0IHJlbHkgb24gaXQgaGVyZVxuICB2YXIgY3Jvc3NPcmlnaW4gPSBzcmNQcm90b2NvbCArIHVybEluZm8uaG9zdCAhPT0gd2luTG9jLnByb3RvY29sICsgd2luTG9jLmhvc3Q7XG5cbiAgcmV0dXJuIGNyb3NzT3JpZ2luO1xufTtcblxudmFyIFVybCA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRwYXJzZVVybDogcGFyc2VVcmwsXG5cdGdldEFic29sdXRlVVJMOiBnZXRBYnNvbHV0ZVVSTCxcblx0Z2V0RmlsZUV4dGVuc2lvbjogZ2V0RmlsZUV4dGVuc2lvbixcblx0aXNDcm9zc09yaWdpbjogaXNDcm9zc09yaWdpblxufSk7XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay5qc1xuICovXG4vKipcbiAqIFRha2VzIGEgd2VidnR0IGZpbGUgY29udGVudHMgYW5kIHBhcnNlcyBpdCBpbnRvIGN1ZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjQ29udGVudFxuICogICAgICAgIHdlYlZUVCBmaWxlIGNvbnRlbnRzXG4gKlxuICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gKiAgICAgICAgVGV4dFRyYWNrIHRvIGFkZCBjdWVzIHRvLiBDdWVzIGNvbWUgZnJvbSB0aGUgc3JjQ29udGVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgcGFyc2VDdWVzID0gZnVuY3Rpb24gcGFyc2VDdWVzKHNyY0NvbnRlbnQsIHRyYWNrKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgd2luZG93LldlYlZUVC5QYXJzZXIod2luZG93LCB3aW5kb3cudnR0anMsIHdpbmRvdy5XZWJWVFQuU3RyaW5nRGVjb2RlcigpKTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuXG4gIHBhcnNlci5vbmN1ZSA9IGZ1bmN0aW9uIChjdWUpIHtcbiAgICB0cmFjay5hZGRDdWUoY3VlKTtcbiAgfTtcblxuICBwYXJzZXIub25wYXJzaW5nZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBlcnJvcnMucHVzaChlcnJvcik7XG4gIH07XG5cbiAgcGFyc2VyLm9uZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJhY2sudHJpZ2dlcih7XG4gICAgICB0eXBlOiAnbG9hZGVkZGF0YScsXG4gICAgICB0YXJnZXQ6IHRyYWNrXG4gICAgfSk7XG4gIH07XG5cbiAgcGFyc2VyLnBhcnNlKHNyY0NvbnRlbnQpO1xuICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAod2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmdyb3VwQ29sbGFwc2VkKCdUZXh0IFRyYWNrIHBhcnNpbmcgZXJyb3JzIGZvciAnICsgdHJhY2suc3JjKTtcbiAgICB9XG4gICAgZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gbG9nJDEuZXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5ncm91cEVuZCkge1xuICAgICAgd2luZG93LmNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZXIuZmx1c2goKTtcbn07XG5cbi8qKlxuICogTG9hZCBhIGBUZXh0VHJhY2tgIGZyb20gYSBzcGVjaWZlZCB1cmwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNyY1xuICogICAgICAgIFVybCB0byBsb2FkIHRyYWNrIGZyb20uXG4gKlxuICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gKiAgICAgICAgVHJhY2sgdG8gYWRkIGN1ZXMgdG8uIENvbWVzIGZyb20gdGhlIGNvbnRlbnQgYXQgdGhlIGVuZCBvZiBgdXJsYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbG9hZFRyYWNrID0gZnVuY3Rpb24gbG9hZFRyYWNrKHNyYywgdHJhY2spIHtcbiAgdmFyIG9wdHMgPSB7XG4gICAgdXJpOiBzcmNcbiAgfTtcbiAgdmFyIGNyb3NzT3JpZ2luID0gaXNDcm9zc09yaWdpbihzcmMpO1xuXG4gIGlmIChjcm9zc09yaWdpbikge1xuICAgIG9wdHMuY29ycyA9IGNyb3NzT3JpZ2luO1xuICB9XG5cbiAgeGhyKG9wdHMsIGJpbmQodGhpcywgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UsIHJlc3BvbnNlQm9keSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBsb2ckMS5lcnJvcihlcnIsIHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICB0cmFjay5sb2FkZWRfID0gdHJ1ZTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHZ0dGpzIGhhcyBsb2FkZWQsIG90aGVyd2lzZSwgd2FpdCB0aWxsIGl0IGZpbmlzaGVkIGxvYWRpbmdcbiAgICAvLyBOT1RFOiB0aGlzIGlzIG9ubHkgdXNlZCBmb3IgdGhlIGFsdC92aWRlby5ub3Z0dC5qcyBidWlsZFxuICAgIGlmICh0eXBlb2Ygd2luZG93LldlYlZUVCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHRyYWNrLnRlY2hfKSB7XG4gICAgICAgIHZhciBsb2FkSGFuZGxlciA9IGZ1bmN0aW9uIGxvYWRIYW5kbGVyKCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZUN1ZXMocmVzcG9uc2VCb2R5LCB0cmFjayk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdHJhY2sudGVjaF8ub24oJ3Z0dGpzbG9hZGVkJywgbG9hZEhhbmRsZXIpO1xuICAgICAgICB0cmFjay50ZWNoXy5vbigndnR0anNlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBsb2ckMS5lcnJvcigndnR0anMgZmFpbGVkIHRvIGxvYWQsIHN0b3BwaW5nIHRyeWluZyB0byBwcm9jZXNzICcgKyB0cmFjay5zcmMpO1xuICAgICAgICAgIHRyYWNrLnRlY2hfLm9mZigndnR0anNsb2FkZWQnLCBsb2FkSGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZUN1ZXMocmVzcG9uc2VCb2R5LCB0cmFjayk7XG4gICAgfVxuICB9KSk7XG59O1xuXG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgYFRleHRUcmFja2AuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja31cbiAqIEBleHRlbmRzIFRyYWNrXG4gKi9cblxudmFyIFRleHRUcmFjayA9IGZ1bmN0aW9uIChfVHJhY2spIHtcbiAgaW5oZXJpdHMoVGV4dFRyYWNrLCBfVHJhY2spO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnM9e31cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h9IG9wdGlvbnMudGVjaFxuICAgKiAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRlY2ggdGhhdCBvd25zIHRoaXMgVGV4dFRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35LaW5kfSBbb3B0aW9ucy5raW5kPSdzdWJ0aXRsZXMnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0ZXh0IHRyYWNrIGtpbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfk1vZGV9IFtvcHRpb25zLm1vZGU9J2Rpc2FibGVkJ11cbiAgICogICAgICAgIEEgdmFsaWQgdGV4dCB0cmFjayBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWQ9J3Zqc190cmFja18nICsgR3VpZC5uZXdHVUlEKCldXG4gICAqICAgICAgICBBIHVuaXF1ZSBpZCBmb3IgdGhpcyBUZXh0VHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbD0nJ11cbiAgICogICAgICAgIFRoZSBtZW51IGxhYmVsIGZvciB0aGlzIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2U9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY2xhbmc9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS4gQW4gYWx0ZXJuYXRpdmUsIGJ1dCBkZXByaW9yaXRpemVkXG4gICAqICAgICAgICB2ZXNpb24gb2YgYG9wdGlvbnMubGFuZ3VhZ2VgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zcmNdXG4gICAqICAgICAgICBBIHVybCB0byBUZXh0VHJhY2sgY3Vlcy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kZWZhdWx0XVxuICAgKiAgICAgICAgSWYgdGhpcyB0cmFjayBzaG91bGQgZGVmYXVsdCB0byBvbiBvciBvZmYuXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2soKSB7XG4gICAgdmFyIF90aGlzLCBfcmV0O1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFjayk7XG5cbiAgICBpZiAoIW9wdGlvbnMudGVjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHRlY2ggd2FzIG5vdCBwcm92aWRlZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgc2V0dGluZ3MgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAga2luZDogVGV4dFRyYWNrS2luZFtvcHRpb25zLmtpbmRdIHx8ICdzdWJ0aXRsZXMnLFxuICAgICAgbGFuZ3VhZ2U6IG9wdGlvbnMubGFuZ3VhZ2UgfHwgb3B0aW9ucy5zcmNsYW5nIHx8ICcnXG4gICAgfSk7XG4gICAgdmFyIG1vZGUgPSBUZXh0VHJhY2tNb2RlW3NldHRpbmdzLm1vZGVdIHx8ICdkaXNhYmxlZCc7XG4gICAgdmFyIGRlZmF1bHRfID0gc2V0dGluZ3NbJ2RlZmF1bHQnXTtcblxuICAgIGlmIChzZXR0aW5ncy5raW5kID09PSAnbWV0YWRhdGEnIHx8IHNldHRpbmdzLmtpbmQgPT09ICdjaGFwdGVycycpIHtcbiAgICAgIG1vZGUgPSAnaGlkZGVuJztcbiAgICB9XG4gICAgLy8gb24gSUU4IHRoaXMgd2lsbCBiZSBhIGRvY3VtZW50IGVsZW1lbnRcbiAgICAvLyBmb3IgZXZlcnkgb3RoZXIgYnJvd3NlciB0aGlzIHdpbGwgYmUgYSBub3JtYWwgb2JqZWN0XG4gICAgdmFyIHR0ID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2suY2FsbCh0aGlzLCBzZXR0aW5ncykpLCBfdGhpcyk7XG5cbiAgICB0dC50ZWNoXyA9IHNldHRpbmdzLnRlY2g7XG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRleHRUcmFjay5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0dFtwcm9wXSA9IFRleHRUcmFjay5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0dC5jdWVzXyA9IFtdO1xuICAgIHR0LmFjdGl2ZUN1ZXNfID0gW107XG5cbiAgICB2YXIgY3VlcyA9IG5ldyBUZXh0VHJhY2tDdWVMaXN0KHR0LmN1ZXNfKTtcbiAgICB2YXIgYWN0aXZlQ3VlcyA9IG5ldyBUZXh0VHJhY2tDdWVMaXN0KHR0LmFjdGl2ZUN1ZXNfKTtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciB0aW1ldXBkYXRlSGFuZGxlciA9IGJpbmQodHQsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gQWNjZXNzaW5nIHRoaXMuYWN0aXZlQ3VlcyBmb3IgdGhlIHNpZGUtZWZmZWN0cyBvZiB1cGRhdGluZyBpdHNlbGZcbiAgICAgIC8vIGR1ZSB0byBpdCdzIG5hdHVyZSBhcyBhIGdldHRlciBmdW5jdGlvbi4gRG8gbm90IHJlbW92ZSBvciBjdWVzIHdpbGxcbiAgICAgIC8vIHN0b3AgdXBkYXRpbmchXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICAgIHRoaXMuYWN0aXZlQ3VlcztcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2N1ZWNoYW5nZScpO1xuICAgICAgICBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobW9kZSAhPT0gJ2Rpc2FibGVkJykge1xuICAgICAgdHQudGVjaF8ucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB0dC50ZWNoXy5vbigndGltZXVwZGF0ZScsIHRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgICAgIH0sIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBkZWZhdWx0XG4gICAgICogICAgICAgICBJZiB0aGlzIHRyYWNrIHdhcyBzZXQgdG8gYmUgb24gb3Igb2ZmIGJ5IGRlZmF1bHQuIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyXG4gICAgICogICAgICAgICBjcmVhdGlvbi5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ2RlZmF1bHQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRfO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKCkge31cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG1vZGVcbiAgICAgKiAgICAgICAgIFNldCB0aGUgbW9kZSBvZiB0aGlzIFRleHRUcmFjayB0byBhIHZhbGlkIHtAbGluayBUZXh0VHJhY2t+TW9kZX0uIFdpbGxcbiAgICAgKiAgICAgICAgIG5vdCBiZSBzZXQgaWYgc2V0dGluZyB0byBhbiBpbnZhbGlkIG1vZGUuXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZmlyZXMgVGV4dFRyYWNrI21vZGVjaGFuZ2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdtb2RlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBtb2RlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKG5ld01vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFUZXh0VHJhY2tNb2RlW25ld01vZGVdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1vZGUgPSBuZXdNb2RlO1xuICAgICAgICBpZiAobW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG5cbiAgICAgICAgICB0aGlzLnRlY2hfLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi50ZWNoXy5vbigndGltZXVwZGF0ZScsIHRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZXZlbnQgdGhhdCBmaXJlcyB3aGVuIG1vZGUgY2hhbmdlcyBvbiB0aGlzIHRyYWNrLiBUaGlzIGFsbG93c1xuICAgICAgICAgKiB0aGUgVGV4dFRyYWNrTGlzdCB0aGF0IGhvbGRzIHRoaXMgdHJhY2sgdG8gYWN0IGFjY29yZGluZ2x5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IE5vdGU6IFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHNwZWMhXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBUZXh0VHJhY2sjbW9kZWNoYW5nZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ21vZGVjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tcbiAgICAgKiBAbWVtYmVyIHtUZXh0VHJhY2tDdWVMaXN0fSBjdWVzXG4gICAgICogICAgICAgICBUaGUgdGV4dCB0cmFjayBjdWUgbGlzdCBmb3IgdGhpcyBUZXh0VHJhY2suXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnY3VlcycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkXykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1ZXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoKSB7fVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRleHRUcmFja1xuICAgICAqIEBtZW1iZXIge1RleHRUcmFja0N1ZUxpc3R9IGFjdGl2ZUN1ZXNcbiAgICAgKiAgICAgICAgIFRoZSBsaXN0IHRleHQgdHJhY2sgY3VlcyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlIGZvciB0aGlzIFRleHRUcmFjay5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdhY3RpdmVDdWVzJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2FkZWRfKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgIGlmICh0aGlzLmN1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZUN1ZXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3QgPSB0aGlzLnRlY2hfLmN1cnJlbnRUaW1lKCk7XG4gICAgICAgIHZhciBhY3RpdmUgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuY3Vlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgY3VlID0gdGhpcy5jdWVzW2ldO1xuXG4gICAgICAgICAgaWYgKGN1ZS5zdGFydFRpbWUgPD0gY3QgJiYgY3VlLmVuZFRpbWUgPj0gY3QpIHtcbiAgICAgICAgICAgIGFjdGl2ZS5wdXNoKGN1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdWUuc3RhcnRUaW1lID09PSBjdWUuZW5kVGltZSAmJiBjdWUuc3RhcnRUaW1lIDw9IGN0ICYmIGN1ZS5zdGFydFRpbWUgKyAwLjUgPj0gY3QpIHtcbiAgICAgICAgICAgIGFjdGl2ZS5wdXNoKGN1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoICE9PSB0aGlzLmFjdGl2ZUN1ZXNfLmxlbmd0aCkge1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhY3RpdmUubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVDdWVzXy5pbmRleE9mKGFjdGl2ZVtfaV0pID09PSAtMSkge1xuICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdGl2ZUN1ZXNfID0gYWN0aXZlO1xuICAgICAgICBhY3RpdmVDdWVzLnNldEN1ZXNfKHRoaXMuYWN0aXZlQ3Vlc18pO1xuXG4gICAgICAgIHJldHVybiBhY3RpdmVDdWVzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKCkge31cbiAgICB9KTtcblxuICAgIGlmIChzZXR0aW5ncy5zcmMpIHtcbiAgICAgIHR0LnNyYyA9IHNldHRpbmdzLnNyYztcbiAgICAgIGxvYWRUcmFjayhzZXR0aW5ncy5zcmMsIHR0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHQubG9hZGVkXyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSB0dCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgY3VlIHRvIHRoZSBpbnRlcm5hbCBsaXN0IG9mIGN1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfkN1ZX0gY3VlXG4gICAqICAgICAgICBUaGUgY3VlIHRvIGFkZCB0byBvdXIgaW50ZXJuYWwgbGlzdFxuICAgKi9cblxuXG4gIFRleHRUcmFjay5wcm90b3R5cGUuYWRkQ3VlID0gZnVuY3Rpb24gYWRkQ3VlKG9yaWdpbmFsQ3VlKSB7XG4gICAgdmFyIGN1ZSA9IG9yaWdpbmFsQ3VlO1xuXG4gICAgaWYgKHdpbmRvdy52dHRqcyAmJiAhKG9yaWdpbmFsQ3VlIGluc3RhbmNlb2Ygd2luZG93LnZ0dGpzLlZUVEN1ZSkpIHtcbiAgICAgIGN1ZSA9IG5ldyB3aW5kb3cudnR0anMuVlRUQ3VlKG9yaWdpbmFsQ3VlLnN0YXJ0VGltZSwgb3JpZ2luYWxDdWUuZW5kVGltZSwgb3JpZ2luYWxDdWUudGV4dCk7XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gb3JpZ2luYWxDdWUpIHtcbiAgICAgICAgaWYgKCEocHJvcCBpbiBjdWUpKSB7XG4gICAgICAgICAgY3VlW3Byb3BdID0gb3JpZ2luYWxDdWVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgYGlkYCBpcyBjb3BpZWQgb3ZlclxuICAgICAgY3VlLmlkID0gb3JpZ2luYWxDdWUuaWQ7XG4gICAgICBjdWUub3JpZ2luYWxDdWVfID0gb3JpZ2luYWxDdWU7XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrcyA9IHRoaXMudGVjaF8udGV4dFRyYWNrcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmFja3NbaV0gIT09IHRoaXMpIHtcbiAgICAgICAgdHJhY2tzW2ldLnJlbW92ZUN1ZShjdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY3Vlc18ucHVzaChjdWUpO1xuICAgIHRoaXMuY3Vlcy5zZXRDdWVzXyh0aGlzLmN1ZXNfKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgY3VlIGZyb20gb3VyIGludGVybmFsIGxpc3RcbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+Q3VlfSByZW1vdmVDdWVcbiAgICogICAgICAgIFRoZSBjdWUgdG8gcmVtb3ZlIGZyb20gb3VyIGludGVybmFsIGxpc3RcbiAgICovXG5cblxuICBUZXh0VHJhY2sucHJvdG90eXBlLnJlbW92ZUN1ZSA9IGZ1bmN0aW9uIHJlbW92ZUN1ZShfcmVtb3ZlQ3VlKSB7XG4gICAgdmFyIGkgPSB0aGlzLmN1ZXNfLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBjdWUgPSB0aGlzLmN1ZXNfW2ldO1xuXG4gICAgICBpZiAoY3VlID09PSBfcmVtb3ZlQ3VlIHx8IGN1ZS5vcmlnaW5hbEN1ZV8gJiYgY3VlLm9yaWdpbmFsQ3VlXyA9PT0gX3JlbW92ZUN1ZSkge1xuICAgICAgICB0aGlzLmN1ZXNfLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5jdWVzLnNldEN1ZXNfKHRoaXMuY3Vlc18pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFjaztcbn0oVHJhY2spO1xuXG4vKipcbiAqIGN1ZWNoYW5nZSAtIE9uZSBvciBtb3JlIGN1ZXMgaW4gdGhlIHRyYWNrIGhhdmUgYmVjb21lIGFjdGl2ZSBvciBzdG9wcGVkIGJlaW5nIGFjdGl2ZS5cbiAqL1xuXG5cblRleHRUcmFjay5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7XG4gIGN1ZWNoYW5nZTogJ2N1ZWNoYW5nZSdcbn07XG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBgQXVkaW9UcmFja2AuIElmIGl0IGlzIHBhcnQgb2YgYW4ge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fVxuICogb25seSBvbmUgYEF1ZGlvVHJhY2tgIGluIHRoZSBsaXN0IHdpbGwgYmUgZW5hYmxlZCBhdCBhIHRpbWUuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2F1ZGlvdHJhY2t9XG4gKiBAZXh0ZW5kcyBUcmFja1xuICovXG5cbnZhciBBdWRpb1RyYWNrID0gZnVuY3Rpb24gKF9UcmFjaykge1xuICBpbmhlcml0cyhBdWRpb1RyYWNrLCBfVHJhY2spO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXG4gICAqXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja35LaW5kfSBbb3B0aW9ucy5raW5kPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCBhdWRpbyB0cmFjayBraW5kXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZD0ndmpzX3RyYWNrXycgKyBHdWlkLm5ld0dVSUQoKV1cbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIEF1ZGlvVHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbD0nJ11cbiAgICogICAgICAgIFRoZSBtZW51IGxhYmVsIGZvciB0aGlzIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2U9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVkXVxuICAgKiAgICAgICAgSWYgdGhpcyB0cmFjayBpcyB0aGUgb25lIHRoYXQgaXMgY3VycmVudGx5IHBsYXlpbmcuIElmIHRoaXMgdHJhY2sgaXMgcGFydCBvZlxuICAgKiAgICAgICAgYW4ge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fSwgb25seSBvbmUge0BsaW5rIEF1ZGlvVHJhY2t9IHdpbGwgYmUgZW5hYmxlZC5cbiAgICovXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2soKSB7XG4gICAgdmFyIF90aGlzLCBfcmV0O1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvVHJhY2spO1xuXG4gICAgdmFyIHNldHRpbmdzID0gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIGtpbmQ6IEF1ZGlvVHJhY2tLaW5kW29wdGlvbnMua2luZF0gfHwgJydcbiAgICB9KTtcbiAgICAvLyBvbiBJRTggdGhpcyB3aWxsIGJlIGEgZG9jdW1lbnQgZWxlbWVudFxuICAgIC8vIGZvciBldmVyeSBvdGhlciBicm93c2VyIHRoaXMgd2lsbCBiZSBhIG5vcm1hbCBvYmplY3RcbiAgICB2YXIgdHJhY2sgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFjay5jYWxsKHRoaXMsIHNldHRpbmdzKSksIF90aGlzKTtcbiAgICB2YXIgZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBBdWRpb1RyYWNrLnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRyYWNrW3Byb3BdID0gQXVkaW9UcmFjay5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIEF1ZGlvVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBlbmFibGVkXG4gICAgICogICAgICAgICBJZiB0aGlzIGBBdWRpb1RyYWNrYCBpcyBlbmFibGVkIG9yIG5vdC4gV2hlbiBzZXR0aW5nIHRoaXMgd2lsbFxuICAgICAqICAgICAgICAgZmlyZSB7QGxpbmsgQXVkaW9UcmFjayNlbmFibGVkY2hhbmdlfSBpZiB0aGUgc3RhdGUgb2YgZW5hYmxlZCBpcyBjaGFuZ2VkLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGZpcmVzIFZpZGVvVHJhY2sjc2VsZWN0ZWRjaGFuZ2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2ssICdlbmFibGVkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBlbmFibGVkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKG5ld0VuYWJsZWQpIHtcbiAgICAgICAgLy8gYW4gaW52YWxpZCBvciB1bmNoYW5nZWQgdmFsdWVcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdFbmFibGVkICE9PSAnYm9vbGVhbicgfHwgbmV3RW5hYmxlZCA9PT0gZW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbmFibGVkID0gbmV3RW5hYmxlZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZXZlbnQgdGhhdCBmaXJlcyB3aGVuIGVuYWJsZWQgY2hhbmdlcyBvbiB0aGlzIHRyYWNrLiBUaGlzIGFsbG93c1xuICAgICAgICAgKiB0aGUgQXVkaW9UcmFja0xpc3QgdGhhdCBob2xkcyB0aGlzIHRyYWNrIHRvIGFjdCBhY2NvcmRpbmdseS5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBOb3RlOiBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzcGVjISBOYXRpdmUgdHJhY2tzIHdpbGwgZG9cbiAgICAgICAgICogICAgICAgICB0aGlzIGludGVybmFsbHkgd2l0aG91dCBhbiBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IEF1ZGlvVHJhY2sjZW5hYmxlZGNoYW5nZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2VuYWJsZWRjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIHRoZSB1c2VyIHNldHMgdGhpcyB0cmFjayB0byBzZWxlY3RlZCB0aGVuXG4gICAgLy8gc2V0IHNlbGVjdGVkIHRvIHRoYXQgdHJ1ZSB2YWx1ZSBvdGhlcndpc2VcbiAgICAvLyB3ZSBrZWVwIGl0IGZhbHNlXG4gICAgaWYgKHNldHRpbmdzLmVuYWJsZWQpIHtcbiAgICAgIHRyYWNrLmVuYWJsZWQgPSBzZXR0aW5ncy5lbmFibGVkO1xuICAgIH1cbiAgICB0cmFjay5sb2FkZWRfID0gdHJ1ZTtcblxuICAgIHJldHVybiBfcmV0ID0gdHJhY2ssIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2s7XG59KFRyYWNrKTtcblxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGBWaWRlb1RyYWNrYC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdmlkZW90cmFja31cbiAqIEBleHRlbmRzIFRyYWNrXG4gKi9cblxudmFyIFZpZGVvVHJhY2sgPSBmdW5jdGlvbiAoX1RyYWNrKSB7XG4gIGluaGVyaXRzKFZpZGVvVHJhY2ssIF9UcmFjayk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmtpbmQ9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHtAbGluayBWaWRlb1RyYWNrfktpbmR9XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZD0ndmpzX3RyYWNrXycgKyBHdWlkLm5ld0dVSUQoKV1cbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIEF1ZGlvVHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbD0nJ11cbiAgICogICAgICAgIFRoZSBtZW51IGxhYmVsIGZvciB0aGlzIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2U9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWxlY3RlZF1cbiAgICogICAgICAgIElmIHRoaXMgdHJhY2sgaXMgdGhlIG9uZSB0aGF0IGlzIGN1cnJlbnRseSBwbGF5aW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gVmlkZW9UcmFjaygpIHtcbiAgICB2YXIgX3RoaXMsIF9yZXQ7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlkZW9UcmFjayk7XG5cbiAgICB2YXIgc2V0dGluZ3MgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAga2luZDogVmlkZW9UcmFja0tpbmRbb3B0aW9ucy5raW5kXSB8fCAnJ1xuICAgIH0pO1xuXG4gICAgLy8gb24gSUU4IHRoaXMgd2lsbCBiZSBhIGRvY3VtZW50IGVsZW1lbnRcbiAgICAvLyBmb3IgZXZlcnkgb3RoZXIgYnJvd3NlciB0aGlzIHdpbGwgYmUgYSBub3JtYWwgb2JqZWN0XG4gICAgdmFyIHRyYWNrID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2suY2FsbCh0aGlzLCBzZXR0aW5ncykpLCBfdGhpcyk7XG4gICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFZpZGVvVHJhY2sucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdHJhY2tbcHJvcF0gPSBWaWRlb1RyYWNrLnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBWaWRlb1RyYWNrXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiAgICAgICAgIElmIHRoaXMgYFZpZGVvVHJhY2tgIGlzIHNlbGVjdGVkIG9yIG5vdC4gV2hlbiBzZXR0aW5nIHRoaXMgd2lsbFxuICAgICAqICAgICAgICAgZmlyZSB7QGxpbmsgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZX0gaWYgdGhlIHN0YXRlIG9mIHNlbGVjdGVkIGNoYW5nZWQuXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZmlyZXMgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmFjaywgJ3NlbGVjdGVkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShuZXdTZWxlY3RlZCkge1xuICAgICAgICAvLyBhbiBpbnZhbGlkIG9yIHVuY2hhbmdlZCB2YWx1ZVxuICAgICAgICBpZiAodHlwZW9mIG5ld1NlbGVjdGVkICE9PSAnYm9vbGVhbicgfHwgbmV3U2VsZWN0ZWQgPT09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGVkID0gbmV3U2VsZWN0ZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV2ZW50IHRoYXQgZmlyZXMgd2hlbiBzZWxlY3RlZCBjaGFuZ2VzIG9uIHRoaXMgdHJhY2suIFRoaXMgYWxsb3dzXG4gICAgICAgICAqIHRoZSBWaWRlb1RyYWNrTGlzdCB0aGF0IGhvbGRzIHRoaXMgdHJhY2sgdG8gYWN0IGFjY29yZGluZ2x5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IE5vdGU6IFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHNwZWMhIE5hdGl2ZSB0cmFja3Mgd2lsbCBkb1xuICAgICAgICAgKiAgICAgICAgIHRoaXMgaW50ZXJuYWxseSB3aXRob3V0IGFuIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdGVkY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBpZiB0aGUgdXNlciBzZXRzIHRoaXMgdHJhY2sgdG8gc2VsZWN0ZWQgdGhlblxuICAgIC8vIHNldCBzZWxlY3RlZCB0byB0aGF0IHRydWUgdmFsdWUgb3RoZXJ3aXNlXG4gICAgLy8gd2Uga2VlcCBpdCBmYWxzZVxuICAgIGlmIChzZXR0aW5ncy5zZWxlY3RlZCkge1xuICAgICAgdHJhY2suc2VsZWN0ZWQgPSBzZXR0aW5ncy5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IHRyYWNrLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIHJldHVybiBWaWRlb1RyYWNrO1xufShUcmFjayk7XG5cbi8qKlxuICogQGZpbGUgaHRtbC10cmFjay1lbGVtZW50LmpzXG4gKi9cblxuLyoqXG4gKiBAbWVtYmVyb2YgSFRNTFRyYWNrRWxlbWVudFxuICogQHR5cGVkZWYge0hUTUxUcmFja0VsZW1lbnR+UmVhZHlTdGF0ZX1cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbnZhciBOT05FID0gMDtcbnZhciBMT0FESU5HID0gMTtcbnZhciBMT0FERUQgPSAyO1xudmFyIEVSUk9SID0gMztcblxuLyoqXG4gKiBBIHNpbmdsZSB0cmFjayByZXByZXNlbnRlZCBpbiB0aGUgRE9NLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNodG1sdHJhY2tlbGVtZW50fVxuICogQGV4dGVuZHMgRXZlbnRUYXJnZXRcbiAqL1xuXG52YXIgSFRNTFRyYWNrRWxlbWVudCA9IGZ1bmN0aW9uIChfRXZlbnRUYXJnZXQpIHtcbiAgaW5oZXJpdHMoSFRNTFRyYWNrRWxlbWVudCwgX0V2ZW50VGFyZ2V0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zPXt9XG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtUZWNofSBvcHRpb25zLnRlY2hcbiAgICogICAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0ZWNoIHRoYXQgb3ducyB0aGlzIEhUTUxUcmFja0VsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfktpbmR9IFtvcHRpb25zLmtpbmQ9J3N1YnRpdGxlcyddXG4gICAqICAgICAgICBBIHZhbGlkIHRleHQgdHJhY2sga2luZC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+TW9kZX0gW29wdGlvbnMubW9kZT0nZGlzYWJsZWQnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0ZXh0IHRyYWNrIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZD0ndmpzX3RyYWNrXycgKyBHdWlkLm5ld0dVSUQoKV1cbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIFRleHRUcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsPScnXVxuICAgKiAgICAgICAgVGhlIG1lbnUgbGFiZWwgZm9yIHRoaXMgdHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3JjbGFuZz0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLiBBbiBhbHRlcm5hdGl2ZSwgYnV0IGRlcHJpb3JpdGl6ZWRcbiAgICogICAgICAgIHZlc2lvbiBvZiBgb3B0aW9ucy5sYW5ndWFnZWBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY11cbiAgICogICAgICAgIEEgdXJsIHRvIFRleHRUcmFjayBjdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmF1bHRdXG4gICAqICAgICAgICBJZiB0aGlzIHRyYWNrIHNob3VsZCBkZWZhdWx0IHRvIG9uIG9yIG9mZi5cbiAgICovXG4gIGZ1bmN0aW9uIEhUTUxUcmFja0VsZW1lbnQoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEhUTUxUcmFja0VsZW1lbnQpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRUYXJnZXQuY2FsbCh0aGlzKSk7XG5cbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHZvaWQgMDtcbiAgICB2YXIgdHJhY2tFbGVtZW50ID0gX3RoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIHRyYWNrRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIEhUTUxUcmFja0VsZW1lbnQucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdHJhY2tFbGVtZW50W3Byb3BdID0gSFRNTFRyYWNrRWxlbWVudC5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJhY2sgPSBuZXcgVGV4dFRyYWNrKG9wdGlvbnMpO1xuXG4gICAgdHJhY2tFbGVtZW50LmtpbmQgPSB0cmFjay5raW5kO1xuICAgIHRyYWNrRWxlbWVudC5zcmMgPSB0cmFjay5zcmM7XG4gICAgdHJhY2tFbGVtZW50LnNyY2xhbmcgPSB0cmFjay5sYW5ndWFnZTtcbiAgICB0cmFja0VsZW1lbnQubGFiZWwgPSB0cmFjay5sYWJlbDtcbiAgICB0cmFja0VsZW1lbnRbJ2RlZmF1bHQnXSA9IHRyYWNrWydkZWZhdWx0J107XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgSFRNTFRyYWNrRWxlbWVudFxuICAgICAqIEBtZW1iZXIge0hUTUxUcmFja0VsZW1lbnR+UmVhZHlTdGF0ZX0gcmVhZHlTdGF0ZVxuICAgICAqICAgICAgICAgVGhlIGN1cnJlbnQgcmVhZHkgc3RhdGUgb2YgdGhlIHRyYWNrIGVsZW1lbnQuXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrRWxlbWVudCwgJ3JlYWR5U3RhdGUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHJlYWR5U3RhdGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgSFRNTFRyYWNrRWxlbWVudFxuICAgICAqIEBtZW1iZXIge1RleHRUcmFja30gdHJhY2tcbiAgICAgKiAgICAgICAgIFRoZSB1bmRlcmx5aW5nIFRleHRUcmFjayBvYmplY3QuXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2tFbGVtZW50LCAndHJhY2snLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhZHlTdGF0ZSA9IE5PTkU7XG5cbiAgICAvKipcbiAgICAgKiBAbGlzdGVucyBUZXh0VHJhY2sjbG9hZGVkZGF0YVxuICAgICAqIEBmaXJlcyBIVE1MVHJhY2tFbGVtZW50I2xvYWRcbiAgICAgKi9cbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmVhZHlTdGF0ZSA9IExPQURFRDtcblxuICAgICAgdHJhY2tFbGVtZW50LnRyaWdnZXIoe1xuICAgICAgICB0eXBlOiAnbG9hZCcsXG4gICAgICAgIHRhcmdldDogdHJhY2tFbGVtZW50XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIHZhciBfcmV0O1xuXG4gICAgICByZXR1cm4gX3JldCA9IHRyYWNrRWxlbWVudCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBIVE1MVHJhY2tFbGVtZW50O1xufShFdmVudFRhcmdldCk7XG5cbkhUTUxUcmFja0VsZW1lbnQucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge1xuICBsb2FkOiAnbG9hZCdcbn07XG5cbkhUTUxUcmFja0VsZW1lbnQuTk9ORSA9IE5PTkU7XG5IVE1MVHJhY2tFbGVtZW50LkxPQURJTkcgPSBMT0FESU5HO1xuSFRNTFRyYWNrRWxlbWVudC5MT0FERUQgPSBMT0FERUQ7XG5IVE1MVHJhY2tFbGVtZW50LkVSUk9SID0gRVJST1I7XG5cbi8qXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgYWxsIHRyYWNrIHByb3BlcnRpZXMgdGhhdCBhcmUgdXNlZCBpblxuICogcGxheWVyLmpzLCB0ZWNoLmpzLCBodG1sNS5qcyBhbmQgcG9zc2libHkgb3RoZXIgdGVjaHMgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuXG52YXIgTk9STUFMID0ge1xuICBhdWRpbzoge1xuICAgIExpc3RDbGFzczogQXVkaW9UcmFja0xpc3QsXG4gICAgVHJhY2tDbGFzczogQXVkaW9UcmFjayxcbiAgICBjYXBpdGFsTmFtZTogJ0F1ZGlvJ1xuICB9LFxuICB2aWRlbzoge1xuICAgIExpc3RDbGFzczogVmlkZW9UcmFja0xpc3QsXG4gICAgVHJhY2tDbGFzczogVmlkZW9UcmFjayxcbiAgICBjYXBpdGFsTmFtZTogJ1ZpZGVvJ1xuICB9LFxuICB0ZXh0OiB7XG4gICAgTGlzdENsYXNzOiBUZXh0VHJhY2tMaXN0LFxuICAgIFRyYWNrQ2xhc3M6IFRleHRUcmFjayxcbiAgICBjYXBpdGFsTmFtZTogJ1RleHQnXG4gIH1cbn07XG5cbk9iamVjdC5rZXlzKE5PUk1BTCkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBOT1JNQUxbdHlwZV0uZ2V0dGVyTmFtZSA9IHR5cGUgKyAnVHJhY2tzJztcbiAgTk9STUFMW3R5cGVdLnByaXZhdGVOYW1lID0gdHlwZSArICdUcmFja3NfJztcbn0pO1xuXG52YXIgUkVNT1RFID0ge1xuICByZW1vdGVUZXh0OiB7XG4gICAgTGlzdENsYXNzOiBUZXh0VHJhY2tMaXN0LFxuICAgIFRyYWNrQ2xhc3M6IFRleHRUcmFjayxcbiAgICBjYXBpdGFsTmFtZTogJ1JlbW90ZVRleHQnLFxuICAgIGdldHRlck5hbWU6ICdyZW1vdGVUZXh0VHJhY2tzJyxcbiAgICBwcml2YXRlTmFtZTogJ3JlbW90ZVRleHRUcmFja3NfJ1xuICB9LFxuICByZW1vdGVUZXh0RWw6IHtcbiAgICBMaXN0Q2xhc3M6IEh0bWxUcmFja0VsZW1lbnRMaXN0LFxuICAgIFRyYWNrQ2xhc3M6IEhUTUxUcmFja0VsZW1lbnQsXG4gICAgY2FwaXRhbE5hbWU6ICdSZW1vdGVUZXh0VHJhY2tFbHMnLFxuICAgIGdldHRlck5hbWU6ICdyZW1vdGVUZXh0VHJhY2tFbHMnLFxuICAgIHByaXZhdGVOYW1lOiAncmVtb3RlVGV4dFRyYWNrRWxzXydcbiAgfVxufTtcblxudmFyIEFMTCA9IG1lcmdlT3B0aW9ucyhOT1JNQUwsIFJFTU9URSk7XG5cblJFTU9URS5uYW1lcyA9IE9iamVjdC5rZXlzKFJFTU9URSk7XG5OT1JNQUwubmFtZXMgPSBPYmplY3Qua2V5cyhOT1JNQUwpO1xuQUxMLm5hbWVzID0gW10uY29uY2F0KFJFTU9URS5uYW1lcykuY29uY2F0KE5PUk1BTC5uYW1lcyk7XG5cbi8qKlxuICogQGZpbGUgdGVjaC5qc1xuICovXG5cbi8qKlxuICogQW4gT2JqZWN0IGNvbnRhaW5pbmcgYSBzdHJ1Y3R1cmUgbGlrZTogYHtzcmM6ICd1cmwnLCB0eXBlOiAnbWltZXR5cGUnfWAgb3Igc3RyaW5nXG4gKiB0aGF0IGp1c3QgY29udGFpbnMgdGhlIHNyYyB1cmwgYWxvbmUuXG4gKiAqIGB2YXIgU291cmNlT2JqZWN0ID0ge3NyYzogJ2h0dHA6Ly9leC5jb20vdmlkZW8ubXA0JywgdHlwZTogJ3ZpZGVvL21wNCd9O2BcbiAgICogYHZhciBTb3VyY2VTdHJpbmcgPSAnaHR0cDovL2V4YW1wbGUuY29tL3NvbWUtdmlkZW8ubXA0JztgXG4gKlxuICogQHR5cGVkZWYge09iamVjdHxzdHJpbmd9IFRlY2h+U291cmNlT2JqZWN0XG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNyY1xuICogICAgICAgICAgIFRoZSB1cmwgdG8gdGhlIHNvdXJjZVxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgICAgVGhlIG1pbWUgdHlwZSBvZiB0aGUgc291cmNlXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHVzZWQgYnkge0BsaW5rIFRlY2h9IHRvIGNyZWF0ZSBhIG5ldyB7QGxpbmsgVGV4dFRyYWNrfS5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VGVjaH0gc2VsZlxuICogICAgICAgIEFuIGluc3RhbmNlIG9mIHRoZSBUZWNoIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXG4gKiAgICAgICAgYFRleHRUcmFja2Aga2luZCAoc3VidGl0bGVzLCBjYXB0aW9ucywgZGVzY3JpcHRpb25zLCBjaGFwdGVycywgb3IgbWV0YWRhdGEpXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtsYWJlbF1cbiAqICAgICAgICBMYWJlbCB0byBpZGVudGlmeSB0aGUgdGV4dCB0cmFja1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2VdXG4gKiAgICAgICAgVHdvIGxldHRlciBsYW5ndWFnZSBhYmJyZXZpYXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gKiAgICAgICAgQW4gb2JqZWN0IHdpdGggYWRkaXRpb25hbCB0ZXh0IHRyYWNrIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuIHtUZXh0VHJhY2t9XG4gKiAgICAgICAgICBUaGUgdGV4dCB0cmFjayB0aGF0IHdhcyBjcmVhdGVkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFja0hlbHBlcihzZWxmLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuXG4gIHZhciB0cmFja3MgPSBzZWxmLnRleHRUcmFja3MoKTtcblxuICBvcHRpb25zLmtpbmQgPSBraW5kO1xuXG4gIGlmIChsYWJlbCkge1xuICAgIG9wdGlvbnMubGFiZWwgPSBsYWJlbDtcbiAgfVxuICBpZiAobGFuZ3VhZ2UpIHtcbiAgICBvcHRpb25zLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gIH1cbiAgb3B0aW9ucy50ZWNoID0gc2VsZjtcblxuICB2YXIgdHJhY2sgPSBuZXcgQUxMLnRleHQuVHJhY2tDbGFzcyhvcHRpb25zKTtcblxuICB0cmFja3MuYWRkVHJhY2sodHJhY2spO1xuXG4gIHJldHVybiB0cmFjaztcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBtZWRpYSBwbGF5YmFjayB0ZWNobm9sb2d5IGNvbnRyb2xsZXJzLCBzdWNoIGFzXG4gKiB7QGxpbmsgRmxhc2h9IGFuZCB7QGxpbmsgSFRNTDV9XG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFRlY2ggPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhUZWNoLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgVGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gcmVhZHlcbiAgICogICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgYEhUTUw1YCBUZWNoIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gVGVjaCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIHJlYWR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmdW5jdGlvbiAoKSB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZWNoKTtcblxuICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHRlY2ggdG8gcmVwb3J0IHVzZXIgYWN0aXZpdHkgYXV0b21hdGljYWxseS5cbiAgICAvLyBUaGlzIGlzIGRvbmUgbWFudWFsbHkgaW4gYWRkQ29udHJvbHNMaXN0ZW5lcnNcbiAgICBvcHRpb25zLnJlcG9ydFRvdWNoQWN0aXZpdHkgPSBmYWxzZTtcblxuICAgIC8vIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGUgY3VycmVudCBzb3VyY2UgaGFzIHBsYXllZCBhdCBhbGwgdG9cbiAgICAvLyBpbXBsZW1lbnQgYSB2ZXJ5IGxpbWl0ZWQgcGxheWVkKClcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBudWxsLCBvcHRpb25zLCByZWFkeSkpO1xuXG4gICAgX3RoaXMuaGFzU3RhcnRlZF8gPSBmYWxzZTtcbiAgICBfdGhpcy5vbigncGxheWluZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaGFzU3RhcnRlZF8gPSB0cnVlO1xuICAgIH0pO1xuICAgIF90aGlzLm9uKCdsb2Fkc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmhhc1N0YXJ0ZWRfID0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBBTEwubmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHByb3BzID0gQUxMW25hbWVdO1xuXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zW3Byb3BzLmdldHRlck5hbWVdKSB7XG4gICAgICAgIF90aGlzW3Byb3BzLnByaXZhdGVOYW1lXSA9IG9wdGlvbnNbcHJvcHMuZ2V0dGVyTmFtZV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBNYW51YWxseSB0cmFjayBwcm9ncmVzcyBpbiBjYXNlcyB3aGVyZSB0aGUgYnJvd3Nlci9mbGFzaCBwbGF5ZXIgZG9lc24ndCByZXBvcnQgaXQuXG4gICAgaWYgKCFfdGhpcy5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzKSB7XG4gICAgICBfdGhpcy5tYW51YWxQcm9ncmVzc09uKCk7XG4gICAgfVxuXG4gICAgLy8gTWFudWFsbHkgdHJhY2sgdGltZXVwZGF0ZXMgaW4gY2FzZXMgd2hlcmUgdGhlIGJyb3dzZXIvZmxhc2ggcGxheWVyIGRvZXNuJ3QgcmVwb3J0IGl0LlxuICAgIGlmICghX3RoaXMuZmVhdHVyZXNUaW1ldXBkYXRlRXZlbnRzKSB7XG4gICAgICBfdGhpcy5tYW51YWxUaW1lVXBkYXRlc09uKCk7XG4gICAgfVxuXG4gICAgWydUZXh0JywgJ0F1ZGlvJywgJ1ZpZGVvJ10uZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgIGlmIChvcHRpb25zWyduYXRpdmUnICsgdHJhY2sgKyAnVHJhY2tzJ10gPT09IGZhbHNlKSB7XG4gICAgICAgIF90aGlzWydmZWF0dXJlc05hdGl2ZScgKyB0cmFjayArICdUcmFja3MnXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMubmF0aXZlQ2FwdGlvbnMgPT09IGZhbHNlIHx8IG9wdGlvbnMubmF0aXZlVGV4dFRyYWNrcyA9PT0gZmFsc2UpIHtcbiAgICAgIF90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5uYXRpdmVDYXB0aW9ucyA9PT0gdHJ1ZSB8fCBvcHRpb25zLm5hdGl2ZVRleHRUcmFja3MgPT09IHRydWUpIHtcbiAgICAgIF90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFfdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIF90aGlzLmVtdWxhdGVUZXh0VHJhY2tzKCk7XG4gICAgfVxuXG4gICAgX3RoaXMuYXV0b1JlbW90ZVRleHRUcmFja3NfID0gbmV3IEFMTC50ZXh0Lkxpc3RDbGFzcygpO1xuXG4gICAgX3RoaXMuaW5pdFRyYWNrTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBUdXJuIG9uIGNvbXBvbmVudCB0YXAgZXZlbnRzIG9ubHkgaWYgbm90IHVzaW5nIG5hdGl2ZSBjb250cm9sc1xuICAgIGlmICghb3B0aW9ucy5uYXRpdmVDb250cm9sc0ZvclRvdWNoKSB7XG4gICAgICBfdGhpcy5lbWl0VGFwRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICBfdGhpcy5uYW1lXyA9IF90aGlzLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ1Vua25vd24gVGVjaCc7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qIEZhbGxiYWNrcyBmb3IgdW5zdXBwb3J0ZWQgZXZlbnQgdHlwZXNcbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAvKipcbiAgICogUG9seWZpbGwgdGhlIGBwcm9ncmVzc2AgZXZlbnQgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdCBuYXRpdmVseS5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgVGVjaCN0cmFja1Byb2dyZXNzfVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLm1hbnVhbFByb2dyZXNzT24gPSBmdW5jdGlvbiBtYW51YWxQcm9ncmVzc09uKCkge1xuICAgIHRoaXMub24oJ2R1cmF0aW9uY2hhbmdlJywgdGhpcy5vbkR1cmF0aW9uQ2hhbmdlKTtcblxuICAgIHRoaXMubWFudWFsUHJvZ3Jlc3MgPSB0cnVlO1xuXG4gICAgLy8gVHJpZ2dlciBwcm9ncmVzcyB3YXRjaGluZyB3aGVuIGEgc291cmNlIGJlZ2lucyBsb2FkaW5nXG4gICAgdGhpcy5vbmUoJ3JlYWR5JywgdGhpcy50cmFja1Byb2dyZXNzKTtcbiAgfTtcblxuICAvKipcbiAgICogVHVybiBvZmYgdGhlIHBvbHlmaWxsIGZvciBgcHJvZ3Jlc3NgIGV2ZW50cyB0aGF0IHdhcyBjcmVhdGVkIGluXG4gICAqIHtAbGluayBUZWNoI21hbnVhbFByb2dyZXNzT259XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUubWFudWFsUHJvZ3Jlc3NPZmYgPSBmdW5jdGlvbiBtYW51YWxQcm9ncmVzc09mZigpIHtcbiAgICB0aGlzLm1hbnVhbFByb2dyZXNzID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wVHJhY2tpbmdQcm9ncmVzcygpO1xuXG4gICAgdGhpcy5vZmYoJ2R1cmF0aW9uY2hhbmdlJywgdGhpcy5vbkR1cmF0aW9uQ2hhbmdlKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBpcyB1c2VkIHRvIHRyaWdnZXIgYSBgcHJvZ3Jlc3NgIGV2ZW50IHdoZW4gdGhlIGJ1ZmZlcmVkIHBlcmNlbnQgY2hhbmdlcy4gSXRcbiAgICogc2V0cyBhbiBpbnRlcnZhbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGV2ZXJ5IDUwMCBtaWxsaXNlY29uZHMgdG8gY2hlY2sgaWYgdGhlXG4gICAqIGJ1ZmZlciBlbmQgcGVyY2VudCBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogPiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSB7QGxpbmsgVGVjaCNtYW51YWxQcm9ncmVzc09ufVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGByZWFkeWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjcmVhZHlcbiAgICogQGZpcmVzIFRlY2gjcHJvZ3Jlc3NcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS50cmFja1Byb2dyZXNzID0gZnVuY3Rpb24gdHJhY2tQcm9ncmVzcyhldmVudCkge1xuICAgIHRoaXMuc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKTtcbiAgICB0aGlzLnByb2dyZXNzSW50ZXJ2YWwgPSB0aGlzLnNldEludGVydmFsKGJpbmQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gRG9uJ3QgdHJpZ2dlciB1bmxlc3MgYnVmZmVyZWQgYW1vdW50IGlzIGdyZWF0ZXIgdGhhbiBsYXN0IHRpbWVcblxuICAgICAgdmFyIG51bUJ1ZmZlcmVkUGVyY2VudCA9IHRoaXMuYnVmZmVyZWRQZXJjZW50KCk7XG5cbiAgICAgIGlmICh0aGlzLmJ1ZmZlcmVkUGVyY2VudF8gIT09IG51bUJ1ZmZlcmVkUGVyY2VudCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIHtAbGluayBQbGF5ZXIjcHJvZ3Jlc3N9XG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBUZWNoI3Byb2dyZXNzXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlcigncHJvZ3Jlc3MnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWZmZXJlZFBlcmNlbnRfID0gbnVtQnVmZmVyZWRQZXJjZW50O1xuXG4gICAgICBpZiAobnVtQnVmZmVyZWRQZXJjZW50ID09PSAxKSB7XG4gICAgICAgIHRoaXMuc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKTtcbiAgICAgIH1cbiAgICB9KSwgNTAwKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIG91ciBpbnRlcm5hbCBkdXJhdGlvbiBvbiBhIGBkdXJhdGlvbmNoYW5nZWAgZXZlbnQgYnkgY2FsbGluZ1xuICAgKiB7QGxpbmsgVGVjaCNkdXJhdGlvbn0uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGR1cmF0aW9uY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCNkdXJhdGlvbmNoYW5nZVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLm9uRHVyYXRpb25DaGFuZ2UgPSBmdW5jdGlvbiBvbkR1cmF0aW9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgdGhpcy5kdXJhdGlvbl8gPSB0aGlzLmR1cmF0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbmQgY3JlYXRlIGEgYFRpbWVSYW5nZWAgb2JqZWN0IGZvciBidWZmZXJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge1RpbWVSYW5nZX1cbiAgICogICAgICAgICBUaGUgdGltZSByYW5nZSBvYmplY3QgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5idWZmZXJlZCA9IGZ1bmN0aW9uIGJ1ZmZlcmVkKCkge1xuICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzKDAsIDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGN1cnJlbnQgdmlkZW8gdGhhdCBpcyBjdXJyZW50bHkgYnVmZmVyZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBBIG51bWJlciBmcm9tIDAgdG8gMSB0aGF0IHJlcHJlc2VudHMgdGhlIGRlY2ltYWwgcGVyY2VudGFnZSBvZiB0aGVcbiAgICogICAgICAgICB2aWRlbyB0aGF0IGlzIGJ1ZmZlcmVkLlxuICAgKlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmJ1ZmZlcmVkUGVyY2VudCA9IGZ1bmN0aW9uIGJ1ZmZlcmVkUGVyY2VudCQkMSgpIHtcbiAgICByZXR1cm4gYnVmZmVyZWRQZXJjZW50KHRoaXMuYnVmZmVyZWQoKSwgdGhpcy5kdXJhdGlvbl8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUdXJuIG9mZiB0aGUgcG9seWZpbGwgZm9yIGBwcm9ncmVzc2AgZXZlbnRzIHRoYXQgd2FzIGNyZWF0ZWQgaW5cbiAgICoge0BsaW5rIFRlY2gjbWFudWFsUHJvZ3Jlc3NPbn1cbiAgICogU3RvcCBtYW51YWxseSB0cmFja2luZyBwcm9ncmVzcyBldmVudHMgYnkgY2xlYXJpbmcgdGhlIGludGVydmFsIHRoYXQgd2FzIHNldCBpblxuICAgKiB7QGxpbmsgVGVjaCN0cmFja1Byb2dyZXNzfS5cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5zdG9wVHJhY2tpbmdQcm9ncmVzcyA9IGZ1bmN0aW9uIHN0b3BUcmFja2luZ1Byb2dyZXNzKCkge1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCh0aGlzLnByb2dyZXNzSW50ZXJ2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQb2x5ZmlsbCB0aGUgYHRpbWV1cGRhdGVgIGV2ZW50IGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXQuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIFRlY2gjdHJhY2tDdXJyZW50VGltZX1cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5tYW51YWxUaW1lVXBkYXRlc09uID0gZnVuY3Rpb24gbWFudWFsVGltZVVwZGF0ZXNPbigpIHtcbiAgICB0aGlzLm1hbnVhbFRpbWVVcGRhdGVzID0gdHJ1ZTtcblxuICAgIHRoaXMub24oJ3BsYXknLCB0aGlzLnRyYWNrQ3VycmVudFRpbWUpO1xuICAgIHRoaXMub24oJ3BhdXNlJywgdGhpcy5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gb2ZmIHRoZSBwb2x5ZmlsbCBmb3IgYHRpbWV1cGRhdGVgIGV2ZW50cyB0aGF0IHdhcyBjcmVhdGVkIGluXG4gICAqIHtAbGluayBUZWNoI21hbnVhbFRpbWVVcGRhdGVzT259XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUubWFudWFsVGltZVVwZGF0ZXNPZmYgPSBmdW5jdGlvbiBtYW51YWxUaW1lVXBkYXRlc09mZigpIHtcbiAgICB0aGlzLm1hbnVhbFRpbWVVcGRhdGVzID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSgpO1xuICAgIHRoaXMub2ZmKCdwbGF5JywgdGhpcy50cmFja0N1cnJlbnRUaW1lKTtcbiAgICB0aGlzLm9mZigncGF1c2UnLCB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB1cCBhbiBpbnRlcnZhbCBmdW5jdGlvbiB0byB0cmFjayBjdXJyZW50IHRpbWUgYW5kIHRyaWdnZXIgYHRpbWV1cGRhdGVgIGV2ZXJ5XG4gICAqIDI1MCBtaWxsaXNlY29uZHMuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjcGxheVxuICAgKiBAdHJpZ2dlcnMgVGVjaCN0aW1ldXBkYXRlXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUudHJhY2tDdXJyZW50VGltZSA9IGZ1bmN0aW9uIHRyYWNrQ3VycmVudFRpbWUoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFRpbWVJbnRlcnZhbCkge1xuICAgICAgdGhpcy5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSgpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRUaW1lSW50ZXJ2YWwgPSB0aGlzLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlcmVkIGF0IGFuIGludGVydmFsIG9mIDI1MG1zIHRvIGluZGljYXRlZCB0aGF0IHRpbWUgaXMgcGFzc2luZyBpbiB0aGUgdmlkZW8uXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IFRlY2gjdGltZXVwZGF0ZVxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoeyB0eXBlOiAndGltZXVwZGF0ZScsIHRhcmdldDogdGhpcywgbWFudWFsbHlUcmlnZ2VyZWQ6IHRydWUgfSk7XG5cbiAgICAgIC8vIDQyID0gMjQgZnBzIC8vIDI1MCBpcyB3aGF0IFdlYmtpdCB1c2VzIC8vIEZGIHVzZXMgMTVcbiAgICB9LCAyNTApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBpbnRlcnZhbCBmdW5jdGlvbiBjcmVhdGVkIGluIHtAbGluayBUZWNoI3RyYWNrQ3VycmVudFRpbWV9IHNvIHRoYXQgdGhlXG4gICAqIGB0aW1ldXBkYXRlYCBldmVudCBpcyBubyBsb25nZXIgdHJpZ2dlcmVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB7VGVjaCNwYXVzZX1cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSA9IGZ1bmN0aW9uIHN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKCkge1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCh0aGlzLmN1cnJlbnRUaW1lSW50ZXJ2YWwpO1xuXG4gICAgLy8gIzEwMDIgLSBpZiB0aGUgdmlkZW8gZW5kcyByaWdodCBiZWZvcmUgdGhlIG5leHQgdGltZXVwZGF0ZSB3b3VsZCBoYXBwZW4sXG4gICAgLy8gdGhlIHByb2dyZXNzIGJhciB3b24ndCBtYWtlIGl0IGFsbCB0aGUgd2F5IHRvIHRoZSBlbmRcbiAgICB0aGlzLnRyaWdnZXIoeyB0eXBlOiAndGltZXVwZGF0ZScsIHRhcmdldDogdGhpcywgbWFudWFsbHlUcmlnZ2VyZWQ6IHRydWUgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gb2ZmIGFsbCBldmVudCBwb2x5ZmlsbHMsIGNsZWFyIHRoZSBgVGVjaGBzIHtAbGluayBBdWRpb1RyYWNrTGlzdH0sXG4gICAqIHtAbGluayBWaWRlb1RyYWNrTGlzdH0sIGFuZCB7QGxpbmsgVGV4dFRyYWNrTGlzdH0sIGFuZCBkaXNwb3NlIG9mIHRoaXMgVGVjaC5cbiAgICpcbiAgICogQGZpcmVzIENvbXBvbmVudCNkaXNwb3NlXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cbiAgICAvLyBjbGVhciBvdXQgYWxsIHRyYWNrcyBiZWNhdXNlIHdlIGNhbid0IHJldXNlIHRoZW0gYmV0d2VlbiB0ZWNoc1xuICAgIHRoaXMuY2xlYXJUcmFja3MoTk9STUFMLm5hbWVzKTtcblxuICAgIC8vIFR1cm4gb2ZmIGFueSBtYW51YWwgcHJvZ3Jlc3Mgb3IgdGltZXVwZGF0ZSB0cmFja2luZ1xuICAgIGlmICh0aGlzLm1hbnVhbFByb2dyZXNzKSB7XG4gICAgICB0aGlzLm1hbnVhbFByb2dyZXNzT2ZmKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWFudWFsVGltZVVwZGF0ZXMpIHtcbiAgICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXNPZmYoKTtcbiAgICB9XG5cbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIG91dCBhIHNpbmdsZSBgVHJhY2tMaXN0YCBvciBhbiBhcnJheSBvZiBgVHJhY2tMaXN0c2AgZ2l2ZW4gdGhlaXIgbmFtZXMuXG4gICAqXG4gICAqID4gTm90ZTogVGVjaHMgd2l0aG91dCBzb3VyY2UgaGFuZGxlcnMgc2hvdWxkIGNhbGwgdGhpcyBiZXR3ZWVuIHNvdXJjZXMgZm9yIGB2aWRlb2BcbiAgICogICAgICAgICAmIGBhdWRpb2AgdHJhY2tzLiBZb3UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlbSBiZXR3ZWVuIHRyYWNrcyFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmdbXXxzdHJpbmd9IHR5cGVzXG4gICAqICAgICAgICBUcmFja0xpc3QgbmFtZXMgdG8gY2xlYXIsIHZhbGlkIG5hbWVzIGFyZSBgdmlkZW9gLCBgYXVkaW9gLCBhbmRcbiAgICogICAgICAgIGB0ZXh0YC5cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5jbGVhclRyYWNrcyA9IGZ1bmN0aW9uIGNsZWFyVHJhY2tzKHR5cGVzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB0eXBlcyA9IFtdLmNvbmNhdCh0eXBlcyk7XG4gICAgLy8gY2xlYXIgb3V0IGFsbCB0cmFja3MgYmVjYXVzZSB3ZSBjYW4ndCByZXVzZSB0aGVtIGJldHdlZW4gdGVjaHNcbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgbGlzdCA9IF90aGlzMlt0eXBlICsgJ1RyYWNrcyddKCkgfHwgW107XG4gICAgICB2YXIgaSA9IGxpc3QubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciB0cmFjayA9IGxpc3RbaV07XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIF90aGlzMi5yZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGxpc3QucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW55IFRleHRUcmFja3MgYWRkZWQgdmlhIGFkZFJlbW90ZVRleHRUcmFjayB0aGF0IGFyZVxuICAgKiBmbGFnZ2VkIGZvciBhdXRvbWF0aWMgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuY2xlYW51cEF1dG9UZXh0VHJhY2tzID0gZnVuY3Rpb24gY2xlYW51cEF1dG9UZXh0VHJhY2tzKCkge1xuICAgIHZhciBsaXN0ID0gdGhpcy5hdXRvUmVtb3RlVGV4dFRyYWNrc18gfHwgW107XG4gICAgdmFyIGkgPSBsaXN0Lmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciB0cmFjayA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMucmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSB0ZWNoLCB3aGljaCB3aWxsIHJlbW92ZXMgYWxsIHNvdXJjZXMgYW5kIHJlc2V0IHRoZSBpbnRlcm5hbCByZWFkeVN0YXRlLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge307XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgYW4gZXJyb3Igb24gdGhlIFRlY2guXG4gICAqXG4gICAqIEBwYXJhbSB7TWVkaWFFcnJvcn0gW2Vycl1cbiAgICogICAgICAgIEVycm9yIHRvIHNldCBvbiB0aGUgVGVjaFxuICAgKlxuICAgKiBAcmV0dXJuIHtNZWRpYUVycm9yfG51bGx9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgZXJyb3Igb2JqZWN0IG9uIHRoZSB0ZWNoLCBvciBudWxsIGlmIHRoZXJlIGlzbid0IG9uZS5cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5lcnJvcl8gPSBuZXcgTWVkaWFFcnJvcihlcnIpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdlcnJvcicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lcnJvcl87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBUaW1lUmFuZ2VgcyB0aGF0IGhhdmUgYmVlbiBwbGF5ZWQgdGhyb3VnaCBmb3IgdGhlIGN1cnJlbnQgc291cmNlLlxuICAgKlxuICAgKiA+IE5PVEU6IFRoaXMgaW1wbGVtZW50YXRpb24gaXMgaW5jb21wbGV0ZS4gSXQgZG9lcyBub3QgdHJhY2sgdGhlIHBsYXllZCBgVGltZVJhbmdlYC5cbiAgICogICAgICAgICBJdCBvbmx5IGNoZWNrcyB3ZXRoZXIgdGhlIHNvdXJjZSBoYXMgcGxheWVkIGF0IGFsbCBvciBub3QuXG4gICAqXG4gICAqIEByZXR1cm4ge1RpbWVSYW5nZX1cbiAgICogICAgICAgICAtIEEgc2luZ2xlIHRpbWUgcmFuZ2UgaWYgdGhpcyB2aWRlbyBoYXMgcGxheWVkXG4gICAqICAgICAgICAgLSBBbiBlbXB0eSBzZXQgb2YgcmFuZ2VzIGlmIG5vdC5cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5wbGF5ZWQgPSBmdW5jdGlvbiBwbGF5ZWQoKSB7XG4gICAgaWYgKHRoaXMuaGFzU3RhcnRlZF8pIHtcbiAgICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzKDAsIDApO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlcygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYXVzZXMgYSBtYW51YWwgdGltZSB1cGRhdGUgdG8gb2NjdXIgaWYge0BsaW5rIFRlY2gjbWFudWFsVGltZVVwZGF0ZXNPbn0gd2FzXG4gICAqIHByZXZpb3VzbHkgY2FsbGVkLlxuICAgKlxuICAgKiBAZmlyZXMgVGVjaCN0aW1ldXBkYXRlXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuc2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiBzZXRDdXJyZW50VGltZSgpIHtcbiAgICAvLyBpbXByb3ZlIHRoZSBhY2N1cmFjeSBvZiBtYW51YWwgdGltZXVwZGF0ZXNcbiAgICBpZiAodGhpcy5tYW51YWxUaW1lVXBkYXRlcykge1xuICAgICAgLyoqXG4gICAgICAgKiBBIG1hbnVhbCBgdGltZXVwZGF0ZWAgZXZlbnQuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IFRlY2gjdGltZXVwZGF0ZVxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoeyB0eXBlOiAndGltZXVwZGF0ZScsIHRhcmdldDogdGhpcywgbWFudWFsbHlUcmlnZ2VyZWQ6IHRydWUgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUdXJuIG9uIGxpc3RlbmVycyBmb3Ige0BsaW5rIFZpZGVvVHJhY2tMaXN0fSwge0BsaW5rIHtBdWRpb1RyYWNrTGlzdH0sIGFuZFxuICAgKiB7QGxpbmsgVGV4dFRyYWNrTGlzdH0gZXZlbnRzLlxuICAgKlxuICAgKiBUaGlzIGFkZHMge0BsaW5rIEV2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJzfSBmb3IgYGFkZHRyYWNrYCwgYW5kICBgcmVtb3ZldHJhY2tgLlxuICAgKlxuICAgKiBAZmlyZXMgVGVjaCNhdWRpb3RyYWNrY2hhbmdlXG4gICAqIEBmaXJlcyBUZWNoI3ZpZGVvdHJhY2tjaGFuZ2VcbiAgICogQGZpcmVzIFRlY2gjdGV4dHRyYWNrY2hhbmdlXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuaW5pdFRyYWNrTGlzdGVuZXJzID0gZnVuY3Rpb24gaW5pdFRyYWNrTGlzdGVuZXJzKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdHJhY2tzIGFyZSBhZGRlZCBvciByZW1vdmVkIG9uIHRoZSBUZWNoIHtAbGluayBBdWRpb1RyYWNrTGlzdH1cbiAgICAgKlxuICAgICAqIEBldmVudCBUZWNoI2F1ZGlvdHJhY2tjaGFuZ2VcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0cmFja3MgYXJlIGFkZGVkIG9yIHJlbW92ZWQgb24gdGhlIFRlY2gge0BsaW5rIFZpZGVvVHJhY2tMaXN0fVxuICAgICAqXG4gICAgICogQGV2ZW50IFRlY2gjdmlkZW90cmFja2NoYW5nZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRyYWNrcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZCBvbiB0aGUgVGVjaCB7QGxpbmsgVGV4dFRyYWNrTGlzdH1cbiAgICAgKlxuICAgICAqIEBldmVudCBUZWNoI3RleHR0cmFja2NoYW5nZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICBOT1JNQUwubmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHByb3BzID0gTk9STUFMW25hbWVdO1xuICAgICAgdmFyIHRyYWNrTGlzdENoYW5nZXMgPSBmdW5jdGlvbiB0cmFja0xpc3RDaGFuZ2VzKCkge1xuICAgICAgICBfdGhpczMudHJpZ2dlcihuYW1lICsgJ3RyYWNrY2hhbmdlJyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgdHJhY2tzID0gX3RoaXMzW3Byb3BzLmdldHRlck5hbWVdKCk7XG5cbiAgICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHRyYWNrTGlzdENoYW5nZXMpO1xuICAgICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdHJhY2tMaXN0Q2hhbmdlcyk7XG5cbiAgICAgIF90aGlzMy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdHJhY2tMaXN0Q2hhbmdlcyk7XG4gICAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRyYWNrTGlzdENoYW5nZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtdWxhdGUgVGV4dFRyYWNrcyB1c2luZyB2dHQuanMgaWYgbmVjZXNzYXJ5XG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI3Z0dGpzbG9hZGVkXG4gICAqIEBmaXJlcyBUZWNoI3Z0dGpzZXJyb3JcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5hZGRXZWJWdHRTY3JpcHRfID0gZnVuY3Rpb24gYWRkV2ViVnR0U2NyaXB0XygpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmICh3aW5kb3cuV2ViVlRUKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGx5LCBUZWNoLmVsXyBpcyBhIGNoaWxkIG9mIGEgZHVtbXktZGl2IHdhaXQgdW50aWwgdGhlIENvbXBvbmVudCBzeXN0ZW1cbiAgICAvLyBzaWduYWxzIHRoYXQgdGhlIFRlY2ggaXMgcmVhZHkgYXQgd2hpY2ggcG9pbnQgVGVjaC5lbF8gaXMgcGFydCBvZiB0aGUgRE9NXG4gICAgLy8gYmVmb3JlIGluc2VydGluZyB0aGUgV2ViVlRUIHNjcmlwdFxuICAgIGlmIChkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMuZWwoKSkpIHtcblxuICAgICAgLy8gbG9hZCB2aWEgcmVxdWlyZSBpZiBhdmFpbGFibGUgYW5kIHZ0dC5qcyBzY3JpcHQgbG9jYXRpb24gd2FzIG5vdCBwYXNzZWQgaW5cbiAgICAgIC8vIGFzIGFuIG9wdGlvbi4gbm92dHQgYnVpbGRzIHdpbGwgdHVybiB0aGUgYWJvdmUgcmVxdWlyZSBjYWxsIGludG8gYW4gZW1wdHkgb2JqZWN0XG4gICAgICAvLyB3aGljaCB3aWxsIGNhdXNlIHRoaXMgaWYgY2hlY2sgdG8gYWx3YXlzIGZhaWwuXG4gICAgICBpZiAoIXRoaXMub3B0aW9uc19bJ3Z0dC5qcyddICYmIGlzUGxhaW4odnR0KSAmJiBPYmplY3Qua2V5cyh2dHQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd2dHRqc2xvYWRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGxvYWQgdnR0LmpzIHZpYSB0aGUgc2NyaXB0IGxvY2F0aW9uIG9wdGlvbiBvciB0aGUgY2RuIG9mIG5vIGxvY2F0aW9uIHdhc1xuICAgICAgLy8gcGFzc2VkIGluXG4gICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgICAgIHNjcmlwdC5zcmMgPSB0aGlzLm9wdGlvbnNfWyd2dHQuanMnXSB8fCAnaHR0cHM6Ly92anMuemVuY2RuLm5ldC92dHRqcy8wLjEyLjQvdnR0Lm1pbi5qcyc7XG4gICAgICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiB2dHQuanMgaXMgbG9hZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgVGVjaCN2dHRqc2xvYWRlZFxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpczQudHJpZ2dlcigndnR0anNsb2FkZWQnKTtcbiAgICAgIH07XG4gICAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdnR0LmpzIHdhcyBub3QgbG9hZGVkIGR1ZSB0byBhbiBlcnJvclxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgVGVjaCN2dHRqc2xvYWRlZFxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpczQudHJpZ2dlcigndnR0anNlcnJvcicpO1xuICAgICAgfTtcbiAgICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuICAgICAgICBzY3JpcHQub25lcnJvciA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIC8vIGJ1dCBoYXZlIG5vdCBsb2FkZWQgeWV0IGFuZCB3ZSBzZXQgaXQgdG8gdHJ1ZSBiZWZvcmUgdGhlIGluamVjdCBzbyB0aGF0XG4gICAgICAvLyB3ZSBkb24ndCBvdmVyd3JpdGUgdGhlIGluamVjdGVkIHdpbmRvdy5XZWJWVFQgaWYgaXQgbG9hZHMgcmlnaHQgYXdheVxuICAgICAgd2luZG93LldlYlZUVCA9IHRydWU7XG4gICAgICB0aGlzLmVsKCkucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlYWR5KHRoaXMuYWRkV2ViVnR0U2NyaXB0Xyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbXVsYXRlIHRleHR0cmFja3NcbiAgICpcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5lbXVsYXRlVGV4dFRyYWNrcyA9IGZ1bmN0aW9uIGVtdWxhdGVUZXh0VHJhY2tzKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgdmFyIHRyYWNrcyA9IHRoaXMudGV4dFRyYWNrcygpO1xuICAgIHZhciByZW1vdGVUcmFja3MgPSB0aGlzLnJlbW90ZVRleHRUcmFja3MoKTtcbiAgICB2YXIgaGFuZGxlQWRkVHJhY2sgPSBmdW5jdGlvbiBoYW5kbGVBZGRUcmFjayhlKSB7XG4gICAgICByZXR1cm4gdHJhY2tzLmFkZFRyYWNrKGUudHJhY2spO1xuICAgIH07XG4gICAgdmFyIGhhbmRsZVJlbW92ZVRyYWNrID0gZnVuY3Rpb24gaGFuZGxlUmVtb3ZlVHJhY2soZSkge1xuICAgICAgcmV0dXJuIHRyYWNrcy5yZW1vdmVUcmFjayhlLnRyYWNrKTtcbiAgICB9O1xuXG4gICAgcmVtb3RlVHJhY2tzLm9uKCdhZGR0cmFjaycsIGhhbmRsZUFkZFRyYWNrKTtcbiAgICByZW1vdGVUcmFja3Mub24oJ3JlbW92ZXRyYWNrJywgaGFuZGxlUmVtb3ZlVHJhY2spO1xuXG4gICAgdGhpcy5hZGRXZWJWdHRTY3JpcHRfKCk7XG5cbiAgICB2YXIgdXBkYXRlRGlzcGxheSA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICByZXR1cm4gX3RoaXM1LnRyaWdnZXIoJ3RleHR0cmFja2NoYW5nZScpO1xuICAgIH07XG5cbiAgICB2YXIgdGV4dFRyYWNrc0NoYW5nZXMgPSBmdW5jdGlvbiB0ZXh0VHJhY2tzQ2hhbmdlcygpIHtcbiAgICAgIHVwZGF0ZURpc3BsYXkoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICAgIHRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIHVwZGF0ZURpc3BsYXkpO1xuICAgICAgICBpZiAodHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgdXBkYXRlRGlzcGxheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGV4dFRyYWNrc0NoYW5nZXMoKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRleHRUcmFja3NDaGFuZ2VzKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmVtb3RlVHJhY2tzLm9mZignYWRkdHJhY2snLCBoYW5kbGVBZGRUcmFjayk7XG4gICAgICByZW1vdGVUcmFja3Mub2ZmKCdyZW1vdmV0cmFjaycsIGhhbmRsZVJlbW92ZVRyYWNrKTtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgICB0cmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdjdWVjaGFuZ2UnLCB1cGRhdGVEaXNwbGF5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZXR1cm5zIGEgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAgICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXVxuICAgKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV1cbiAgICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja31cbiAgICogICAgICAgICBUaGUgVGV4dFRyYWNrIHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmFkZFRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAoIWtpbmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dFRyYWNrIGtpbmQgaXMgcmVxdWlyZWQgYnV0IHdhcyBub3QgcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlVHJhY2tIZWxwZXIodGhpcywga2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGVtdWxhdGVkIFRleHRUcmFjayBmb3IgdXNlIGJ5IGFkZFJlbW90ZVRleHRUcmFja1xuICAgKlxuICAgKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyB0aGF0IGluaGVyaXQgZnJvbVxuICAgKiBUZWNoIGluIG9yZGVyIHRvIGNyZWF0ZSBuYXRpdmUgb3IgY3VzdG9tIFRleHRUcmFja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIHRoZSBvcHRpb25zIHRvIGluaXRpYWxpemUgdGhlIFRleHRUcmFjayB3aXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2luZF1cbiAgICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsXS5cbiAgICogICAgICAgIExhYmVsIHRvIGlkZW50aWZ5IHRoZSB0ZXh0IHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZV1cbiAgICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSB0cmFjayBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmNyZWF0ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGNyZWF0ZVJlbW90ZVRleHRUcmFjayhvcHRpb25zKSB7XG4gICAgdmFyIHRyYWNrID0gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIHRlY2g6IHRoaXNcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgUkVNT1RFLnJlbW90ZVRleHRFbC5UcmFja0NsYXNzKHRyYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlbW90ZSB0ZXh0IHRyYWNrIG9iamVjdCBhbmQgcmV0dXJucyBhbiBodG1sIHRyYWNrIGVsZW1lbnQuXG4gICAqXG4gICAqID4gTm90ZTogVGhpcyBjYW4gYmUgYW4gZW11bGF0ZWQge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9IG9yIGEgbmF0aXZlIG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFNlZSB7QGxpbmsgVGVjaCNjcmVhdGVSZW1vdGVUZXh0VHJhY2t9IGZvciBtb3JlIGRldGFpbGVkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW21hbnVhbENsZWFudXA9dHJ1ZV1cbiAgICogICAgICAgIC0gV2hlbiBmYWxzZTogdGhlIFRleHRUcmFjayB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSB2aWRlb1xuICAgKiAgICAgICAgICBlbGVtZW50IHdoZW5ldmVyIHRoZSBzb3VyY2UgY2hhbmdlc1xuICAgKiAgICAgICAgLSBXaGVuIFRydWU6IFRoZSBUZXh0VHJhY2sgd2lsbCBoYXZlIHRvIGJlIGNsZWFuZWQgdXAgbWFudWFsbHlcbiAgICpcbiAgICogQHJldHVybiB7SFRNTFRyYWNrRWxlbWVudH1cbiAgICogICAgICAgICBBbiBIdG1sIFRyYWNrIEVsZW1lbnQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBkZWZhdWx0IGZ1bmN0aW9uYWxpdHkgZm9yIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBlcXVpdmFsZW50XG4gICAqICAgICAgICAgICAgIHRvIFwibWFudWFsQ2xlYW51cD1mYWxzZVwiIGluIHRoZSBmdXR1cmUuIFRoZSBtYW51YWxDbGVhbnVwIHBhcmFtZXRlciB3aWxsXG4gICAqICAgICAgICAgICAgIGFsc28gYmUgcmVtb3ZlZC5cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5hZGRSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRSZW1vdGVUZXh0VHJhY2soKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIG1hbnVhbENsZWFudXAgPSBhcmd1bWVudHNbMV07XG5cbiAgICB2YXIgaHRtbFRyYWNrRWxlbWVudCA9IHRoaXMuY3JlYXRlUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMpO1xuXG4gICAgaWYgKG1hbnVhbENsZWFudXAgIT09IHRydWUgJiYgbWFudWFsQ2xlYW51cCAhPT0gZmFsc2UpIHtcbiAgICAgIC8vIGRlcHJlY2F0aW9uIHdhcm5pbmdcbiAgICAgIGxvZyQxLndhcm4oJ0NhbGxpbmcgYWRkUmVtb3RlVGV4dFRyYWNrIHdpdGhvdXQgZXhwbGljaXRseSBzZXR0aW5nIHRoZSBcIm1hbnVhbENsZWFudXBcIiBwYXJhbWV0ZXIgdG8gYHRydWVgIGlzIGRlcHJlY2F0ZWQgYW5kIGRlZmF1bHQgdG8gYGZhbHNlYCBpbiBmdXR1cmUgdmVyc2lvbiBvZiB2aWRlby5qcycpO1xuICAgICAgbWFudWFsQ2xlYW51cCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gc3RvcmUgSFRNTFRyYWNrRWxlbWVudCBhbmQgVGV4dFRyYWNrIHRvIHJlbW90ZSBsaXN0XG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5hZGRUcmFja0VsZW1lbnRfKGh0bWxUcmFja0VsZW1lbnQpO1xuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrcygpLmFkZFRyYWNrKGh0bWxUcmFja0VsZW1lbnQudHJhY2spO1xuXG4gICAgaWYgKG1hbnVhbENsZWFudXAgIT09IHRydWUpIHtcbiAgICAgIC8vIGNyZWF0ZSB0aGUgVGV4dFRyYWNrTGlzdCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNi5hdXRvUmVtb3RlVGV4dFRyYWNrc18uYWRkVHJhY2soaHRtbFRyYWNrRWxlbWVudC50cmFjayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbFRyYWNrRWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgcmVtb3RlIHRleHQgdHJhY2sgZnJvbSB0aGUgcmVtb3RlIGBUZXh0VHJhY2tMaXN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBgVGV4dFRyYWNrYCB0byByZW1vdmUgZnJvbSB0aGUgYFRleHRUcmFja0xpc3RgXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUucmVtb3ZlUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKSB7XG4gICAgdmFyIHRyYWNrRWxlbWVudCA9IHRoaXMucmVtb3RlVGV4dFRyYWNrRWxzKCkuZ2V0VHJhY2tFbGVtZW50QnlUcmFja18odHJhY2spO1xuXG4gICAgLy8gcmVtb3ZlIEhUTUxUcmFja0VsZW1lbnQgYW5kIFRleHRUcmFjayBmcm9tIHJlbW90ZSBsaXN0XG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5yZW1vdmVUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudCk7XG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgIHRoaXMuYXV0b1JlbW90ZVRleHRUcmFja3NfLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhdmFpbGFibGUgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzIGFzIHNwZWNpZmllZCBieSB0aGUgVzNDJ3MgTWVkaWFcbiAgICogUGxheWJhY2sgUXVhbGl0eSBBUEkuXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vbWVkaWEtcGxheWJhY2stcXVhbGl0eX1cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEFuIG9iamVjdCB3aXRoIHN1cHBvcnRlZCBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3NcbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPSBmdW5jdGlvbiBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpIHtcbiAgICByZXR1cm4ge307XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRvIHNldCBhIHBvc3RlciBmcm9tIGEgYFRlY2hgLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5zZXRQb3N0ZXIgPSBmdW5jdGlvbiBzZXRQb3N0ZXIoKSB7fTtcblxuICAvKipcbiAgICogQSBtZXRob2QgdG8gY2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiB0aGUgJ3BsYXlzaW5pbmUnIDx2aWRlbz4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5wbGF5c2lubGluZSA9IGZ1bmN0aW9uIHBsYXlzaW5saW5lKCkge307XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRvIHNldCBvciB1bnNldCB0aGUgJ3BsYXlzaW5pbmUnIDx2aWRlbz4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5zZXRQbGF5c2lubGluZSA9IGZ1bmN0aW9uIHNldFBsYXlzaW5saW5lKCkge307XG5cbiAgLypcbiAgICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIG1pbWUtdHlwZS5cbiAgICpcbiAgICogVGhlIGJhc2UgdGVjaCBkb2VzIG5vdCBzdXBwb3J0IGFueSB0eXBlLCBidXQgc291cmNlIGhhbmRsZXJzIG1pZ2h0XG4gICAqIG92ZXJ3cml0ZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGVcbiAgICogICAgICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2sgZm9yIHN1cHBvcnRcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yIGVtcHR5IHN0cmluZ1xuICAgKlxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9jYW5QbGF5VHlwZX1cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiBjYW5QbGF5VHlwZSgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0eXBlIGlzIHN1cHBvcnRlZCBieSB0aGlzIHRlY2guXG4gICAqXG4gICAqIFRoZSBiYXNlIHRlY2ggZG9lcyBub3Qgc3VwcG9ydCBhbnkgdHlwZSwgYnV0IHNvdXJjZSBoYW5kbGVycyBtaWdodFxuICAgKiBvdmVyd3JpdGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogICAgICAgIFRoZSBtZWRpYSB0eXBlIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgbmF0aXZlIHZpZGVvIGVsZW1lbnQncyByZXNwb25zZVxuICAgKi9cblxuXG4gIFRlY2guY2FuUGxheVR5cGUgPSBmdW5jdGlvbiBjYW5QbGF5VHlwZSgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiBzb3VyY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY09ialxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdGVjaFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9ICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gICAqL1xuXG5cbiAgVGVjaC5jYW5QbGF5U291cmNlID0gZnVuY3Rpb24gY2FuUGxheVNvdXJjZShzcmNPYmosIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gVGVjaC5jYW5QbGF5VHlwZShzcmNPYmoudHlwZSk7XG4gIH07XG5cbiAgLypcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIGFyZ3VtZW50IGlzIGEgVGVjaCBvciBub3QuXG4gICAqIENhbiBiZSBwYXNzZWQgZWl0aGVyIGEgQ2xhc3MgbGlrZSBgSHRtbDVgIG9yIGEgaW5zdGFuY2UgbGlrZSBgcGxheWVyLnRlY2hfYFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50XG4gICAqICAgICAgICBUaGUgaXRlbSB0byBjaGVja1xuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFdoZXRoZXIgaXQgaXMgYSB0ZWNoIG9yIG5vdFxuICAgKiAgICAgICAgIC0gVHJ1ZSBpZiBpdCBpcyBhIHRlY2hcbiAgICogICAgICAgICAtIEZhbHNlIGlmIGl0IGlzIG5vdFxuICAgKi9cblxuXG4gIFRlY2guaXNUZWNoID0gZnVuY3Rpb24gaXNUZWNoKGNvbXBvbmVudCkge1xuICAgIHJldHVybiBjb21wb25lbnQucHJvdG90eXBlIGluc3RhbmNlb2YgVGVjaCB8fCBjb21wb25lbnQgaW5zdGFuY2VvZiBUZWNoIHx8IGNvbXBvbmVudCA9PT0gVGVjaDtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgYFRlY2hgIGludG8gYSBzaGFyZWQgbGlzdCBmb3IgdmlkZW9qcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIE5hbWUgb2YgdGhlIGBUZWNoYCB0byByZWdpc3Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRlY2hcbiAgICogICAgICAgIFRoZSBgVGVjaGAgY2xhc3MgdG8gcmVnaXN0ZXIuXG4gICAqL1xuXG5cbiAgVGVjaC5yZWdpc3RlclRlY2ggPSBmdW5jdGlvbiByZWdpc3RlclRlY2gobmFtZSwgdGVjaCkge1xuICAgIGlmICghVGVjaC50ZWNoc18pIHtcbiAgICAgIFRlY2gudGVjaHNfID0ge307XG4gICAgfVxuXG4gICAgaWYgKCFUZWNoLmlzVGVjaCh0ZWNoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZWNoICcgKyBuYW1lICsgJyBtdXN0IGJlIGEgVGVjaCcpO1xuICAgIH1cblxuICAgIGlmICghVGVjaC5jYW5QbGF5VHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZWNocyBtdXN0IGhhdmUgYSBzdGF0aWMgY2FuUGxheVR5cGUgbWV0aG9kIG9uIHRoZW0nKTtcbiAgICB9XG4gICAgaWYgKCFUZWNoLmNhblBsYXlTb3VyY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVjaHMgbXVzdCBoYXZlIGEgc3RhdGljIGNhblBsYXlTb3VyY2UgbWV0aG9kIG9uIHRoZW0nKTtcbiAgICB9XG5cbiAgICBuYW1lID0gdG9UaXRsZUNhc2UobmFtZSk7XG5cbiAgICBUZWNoLnRlY2hzX1tuYW1lXSA9IHRlY2g7XG4gICAgaWYgKG5hbWUgIT09ICdUZWNoJykge1xuICAgICAgLy8gY2FtZWwgY2FzZSB0aGUgdGVjaE5hbWUgZm9yIHVzZSBpbiB0ZWNoT3JkZXJcbiAgICAgIFRlY2guZGVmYXVsdFRlY2hPcmRlcl8ucHVzaChuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlY2g7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIGBUZWNoYCBmcm9tIHRoZSBzaGFyZWQgbGlzdCBieSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgYGNhbWVsQ2FzZWAgb3IgYFRpdGxlQ2FzZWAgbmFtZSBvZiB0aGUgVGVjaCB0byBnZXRcbiAgICpcbiAgICogQHJldHVybiB7VGVjaHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgVGhlIGBUZWNoYCBvciB1bmRlZmluZWQgaWYgdGhlcmUgd2FzIG5vIHRlY2ggd2l0aCB0aGUgbmFtZSByZXF1c3RlZC5cbiAgICovXG5cblxuICBUZWNoLmdldFRlY2ggPSBmdW5jdGlvbiBnZXRUZWNoKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuYW1lID0gdG9UaXRsZUNhc2UobmFtZSk7XG5cbiAgICBpZiAoVGVjaC50ZWNoc18gJiYgVGVjaC50ZWNoc19bbmFtZV0pIHtcbiAgICAgIHJldHVybiBUZWNoLnRlY2hzX1tuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAod2luZG93ICYmIHdpbmRvdy52aWRlb2pzICYmIHdpbmRvdy52aWRlb2pzW25hbWVdKSB7XG4gICAgICBsb2ckMS53YXJuKCdUaGUgJyArIG5hbWUgKyAnIHRlY2ggd2FzIGFkZGVkIHRvIHRoZSB2aWRlb2pzIG9iamVjdCB3aGVuIGl0IHNob3VsZCBiZSByZWdpc3RlcmVkIHVzaW5nIHZpZGVvanMucmVnaXN0ZXJUZWNoKG5hbWUsIHRlY2gpJyk7XG4gICAgICByZXR1cm4gd2luZG93LnZpZGVvanNbbmFtZV07XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUZWNoO1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIEdldCB0aGUge0BsaW5rIFZpZGVvVHJhY2tMaXN0fVxuICpcbiAqIEByZXR1cm5zIHtWaWRlb1RyYWNrTGlzdH1cbiAqIEBtZXRob2QgVGVjaC5wcm90b3R5cGUudmlkZW9UcmFja3NcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fVxuICpcbiAqIEByZXR1cm5zIHtBdWRpb1RyYWNrTGlzdH1cbiAqIEBtZXRob2QgVGVjaC5wcm90b3R5cGUuYXVkaW9UcmFja3NcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUge0BsaW5rIFRleHRUcmFja0xpc3R9XG4gKlxuICogQHJldHVybnMge1RleHRUcmFja0xpc3R9XG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLnRleHRUcmFja3NcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgcmVtb3RlIGVsZW1lbnQge0BsaW5rIFRleHRUcmFja0xpc3R9XG4gKlxuICogQHJldHVybnMge1RleHRUcmFja0xpc3R9XG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLnJlbW90ZVRleHRUcmFja3NcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgcmVtb3RlIGVsZW1lbnQge0BsaW5rIEh0bWxUcmFja0VsZW1lbnRMaXN0fVxuICpcbiAqIEByZXR1cm5zIHtIdG1sVHJhY2tFbGVtZW50TGlzdH1cbiAqIEBtZXRob2QgVGVjaC5wcm90b3R5cGUucmVtb3RlVGV4dFRyYWNrRWxzXG4gKi9cblxuQUxMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHByb3BzID0gQUxMW25hbWVdO1xuXG4gIFRlY2gucHJvdG90eXBlW3Byb3BzLmdldHRlck5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdID0gdGhpc1twcm9wcy5wcml2YXRlTmFtZV0gfHwgbmV3IHByb3BzLkxpc3RDbGFzcygpO1xuICAgIHJldHVybiB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIExpc3Qgb2YgYXNzb2NpYXRlZCB0ZXh0IHRyYWNrc1xuICpcbiAqIEB0eXBlIHtUZXh0VHJhY2tMaXN0fVxuICogQHByaXZhdGVcbiAqIEBwcm9wZXJ0eSBUZWNoI3RleHRUcmFja3NfXG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIGFzc29jaWF0ZWQgYXVkaW8gdHJhY2tzLlxuICpcbiAqIEB0eXBlIHtBdWRpb1RyYWNrTGlzdH1cbiAqIEBwcml2YXRlXG4gKiBAcHJvcGVydHkgVGVjaCNhdWRpb1RyYWNrc19cbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgYXNzb2NpYXRlZCB2aWRlbyB0cmFja3MuXG4gKlxuICogQHR5cGUge1ZpZGVvVHJhY2tMaXN0fVxuICogQHByaXZhdGVcbiAqIEBwcm9wZXJ0eSBUZWNoI3ZpZGVvVHJhY2tzX1xuICovXG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHZvbHVtZSBjb250cm9sLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNWb2x1bWVDb250cm9sID0gdHJ1ZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2V0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydCBmdWxsc2NyZWVuIHJlc2l6ZSBjb250cm9sLlxuICogUmVzaXppbmcgcGx1Z2lucyB1c2luZyByZXF1ZXN0IGZ1bGxzY3JlZW4gcmVsb2FkcyB0aGUgcGx1Z2luXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc0Z1bGxzY3JlZW5SZXNpemUgPSBmYWxzZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2V0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgY2hhbmdpbmcgdGhlIHNwZWVkIGF0IHdoaWNoIHRoZSB2aWRlb1xuICogcGxheXMuIEV4YW1wbGVzOlxuICogICAtIFNldCBwbGF5ZXIgdG8gcGxheSAyeCAodHdpY2UpIGFzIGZhc3RcbiAqICAgLSBTZXQgcGxheWVyIHRvIHBsYXkgMC41eCAoaGFsZikgYXMgZmFzdFxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNQbGF5YmFja1JhdGUgPSBmYWxzZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2V0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgdGhlIGBwcm9ncmVzc2AgZXZlbnQuIFRoaXMgaXMgY3VycmVudGx5XG4gKiBub3QgdHJpZ2dlcmVkIGJ5IHZpZGVvLWpzLXN3Zi4gVGhpcyB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmXG4gKiB7QGxpbmsgVGVjaCNtYW51YWxQcm9ncmVzc09ufSBzaG91bGQgYmUgY2FsbGVkLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNQcm9ncmVzc0V2ZW50cyA9IGZhbHNlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB0aGUgYHRpbWV1cGRhdGVgIGV2ZW50LiBUaGlzIGlzIGN1cnJlbnRseVxuICogbm90IHRyaWdnZXJlZCBieSB2aWRlby1qcy1zd2YuIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSBpZlxuICoge0BsaW5rIFRlY2gjbWFudWFsVGltZVVwZGF0ZXN9IHNob3VsZCBiZSBjYWxsZWQuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1RpbWV1cGRhdGVFdmVudHMgPSBmYWxzZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2V0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgdGhlIG5hdGl2ZSBgVGV4dFRyYWNrYHMuXG4gKiBUaGlzIHdpbGwgaGVscCB1cyBpbnRlZ3JhdGUgd2l0aCBuYXRpdmUgYFRleHRUcmFja2BzIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZW0uXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgPSBmYWxzZTtcblxuLyoqXG4gKiBBIGZ1bmN0aW9uYWwgbWl4aW4gZm9yIHRlY2hzIHRoYXQgd2FudCB0byB1c2UgdGhlIFNvdXJjZSBIYW5kbGVyIHBhdHRlcm4uXG4gKiBTb3VyY2UgaGFuZGxlcnMgYXJlIHNjcmlwdHMgZm9yIGhhbmRsaW5nIHNwZWNpZmljIGZvcm1hdHMuXG4gKiBUaGUgc291cmNlIGhhbmRsZXIgcGF0dGVybiBpcyB1c2VkIGZvciBhZGFwdGl2ZSBmb3JtYXRzIChITFMsIERBU0gpIHRoYXRcbiAqIG1hbnVhbGx5IGxvYWQgdmlkZW8gZGF0YSBhbmQgZmVlZCBpdCBpbnRvIGEgU291cmNlIEJ1ZmZlciAoTWVkaWEgU291cmNlIEV4dGVuc2lvbnMpXG4gKiBFeGFtcGxlOiBgVGVjaC53aXRoU291cmNlSGFuZGxlcnMuY2FsbChNeVRlY2gpO2BcbiAqXG4gKiBAcGFyYW0ge1RlY2h9IF9UZWNoXG4gKiAgICAgICAgVGhlIHRlY2ggdG8gYWRkIHNvdXJjZSBoYW5kbGVyIGZ1bmN0aW9ucyB0by5cbiAqXG4gKiBAbWl4ZXMgVGVjaH5Tb3VyY2VIYW5kbGVyQWRkaXRpb25zXG4gKi9cblRlY2gud2l0aFNvdXJjZUhhbmRsZXJzID0gZnVuY3Rpb24gKF9UZWNoKSB7XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgc291cmNlIGhhbmRsZXJcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBoYW5kbGVyIGNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdXG4gICAqICAgICAgICBSZWdpc3RlciBpdCBhdCB0aGUgZm9sbG93aW5nIGluZGV4XG4gICAqL1xuICBfVGVjaC5yZWdpc3RlclNvdXJjZUhhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlciwgaW5kZXgpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSBfVGVjaC5zb3VyY2VIYW5kbGVycztcblxuICAgIGlmICghaGFuZGxlcnMpIHtcbiAgICAgIGhhbmRsZXJzID0gX1RlY2guc291cmNlSGFuZGxlcnMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYWRkIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RcbiAgICAgIGluZGV4ID0gaGFuZGxlcnMubGVuZ3RoO1xuICAgIH1cblxuICAgIGhhbmRsZXJzLnNwbGljZShpbmRleCwgMCwgaGFuZGxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiB0eXBlLiBBbHNvIGNoZWNrcyB0aGVcbiAgICogVGVjaHMgc291cmNlSGFuZGxlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqICAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAgICovXG4gIF9UZWNoLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSBfVGVjaC5zb3VyY2VIYW5kbGVycyB8fCBbXTtcbiAgICB2YXIgY2FuID0gdm9pZCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY2FuID0gaGFuZGxlcnNbaV0uY2FuUGxheVR5cGUodHlwZSk7XG5cbiAgICAgIGlmIChjYW4pIHtcbiAgICAgICAgcmV0dXJuIGNhbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHNvdXJjZSBoYW5kbGVyIHRoYXQgc3VwcG9ydHMgdGhlIHNvdXJjZS5cbiAgICpcbiAgICogVE9ETzogQW5zd2VyIHF1ZXN0aW9uOiBzaG91bGQgJ3Byb2JhYmx5JyBiZSBwcmlvcml0aXplZCBvdmVyICdtYXliZSdcbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gICAqICAgICAgICBUaGUgc291cmNlIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB0ZWNoXG4gICAqXG4gICAqIEByZXR1cm4ge1NvdXJjZUhhbmRsZXJ8bnVsbH1cbiAgICogICAgICAgICAgVGhlIGZpcnN0IHNvdXJjZSBoYW5kbGVyIHRoYXQgc3VwcG9ydHMgdGhlIHNvdXJjZSBvciBudWxsIGlmXG4gICAqICAgICAgICAgIG5vIFNvdXJjZUhhbmRsZXIgc3VwcG9ydHMgdGhlIHNvdXJjZVxuICAgKi9cbiAgX1RlY2guc2VsZWN0U291cmNlSGFuZGxlciA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSBfVGVjaC5zb3VyY2VIYW5kbGVycyB8fCBbXTtcbiAgICB2YXIgY2FuID0gdm9pZCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY2FuID0gaGFuZGxlcnNbaV0uY2FuSGFuZGxlU291cmNlKHNvdXJjZSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChjYW4pIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXJzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzcmNPYmpcbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHRlY2hcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gICAqL1xuICBfVGVjaC5jYW5QbGF5U291cmNlID0gZnVuY3Rpb24gKHNyY09iaiwgb3B0aW9ucykge1xuICAgIHZhciBzaCA9IF9UZWNoLnNlbGVjdFNvdXJjZUhhbmRsZXIoc3JjT2JqLCBvcHRpb25zKTtcblxuICAgIGlmIChzaCkge1xuICAgICAgcmV0dXJuIHNoLmNhbkhhbmRsZVNvdXJjZShzcmNPYmosIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB1c2luZyBhIHNvdXJjZSBoYW5kbGVyLCBwcmVmZXIgaXRzIGltcGxlbWVudGF0aW9uIG9mXG4gICAqIGFueSBmdW5jdGlvbiBub3JtYWxseSBwcm92aWRlZCBieSB0aGUgdGVjaC5cbiAgICovXG4gIHZhciBkZWZlcnJhYmxlID0gWydzZWVrYWJsZScsICdkdXJhdGlvbiddO1xuXG4gIC8qKlxuICAgKiBBIHdyYXBwZXIgYXJvdW5kIHtAbGluayBUZWNoI3NlZWthYmxlfSB0aGF0IHdpbGwgY2FsbCBhIGBTb3VyY2VIYW5kbGVyYHMgc2Vla2FibGVcbiAgICogZnVuY3Rpb24gaWYgaXQgZXhpc3RzLCB3aXRoIGEgZmFsbGJhY2sgdG8gdGhlIFRlY2hzIHNlZWthYmxlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbWV0aG9kIF9UZWNoLnNlZWthYmxlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBIHdyYXBwZXIgYXJvdW5kIHtAbGluayBUZWNoI2R1cmF0aW9ufSB0aGF0IHdpbGwgY2FsbCBhIGBTb3VyY2VIYW5kbGVyYHMgZHVyYXRpb25cbiAgICogZnVuY3Rpb24gaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgaXQgd2lsbCBmYWxsYmFjayB0byB0aGUgdGVjaHMgZHVyYXRpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBtZXRob2QgX1RlY2guZHVyYXRpb25cbiAgICovXG5cbiAgZGVmZXJyYWJsZS5mb3JFYWNoKGZ1bmN0aW9uIChmbk5hbWUpIHtcbiAgICB2YXIgb3JpZ2luYWxGbiA9IHRoaXNbZm5OYW1lXTtcblxuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXNbZm5OYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnNvdXJjZUhhbmRsZXJfICYmIHRoaXMuc291cmNlSGFuZGxlcl9bZm5OYW1lXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VIYW5kbGVyX1tmbk5hbWVdLmFwcGx5KHRoaXMuc291cmNlSGFuZGxlcl8sIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0sIF9UZWNoLnByb3RvdHlwZSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZ1bmN0aW9uIGZvciBzZXR0aW5nIHRoZSBzb3VyY2UgdXNpbmcgYSBzb3VyY2Ugb2JqZWN0XG4gICAqIGFuZCBzb3VyY2UgaGFuZGxlcnMuXG4gICAqIFNob3VsZCBuZXZlciBiZSBjYWxsZWQgdW5sZXNzIGEgc291cmNlIGhhbmRsZXIgd2FzIGZvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAgICogICAgICAgIEEgc291cmNlIG9iamVjdCB3aXRoIHNyYyBhbmQgdHlwZSBrZXlzXG4gICAqL1xuICBfVGVjaC5wcm90b3R5cGUuc2V0U291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIHZhciBzaCA9IF9UZWNoLnNlbGVjdFNvdXJjZUhhbmRsZXIoc291cmNlLCB0aGlzLm9wdGlvbnNfKTtcblxuICAgIGlmICghc2gpIHtcbiAgICAgIC8vIEZhbGwgYmFjayB0byBhIG5hdGl2ZSBzb3VyY2UgaGFuZGVyIHdoZW4gdW5zdXBwb3J0ZWQgc291cmNlcyBhcmVcbiAgICAgIC8vIGRlbGliZXJhdGVseSBzZXRcbiAgICAgIGlmIChfVGVjaC5uYXRpdmVTb3VyY2VIYW5kbGVyKSB7XG4gICAgICAgIHNoID0gX1RlY2gubmF0aXZlU291cmNlSGFuZGxlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZyQxLmVycm9yKCdObyBzb3VyY2UgaGFuZGVyIGZvdW5kIGZvciB0aGUgY3VycmVudCBzb3VyY2UuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGlzcG9zZSBhbnkgZXhpc3Rpbmcgc291cmNlIGhhbmRsZXJcbiAgICB0aGlzLmRpc3Bvc2VTb3VyY2VIYW5kbGVyKCk7XG4gICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnLCB0aGlzLmRpc3Bvc2VTb3VyY2VIYW5kbGVyKTtcblxuICAgIGlmIChzaCAhPT0gX1RlY2gubmF0aXZlU291cmNlSGFuZGxlcikge1xuICAgICAgdGhpcy5jdXJyZW50U291cmNlXyA9IHNvdXJjZTtcbiAgICB9XG5cbiAgICB0aGlzLnNvdXJjZUhhbmRsZXJfID0gc2guaGFuZGxlU291cmNlKHNvdXJjZSwgdGhpcywgdGhpcy5vcHRpb25zXyk7XG4gICAgdGhpcy5vbignZGlzcG9zZScsIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBhbnkgZXhpc3RpbmcgU291cmNlSGFuZGxlcnMgYW5kIGxpc3RlbmVycyB3aGVuIHRoZSBUZWNoIGlzIGRpc3Bvc2VkLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI2Rpc3Bvc2VcbiAgICovXG4gIF9UZWNoLnByb3RvdHlwZS5kaXNwb3NlU291cmNlSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBpZiB3ZSBoYXZlIGEgc291cmNlIGFuZCBnZXQgYW5vdGhlciBvbmVcbiAgICAvLyB0aGVuIHdlIGFyZSBsb2FkaW5nIHNvbWV0aGluZyBuZXdcbiAgICAvLyB0aGFuIGNsZWFyIGFsbCBvZiBvdXIgY3VycmVudCB0cmFja3NcbiAgICBpZiAodGhpcy5jdXJyZW50U291cmNlXykge1xuICAgICAgdGhpcy5jbGVhclRyYWNrcyhbJ2F1ZGlvJywgJ3ZpZGVvJ10pO1xuICAgICAgdGhpcy5jdXJyZW50U291cmNlXyA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gYWx3YXlzIGNsZWFuIHVwIGF1dG8tdGV4dCB0cmFja3NcbiAgICB0aGlzLmNsZWFudXBBdXRvVGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKHRoaXMuc291cmNlSGFuZGxlcl8pIHtcblxuICAgICAgaWYgKHRoaXMuc291cmNlSGFuZGxlcl8uZGlzcG9zZSkge1xuICAgICAgICB0aGlzLnNvdXJjZUhhbmRsZXJfLmRpc3Bvc2UoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zb3VyY2VIYW5kbGVyXyA9IG51bGw7XG4gICAgfVxuICB9O1xufTtcblxuLy8gVGhlIGJhc2UgVGVjaCBjbGFzcyBuZWVkcyB0byBiZSByZWdpc3RlcmVkIGFzIGEgQ29tcG9uZW50LiBJdCBpcyB0aGUgb25seVxuLy8gVGVjaCB0aGF0IGNhbiBiZSByZWdpc3RlcmVkIGFzIGEgQ29tcG9uZW50LlxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZWNoJywgVGVjaCk7XG5UZWNoLnJlZ2lzdGVyVGVjaCgnVGVjaCcsIFRlY2gpO1xuXG4vKipcbiAqIEEgbGlzdCBvZiB0ZWNocyB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0ZWNoT3JkZXIgb24gUGxheWVyc1xuICpcbiAqIEBwcml2YXRlXG4gKi9cblRlY2guZGVmYXVsdFRlY2hPcmRlcl8gPSBbXTtcblxudmFyIG1pZGRsZXdhcmVzID0ge307XG5cbmZ1bmN0aW9uIHVzZSh0eXBlLCBtaWRkbGV3YXJlKSB7XG4gIG1pZGRsZXdhcmVzW3R5cGVdID0gbWlkZGxld2FyZXNbdHlwZV0gfHwgW107XG4gIG1pZGRsZXdhcmVzW3R5cGVdLnB1c2gobWlkZGxld2FyZSk7XG59XG5cblxuXG5mdW5jdGlvbiBzZXRTb3VyY2UocGxheWVyLCBzcmMsIG5leHQpIHtcbiAgcGxheWVyLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtaWRkbGV3YXJlc1tzcmMudHlwZV0sIG5leHQsIHBsYXllcik7XG4gIH0sIDEpO1xufVxuXG5mdW5jdGlvbiBzZXRUZWNoKG1pZGRsZXdhcmUsIHRlY2gpIHtcbiAgbWlkZGxld2FyZS5mb3JFYWNoKGZ1bmN0aW9uIChtdykge1xuICAgIHJldHVybiBtdy5zZXRUZWNoICYmIG13LnNldFRlY2godGVjaCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXQkMShtaWRkbGV3YXJlLCB0ZWNoLCBtZXRob2QpIHtcbiAgcmV0dXJuIG1pZGRsZXdhcmUucmVkdWNlUmlnaHQobWlkZGxld2FyZUl0ZXJhdG9yKG1ldGhvZCksIHRlY2hbbWV0aG9kXSgpKTtcbn1cblxuZnVuY3Rpb24gc2V0JDEobWlkZGxld2FyZSwgdGVjaCwgbWV0aG9kLCBhcmcpIHtcbiAgcmV0dXJuIHRlY2hbbWV0aG9kXShtaWRkbGV3YXJlLnJlZHVjZShtaWRkbGV3YXJlSXRlcmF0b3IobWV0aG9kKSwgYXJnKSk7XG59XG5cbnZhciBhbGxvd2VkR2V0dGVycyA9IHtcbiAgYnVmZmVyZWQ6IDEsXG4gIGN1cnJlbnRUaW1lOiAxLFxuICBkdXJhdGlvbjogMSxcbiAgc2Vla2FibGU6IDEsXG4gIHBsYXllZDogMVxufTtcblxudmFyIGFsbG93ZWRTZXR0ZXJzID0ge1xuICBzZXRDdXJyZW50VGltZTogMVxufTtcblxuZnVuY3Rpb24gbWlkZGxld2FyZUl0ZXJhdG9yKG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBtdykge1xuICAgIGlmIChtd1ttZXRob2RdKSB7XG4gICAgICByZXR1cm4gbXdbbWV0aG9kXSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZXRTb3VyY2VIZWxwZXIoKSB7XG4gIHZhciBzcmMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgbWlkZGxld2FyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gIHZhciBuZXh0ID0gYXJndW1lbnRzWzJdO1xuICB2YXIgcGxheWVyID0gYXJndW1lbnRzWzNdO1xuICB2YXIgYWNjID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBbXTtcbiAgdmFyIGxhc3RSdW4gPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IGZhbHNlO1xuICB2YXIgbXdGYWN0b3J5ID0gbWlkZGxld2FyZVswXSxcbiAgICAgIG13cmVzdCA9IG1pZGRsZXdhcmUuc2xpY2UoMSk7XG5cbiAgLy8gaWYgbXdGYWN0b3J5IGlzIGEgc3RyaW5nLCB0aGVuIHdlJ3JlIGF0IGEgZm9yayBpbiB0aGUgcm9hZFxuXG4gIGlmICh0eXBlb2YgbXdGYWN0b3J5ID09PSAnc3RyaW5nJykge1xuICAgIHNldFNvdXJjZUhlbHBlcihzcmMsIG1pZGRsZXdhcmVzW213RmFjdG9yeV0sIG5leHQsIHBsYXllciwgYWNjLCBsYXN0UnVuKTtcblxuICAgIC8vIGlmIHdlIGhhdmUgYW4gbXdGYWN0b3J5LCBjYWxsIGl0IHdpdGggdGhlIHBsYXllciB0byBnZXQgdGhlIG13LFxuICAgIC8vIHRoZW4gY2FsbCB0aGUgbXcncyBzZXRTb3VyY2UgbWV0aG9kXG4gIH0gZWxzZSBpZiAobXdGYWN0b3J5KSB7XG4gICAgdmFyIG13ID0gbXdGYWN0b3J5KHBsYXllcik7XG5cbiAgICBtdy5zZXRTb3VyY2UoYXNzaWduKHt9LCBzcmMpLCBmdW5jdGlvbiAoZXJyLCBfc3JjKSB7XG5cbiAgICAgIC8vIHNvbWV0aGluZyBoYXBwZW5lZCwgdHJ5IHRoZSBuZXh0IG1pZGRsZXdhcmUgb24gdGhlIGN1cnJlbnQgbGV2ZWxcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byB1c2UgdGhlIG9sZCBzcmNcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHNldFNvdXJjZUhlbHBlcihzcmMsIG13cmVzdCwgbmV4dCwgcGxheWVyLCBhY2MsIGxhc3RSdW4pO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSd2ZSBzdWNjZWVkZWQsIG5vdyB3ZSBuZWVkIHRvIGdvIGRlZXBlclxuICAgICAgYWNjLnB1c2gobXcpO1xuXG4gICAgICAvLyBpZiBpdCdzIHRoZSBzYW1lIHRpbWUsIGNvbnRpbnVlIGRvZXMgdGhlIGN1cnJlbnQgY2hhaW5cbiAgICAgIC8vIG90aGVyd2lzZSwgd2Ugd2FudCB0byBnbyBkb3duIHRoZSBuZXcgY2hhaW5cbiAgICAgIHNldFNvdXJjZUhlbHBlcihfc3JjLCBzcmMudHlwZSA9PT0gX3NyYy50eXBlID8gbXdyZXN0IDogbWlkZGxld2FyZXNbX3NyYy50eXBlXSwgbmV4dCwgcGxheWVyLCBhY2MsIGxhc3RSdW4pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG13cmVzdC5sZW5ndGgpIHtcbiAgICBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtd3Jlc3QsIG5leHQsIHBsYXllciwgYWNjLCBsYXN0UnVuKTtcbiAgfSBlbHNlIGlmIChsYXN0UnVuKSB7XG4gICAgbmV4dChzcmMsIGFjYyk7XG4gIH0gZWxzZSB7XG4gICAgc2V0U291cmNlSGVscGVyKHNyYywgbWlkZGxld2FyZXNbJyonXSwgbmV4dCwgcGxheWVyLCBhY2MsIHRydWUpO1xuICB9XG59XG5cbi8qKlxuICogQG1vZHVsZSBmaWx0ZXItc291cmNlXG4gKi9cbi8qKlxuICogRmlsdGVyIG91dCBzaW5nbGUgYmFkIHNvdXJjZSBvYmplY3RzIG9yIG11bHRpcGxlIHNvdXJjZSBvYmplY3RzIGluIGFuXG4gKiBhcnJheS4gQWxzbyBmbGF0dGVucyBuZXN0ZWQgc291cmNlIG9iamVjdCBhcnJheXMgaW50byBhIDEgZGltZW5zaW9uYWxcbiAqIGFycmF5IG9mIHNvdXJjZSBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R8VGVjaH5Tb3VyY2VPYmplY3RbXX0gc3JjXG4gKiAgICAgICAgVGhlIHNyYyBvYmplY3QgdG8gZmlsdGVyXG4gKlxuICogQHJldHVybiB7VGVjaH5Tb3VyY2VPYmplY3RbXX1cbiAqICAgICAgICAgQW4gYXJyYXkgb2Ygc291cmNlb2JqZWN0cyBjb250YWluaW5nIG9ubHkgdmFsaWQgc291cmNlc1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBmaWx0ZXJTb3VyY2UgPSBmdW5jdGlvbiBmaWx0ZXJTb3VyY2Uoc3JjKSB7XG4gIC8vIHRyYXZlcnNlIGFycmF5XG4gIGlmIChBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICB2YXIgbmV3c3JjID0gW107XG5cbiAgICBzcmMuZm9yRWFjaChmdW5jdGlvbiAoc3Jjb2JqKSB7XG4gICAgICBzcmNvYmogPSBmaWx0ZXJTb3VyY2Uoc3Jjb2JqKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3Jjb2JqKSkge1xuICAgICAgICBuZXdzcmMgPSBuZXdzcmMuY29uY2F0KHNyY29iaik7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNyY29iaikpIHtcbiAgICAgICAgbmV3c3JjLnB1c2goc3Jjb2JqKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHNyYyA9IG5ld3NyYztcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyAmJiBzcmMudHJpbSgpKSB7XG4gICAgLy8gY29udmVydCBzdHJpbmcgaW50byBvYmplY3RcbiAgICBzcmMgPSBbeyBzcmM6IHNyYyB9XTtcbiAgfSBlbHNlIGlmIChpc09iamVjdChzcmMpICYmIHR5cGVvZiBzcmMuc3JjID09PSAnc3RyaW5nJyAmJiBzcmMuc3JjICYmIHNyYy5zcmMudHJpbSgpKSB7XG4gICAgLy8gc3JjIGlzIGFscmVhZHkgdmFsaWRcbiAgICBzcmMgPSBbc3JjXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbnZhbGlkIHNvdXJjZSwgdHVybiBpdCBpbnRvIGFuIGVtcHR5IGFycmF5XG4gICAgc3JjID0gW107XG4gIH1cblxuICByZXR1cm4gc3JjO1xufTtcblxuLyoqXG4gKiBAZmlsZSBsb2FkZXIuanNcbiAqL1xuLyoqXG4gKiBUaGUgYE1lZGlhTG9hZGVyYCBpcyB0aGUgYENvbXBvbmVudGAgdGhhdCBkZWNpZGVzIHdoaWNoIHBsYXliYWNrIHRlY2hub2xvZ3kgdG8gbG9hZFxuICogd2hlbiBhIHBsYXllciBpcyBpbml0aWFsaXplZC5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTWVkaWFMb2FkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhNZWRpYUxvYWRlciwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBhdHRhY2ggdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3Ryb2Ugb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIHJ1biB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gTWVkaWFMb2FkZXIocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1lZGlhTG9hZGVyKTtcblxuICAgIC8vIE1lZGlhTG9hZGVyIGhhcyBubyBlbGVtZW50XG4gICAgdmFyIG9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKHsgY3JlYXRlRWw6IGZhbHNlIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHNvdXJjZXMgd2hlbiB0aGUgcGxheWVyIGlzIGluaXRpYWxpemVkLFxuICAgIC8vIGxvYWQgdGhlIGZpcnN0IHN1cHBvcnRlZCBwbGF5YmFjayB0ZWNobm9sb2d5LlxuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zXywgcmVhZHkpKTtcblxuICAgIGlmICghb3B0aW9ucy5wbGF5ZXJPcHRpb25zLnNvdXJjZXMgfHwgb3B0aW9ucy5wbGF5ZXJPcHRpb25zLnNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IG9wdGlvbnMucGxheWVyT3B0aW9ucy50ZWNoT3JkZXI7IGkgPCBqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ZWNoTmFtZSA9IHRvVGl0bGVDYXNlKGpbaV0pO1xuICAgICAgICB2YXIgdGVjaCA9IFRlY2guZ2V0VGVjaCh0ZWNoTmFtZSk7XG5cbiAgICAgICAgLy8gU3VwcG9ydCBvbGQgYmVoYXZpb3Igb2YgdGVjaHMgYmVpbmcgcmVnaXN0ZXJlZCBhcyBjb21wb25lbnRzLlxuICAgICAgICAvLyBSZW1vdmUgb25jZSB0aGF0IGRlcHJlY2F0ZWQgYmVoYXZpb3IgaXMgcmVtb3ZlZC5cbiAgICAgICAgaWYgKCF0ZWNoTmFtZSkge1xuICAgICAgICAgIHRlY2ggPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KHRlY2hOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoaXMgdGVjaG5vbG9neVxuICAgICAgICBpZiAodGVjaCAmJiB0ZWNoLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICBwbGF5ZXIubG9hZFRlY2hfKHRlY2hOYW1lKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMb29wIHRocm91Z2ggcGxheWJhY2sgdGVjaG5vbG9naWVzIChIVE1MNSwgRmxhc2gpIGFuZCBjaGVjayBmb3Igc3VwcG9ydC5cbiAgICAgIC8vIFRoZW4gbG9hZCB0aGUgYmVzdCBzb3VyY2UuXG4gICAgICAvLyBBIGZldyBhc3N1bXB0aW9ucyBoZXJlOlxuICAgICAgLy8gICBBbGwgcGxheWJhY2sgdGVjaG5vbG9naWVzIHJlc3BlY3QgcHJlbG9hZCBmYWxzZS5cbiAgICAgIHBsYXllci5zcmMob3B0aW9ucy5wbGF5ZXJPcHRpb25zLnNvdXJjZXMpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gTWVkaWFMb2FkZXI7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVkaWFMb2FkZXInLCBNZWRpYUxvYWRlcik7XG5cbi8qKlxuICogQGZpbGUgYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogQ2xpY2thYmxlIENvbXBvbmVudCB3aGljaCBpcyBjbGlja2FibGUgb3Iga2V5Ym9hcmQgYWN0aW9uYWJsZSxcbiAqIGJ1dCBpcyBub3QgYSBuYXRpdmUgSFRNTCBidXR0b24uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIENsaWNrYWJsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKENsaWNrYWJsZUNvbXBvbmVudCwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2xpY2thYmxlQ29tcG9uZW50KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENsaWNrYWJsZUNvbXBvbmVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmVtaXRUYXBFdmVudHMoKTtcblxuICAgIF90aGlzLmVuYWJsZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0YWc9ZGl2XVxuICAgKiAgICAgICAgVGhlIGVsZW1lbnQncyBub2RlIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlcz17fV1cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIHRhZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2Rpdic7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBwcm9wcyA9IGFzc2lnbih7XG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInZqcy1pY29uLXBsYWNlaG9sZGVyXCI+PC9zcGFuPicsXG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpLFxuICAgICAgdGFiSW5kZXg6IDBcbiAgICB9LCBwcm9wcyk7XG5cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgbG9nJDEuZXJyb3IoJ0NyZWF0aW5nIGEgQ2xpY2thYmxlQ29tcG9uZW50IHdpdGggYW4gSFRNTCBlbGVtZW50IG9mICcgKyB0YWcgKyAnIGlzIG5vdCBzdXBwb3J0ZWQ7IHVzZSBhIEJ1dHRvbiBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIC8vIEFkZCBBUklBIGF0dHJpYnV0ZXMgZm9yIGNsaWNrYWJsZSBlbGVtZW50IHdoaWNoIGlzIG5vdCBhIG5hdGl2ZSBIVE1MIGJ1dHRvblxuICAgIGF0dHJpYnV0ZXMgPSBhc3NpZ24oe1xuICAgICAgJ3JvbGUnOiAnYnV0dG9uJyxcblxuICAgICAgLy8gbGV0IHRoZSBzY3JlZW4gcmVhZGVyIHVzZXIga25vdyB0aGF0IHRoZSB0ZXh0IG9mIHRoZSBlbGVtZW50IG1heSBjaGFuZ2VcbiAgICAgICdhcmlhLWxpdmUnOiAncG9saXRlJ1xuICAgIH0sIGF0dHJpYnV0ZXMpO1xuXG4gICAgdGhpcy50YWJJbmRleF8gPSBwcm9wcy50YWJJbmRleDtcblxuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgdGFnLCBwcm9wcywgYXR0cmlidXRlcyk7XG5cbiAgICB0aGlzLmNyZWF0ZUNvbnRyb2xUZXh0RWwoZWwpO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjb250cm9sIHRleHQgZWxlbWVudCBvbiB0aGlzIGBDb21wb25lbnRgXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gW2VsXVxuICAgKiAgICAgICAgUGFyZW50IGVsZW1lbnQgZm9yIHRoZSBjb250cm9sIHRleHQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGNvbnRyb2wgdGV4dCBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlQ29udHJvbFRleHRFbCA9IGZ1bmN0aW9uIGNyZWF0ZUNvbnRyb2xUZXh0RWwoZWwpIHtcbiAgICB0aGlzLmNvbnRyb2xUZXh0RWxfID0gY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC10ZXh0J1xuICAgIH0pO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRyb2xUZXh0RWxfKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xUZXh0KHRoaXMuY29udHJvbFRleHRfLCBlbCk7XG5cbiAgICByZXR1cm4gdGhpcy5jb250cm9sVGV4dEVsXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgbG9jYWxpemUgdGV4dCB0byB1c2UgZm9yIHRoZSBjb250cm9scyBvbiB0aGUgYENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dF1cbiAgICogICAgICAgIENvbnRyb2wgdGV4dCBmb3IgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBbZWw9dGhpcy5lbCgpXVxuICAgKiAgICAgICAgRWxlbWVudCB0byBzZXQgdGhlIHRpdGxlIG9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgLSBUaGUgY29udHJvbCB0ZXh0IHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuY29udHJvbFRleHQgPSBmdW5jdGlvbiBjb250cm9sVGV4dCh0ZXh0KSB7XG4gICAgdmFyIGVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmVsKCk7XG5cbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xUZXh0XyB8fCAnTmVlZCBUZXh0JztcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxpemVkVGV4dCA9IHRoaXMubG9jYWxpemUodGV4dCk7XG5cbiAgICB0aGlzLmNvbnRyb2xUZXh0XyA9IHRleHQ7XG4gICAgdGV4dENvbnRlbnQodGhpcy5jb250cm9sVGV4dEVsXywgbG9jYWxpemVkVGV4dCk7XG4gICAgaWYgKCF0aGlzLm5vbkljb25Db250cm9sKSB7XG4gICAgICAvLyBTZXQgdGl0bGUgYXR0cmlidXRlIGlmIG9ubHkgYW4gaWNvbiBpcyBzaG93blxuICAgICAgZWwuc2V0QXR0cmlidXRlKCd0aXRsZScsIGxvY2FsaXplZFRleHQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY29udHJvbCB2anMtYnV0dG9uICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGlzIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkXykge1xuICAgICAgdGhpcy5lbmFibGVkXyA9IHRydWU7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZGlzYWJsZWQnKTtcbiAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnRhYkluZGV4XyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIHRoaXMudGFiSW5kZXhfKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub24oWyd0YXAnLCAnY2xpY2snXSwgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMpO1xuICAgICAgdGhpcy5vbignYmx1cicsIHRoaXMuaGFuZGxlQmx1cik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoaXMgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWRpc2FibGVkJyk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICBpZiAodHlwZW9mIHRoaXMudGFiSW5kZXhfICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5lbF8ucmVtb3ZlQXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgIH1cbiAgICB0aGlzLm9mZihbJ3RhcCcsICdjbGljayddLCB0aGlzLmhhbmRsZUNsaWNrKTtcbiAgICB0aGlzLm9mZignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzKTtcbiAgICB0aGlzLm9mZignYmx1cicsIHRoaXMuaGFuZGxlQmx1cik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhIGBDbGlja2FibGVDb21wb25lbnRgIGdldHM6XG4gICAqIC0gQ2xpY2tlZCAodmlhIHRoZSBgY2xpY2tgIGV2ZW50LCBsaXN0ZW5pbmcgc3RhcnRzIGluIHRoZSBjb25zdHJ1Y3RvcilcbiAgICogLSBUYXBwZWQgKHZpYSB0aGUgYHRhcGAgZXZlbnQsIGxpc3RlbmluZyBzdGFydHMgaW4gdGhlIGNvbnN0cnVjdG9yKVxuICAgKiAtIFRoZSBmb2xsb3dpbmcgdGhpbmdzIGhhcHBlbiBpbiBvcmRlcjpcbiAgICogICAxLiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUZvY3VzfSBpcyBjYWxsZWQgdmlhIGEgYGZvY3VzYCBldmVudCBvbiB0aGVcbiAgICogICAgICBgQ2xpY2thYmxlQ29tcG9uZW50YC5cbiAgICogICAyLiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUZvY3VzfSBhZGRzIGEgbGlzdGVuZXIgZm9yIGBrZXlkb3duYCBvbiB1c2luZ1xuICAgKiAgICAgIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlS2V5UHJlc3N9LlxuICAgKiAgIDMuIGBDbGlja2FibGVDb21wb25lbnRgIGhhcyBub3QgaGFkIGEgYGJsdXJgIGV2ZW50IChgYmx1cmAgbWVhbnMgdGhhdCBmb2N1cyB3YXMgbG9zdCkuIFRoZSB1c2VyIHByZXNzZXNcbiAgICogICAgICB0aGUgc3BhY2Ugb3IgZW50ZXIga2V5LlxuICAgKiAgIDQuIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlS2V5UHJlc3N9IGNhbGxzIHRoaXMgZnVuY3Rpb24gd2l0aCB0aGUgYGtleWRvd25gXG4gICAqICAgICAgZXZlbnQgYXMgYSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHt9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQ2xpY2thYmxlQ29tcG9uZW50YCBnYWlucyBmb2N1cyB2aWEgYSBgZm9jdXNgIGV2ZW50LlxuICAgKiBUdXJucyBvbiBsaXN0ZW5pbmcgZm9yIGBrZXlkb3duYCBldmVudHMuIFdoZW4gdGhleSBoYXBwZW4gaXRcbiAgICogY2FsbHMgYHRoaXMuaGFuZGxlS2V5UHJlc3NgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBmb2N1c2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGZvY3VzXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIGhhbmRsZUZvY3VzKGV2ZW50KSB7XG4gICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoaXMgQ2xpY2thYmxlQ29tcG9uZW50IGhhcyBmb2N1cyBhbmQgYSBrZXkgZ2V0cyBwcmVzc2VkIGRvd24uIEJ5XG4gICAqIGRlZmF1bHQgaXQgd2lsbCBjYWxsIGB0aGlzLmhhbmRsZUNsaWNrYCB3aGVuIHRoZSBrZXkgaXMgc3BhY2Ugb3IgZW50ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBTdXBwb3J0IFNwYWNlICgzMikgb3IgRW50ZXIgKDEzKSBrZXkgb3BlcmF0aW9uIHRvIGZpcmUgYSBjbGljayBldmVudFxuICAgIGlmIChldmVudC53aGljaCA9PT0gMzIgfHwgZXZlbnQud2hpY2ggPT09IDEzKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdjbGljaycpO1xuICAgIH0gZWxzZSBpZiAoX0NvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MpIHtcblxuICAgICAgLy8gUGFzcyBrZXlwcmVzcyBoYW5kbGluZyB1cCBmb3IgdW5zdXBwb3J0ZWQga2V5c1xuICAgICAgX0NvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGBDbGlja2FibGVDb21wb25lbnRgIGxvc2VzIGZvY3VzLiBUdXJucyBvZmYgdGhlIGxpc3RlbmVyIGZvclxuICAgKiBga2V5ZG93bmAgZXZlbnRzLiBXaGljaCBTdG9wcyBgdGhpcy5oYW5kbGVLZXlQcmVzc2AgZnJvbSBnZXR0aW5nIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgYmx1cmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGJsdXJcbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKGV2ZW50KSB7XG4gICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIGJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICB9O1xuXG4gIHJldHVybiBDbGlja2FibGVDb21wb25lbnQ7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2xpY2thYmxlQ29tcG9uZW50JywgQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAZmlsZSBwb3N0ZXItaW1hZ2UuanNcbiAqL1xuLyoqXG4gKiBBIGBDbGlja2FibGVDb21wb25lbnRgIHRoYXQgaGFuZGxlcyBzaG93aW5nIHRoZSBwb3N0ZXIgaW1hZ2UgZm9yIHRoZSBwbGF5ZXIuXG4gKlxuICogQGV4dGVuZHMgQ2xpY2thYmxlQ29tcG9uZW50XG4gKi9cblxudmFyIFBvc3RlckltYWdlID0gZnVuY3Rpb24gKF9DbGlja2FibGVDb21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUG9zdGVySW1hZ2UsIF9DbGlja2FibGVDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYXR0YWNoIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUG9zdGVySW1hZ2UocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9zdGVySW1hZ2UpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ2xpY2thYmxlQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGUoKTtcbiAgICBwbGF5ZXIub24oJ3Bvc3RlcmNoYW5nZScsIGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZSkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBhbmQgZGlzcG9zZSBvZiB0aGUgYFBvc3RlckltYWdlYC5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5wbGF5ZXIoKS5vZmYoJ3Bvc3RlcmNoYW5nZScsIHRoaXMudXBkYXRlKTtcbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYFBvc3RlckltYWdlYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUG9zdGVySW1hZ2UucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGVsID0gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wb3N0ZXInLFxuXG4gICAgICAvLyBEb24ndCB3YW50IHBvc3RlciB0byBiZSB0YWJiYWJsZS5cbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0pO1xuXG4gICAgLy8gVG8gZW5zdXJlIHRoZSBwb3N0ZXIgaW1hZ2UgcmVzaXplcyB3aGlsZSBtYWludGFpbmluZyBpdHMgb3JpZ2luYWwgYXNwZWN0XG4gICAgLy8gcmF0aW8sIHVzZSBhIGRpdiB3aXRoIGBiYWNrZ3JvdW5kLXNpemVgIHdoZW4gYXZhaWxhYmxlLiBGb3IgYnJvd3NlcnMgdGhhdFxuICAgIC8vIGRvIG5vdCBzdXBwb3J0IGBiYWNrZ3JvdW5kLXNpemVgIChlLmcuIElFOCksIGZhbGwgYmFjayBvbiB1c2luZyBhIHJlZ3VsYXJcbiAgICAvLyBpbWcgZWxlbWVudC5cbiAgICBpZiAoIUJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURUQpIHtcbiAgICAgIHRoaXMuZmFsbGJhY2tJbWdfID0gY3JlYXRlRWwoJ2ltZycpO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5mYWxsYmFja0ltZ18pO1xuICAgIH1cblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogQW4ge0BsaW5rIEV2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZvciB7QGxpbmsgUGxheWVyI3Bvc3RlcmNoYW5nZX0gZXZlbnRzLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcG9zdGVyY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgUGxheWVyI3Bvc3RlcmNoYW5nZWAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvbi5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgdmFyIHVybCA9IHRoaXMucGxheWVyKCkucG9zdGVyKCk7XG5cbiAgICB0aGlzLnNldFNyYyh1cmwpO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBwb3N0ZXIgc291cmNlIHdlIHNob3VsZCBkaXNwbGF5Om5vbmUgb24gdGhpcyBjb21wb25lbnRcbiAgICAvLyBzbyBpdCdzIG5vdCBzdGlsbCBjbGlja2FibGUgb3IgcmlnaHQtY2xpY2thYmxlXG4gICAgaWYgKHVybCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2Ugb2YgdGhlIGBQb3N0ZXJJbWFnZWAgZGVwZW5kaW5nIG9uIHRoZSBkaXNwbGF5IG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiAgICAgICAgVGhlIFVSTCB0byB0aGUgc291cmNlIGZvciB0aGUgYFBvc3RlckltYWdlYC5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuc2V0U3JjID0gZnVuY3Rpb24gc2V0U3JjKHVybCkge1xuICAgIGlmICh0aGlzLmZhbGxiYWNrSW1nXykge1xuICAgICAgdGhpcy5mYWxsYmFja0ltZ18uc3JjID0gdXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYmFja2dyb3VuZEltYWdlID0gJyc7XG5cbiAgICAgIC8vIEFueSBmYWxzZXkgdmFsdWVzIHNob3VsZCBzdGF5IGFzIGFuIGVtcHR5IHN0cmluZywgb3RoZXJ3aXNlXG4gICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgYW4gZXh0cmEgZXJyb3JcbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicgKyB1cmwgKyAnXCIpJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbF8uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYmFja2dyb3VuZEltYWdlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQW4ge0BsaW5rIEV2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZvciBjbGlja3Mgb24gdGhlIGBQb3N0ZXJJbWFnZWAuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUNsaWNrfSBmb3IgaW5zdGFuY2VzIHdoZXJlIHRoaXMgd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICArICAgICAgICBUaGUgYGNsaWNrYCwgYHRhcGAgb3IgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKi9cblxuXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBhIGNsaWNrIHRvIHRyaWdnZXIgcGxheWJhY2sgd2hlbiBjb250cm9scyBhcmUgZGlzYWJsZWRcbiAgICBpZiAoIXRoaXMucGxheWVyXy5jb250cm9scygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQb3N0ZXJJbWFnZTtcbn0oQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQb3N0ZXJJbWFnZScsIFBvc3RlckltYWdlKTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWRpc3BsYXkuanNcbiAqL1xudmFyIGRhcmtHcmF5ID0gJyMyMjInO1xudmFyIGxpZ2h0R3JheSA9ICcjY2NjJztcbnZhciBmb250TWFwID0ge1xuICBtb25vc3BhY2U6ICdtb25vc3BhY2UnLFxuICBzYW5zU2VyaWY6ICdzYW5zLXNlcmlmJyxcbiAgc2VyaWY6ICdzZXJpZicsXG4gIG1vbm9zcGFjZVNhbnNTZXJpZjogJ1wiQW5kYWxlIE1vbm9cIiwgXCJMdWNpZGEgQ29uc29sZVwiLCBtb25vc3BhY2UnLFxuICBtb25vc3BhY2VTZXJpZjogJ1wiQ291cmllciBOZXdcIiwgbW9ub3NwYWNlJyxcbiAgcHJvcG9ydGlvbmFsU2Fuc1NlcmlmOiAnc2Fucy1zZXJpZicsXG4gIHByb3BvcnRpb25hbFNlcmlmOiAnc2VyaWYnLFxuICBjYXN1YWw6ICdcIkNvbWljIFNhbnMgTVNcIiwgSW1wYWN0LCBmYW50YXN5JyxcbiAgc2NyaXB0OiAnXCJNb25vdHlwZSBDb3JzaXZhXCIsIGN1cnNpdmUnLFxuICBzbWFsbGNhcHM6ICdcIkFuZGFsZSBNb25vXCIsIFwiTHVjaWRhIENvbnNvbGVcIiwgbW9ub3NwYWNlLCBzYW5zLXNlcmlmJ1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3QgYW4gcmdiYSBjb2xvciBmcm9tIGEgZ2l2ZW4gaGV4IGNvbG9yIGNvZGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbG9yXG4gKiAgICAgICAgSGV4IG51bWJlciBmb3IgY29sb3IsIGxpa2UgI2YwZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eVxuICogICAgICAgIFZhbHVlIGZvciBvcGFjaXR5LCAwLjAgLSAxLjAuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgcmdiYSBjb2xvciB0aGF0IHdhcyBjcmVhdGVkLCBsaWtlICdyZ2JhKDI1NSwgMCwgMCwgMC4zKScuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0Q29sb3IoY29sb3IsIG9wYWNpdHkpIHtcbiAgcmV0dXJuICdyZ2JhKCcgK1xuICAvLyBjb2xvciBsb29rcyBsaWtlIFwiI2YwZVwiXG4gIHBhcnNlSW50KGNvbG9yWzFdICsgY29sb3JbMV0sIDE2KSArICcsJyArIHBhcnNlSW50KGNvbG9yWzJdICsgY29sb3JbMl0sIDE2KSArICcsJyArIHBhcnNlSW50KGNvbG9yWzNdICsgY29sb3JbM10sIDE2KSArICcsJyArIG9wYWNpdHkgKyAnKSc7XG59XG5cbi8qKlxuICogVHJ5IHRvIHVwZGF0ZSB0aGUgc3R5bGUgb2YgYSBET00gZWxlbWVudC4gU29tZSBzdHlsZSBjaGFuZ2VzIHdpbGwgdGhyb3cgYW4gZXJyb3IsXG4gKiBwYXJ0aWN1bGFybHkgaW4gSUU4LiBUaG9zZSBzaG91bGQgYmUgbm9vcHMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBET00gZWxlbWVudCB0byBiZSBzdHlsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlXG4gKiAgICAgICAgVGhlIENTUyBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBzdHlsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqICAgICAgICBUaGUgc3R5bGUgcnVsZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0cnlVcGRhdGVTdHlsZShlbCwgc3R5bGUsIHJ1bGUpIHtcbiAgdHJ5IHtcbiAgICBlbC5zdHlsZVtzdHlsZV0gPSBydWxlO1xuICB9IGNhdGNoIChlKSB7XG5cbiAgICAvLyBTYXRpc2ZpZXMgbGludGVyLlxuICAgIHJldHVybjtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgdGV4dCB0cmFjayBjdWVzLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUZXh0VHJhY2tEaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGV4dFRyYWNrRGlzcGxheSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYFRleHRUcmFja0Rpc3BsYXlgIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XG5cbiAgICBwbGF5ZXIub24oJ2xvYWRzdGFydCcsIGJpbmQoX3RoaXMsIF90aGlzLnRvZ2dsZURpc3BsYXkpKTtcbiAgICBwbGF5ZXIub24oJ3RleHR0cmFja2NoYW5nZScsIGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBwbGF5ZXIub24oJ2xvYWRzdGFydCcsIGJpbmQoX3RoaXMsIF90aGlzLnByZXNlbGVjdFRyYWNrKSk7XG5cbiAgICAvLyBUaGlzIHVzZWQgdG8gYmUgY2FsbGVkIGR1cmluZyBwbGF5ZXIgaW5pdCwgYnV0IHdhcyBjYXVzaW5nIGFuIGVycm9yXG4gICAgLy8gaWYgYSB0cmFjayBzaG91bGQgc2hvdyBieSBkZWZhdWx0IGFuZCB0aGUgZGlzcGxheSBoYWRuJ3QgbG9hZGVkIHlldC5cbiAgICAvLyBTaG91bGQgcHJvYmFibHkgYmUgbW92ZWQgdG8gYW4gZXh0ZXJuYWwgdHJhY2sgbG9hZGVyIHdoZW4gd2Ugc3VwcG9ydFxuICAgIC8vIHRyYWNrcyB0aGF0IGRvbid0IG5lZWQgYSBkaXNwbGF5LlxuICAgIHBsYXllci5yZWFkeShiaW5kKF90aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGxheWVyLnRlY2hfICYmIHBsYXllci50ZWNoXy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGxheWVyLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcblxuICAgICAgdmFyIHRyYWNrcyA9IHRoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucy50cmFja3MgfHwgW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucGxheWVyXy5hZGRSZW1vdGVUZXh0VHJhY2sodHJhY2tzW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmVzZWxlY3RUcmFjaygpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgKiBQcmVzZWxlY3QgYSB0cmFjayBmb2xsb3dpbmcgdGhpcyBwcmVjZWRlbmNlOlxuICAqIC0gbWF0Y2hlcyB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCB7QGxpbmsgVGV4dFRyYWNrfSdzIGxhbmd1YWdlIGFuZCBraW5kXG4gICogLSBtYXRjaGVzIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIHtAbGluayBUZXh0VHJhY2t9J3MgbGFuZ3VhZ2Ugb25seVxuICAqIC0gaXMgdGhlIGZpcnN0IGRlZmF1bHQgY2FwdGlvbnMgdHJhY2tcbiAgKiAtIGlzIHRoZSBmaXJzdCBkZWZhdWx0IGRlc2NyaXB0aW9ucyB0cmFja1xuICAqXG4gICogQGxpc3RlbnMgUGxheWVyI2xvYWRzdGFydFxuICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUucHJlc2VsZWN0VHJhY2sgPSBmdW5jdGlvbiBwcmVzZWxlY3RUcmFjaygpIHtcbiAgICB2YXIgbW9kZXMgPSB7IGNhcHRpb25zOiAxLCBzdWJ0aXRsZXM6IDEgfTtcbiAgICB2YXIgdHJhY2tMaXN0ID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcbiAgICB2YXIgdXNlclByZWYgPSB0aGlzLnBsYXllcl8uY2FjaGVfLnNlbGVjdGVkTGFuZ3VhZ2U7XG4gICAgdmFyIGZpcnN0RGVzYyA9IHZvaWQgMDtcbiAgICB2YXIgZmlyc3RDYXB0aW9ucyA9IHZvaWQgMDtcbiAgICB2YXIgcHJlZmVycmVkVHJhY2sgPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tMaXN0W2ldO1xuXG4gICAgICBpZiAodXNlclByZWYgJiYgdXNlclByZWYuZW5hYmxlZCAmJiB1c2VyUHJlZi5sYW5ndWFnZSA9PT0gdHJhY2subGFuZ3VhZ2UpIHtcbiAgICAgICAgLy8gQWx3YXlzIGNob29zZSB0aGUgdHJhY2sgdGhhdCBtYXRjaGVzIGJvdGggbGFuZ3VhZ2UgYW5kIGtpbmRcbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IHVzZXJQcmVmLmtpbmQpIHtcbiAgICAgICAgICBwcmVmZXJyZWRUcmFjayA9IHRyYWNrO1xuICAgICAgICAgIC8vIG9yIGNob29zZSB0aGUgZmlyc3QgdHJhY2sgdGhhdCBtYXRjaGVzIGxhbmd1YWdlXG4gICAgICAgIH0gZWxzZSBpZiAoIXByZWZlcnJlZFRyYWNrKSB7XG4gICAgICAgICAgcHJlZmVycmVkVHJhY2sgPSB0cmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIGV2ZXJ5dGhpbmcgaWYgb2ZmVGV4dFRyYWNrTWVudUl0ZW0gd2FzIGNsaWNrZWRcbiAgICAgIH0gZWxzZSBpZiAodXNlclByZWYgJiYgIXVzZXJQcmVmLmVuYWJsZWQpIHtcbiAgICAgICAgcHJlZmVycmVkVHJhY2sgPSBudWxsO1xuICAgICAgICBmaXJzdERlc2MgPSBudWxsO1xuICAgICAgICBmaXJzdENhcHRpb25zID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tbJ2RlZmF1bHQnXSkge1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ2Rlc2NyaXB0aW9ucycgJiYgIWZpcnN0RGVzYykge1xuICAgICAgICAgIGZpcnN0RGVzYyA9IHRyYWNrO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgaW4gbW9kZXMgJiYgIWZpcnN0Q2FwdGlvbnMpIHtcbiAgICAgICAgICBmaXJzdENhcHRpb25zID0gdHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgcHJlZmVycmVkVHJhY2sgbWF0Y2hlcyB0aGUgdXNlciBwcmVmZXJlbmNlIGFuZCB0YWtlc1xuICAgIC8vIHByZWNlbmRlbmNlIG92ZXIgYWxsIHRoZSBvdGhlciB0cmFja3MuXG4gICAgLy8gU28sIGRpc3BsYXkgdGhlIHByZWZlcnJlZFRyYWNrIGJlZm9yZSB0aGUgZmlyc3QgZGVmYXVsdCB0cmFja1xuICAgIC8vIGFuZCB0aGUgc3VidGl0bGVzL2NhcHRpb25zIHRyYWNrIGJlZm9yZSB0aGUgZGVzY3JpcHRpb25zIHRyYWNrXG4gICAgaWYgKHByZWZlcnJlZFRyYWNrKSB7XG4gICAgICBwcmVmZXJyZWRUcmFjay5tb2RlID0gJ3Nob3dpbmcnO1xuICAgIH0gZWxzZSBpZiAoZmlyc3RDYXB0aW9ucykge1xuICAgICAgZmlyc3RDYXB0aW9ucy5tb2RlID0gJ3Nob3dpbmcnO1xuICAgIH0gZWxzZSBpZiAoZmlyc3REZXNjKSB7XG4gICAgICBmaXJzdERlc2MubW9kZSA9ICdzaG93aW5nJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gZGlzcGxheSBvZiB7QGxpbmsgVGV4dFRyYWNrfSdzIGZyb20gdGhlIGN1cnJlbnQgc3RhdGUgaW50byB0aGUgb3RoZXIgc3RhdGUuXG4gICAqIFRoZXJlIGFyZSBvbmx5IHR3byBzdGF0ZXM6XG4gICAqIC0gJ3Nob3duJ1xuICAgKiAtICdoaWRkZW4nXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNsb2Fkc3RhcnRcbiAgICovXG5cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS50b2dnbGVEaXNwbGF5ID0gZnVuY3Rpb24gdG9nZ2xlRGlzcGxheSgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLnRlY2hfICYmIHRoaXMucGxheWVyXy50ZWNoXy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUge0BsaW5rIENvbXBvbmVudH0ncyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10ZXh0LXRyYWNrLWRpc3BsYXknXG4gICAgfSwge1xuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnLFxuICAgICAgJ2FyaWEtYXRvbWljJzogJ3RydWUnXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBkaXNwbGF5ZWQge0BsaW5rIFRleHRUcmFja31zLlxuICAgKi9cblxuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLmNsZWFyRGlzcGxheSA9IGZ1bmN0aW9uIGNsZWFyRGlzcGxheSgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5XZWJWVFQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdpbmRvdy5XZWJWVFQucHJvY2Vzc0N1ZXMod2luZG93LCBbXSwgdGhpcy5lbF8pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBkaXNwbGF5ZWQgVGV4dFRyYWNrIHdoZW4gYSBlaXRoZXIgYSB7QGxpbmsgUGxheWVyI3RleHR0cmFja2NoYW5nZX0gb3JcbiAgICogYSB7QGxpbmsgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2V9IGlzIGZpcmVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGV4dHRyYWNrY2hhbmdlXG4gICAqIEBsaXN0ZW5zIFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUudXBkYXRlRGlzcGxheSA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCk7XG5cbiAgICB0aGlzLmNsZWFyRGlzcGxheSgpO1xuXG4gICAgLy8gVHJhY2sgZGlzcGxheSBwcmlvcml0aXphdGlvbiBtb2RlbDogaWYgbXVsdGlwbGUgdHJhY2tzIGFyZSAnc2hvd2luZycsXG4gICAgLy8gIGRpc3BsYXkgdGhlIGZpcnN0ICdzdWJ0aXRsZXMnIG9yICdjYXB0aW9ucycgdHJhY2sgd2hpY2ggaXMgJ3Nob3dpbmcnLFxuICAgIC8vICBvdGhlcndpc2UgZGlzcGxheSB0aGUgZmlyc3QgJ2Rlc2NyaXB0aW9ucycgdHJhY2sgd2hpY2ggaXMgJ3Nob3dpbmcnXG5cbiAgICB2YXIgZGVzY3JpcHRpb25zVHJhY2sgPSBudWxsO1xuICAgIHZhciBjYXB0aW9uc1N1YnRpdGxlc1RyYWNrID0gbnVsbDtcbiAgICB2YXIgaSA9IHRyYWNrcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmICh0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdkZXNjcmlwdGlvbnMnKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb25zVHJhY2sgPSB0cmFjaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0aW9uc1N1YnRpdGxlc1RyYWNrID0gdHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2FwdGlvbnNTdWJ0aXRsZXNUcmFjaykge1xuICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnKSAhPT0gJ29mZicpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdvZmYnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRm9yVHJhY2soY2FwdGlvbnNTdWJ0aXRsZXNUcmFjayk7XG4gICAgfSBlbHNlIGlmIChkZXNjcmlwdGlvbnNUcmFjaykge1xuICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnKSAhPT0gJ2Fzc2VydGl2ZScpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdhc3NlcnRpdmUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRm9yVHJhY2soZGVzY3JpcHRpb25zVHJhY2spO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIGFuIHtAbGluayBUZXh0dHJhY2t9IHRvIHRvIHRoZSB7QGxpbmsgVGVjaH1zIHtAbGluayBUZXh0VHJhY2tMaXN0fS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUZXh0IHRyYWNrIG9iamVjdCB0byBiZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICovXG5cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVGb3JUcmFjayA9IGZ1bmN0aW9uIHVwZGF0ZUZvclRyYWNrKHRyYWNrKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuV2ViVlRUICE9PSAnZnVuY3Rpb24nIHx8ICF0cmFjay5hY3RpdmVDdWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG92ZXJyaWRlcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tTZXR0aW5ncy5nZXRWYWx1ZXMoKTtcbiAgICB2YXIgY3VlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRyYWNrLmFjdGl2ZUN1ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBjdWVzLnB1c2godHJhY2suYWN0aXZlQ3Vlc1tfaV0pO1xuICAgIH1cblxuICAgIHdpbmRvdy5XZWJWVFQucHJvY2Vzc0N1ZXMod2luZG93LCBjdWVzLCB0aGlzLmVsXyk7XG5cbiAgICB2YXIgaSA9IGN1ZXMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGN1ZSA9IGN1ZXNbaV07XG5cbiAgICAgIGlmICghY3VlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VlRGl2ID0gY3VlLmRpc3BsYXlTdGF0ZTtcblxuICAgICAgaWYgKG92ZXJyaWRlcy5jb2xvcikge1xuICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS5jb2xvciA9IG92ZXJyaWRlcy5jb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMudGV4dE9wYWNpdHkpIHtcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsICdjb2xvcicsIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy5jb2xvciB8fCAnI2ZmZicsIG92ZXJyaWRlcy50ZXh0T3BhY2l0eSkpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuYmFja2dyb3VuZE9wYWNpdHkpIHtcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsICdiYWNrZ3JvdW5kQ29sb3InLCBjb25zdHJ1Y3RDb2xvcihvdmVycmlkZXMuYmFja2dyb3VuZENvbG9yIHx8ICcjMDAwJywgb3ZlcnJpZGVzLmJhY2tncm91bmRPcGFjaXR5KSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLndpbmRvd0NvbG9yKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMud2luZG93T3BhY2l0eSkge1xuICAgICAgICAgIHRyeVVwZGF0ZVN0eWxlKGN1ZURpdiwgJ2JhY2tncm91bmRDb2xvcicsIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy53aW5kb3dDb2xvciwgb3ZlcnJpZGVzLndpbmRvd09wYWNpdHkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdWVEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLndpbmRvd0NvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSkge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ2Ryb3BzaGFkb3cnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUudGV4dFNoYWRvdyA9ICcycHggMnB4IDNweCAnICsgZGFya0dyYXkgKyAnLCAycHggMnB4IDRweCAnICsgZGFya0dyYXkgKyAnLCAycHggMnB4IDVweCAnICsgZGFya0dyYXk7XG4gICAgICAgIH0gZWxzZSBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ3JhaXNlZCcpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS50ZXh0U2hhZG93ID0gJzFweCAxcHggJyArIGRhcmtHcmF5ICsgJywgMnB4IDJweCAnICsgZGFya0dyYXkgKyAnLCAzcHggM3B4ICcgKyBkYXJrR3JheTtcbiAgICAgICAgfSBlbHNlIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlID09PSAnZGVwcmVzc2VkJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMXB4IDFweCAnICsgbGlnaHRHcmF5ICsgJywgMCAxcHggJyArIGxpZ2h0R3JheSArICcsIC0xcHggLTFweCAnICsgZGFya0dyYXkgKyAnLCAwIC0xcHggJyArIGRhcmtHcmF5O1xuICAgICAgICB9IGVsc2UgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUgPT09ICd1bmlmb3JtJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMCAwIDRweCAnICsgZGFya0dyYXkgKyAnLCAwIDAgNHB4ICcgKyBkYXJrR3JheSArICcsIDAgMCA0cHggJyArIGRhcmtHcmF5ICsgJywgMCAwIDRweCAnICsgZGFya0dyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuZm9udFBlcmNlbnQgJiYgb3ZlcnJpZGVzLmZvbnRQZXJjZW50ICE9PSAxKSB7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IHdpbmRvdy5wYXJzZUZsb2F0KGN1ZURpdi5zdHlsZS5mb250U2l6ZSk7XG5cbiAgICAgICAgY3VlRGl2LnN0eWxlLmZvbnRTaXplID0gZm9udFNpemUgKiBvdmVycmlkZXMuZm9udFBlcmNlbnQgKyAncHgnO1xuICAgICAgICBjdWVEaXYuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICBjdWVEaXYuc3R5bGUudG9wID0gJ2F1dG8nO1xuICAgICAgICBjdWVEaXYuc3R5bGUuYm90dG9tID0gJzJweCc7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmZvbnRGYW1pbHkgJiYgb3ZlcnJpZGVzLmZvbnRGYW1pbHkgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLmZvbnRGYW1pbHkgPT09ICdzbWFsbC1jYXBzJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmZvbnRWYXJpYW50ID0gJ3NtYWxsLWNhcHMnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmZvbnRGYW1pbHkgPSBmb250TWFwW292ZXJyaWRlcy5mb250RmFtaWx5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrRGlzcGxheTtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tEaXNwbGF5JywgVGV4dFRyYWNrRGlzcGxheSk7XG5cbi8qKlxuICogQGZpbGUgbG9hZGluZy1zcGlubmVyLmpzXG4gKi9cbi8qKlxuICogQSBsb2FkaW5nIHNwaW5uZXIgZm9yIHVzZSBkdXJpbmcgd2FpdGluZy9sb2FkaW5nIGV2ZW50cy5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTG9hZGluZ1NwaW5uZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhMb2FkaW5nU3Bpbm5lciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTG9hZGluZ1NwaW5uZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9hZGluZ1NwaW5uZXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgTG9hZGluZ1NwaW5uZXJgcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZG9tIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuICBMb2FkaW5nU3Bpbm5lci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxvYWRpbmctc3Bpbm5lcicsXG4gICAgICBkaXI6ICdsdHInXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIExvYWRpbmdTcGlubmVyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0xvYWRpbmdTcGlubmVyJywgTG9hZGluZ1NwaW5uZXIpO1xuXG4vKipcbiAqIEBmaWxlIGJ1dHRvbi5qc1xuICovXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBidXR0b25zLlxuICpcbiAqIEBleHRlbmRzIENsaWNrYWJsZUNvbXBvbmVudFxuICovXG5cbnZhciBCdXR0b24gPSBmdW5jdGlvbiAoX0NsaWNrYWJsZUNvbXBvbmVudCkge1xuICBpbmhlcml0cyhCdXR0b24sIF9DbGlja2FibGVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEJ1dHRvbigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBCdXR0b24pO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9DbGlja2FibGVDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQnV0dG9uYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFnPVwiYnV0dG9uXCJdXG4gICAqICAgICAgICBUaGUgZWxlbWVudCdzIG5vZGUgdHlwZS4gVGhpcyBhcmd1bWVudCBpcyBJR05PUkVEOiBubyBtYXR0ZXIgd2hhdFxuICAgKiAgICAgICAgaXMgcGFzc2VkLCBpdCB3aWxsIGFsd2F5cyBjcmVhdGUgYSBgYnV0dG9uYCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzPXt9XVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuICBCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwodGFnKSB7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICB0YWcgPSAnYnV0dG9uJztcblxuICAgIHByb3BzID0gYXNzaWduKHtcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwidmpzLWljb24tcGxhY2Vob2xkZXJcIj48L3NwYW4+JyxcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKClcbiAgICB9LCBwcm9wcyk7XG5cbiAgICAvLyBBZGQgYXR0cmlidXRlcyBmb3IgYnV0dG9uIGVsZW1lbnRcbiAgICBhdHRyaWJ1dGVzID0gYXNzaWduKHtcblxuICAgICAgLy8gTmVjZXNzYXJ5IHNpbmNlIHRoZSBkZWZhdWx0IGJ1dHRvbiB0eXBlIGlzIFwic3VibWl0XCJcbiAgICAgICd0eXBlJzogJ2J1dHRvbicsXG5cbiAgICAgIC8vIGxldCB0aGUgc2NyZWVuIHJlYWRlciB1c2VyIGtub3cgdGhhdCB0aGUgdGV4dCBvZiB0aGUgYnV0dG9uIG1heSBjaGFuZ2VcbiAgICAgICdhcmlhLWxpdmUnOiAncG9saXRlJ1xuICAgIH0sIGF0dHJpYnV0ZXMpO1xuXG4gICAgdmFyIGVsID0gQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHRhZywgcHJvcHMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgdGhpcy5jcmVhdGVDb250cm9sVGV4dEVsKGVsKTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2hpbGQgYENvbXBvbmVudGAgaW5zaWRlIG9mIHRoaXMgYEJ1dHRvbmAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfENvbXBvbmVudH0gY2hpbGRcbiAgICogICAgICAgIFRoZSBuYW1lIG9yIGluc3RhbmNlIG9mIGEgY2hpbGQgdG8gYWRkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIG9wdGlvbnMgdGhhdCB3aWxsIGdldCBwYXNzZWQgdG8gY2hpbGRyZW4gb2ZcbiAgICogICAgICAgIHRoZSBjaGlsZC5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiAgICAgICAgIFRoZSBgQ29tcG9uZW50YCB0aGF0IGdldHMgYWRkZWQgYXMgYSBjaGlsZC4gV2hlbiB1c2luZyBhIHN0cmluZyB0aGVcbiAgICogICAgICAgICBgQ29tcG9uZW50YCB3aWxsIGdldCBjcmVhdGVkIGJ5IHRoaXMgcHJvY2Vzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1XG4gICAqL1xuXG5cbiAgQnV0dG9uLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkKGNoaWxkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcblxuICAgIGxvZyQxLndhcm4oJ0FkZGluZyBhbiBhY3Rpb25hYmxlICh1c2VyIGNvbnRyb2xsYWJsZSkgY2hpbGQgdG8gYSBCdXR0b24gKCcgKyBjbGFzc05hbWUgKyAnKSBpcyBub3Qgc3VwcG9ydGVkOyB1c2UgYSBDbGlja2FibGVDb21wb25lbnQgaW5zdGVhZC4nKTtcblxuICAgIC8vIEF2b2lkIHRoZSBlcnJvciBtZXNzYWdlIGdlbmVyYXRlZCBieSBDbGlja2FibGVDb21wb25lbnQncyBhZGRDaGlsZCBtZXRob2RcbiAgICByZXR1cm4gQ29tcG9uZW50LnByb3RvdHlwZS5hZGRDaGlsZC5jYWxsKHRoaXMsIGNoaWxkLCBvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIHRoZSBgQnV0dG9uYCBlbGVtZW50IHNvIHRoYXQgaXQgY2FuIGJlIGFjdGl2YXRlZCBvciBjbGlja2VkLiBVc2UgdGhpcyB3aXRoXG4gICAqIHtAbGluayBCdXR0b24jZGlzYWJsZX0uXG4gICAqL1xuXG5cbiAgQnV0dG9uLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuZW5hYmxlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5lbF8ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhlIGBCdXR0b25gIGVsZW1lbnQgc28gdGhhdCBpdCBjYW5ub3QgYmUgYWN0aXZhdGVkIG9yIGNsaWNrZWQuIFVzZSB0aGlzIHdpdGhcbiAgICoge0BsaW5rIEJ1dHRvbiNlbmFibGV9LlxuICAgKi9cblxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGEgYEJ1dHRvbmAgaGFzIGZvY3VzIGFuZCBga2V5ZG93bmAgaXMgdHJpZ2dlcmVkIHZpYSBhIGtleVxuICAgKiBwcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGdldCBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBCdXR0b24ucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcblxuICAgIC8vIElnbm9yZSBTcGFjZSAoMzIpIG9yIEVudGVyICgxMykga2V5IG9wZXJhdGlvbiwgd2hpY2ggaXMgaGFuZGxlZCBieSB0aGUgYnJvd3NlciBmb3IgYSBidXR0b24uXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzMiB8fCBldmVudC53aGljaCA9PT0gMTMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQYXNzIGtleXByZXNzIGhhbmRsaW5nIHVwIGZvciB1bnN1cHBvcnRlZCBrZXlzXG4gICAgX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MuY2FsbCh0aGlzLCBldmVudCk7XG4gIH07XG5cbiAgcmV0dXJuIEJ1dHRvbjtcbn0oQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdCdXR0b24nLCBCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGJpZy1wbGF5LWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBpbml0aWFsIHBsYXkgYnV0dG9uIHRoYXQgc2hvd3MgYmVmb3JlIHRoZSB2aWRlbyBoYXMgcGxheWVkLiBUaGUgaGlkaW5nIG9mIHRoZVxuICogYEJpZ1BsYXlCdXR0b25gIGdldCBkb25lIHZpYSBDU1MgYW5kIGBQbGF5ZXJgIHN0YXRlcy5cbiAqXG4gKiBAZXh0ZW5kcyBCdXR0b25cbiAqL1xuXG52YXIgQmlnUGxheUJ1dHRvbiA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKEJpZ1BsYXlCdXR0b24sIF9CdXR0b24pO1xuXG4gIGZ1bmN0aW9uIEJpZ1BsYXlCdXR0b24ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQmlnUGxheUJ1dHRvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm1vdXNldXNlZF8gPSBmYWxzZTtcblxuICAgIF90aGlzLm9uKCdtb3VzZWRvd24nLCBfdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuIEFsd2F5cyByZXR1cm5zICd2anMtYmlnLXBsYXktYnV0dG9uJy5cbiAgICovXG5cblxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1iaWctcGxheS1idXR0b24nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQmlnUGxheUJ1dHRvbmAgXCJjbGlja2VkXCIuIFNlZSB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fVxuICAgKiBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHBsYXlQcm9taXNlID0gdGhpcy5wbGF5ZXJfLnBsYXkoKTtcblxuICAgIC8vIGV4aXQgZWFybHkgaWYgY2xpY2tlZCB2aWEgdGhlIG1vdXNlXG4gICAgaWYgKHRoaXMubW91c2V1c2VkXyAmJiBldmVudC5jbGllbnRYICYmIGV2ZW50LmNsaWVudFkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2IgPSB0aGlzLnBsYXllcl8uZ2V0Q2hpbGQoJ2NvbnRyb2xCYXInKTtcbiAgICB2YXIgcGxheVRvZ2dsZSA9IGNiICYmIGNiLmdldENoaWxkKCdwbGF5VG9nZ2xlJyk7XG5cbiAgICBpZiAoIXBsYXlUb2dnbGUpIHtcbiAgICAgIHRoaXMucGxheWVyXy5mb2N1cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwbGF5Rm9jdXMgPSBmdW5jdGlvbiBwbGF5Rm9jdXMoKSB7XG4gICAgICByZXR1cm4gcGxheVRvZ2dsZS5mb2N1cygpO1xuICAgIH07XG5cbiAgICBpZiAocGxheVByb21pc2UgJiYgcGxheVByb21pc2UudGhlbikge1xuICAgICAgdmFyIGlnbm9yZVJlamVjdGVkUGxheVByb21pc2UgPSBmdW5jdGlvbiBpZ25vcmVSZWplY3RlZFBsYXlQcm9taXNlKCkge307XG5cbiAgICAgIHBsYXlQcm9taXNlLnRoZW4ocGxheUZvY3VzLCBpZ25vcmVSZWplY3RlZFBsYXlQcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRUaW1lb3V0KHBsYXlGb2N1cywgMSk7XG4gICAgfVxuICB9O1xuXG4gIEJpZ1BsYXlCdXR0b24ucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcbiAgICB0aGlzLm1vdXNldXNlZF8gPSBmYWxzZTtcblxuICAgIF9CdXR0b24ucHJvdG90eXBlLmhhbmRsZUtleVByZXNzLmNhbGwodGhpcywgZXZlbnQpO1xuICB9O1xuXG4gIEJpZ1BsYXlCdXR0b24ucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIHRoaXMubW91c2V1c2VkXyA9IHRydWU7XG4gIH07XG5cbiAgcmV0dXJuIEJpZ1BsYXlCdXR0b247XG59KEJ1dHRvbik7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgQmlnUGxheUJ1dHRvbmBzIGNvbnRyb2xzLiBBZGRlZCB0byBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQmlnUGxheUJ1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1BsYXkgVmlkZW8nO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0JpZ1BsYXlCdXR0b24nLCBCaWdQbGF5QnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBjbG9zZS1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYENsb3NlQnV0dG9uYCBpcyBhIGB7QGxpbmsgQnV0dG9ufWAgdGhhdCBmaXJlcyBhIGBjbG9zZWAgZXZlbnQgd2hlblxuICogaXQgZ2V0cyBjbGlja2VkLlxuICpcbiAqIEBleHRlbmRzIEJ1dHRvblxuICovXG5cbnZhciBDbG9zZUJ1dHRvbiA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKENsb3NlQnV0dG9uLCBfQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2xvc2VCdXR0b24ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xvc2VCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5jb250cm9sVGV4dChvcHRpb25zICYmIG9wdGlvbnMuY29udHJvbFRleHQgfHwgX3RoaXMubG9jYWxpemUoJ0Nsb3NlJykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgQ2xvc2VCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWNsb3NlLWJ1dHRvbiAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQ2xvc2VCdXR0b25gIGdldHMgY2xpY2tlZC4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlQ2xpY2t9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdoZW4gdGhpcyB3aWxsIGJlXG4gICAqIHRyaWdnZXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICogQGZpcmVzIENsb3NlQnV0dG9uI2Nsb3NlXG4gICAqL1xuXG5cbiAgQ2xvc2VCdXR0b24ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBhIGBDbG9zZUJ1dHRvbmAgaXMgY2xpY2tlZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBDbG9zZUJ1dHRvbiNjbG9zZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdXG4gICAgICogICAgICAgICAgIHNldCB0byBmYWxzZSBzbyB0aGF0IHRoZSBjbG9zZSBldmVudCBkb2VzIG5vdFxuICAgICAqICAgICAgICAgICBidWJibGUgdXAgdG8gcGFyZW50cyBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lclxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICdjbG9zZScsIGJ1YmJsZXM6IGZhbHNlIH0pO1xuICB9O1xuXG4gIHJldHVybiBDbG9zZUJ1dHRvbjtcbn0oQnV0dG9uKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDbG9zZUJ1dHRvbicsIENsb3NlQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5LXRvZ2dsZS5qc1xuICovXG4vKipcbiAqIEJ1dHRvbiB0byB0b2dnbGUgYmV0d2VlbiBwbGF5IGFuZCBwYXVzZS5cbiAqXG4gKiBAZXh0ZW5kcyBCdXR0b25cbiAqL1xuXG52YXIgUGxheVRvZ2dsZSA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKFBsYXlUb2dnbGUsIF9CdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUGxheVRvZ2dsZShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5VG9nZ2xlKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAncGxheScsIF90aGlzLmhhbmRsZVBsYXkpO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ3BhdXNlJywgX3RoaXMuaGFuZGxlUGF1c2UpO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ2VuZGVkJywgX3RoaXMuaGFuZGxlRW5kZWQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtcGxheS1jb250cm9sICcgKyBfQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgUGxheVRvZ2dsZWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLnBhdXNlZCgpKSB7XG4gICAgICB0aGlzLnBsYXllcl8ucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsYXllcl8ucGF1c2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgdmpzLXBsYXlpbmcgY2xhc3MgdG8gdGhlIGVsZW1lbnQgc28gaXQgY2FuIGNoYW5nZSBhcHBlYXJhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNwbGF5XG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlUGxheSA9IGZ1bmN0aW9uIGhhbmRsZVBsYXkoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZW5kZWQnKTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGF1c2VkJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBsYXlpbmcnKTtcbiAgICAvLyBjaGFuZ2UgdGhlIGJ1dHRvbiB0ZXh0IHRvIFwiUGF1c2VcIlxuICAgIHRoaXMuY29udHJvbFRleHQoJ1BhdXNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgdmpzLXBhdXNlZCBjbGFzcyB0byB0aGUgZWxlbWVudCBzbyBpdCBjYW4gY2hhbmdlIGFwcGVhcmFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3BhdXNlXG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlUGF1c2UgPSBmdW5jdGlvbiBoYW5kbGVQYXVzZShldmVudCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIC8vIGNoYW5nZSB0aGUgYnV0dG9uIHRleHQgdG8gXCJQbGF5XCJcbiAgICB0aGlzLmNvbnRyb2xUZXh0KCdQbGF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgdmpzLWVuZGVkIGNsYXNzIHRvIHRoZSBlbGVtZW50IHNvIGl0IGNhbiBjaGFuZ2UgYXBwZWFyYW5jZVxuICAgKlxuICAgKi9cblxuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZUVuZGVkID0gZnVuY3Rpb24gaGFuZGxlRW5kZWQoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGxheWluZycpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuICAgIC8vIGNoYW5nZSB0aGUgYnV0dG9uIHRleHQgdG8gXCJSZXBsYXlcIlxuICAgIHRoaXMuY29udHJvbFRleHQoJ1JlcGxheScpO1xuICB9O1xuXG4gIHJldHVybiBQbGF5VG9nZ2xlO1xufShCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFBsYXlUb2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cblBsYXlUb2dnbGUucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdQbGF5JztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5VG9nZ2xlJywgUGxheVRvZ2dsZSk7XG5cbi8qKlxuICogQGZpbGUgZm9ybWF0LXRpbWUuanNcbiAqIEBtb2R1bGUgRm9ybWF0LXRpbWVcbiAqL1xuXG4vKipcbiAqIEZvcm1hdCBzZWNvbmRzIGFzIGEgdGltZSBzdHJpbmcsIEg6TU06U1Mgb3IgTTpTUy4gU3VwcGx5aW5nIGEgZ3VpZGUgKGluIHNlY29uZHMpXG4gKiB3aWxsIGZvcmNlIGEgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3MgdG8gY292ZXIgdGhlIGxlbmd0aCBvZiB0aGUgZ3VpZGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHNcbiAqICAgICAgICBOdW1iZXIgb2Ygc2Vjb25kcyB0byBiZSB0dXJuZWQgaW50byBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBndWlkZVxuICogICAgICAgIE51bWJlciAoaW4gc2Vjb25kcykgdG8gbW9kZWwgdGhlIHN0cmluZyBhZnRlclxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGltZSBmb3JtYXR0ZWQgYXMgSDpNTTpTUyBvciBNOlNTXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFRpbWUoc2Vjb25kcykge1xuICB2YXIgZ3VpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHNlY29uZHM7XG5cbiAgc2Vjb25kcyA9IHNlY29uZHMgPCAwID8gMCA6IHNlY29uZHM7XG4gIHZhciBzID0gTWF0aC5mbG9vcihzZWNvbmRzICUgNjApO1xuICB2YXIgbSA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwICUgNjApO1xuICB2YXIgaCA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDM2MDApO1xuICB2YXIgZ20gPSBNYXRoLmZsb29yKGd1aWRlIC8gNjAgJSA2MCk7XG4gIHZhciBnaCA9IE1hdGguZmxvb3IoZ3VpZGUgLyAzNjAwKTtcblxuICAvLyBoYW5kbGUgaW52YWxpZCB0aW1lc1xuICBpZiAoaXNOYU4oc2Vjb25kcykgfHwgc2Vjb25kcyA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyAnLScgaXMgZmFsc2UgZm9yIGFsbCByZWxhdGlvbmFsIG9wZXJhdG9ycyAoZS5nLiA8LCA+PSkgc28gdGhpcyBzZXR0aW5nXG4gICAgLy8gd2lsbCBhZGQgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGZpZWxkcyBzcGVjaWZpZWQgYnkgdGhlIGd1aWRlXG4gICAgaCA9IG0gPSBzID0gJy0nO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBzaG93IGhvdXJzXG4gIGggPSBoID4gMCB8fCBnaCA+IDAgPyBoICsgJzonIDogJyc7XG5cbiAgLy8gSWYgaG91cnMgYXJlIHNob3dpbmcsIHdlIG1heSBuZWVkIHRvIGFkZCBhIGxlYWRpbmcgemVyby5cbiAgLy8gQWx3YXlzIHNob3cgYXQgbGVhc3Qgb25lIGRpZ2l0IG9mIG1pbnV0ZXMuXG4gIG0gPSAoKGggfHwgZ20gPj0gMTApICYmIG0gPCAxMCA/ICcwJyArIG0gOiBtKSArICc6JztcblxuICAvLyBDaGVjayBpZiBsZWFkaW5nIHplcm8gaXMgbmVlZCBmb3Igc2Vjb25kc1xuICBzID0gcyA8IDEwID8gJzAnICsgcyA6IHM7XG5cbiAgcmV0dXJuIGggKyBtICsgcztcbn1cblxuLyoqXG4gKiBAZmlsZSBjdXJyZW50LXRpbWUtZGlzcGxheS5qc1xuICovXG4vKipcbiAqIERpc3BsYXlzIHRoZSBjdXJyZW50IHRpbWVcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgQ3VycmVudFRpbWVEaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoQ3VycmVudFRpbWVEaXNwbGF5LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEN1cnJlbnRUaW1lRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDdXJyZW50VGltZURpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy50aHJvdHRsZWRVcGRhdGVDb250ZW50ID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMudXBkYXRlQ29udGVudCksIDI1KTtcbiAgICBfdGhpcy5vbihwbGF5ZXIsICd0aW1ldXBkYXRlJywgX3RoaXMudGhyb3R0bGVkVXBkYXRlQ29udGVudCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgQ3VycmVudFRpbWVEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jdXJyZW50LXRpbWUgdmpzLXRpbWUtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXyA9IGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY3VycmVudC10aW1lLWRpc3BsYXknXG4gICAgfSwge1xuICAgICAgLy8gdGVsbCBzY3JlZW4gcmVhZGVycyBub3QgdG8gYXV0b21hdGljYWxseSByZWFkIHRoZSB0aW1lIGFzIGl0IGNoYW5nZXNcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0sIGNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCcsXG4gICAgICB0ZXh0Q29udGVudDogdGhpcy5sb2NhbGl6ZSgnQ3VycmVudCBUaW1lJylcbiAgICB9KSk7XG5cbiAgICB0aGlzLnVwZGF0ZVRleHROb2RlXygpO1xuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsXyk7XG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBcImN1cnJlbnQgdGltZVwiIHRleHQgbm9kZSB3aXRoIG5ldyBjb250ZW50IHVzaW5nIHRoZVxuICAgKiBjb250ZW50cyBvZiB0aGUgYGZvcm1hdHRlZFRpbWVfYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDdXJyZW50VGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZVRleHROb2RlXyA9IGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlXygpIHtcbiAgICBpZiAodGhpcy50ZXh0Tm9kZV8pIHtcbiAgICAgIHRoaXMuY29udGVudEVsXy5yZW1vdmVDaGlsZCh0aGlzLnRleHROb2RlXyk7XG4gICAgfVxuICAgIHRoaXMudGV4dE5vZGVfID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnICsgKHRoaXMuZm9ybWF0dGVkVGltZV8gfHwgJzA6MDAnKSk7XG4gICAgdGhpcy5jb250ZW50RWxfLmFwcGVuZENoaWxkKHRoaXMudGV4dE5vZGVfKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGN1cnJlbnQgdGltZSBkaXNwbGF5XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdGltZXVwZGF0ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciN0aW1ldXBkYXRlXG4gICAqL1xuXG5cbiAgQ3VycmVudFRpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudChldmVudCkge1xuICAgIC8vIEFsbG93cyBmb3Igc21vb3RoIHNjcnViYmluZywgd2hlbiBwbGF5ZXIgY2FuJ3Qga2VlcCB1cC5cbiAgICB2YXIgdGltZSA9IHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG4gICAgdmFyIGZvcm1hdHRlZFRpbWUgPSBmb3JtYXRUaW1lKHRpbWUsIHRoaXMucGxheWVyXy5kdXJhdGlvbigpKTtcblxuICAgIGlmIChmb3JtYXR0ZWRUaW1lICE9PSB0aGlzLmZvcm1hdHRlZFRpbWVfKSB7XG4gICAgICB0aGlzLmZvcm1hdHRlZFRpbWVfID0gZm9ybWF0dGVkVGltZTtcbiAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlVGV4dE5vZGVfKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEN1cnJlbnRUaW1lRGlzcGxheTtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDdXJyZW50VGltZURpc3BsYXknLCBDdXJyZW50VGltZURpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIGR1cmF0aW9uLWRpc3BsYXkuanNcbiAqL1xuLyoqXG4gKiBEaXNwbGF5cyB0aGUgZHVyYXRpb25cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgRHVyYXRpb25EaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoRHVyYXRpb25EaXNwbGF5LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIER1cmF0aW9uRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBEdXJhdGlvbkRpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy50aHJvdHRsZWRVcGRhdGVDb250ZW50ID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMudXBkYXRlQ29udGVudCksIDI1KTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgWydkdXJhdGlvbmNoYW5nZScsXG5cbiAgICAvLyBBbHNvIGxpc3RlbiBmb3IgdGltZXVwZGF0ZSBhbmQgbG9hZGVkbWV0YWRhdGEgYmVjYXVzZSByZW1vdmluZyB0aG9zZVxuICAgIC8vIGxpc3RlbmVycyBjb3VsZCBoYXZlIGJyb2tlbiBkZXBlbmRlbnQgYXBwbGljYXRpb25zL2xpYnJhcmllcy4gVGhlc2VcbiAgICAvLyBjYW4gbGlrZWx5IGJlIHJlbW92ZWQgZm9yIDcuMC5cbiAgICAnbG9hZGVkbWV0YWRhdGEnLCAndGltZXVwZGF0ZSddLCBfdGhpcy50aHJvdHRsZWRVcGRhdGVDb250ZW50KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBEdXJhdGlvbkRpc3BsYXkucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGVsID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWR1cmF0aW9uIHZqcy10aW1lLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWR1cmF0aW9uLWRpc3BsYXknXG4gICAgfSwge1xuICAgICAgLy8gdGVsbCBzY3JlZW4gcmVhZGVycyBub3QgdG8gYXV0b21hdGljYWxseSByZWFkIHRoZSB0aW1lIGFzIGl0IGNoYW5nZXNcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0sIGNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCcsXG4gICAgICB0ZXh0Q29udGVudDogdGhpcy5sb2NhbGl6ZSgnRHVyYXRpb24gVGltZScpXG4gICAgfSkpO1xuXG4gICAgdGhpcy51cGRhdGVUZXh0Tm9kZV8oKTtcbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgXCJjdXJyZW50IHRpbWVcIiB0ZXh0IG5vZGUgd2l0aCBuZXcgY29udGVudCB1c2luZyB0aGVcbiAgICogY29udGVudHMgb2YgdGhlIGBmb3JtYXR0ZWRUaW1lX2AgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgRHVyYXRpb25EaXNwbGF5LnByb3RvdHlwZS51cGRhdGVUZXh0Tm9kZV8gPSBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZV8oKSB7XG4gICAgaWYgKHRoaXMudGV4dE5vZGVfKSB7XG4gICAgICB0aGlzLmNvbnRlbnRFbF8ucmVtb3ZlQ2hpbGQodGhpcy50ZXh0Tm9kZV8pO1xuICAgIH1cbiAgICB0aGlzLnRleHROb2RlXyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJyArICh0aGlzLmZvcm1hdHRlZFRpbWVfIHx8ICcwOjAwJykpO1xuICAgIHRoaXMuY29udGVudEVsXy5hcHBlbmRDaGlsZCh0aGlzLnRleHROb2RlXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBkdXJhdGlvbiB0aW1lIGRpc3BsYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgZHVyYXRpb25jaGFuZ2VgLCBgdGltZXVwZGF0ZWAsIG9yIGBsb2FkZWRtZXRhZGF0YWAgZXZlbnQgdGhhdCBjYXVzZWRcbiAgICogICAgICAgIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICogQGxpc3RlbnMgUGxheWVyI3RpbWV1cGRhdGVcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRlZG1ldGFkYXRhXG4gICAqL1xuXG5cbiAgRHVyYXRpb25EaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudChldmVudCkge1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuXG4gICAgaWYgKGR1cmF0aW9uICYmIHRoaXMuZHVyYXRpb25fICE9PSBkdXJhdGlvbikge1xuICAgICAgdGhpcy5kdXJhdGlvbl8gPSBkdXJhdGlvbjtcbiAgICAgIHRoaXMuZm9ybWF0dGVkVGltZV8gPSBmb3JtYXRUaW1lKGR1cmF0aW9uKTtcbiAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlVGV4dE5vZGVfKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIER1cmF0aW9uRGlzcGxheTtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdEdXJhdGlvbkRpc3BsYXknLCBEdXJhdGlvbkRpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIHRpbWUtZGl2aWRlci5qc1xuICovXG4vKipcbiAqIFRoZSBzZXBhcmF0b3IgYmV0d2VlbiB0aGUgY3VycmVudCB0aW1lIGFuZCBkdXJhdGlvbi5cbiAqIENhbiBiZSBoaWRkZW4gaWYgaXQncyBub3QgbmVlZGVkIGluIHRoZSBkZXNpZ24uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFRpbWVEaXZpZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGltZURpdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRpbWVEaXZpZGVyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVEaXZpZGVyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgVGltZURpdmlkZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10aW1lLWNvbnRyb2wgdmpzLXRpbWUtZGl2aWRlcicsXG4gICAgICBpbm5lckhUTUw6ICc8ZGl2PjxzcGFuPi88L3NwYW4+PC9kaXY+J1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUaW1lRGl2aWRlcjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUaW1lRGl2aWRlcicsIFRpbWVEaXZpZGVyKTtcblxuLyoqXG4gKiBAZmlsZSByZW1haW5pbmctdGltZS1kaXNwbGF5LmpzXG4gKi9cbi8qKlxuICogRGlzcGxheXMgdGhlIHRpbWUgbGVmdCBpbiB0aGUgdmlkZW9cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUmVtYWluaW5nVGltZURpc3BsYXkgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhSZW1haW5pbmdUaW1lRGlzcGxheSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBSZW1haW5pbmdUaW1lRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBSZW1haW5pbmdUaW1lRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy51cGRhdGVDb250ZW50KSwgMjUpO1xuICAgIF90aGlzLm9uKHBsYXllciwgWyd0aW1ldXBkYXRlJywgJ2R1cmF0aW9uY2hhbmdlJ10sIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFJlbWFpbmluZ1RpbWVEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1yZW1haW5pbmctdGltZSB2anMtdGltZS1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfID0gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1yZW1haW5pbmctdGltZS1kaXNwbGF5J1xuICAgIH0sIHtcbiAgICAgIC8vIHRlbGwgc2NyZWVuIHJlYWRlcnMgbm90IHRvIGF1dG9tYXRpY2FsbHkgcmVhZCB0aGUgdGltZSBhcyBpdCBjaGFuZ2VzXG4gICAgICAnYXJpYS1saXZlJzogJ29mZidcbiAgICB9LCBjcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLXRleHQnLFxuICAgICAgdGV4dENvbnRlbnQ6IHRoaXMubG9jYWxpemUoJ1JlbWFpbmluZyBUaW1lJylcbiAgICB9KSk7XG5cbiAgICB0aGlzLnVwZGF0ZVRleHROb2RlXygpO1xuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsXyk7XG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBcInJlbWFpbmluZyB0aW1lXCIgdGV4dCBub2RlIHdpdGggbmV3IGNvbnRlbnQgdXNpbmcgdGhlXG4gICAqIGNvbnRlbnRzIG9mIHRoZSBgZm9ybWF0dGVkVGltZV9gIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFJlbWFpbmluZ1RpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVUZXh0Tm9kZV8gPSBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZV8oKSB7XG4gICAgaWYgKHRoaXMudGV4dE5vZGVfKSB7XG4gICAgICB0aGlzLmNvbnRlbnRFbF8ucmVtb3ZlQ2hpbGQodGhpcy50ZXh0Tm9kZV8pO1xuICAgIH1cbiAgICB0aGlzLnRleHROb2RlXyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgLScgKyAodGhpcy5mb3JtYXR0ZWRUaW1lXyB8fCAnMDowMCcpKTtcbiAgICB0aGlzLmNvbnRlbnRFbF8uYXBwZW5kQ2hpbGQodGhpcy50ZXh0Tm9kZV8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgcmVtYWluaW5nIHRpbWUgZGlzcGxheS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGB0aW1ldXBkYXRlYCBvciBgZHVyYXRpb25jaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGltZXVwZGF0ZVxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICovXG5cblxuICBSZW1haW5pbmdUaW1lRGlzcGxheS5wcm90b3R5cGUudXBkYXRlQ29udGVudCA9IGZ1bmN0aW9uIHVwZGF0ZUNvbnRlbnQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpIHtcbiAgICAgIHZhciBmb3JtYXR0ZWRUaW1lID0gZm9ybWF0VGltZSh0aGlzLnBsYXllcl8ucmVtYWluaW5nVGltZSgpKTtcblxuICAgICAgaWYgKGZvcm1hdHRlZFRpbWUgIT09IHRoaXMuZm9ybWF0dGVkVGltZV8pIHtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZWRUaW1lXyA9IGZvcm1hdHRlZFRpbWU7XG4gICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlVGV4dE5vZGVfKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlbWFpbmluZ1RpbWVEaXNwbGF5O1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1JlbWFpbmluZ1RpbWVEaXNwbGF5JywgUmVtYWluaW5nVGltZURpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIGxpdmUtZGlzcGxheS5qc1xuICovXG4vLyBUT0RPIC0gRnV0dXJlIG1ha2UgaXQgY2xpY2sgdG8gc25hcCB0byBsaXZlXG5cbi8qKlxuICogRGlzcGxheXMgdGhlIGxpdmUgaW5kaWNhdG9yIHdoZW4gZHVyYXRpb24gaXMgSW5maW5pdHkuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIExpdmVEaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTGl2ZURpc3BsYXksIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTGl2ZURpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTGl2ZURpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGVTaG93aW5nKCk7XG4gICAgX3RoaXMub24oX3RoaXMucGxheWVyKCksICdkdXJhdGlvbmNoYW5nZScsIF90aGlzLnVwZGF0ZVNob3dpbmcpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIExpdmVEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1saXZlLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxpdmUtZGlzcGxheScsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4nICsgdGhpcy5sb2NhbGl6ZSgnU3RyZWFtIFR5cGUnKSArICc8L3NwYW4+JyArIHRoaXMubG9jYWxpemUoJ0xJVkUnKVxuICAgIH0sIHtcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBkdXJhdGlvbiB0byBzZWUgaWYgdGhlIExpdmVEaXNwbGF5IHNob3VsZCBiZSBzaG93aW5nIG9yIG5vdC4gVGhlbiBzaG93L2hpZGVcbiAgICogaXQgYWNjb3JkaW5nbHlcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBQbGF5ZXIjZHVyYXRpb25jaGFuZ2V9IGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICovXG5cblxuICBMaXZlRGlzcGxheS5wcm90b3R5cGUudXBkYXRlU2hvd2luZyA9IGZ1bmN0aW9uIHVwZGF0ZVNob3dpbmcoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXIoKS5kdXJhdGlvbigpID09PSBJbmZpbml0eSkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTGl2ZURpc3BsYXk7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTGl2ZURpc3BsYXknLCBMaXZlRGlzcGxheSk7XG5cbi8qKlxuICogQGZpbGUgc2xpZGVyLmpzXG4gKi9cbi8qKlxuICogVGhlIGJhc2UgZnVuY3Rpb25hbGl0eSBmb3IgYSBzbGlkZXIuIENhbiBiZSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsLlxuICogRm9yIGluc3RhbmNlIHRoZSB2b2x1bWUgYmFyIG9yIHRoZSBzZWVrIGJhciBvbiBhIHZpZGVvIGlzIGEgc2xpZGVyLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBTbGlkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhTbGlkZXIsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFNsaWRlcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTbGlkZXIpO1xuXG4gICAgLy8gU2V0IHByb3BlcnR5IG5hbWVzIHRvIGJhciB0byBtYXRjaCB3aXRoIHRoZSBjaGlsZCBTbGlkZXIgY2xhc3MgaXMgbG9va2luZyBmb3JcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmJhciA9IF90aGlzLmdldENoaWxkKF90aGlzLm9wdGlvbnNfLmJhck5hbWUpO1xuXG4gICAgLy8gU2V0IGEgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjbGFzcyBvbiB0aGUgc2xpZGVyIGRlcGVuZGluZyBvbiB0aGUgc2xpZGVyIHR5cGVcbiAgICBfdGhpcy52ZXJ0aWNhbCghIV90aGlzLm9wdGlvbnNfLnZlcnRpY2FsKTtcblxuICAgIF90aGlzLm9uKCdtb3VzZWRvd24nLCBfdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIF90aGlzLm9uKCd0b3VjaHN0YXJ0JywgX3RoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICBfdGhpcy5vbignZm9jdXMnLCBfdGhpcy5oYW5kbGVGb2N1cyk7XG4gICAgX3RoaXMub24oJ2JsdXInLCBfdGhpcy5oYW5kbGVCbHVyKTtcbiAgICBfdGhpcy5vbignY2xpY2snLCBfdGhpcy5oYW5kbGVDbGljayk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdjb250cm9sc3Zpc2libGUnLCBfdGhpcy51cGRhdGUpO1xuXG4gICAgaWYgKF90aGlzLnBsYXllckV2ZW50KSB7XG4gICAgICBfdGhpcy5vbihwbGF5ZXIsIF90aGlzLnBsYXllckV2ZW50LCBfdGhpcy51cGRhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQnV0dG9uYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBUeXBlIG9mIGVsZW1lbnQgdG8gY3JlYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzPXt9XVxuICAgKiAgICAgICAgTGlzdCBvZiBwcm9wZXJ0aWVzIGluIE9iamVjdCBmb3JtLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXM9e31dXG4gICAqICAgICAgICBsaXN0IG9mIGF0dHJpYnV0ZXMgaW4gT2JqZWN0IGZvcm0uXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKHR5cGUpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIC8vIEFkZCB0aGUgc2xpZGVyIGVsZW1lbnQgY2xhc3MgdG8gYWxsIHN1YiBjbGFzc2VzXG4gICAgcHJvcHMuY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lICsgJyB2anMtc2xpZGVyJztcbiAgICBwcm9wcyA9IGFzc2lnbih7XG4gICAgICB0YWJJbmRleDogMFxuICAgIH0sIHByb3BzKTtcblxuICAgIGF0dHJpYnV0ZXMgPSBhc3NpZ24oe1xuICAgICAgJ3JvbGUnOiAnc2xpZGVyJyxcbiAgICAgICdhcmlhLXZhbHVlbm93JzogMCxcbiAgICAgICdhcmlhLXZhbHVlbWluJzogMCxcbiAgICAgICdhcmlhLXZhbHVlbWF4JzogMTAwLFxuICAgICAgJ3RhYkluZGV4JzogMFxuICAgIH0sIGF0dHJpYnV0ZXMpO1xuXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgdHlwZSwgcHJvcHMsIGF0dHJpYnV0ZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50cyBvbiB0aGUgYFNsaWRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICogQGxpc3RlbnMgdG91Y2hzdGFydFxuICAgKiBAZmlyZXMgU2xpZGVyI3NsaWRlcmFjdGl2ZVxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgdmFyIGRvYyA9IHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBibG9ja1RleHRTZWxlY3Rpb24oKTtcblxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkaW5nJyk7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHNsaWRlciBpcyBpbiBhbiBhY3RpdmUgc3RhdGVcbiAgICAgKlxuICAgICAqIEBldmVudCBTbGlkZXIjc2xpZGVyYWN0aXZlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignc2xpZGVyYWN0aXZlJyk7XG5cbiAgICB0aGlzLm9uKGRvYywgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKGRvYywgJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIHRoaXMub24oZG9jLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub24oZG9jLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuXG4gICAgdGhpcy5oYW5kbGVNb3VzZU1vdmUoZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGhlIGBtb3VzZW1vdmVgLCBgdG91Y2htb3ZlYCwgYW5kIGBtb3VzZWRvd25gIGV2ZW50cyBvbiB0aGlzIGBTbGlkZXJgLlxuICAgKiBUaGUgYG1vdXNlbW92ZWAgYW5kIGB0b3VjaG1vdmVgIGV2ZW50cyB3aWxsIG9ubHkgb25seSB0cmlnZ2VyIHRoaXMgZnVuY3Rpb24gZHVyaW5nXG4gICAqIGBtb3VzZWRvd25gIGFuZCBgdG91Y2hzdGFydGAuIFRoaXMgaXMgZHVlIHRvIHtAbGluayBTbGlkZXIjaGFuZGxlTW91c2VEb3dufSBhbmRcbiAgICoge0BsaW5rIFNsaWRlciNoYW5kbGVNb3VzZVVwfS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZWRvd25gLCBgbW91c2Vtb3ZlYCwgYHRvdWNoc3RhcnRgLCBvciBgdG91Y2htb3ZlYCBldmVudCB0aGF0IHRyaWdnZXJlZFxuICAgKiAgICAgICAgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICogQGxpc3RlbnMgdG91Y2htb3ZlXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHt9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNldXBgIG9yIGB0b3VjaGVuZGAgZXZlbnRzIG9uIHRoZSBgU2xpZGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRvdWNoZW5kXG4gICAqIEBsaXN0ZW5zIG1vdXNldXBcbiAgICogQGZpcmVzIFNsaWRlciNzbGlkZXJpbmFjdGl2ZVxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoKSB7XG4gICAgdmFyIGRvYyA9IHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdW5ibG9ja1RleHRTZWxlY3Rpb24oKTtcblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkaW5nJyk7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHNsaWRlciBpcyBubyBsb25nZXIgaW4gYW4gYWN0aXZlIHN0YXRlLlxuICAgICAqXG4gICAgICogQGV2ZW50IFNsaWRlciNzbGlkZXJpbmFjdGl2ZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3NsaWRlcmluYWN0aXZlJyk7XG5cbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MgYmFyIG9mIHRoZSBgU2xpZGVyYC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogICAgICAgICAgVGhlIHBlcmNlbnRhZ2Ugb2YgcHJvZ3Jlc3MgdGhlIHByb2dyZXNzIGJhciByZXByZXNlbnRzIGFzIGFcbiAgICogICAgICAgICAgbnVtYmVyIGZyb20gMCB0byAxLlxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG4gICAgLy8gSW4gVm9sdW1lQmFyIGluaXQgd2UgaGF2ZSBhIHNldFRpbWVvdXQgZm9yIHVwZGF0ZSB0aGF0IHBvcHMgYW5kIHVwZGF0ZVxuICAgIC8vIHRvIHRoZSBlbmQgb2YgdGhlIGV4ZWN1dGlvbiBzdGFjay4gVGhlIHBsYXllciBpcyBkZXN0cm95ZWQgYmVmb3JlIHRoZW5cbiAgICAvLyB1cGRhdGUgd2lsbCBjYXVzZSBhbiBlcnJvclxuICAgIGlmICghdGhpcy5lbF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBzY3J1YmJpbmcsIHdlIGNvdWxkIHVzZSBhIGNhY2hlZCB2YWx1ZSB0byBtYWtlIHRoZSBoYW5kbGUga2VlcCB1cFxuICAgIC8vIHdpdGggdGhlIHVzZXIncyBtb3VzZS4gT24gSFRNTDUgYnJvd3NlcnMgc2NydWJiaW5nIGlzIHJlYWxseSBzbW9vdGgsIGJ1dFxuICAgIC8vIHNvbWUgZmxhc2ggcGxheWVycyBhcmUgc2xvdywgc28gd2UgbWlnaHQgd2FudCB0byB1dGlsaXplIHRoaXMgbGF0ZXIuXG4gICAgLy8gdmFyIHByb2dyZXNzID0gICh0aGlzLnBsYXllcl8uc2NydWJiaW5nKCkpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgLyB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSA6IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpIC8gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG4gICAgdmFyIHByb2dyZXNzID0gdGhpcy5nZXRQZXJjZW50KCk7XG4gICAgdmFyIGJhciA9IHRoaXMuYmFyO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBiYXIuLi5cbiAgICBpZiAoIWJhcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByb3RlY3QgYWdhaW5zdCBubyBkdXJhdGlvbiBhbmQgb3RoZXIgZGl2aXNpb24gaXNzdWVzXG4gICAgaWYgKHR5cGVvZiBwcm9ncmVzcyAhPT0gJ251bWJlcicgfHwgcHJvZ3Jlc3MgIT09IHByb2dyZXNzIHx8IHByb2dyZXNzIDwgMCB8fCBwcm9ncmVzcyA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHByb2dyZXNzID0gMDtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IHRvIGEgcGVyY2VudGFnZSBmb3Igc2V0dGluZ1xuICAgIHZhciBwZXJjZW50YWdlID0gKHByb2dyZXNzICogMTAwKS50b0ZpeGVkKDIpICsgJyUnO1xuICAgIHZhciBzdHlsZSA9IGJhci5lbCgpLnN0eWxlO1xuXG4gICAgLy8gU2V0IHRoZSBuZXcgYmFyIHdpZHRoIG9yIGhlaWdodFxuICAgIGlmICh0aGlzLnZlcnRpY2FsKCkpIHtcbiAgICAgIHN0eWxlLmhlaWdodCA9IHBlcmNlbnRhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLndpZHRoID0gcGVyY2VudGFnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBkaXN0YW5jZSBmb3Igc2xpZGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgU2xpZGVyLlxuICAgKiAgICAgICAgIC0gcG9zdGl0aW9uLnggZm9yIHZlcnRpY2FsIGBTbGlkZXJgc1xuICAgKiAgICAgICAgIC0gcG9zdGl0aW9uLnkgZm9yIGhvcml6b250YWwgYFNsaWRlcmBzXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5jYWxjdWxhdGVEaXN0YW5jZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSB7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2V0UG9pbnRlclBvc2l0aW9uKHRoaXMuZWxfLCBldmVudCk7XG5cbiAgICBpZiAodGhpcy52ZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24ueTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uLng7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBmb2N1c2AgZXZlbnQgb24gdGhpcyBgU2xpZGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgZm9jdXNgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBmb2N1c1xuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cygpIHtcbiAgICB0aGlzLm9uKHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5UHJlc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBga2V5ZG93bmAgZXZlbnQgb24gdGhlIGBTbGlkZXJgLiBXYXRjaGVzIGZvciBsZWZ0LCByaWd0aCwgdXAsIGFuZCBkb3duXG4gICAqIGFycm93IGtleXMuIFRoaXMgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIGNhbGxlZCB3aGVuIHRoZSBzbGlkZXIgaGFzIGZvY3VzLiBTZWVcbiAgICoge0BsaW5rIFNsaWRlciNoYW5kbGVGb2N1c30gYW5kIHtAbGluayBTbGlkZXIjaGFuZGxlQmx1cn0uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICB0aGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG4gICAgLy8gTGVmdCBhbmQgRG93biBBcnJvd3NcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDM3IHx8IGV2ZW50LndoaWNoID09PSA0MCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEJhY2soKTtcblxuICAgICAgLy8gVXAgYW5kIFJpZ2h0IEFycm93c1xuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4IHx8IGV2ZW50LndoaWNoID09PSAzOSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEZvcndhcmQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBibHVyYCBldmVudCBvbiB0aGlzIGBTbGlkZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBibHVyYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgYmx1clxuICAgKi9cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICAgIHRoaXMub2ZmKHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5UHJlc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0ZW5lciBmb3IgY2xpY2sgZXZlbnRzIG9uIHNsaWRlciwgdXNlZCB0byBwcmV2ZW50IGNsaWNrc1xuICAgKiAgIGZyb20gYnViYmxpbmcgdXAgdG8gcGFyZW50IGVsZW1lbnRzIGxpa2UgYnV0dG9uIG1lbnVzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICAgICAgIEV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgb2JqZWN0IHRvIHJ1blxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgaWYgc2xpZGVyIGlzIGhvcml6b250YWwgZm9yIHZlcnRpY2FsXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb2xdXG4gICAqICAgICAgICAtIHRydWUgaWYgc2xpZGVyIGlzIHZlcnRpY2FsLFxuICAgKiAgICAgICAgLSBmYWxzZSBpcyBob3Jpem9udGFsXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSB0cnVlIGlmIHNsaWRlciBpcyB2ZXJ0aWNhbCwgYW5kIGdldHRpbmdcbiAgICogICAgICAgICAtIGZhbHNlIGlmIHRoZSBzbGlkZXIgaXMgaG9yaXpvbnRhbCwgYW5kIGdldHRpbmdcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLnZlcnRpY2FsID0gZnVuY3Rpb24gdmVydGljYWwoYm9vbCkge1xuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZlcnRpY2FsXyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnZlcnRpY2FsXyA9ICEhYm9vbDtcblxuICAgIGlmICh0aGlzLnZlcnRpY2FsXykge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNsaWRlci12ZXJ0aWNhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWhvcml6b250YWwnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNsaWRlcjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTbGlkZXInLCBTbGlkZXIpO1xuXG4vKipcbiAqIEBmaWxlIGxvYWQtcHJvZ3Jlc3MtYmFyLmpzXG4gKi9cbi8qKlxuICogU2hvd3MgbG9hZGluZyBwcm9ncmVzc1xuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBMb2FkUHJvZ3Jlc3NCYXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhMb2FkUHJvZ3Jlc3NCYXIsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTG9hZFByb2dyZXNzQmFyKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIExvYWRQcm9ncmVzc0Jhcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnBhcnRFbHNfID0gW107XG4gICAgX3RoaXMub24ocGxheWVyLCAncHJvZ3Jlc3MnLCBfdGhpcy51cGRhdGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIExvYWRQcm9ncmVzc0Jhci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxvYWQtcHJvZ3Jlc3MnLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PHNwYW4+JyArIHRoaXMubG9jYWxpemUoJ0xvYWRlZCcpICsgJzwvc3Bhbj46IDAlPC9zcGFuPidcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHByb2dyZXNzIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYHByb2dyZXNzYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3Byb2dyZXNzXG4gICAqL1xuXG5cbiAgTG9hZFByb2dyZXNzQmFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnBsYXllcl8uYnVmZmVyZWQoKTtcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcbiAgICB2YXIgYnVmZmVyZWRFbmQgPSB0aGlzLnBsYXllcl8uYnVmZmVyZWRFbmQoKTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnBhcnRFbHNfO1xuXG4gICAgLy8gZ2V0IHRoZSBwZXJjZW50IHdpZHRoIG9mIGEgdGltZSBjb21wYXJlZCB0byB0aGUgdG90YWwgZW5kXG4gICAgdmFyIHBlcmNlbnRpZnkgPSBmdW5jdGlvbiBwZXJjZW50aWZ5KHRpbWUsIGVuZCkge1xuICAgICAgLy8gbm8gTmFOXG4gICAgICB2YXIgcGVyY2VudCA9IHRpbWUgLyBlbmQgfHwgMDtcblxuICAgICAgcmV0dXJuIChwZXJjZW50ID49IDEgPyAxIDogcGVyY2VudCkgKiAxMDAgKyAnJSc7XG4gICAgfTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgd2lkdGggb2YgdGhlIHByb2dyZXNzIGJhclxuICAgIHRoaXMuZWxfLnN0eWxlLndpZHRoID0gcGVyY2VudGlmeShidWZmZXJlZEVuZCwgZHVyYXRpb24pO1xuXG4gICAgLy8gYWRkIGNoaWxkIGVsZW1lbnRzIHRvIHJlcHJlc2VudCB0aGUgaW5kaXZpZHVhbCBidWZmZXJlZCB0aW1lIHJhbmdlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgICAgdmFyIGVuZCA9IGJ1ZmZlcmVkLmVuZChpKTtcbiAgICAgIHZhciBwYXJ0ID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmICghcGFydCkge1xuICAgICAgICBwYXJ0ID0gdGhpcy5lbF8uYXBwZW5kQ2hpbGQoY3JlYXRlRWwoKSk7XG4gICAgICAgIGNoaWxkcmVuW2ldID0gcGFydDtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHRoZSBwZXJjZW50IGJhc2VkIG9uIHRoZSB3aWR0aCBvZiB0aGUgcHJvZ3Jlc3MgYmFyIChidWZmZXJlZEVuZClcbiAgICAgIHBhcnQuc3R5bGUubGVmdCA9IHBlcmNlbnRpZnkoc3RhcnQsIGJ1ZmZlcmVkRW5kKTtcbiAgICAgIHBhcnQuc3R5bGUud2lkdGggPSBwZXJjZW50aWZ5KGVuZCAtIHN0YXJ0LCBidWZmZXJlZEVuZCk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHVudXNlZCBidWZmZXJlZCByYW5nZSBlbGVtZW50c1xuICAgIGZvciAodmFyIF9pID0gY2hpbGRyZW4ubGVuZ3RoOyBfaSA+IGJ1ZmZlcmVkLmxlbmd0aDsgX2ktLSkge1xuICAgICAgdGhpcy5lbF8ucmVtb3ZlQ2hpbGQoY2hpbGRyZW5bX2kgLSAxXSk7XG4gICAgfVxuICAgIGNoaWxkcmVuLmxlbmd0aCA9IGJ1ZmZlcmVkLmxlbmd0aDtcbiAgfTtcblxuICByZXR1cm4gTG9hZFByb2dyZXNzQmFyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0xvYWRQcm9ncmVzc0JhcicsIExvYWRQcm9ncmVzc0Jhcik7XG5cbi8qKlxuICogQGZpbGUgdGltZS10b29sdGlwLmpzXG4gKi9cbi8qKlxuICogVGltZSB0b29sdGlwcyBkaXNwbGF5IGEgdGltZSBhYm92ZSB0aGUgcHJvZ3Jlc3MgYmFyLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUaW1lVG9vbHRpcCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFRpbWVUb29sdGlwLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUaW1lVG9vbHRpcCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lVG9vbHRpcCk7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIHRpbWUgdG9vbHRpcCBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBUaW1lVG9vbHRpcC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXRpbWUtdG9vbHRpcCdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHRpbWUgdG9vbHRpcCByZWxhdGl2ZSB0byB0aGUgYFNlZWtCYXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2Vla0JhclJlY3RcbiAgICogICAgICAgIFRoZSBgQ2xpZW50UmVjdGAgZm9yIHRoZSB7QGxpbmsgU2Vla0Jhcn0gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlZWtCYXJQb2ludFxuICAgKiAgICAgICAgQSBudW1iZXIgZnJvbSAwIHRvIDEsIHJlcHJlc2VudGluZyBhIGhvcml6b250YWwgcmVmZXJlbmNlIHBvaW50XG4gICAqICAgICAgICBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHtAbGluayBTZWVrQmFyfVxuICAgKi9cblxuXG4gIFRpbWVUb29sdGlwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCwgY29udGVudCkge1xuICAgIHZhciB0b29sdGlwUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLmVsXyk7XG4gICAgdmFyIHBsYXllclJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy5wbGF5ZXJfLmVsKCkpO1xuICAgIHZhciBzZWVrQmFyUG9pbnRQeCA9IHNlZWtCYXJSZWN0LndpZHRoICogc2Vla0JhclBvaW50O1xuXG4gICAgLy8gZG8gbm90aGluZyBpZiBlaXRoZXIgcmVjdCBpc24ndCBhdmFpbGFibGVcbiAgICAvLyBmb3IgZXhhbXBsZSwgaWYgdGhlIHBsYXllciBpc24ndCBpbiB0aGUgRE9NIGZvciB0ZXN0aW5nXG4gICAgaWYgKCFwbGF5ZXJSZWN0IHx8ICF0b29sdGlwUmVjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgdGhlIHNwYWNlIGxlZnQgb2YgdGhlIGBzZWVrQmFyUG9pbnRgIGF2YWlsYWJsZSB3aXRoaW4gdGhlIGJvdW5kc1xuICAgIC8vIG9mIHRoZSBwbGF5ZXIuIFdlIGNhbGN1bGF0ZSBhbnkgZ2FwIGJldHdlZW4gdGhlIGxlZnQgZWRnZSBvZiB0aGUgcGxheWVyXG4gICAgLy8gYW5kIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGBTZWVrQmFyYCBhbmQgYWRkIHRoZSBudW1iZXIgb2YgcGl4ZWxzIGluIHRoZVxuICAgIC8vIGBTZWVrQmFyYCBiZWZvcmUgaGl0dGluZyB0aGUgYHNlZWtCYXJQb2ludGBcbiAgICB2YXIgc3BhY2VMZWZ0T2ZQb2ludCA9IHNlZWtCYXJSZWN0LmxlZnQgLSBwbGF5ZXJSZWN0LmxlZnQgKyBzZWVrQmFyUG9pbnRQeDtcblxuICAgIC8vIFRoaXMgaXMgdGhlIHNwYWNlIHJpZ2h0IG9mIHRoZSBgc2Vla0JhclBvaW50YCBhdmFpbGFibGUgd2l0aGluIHRoZSBib3VuZHNcbiAgICAvLyBvZiB0aGUgcGxheWVyLiBXZSBjYWxjdWxhdGUgdGhlIG51bWJlciBvZiBwaXhlbHMgZnJvbSB0aGUgYHNlZWtCYXJQb2ludGBcbiAgICAvLyB0byB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgYFNlZWtCYXJgIGFuZCBhZGQgdG8gdGhhdCBhbnkgZ2FwIGJldHdlZW4gdGhlXG4gICAgLy8gcmlnaHQgZWRnZSBvZiB0aGUgYFNlZWtCYXJgIGFuZCB0aGUgcGxheWVyLlxuICAgIHZhciBzcGFjZVJpZ2h0T2ZQb2ludCA9IHNlZWtCYXJSZWN0LndpZHRoIC0gc2Vla0JhclBvaW50UHggKyAocGxheWVyUmVjdC5yaWdodCAtIHNlZWtCYXJSZWN0LnJpZ2h0KTtcblxuICAgIC8vIFRoaXMgaXMgdGhlIG51bWJlciBvZiBwaXhlbHMgYnkgd2hpY2ggdGhlIHRvb2x0aXAgd2lsbCBuZWVkIHRvIGJlIHB1bGxlZFxuICAgIC8vIGZ1cnRoZXIgdG8gdGhlIHJpZ2h0IHRvIGNlbnRlciBpdCBvdmVyIHRoZSBgc2Vla0JhclBvaW50YC5cbiAgICB2YXIgcHVsbFRvb2x0aXBCeSA9IHRvb2x0aXBSZWN0LndpZHRoIC8gMjtcblxuICAgIC8vIEFkanVzdCB0aGUgYHB1bGxUb29sdGlwQnlgIGRpc3RhbmNlIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0IGRlcGVuZGluZyBvblxuICAgIC8vIHRoZSByZXN1bHRzIG9mIHRoZSBzcGFjZSBjYWxjdWxhdGlvbnMgYWJvdmUuXG4gICAgaWYgKHNwYWNlTGVmdE9mUG9pbnQgPCBwdWxsVG9vbHRpcEJ5KSB7XG4gICAgICBwdWxsVG9vbHRpcEJ5ICs9IHB1bGxUb29sdGlwQnkgLSBzcGFjZUxlZnRPZlBvaW50O1xuICAgIH0gZWxzZSBpZiAoc3BhY2VSaWdodE9mUG9pbnQgPCBwdWxsVG9vbHRpcEJ5KSB7XG4gICAgICBwdWxsVG9vbHRpcEJ5ID0gc3BhY2VSaWdodE9mUG9pbnQ7XG4gICAgfVxuXG4gICAgLy8gRHVlIHRvIHRoZSBpbXByZWNpc2lvbiBvZiBkZWNpbWFsL3JhdGlvIGJhc2VkIGNhbGN1bGF0aW9ucyBhbmQgdmFyeWluZ1xuICAgIC8vIHJvdW5kaW5nIGJlaGF2aW9ycywgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHRoZSBzcGFjaW5nIGFkanVzdG1lbnQgaXMgb2ZmXG4gICAgLy8gYnkgYSBwaXhlbCBvciB0d28uIFRoaXMgYWRkcyBpbnN1cmFuY2UgdG8gdGhlc2UgY2FsY3VsYXRpb25zLlxuICAgIGlmIChwdWxsVG9vbHRpcEJ5IDwgMCkge1xuICAgICAgcHVsbFRvb2x0aXBCeSA9IDA7XG4gICAgfSBlbHNlIGlmIChwdWxsVG9vbHRpcEJ5ID4gdG9vbHRpcFJlY3Qud2lkdGgpIHtcbiAgICAgIHB1bGxUb29sdGlwQnkgPSB0b29sdGlwUmVjdC53aWR0aDtcbiAgICB9XG5cbiAgICB0aGlzLmVsXy5zdHlsZS5yaWdodCA9ICctJyArIHB1bGxUb29sdGlwQnkgKyAncHgnO1xuICAgIHRleHRDb250ZW50KHRoaXMuZWxfLCBjb250ZW50KTtcbiAgfTtcblxuICByZXR1cm4gVGltZVRvb2x0aXA7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGltZVRvb2x0aXAnLCBUaW1lVG9vbHRpcCk7XG5cbi8qKlxuICogQGZpbGUgcGxheS1wcm9ncmVzcy1iYXIuanNcbiAqL1xuLyoqXG4gKiBVc2VkIGJ5IHtAbGluayBTZWVrQmFyfSB0byBkaXNwbGF5IG1lZGlhIHBsYXliYWNrIHByb2dyZXNzIGFzIHBhcnQgb2YgdGhlXG4gKiB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sfS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUGxheVByb2dyZXNzQmFyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUGxheVByb2dyZXNzQmFyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQbGF5UHJvZ3Jlc3NCYXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheVByb2dyZXNzQmFyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgdGhlIERPTSBlbGVtZW50IGZvciB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBQbGF5UHJvZ3Jlc3NCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wbGF5LXByb2dyZXNzIHZqcy1zbGlkZXItYmFyJyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPjxzcGFuPicgKyB0aGlzLmxvY2FsaXplKCdQcm9ncmVzcycpICsgJzwvc3Bhbj46IDAlPC9zcGFuPidcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRW5xdWV1ZXMgdXBkYXRlcyB0byBpdHMgb3duIERPTSBhcyB3ZWxsIGFzIHRoZSBET00gb2YgaXRzXG4gICAqIHtAbGluayBUaW1lVG9vbHRpcH0gY2hpbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZWVrQmFyUmVjdFxuICAgKiAgICAgICAgVGhlIGBDbGllbnRSZWN0YCBmb3IgdGhlIHtAbGluayBTZWVrQmFyfSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vla0JhclBvaW50XG4gICAqICAgICAgICBBIG51bWJlciBmcm9tIDAgdG8gMSwgcmVwcmVzZW50aW5nIGEgaG9yaXpvbnRhbCByZWZlcmVuY2UgcG9pbnRcbiAgICogICAgICAgIGZyb20gdGhlIGxlZnQgZWRnZSBvZiB0aGUge0BsaW5rIFNlZWtCYXJ9XG4gICAqL1xuXG5cbiAgUGxheVByb2dyZXNzQmFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgckFGIElELCBjYW5jZWwgaXQgc28gd2UgZG9uJ3Qgb3Zlci1xdWV1ZS5cbiAgICBpZiAodGhpcy5yYWZJZF8pIHtcbiAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZF8pO1xuICAgIH1cblxuICAgIHRoaXMucmFmSWRfID0gdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRpbWUgPSBfdGhpczIucGxheWVyXy5zY3J1YmJpbmcoKSA/IF90aGlzMi5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgOiBfdGhpczIucGxheWVyXy5jdXJyZW50VGltZSgpO1xuXG4gICAgICB2YXIgY29udGVudCA9IGZvcm1hdFRpbWUodGltZSwgX3RoaXMyLnBsYXllcl8uZHVyYXRpb24oKSk7XG4gICAgICB2YXIgdGltZVRvb2x0aXAgPSBfdGhpczIuZ2V0Q2hpbGQoJ3RpbWVUb29sdGlwJyk7XG5cbiAgICAgIGlmICh0aW1lVG9vbHRpcCkge1xuICAgICAgICB0aW1lVG9vbHRpcC51cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFBsYXlQcm9ncmVzc0Jhcjtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHtAbGluayBQbGF5UHJvZ3Jlc3NCYXJ9LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuUGxheVByb2dyZXNzQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFtdXG59O1xuXG4vLyBUaW1lIHRvb2x0aXBzIHNob3VsZCBub3QgYmUgYWRkZWQgdG8gYSBwbGF5ZXIgb24gbW9iaWxlIGRldmljZXMgb3IgSUU4XG5pZiAoKCFJRV9WRVJTSU9OIHx8IElFX1ZFUlNJT04gPiA4KSAmJiAhSVNfSU9TICYmICFJU19BTkRST0lEKSB7XG4gIFBsYXlQcm9ncmVzc0Jhci5wcm90b3R5cGUub3B0aW9uc18uY2hpbGRyZW4ucHVzaCgndGltZVRvb2x0aXAnKTtcbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5UHJvZ3Jlc3NCYXInLCBQbGF5UHJvZ3Jlc3NCYXIpO1xuXG4vKipcbiAqIEBmaWxlIG1vdXNlLXRpbWUtZGlzcGxheS5qc1xuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgTW91c2VUaW1lRGlzcGxheX0gY29tcG9uZW50IHRyYWNrcyBtb3VzZSBtb3ZlbWVudCBvdmVyIHRoZVxuICoge0BsaW5rIFByb2dyZXNzQ29udHJvbH0uIEl0IGRpc3BsYXlzIGFuIGluZGljYXRvciBhbmQgYSB7QGxpbmsgVGltZVRvb2x0aXB9XG4gKiBpbmRpY2F0aW5nIHRoZSB0aW1lIHdoaWNoIGlzIHJlcHJlc2VudGVkIGJ5IGEgZ2l2ZW4gcG9pbnQgaW4gdGhlXG4gKiB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sfS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTW91c2VUaW1lRGlzcGxheSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1vdXNlVGltZURpc3BsYXksIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSB7QGxpbmsgUGxheWVyfSB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTW91c2VUaW1lRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNb3VzZVRpbWVEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudXBkYXRlID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMudXBkYXRlKSwgMjUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIERPTSBlbGVtZW50IGZvciB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgTW91c2VUaW1lRGlzcGxheS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLW1vdXNlLWRpc3BsYXknXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIHVwZGF0ZXMgdG8gaXRzIG93biBET00gYXMgd2VsbCBhcyB0aGUgRE9NIG9mIGl0c1xuICAgKiB7QGxpbmsgVGltZVRvb2x0aXB9IGNoaWxkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2Vla0JhclJlY3RcbiAgICogICAgICAgIFRoZSBgQ2xpZW50UmVjdGAgZm9yIHRoZSB7QGxpbmsgU2Vla0Jhcn0gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlZWtCYXJQb2ludFxuICAgKiAgICAgICAgQSBudW1iZXIgZnJvbSAwIHRvIDEsIHJlcHJlc2VudGluZyBhIGhvcml6b250YWwgcmVmZXJlbmNlIHBvaW50XG4gICAqICAgICAgICBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHtAbGluayBTZWVrQmFyfVxuICAgKi9cblxuXG4gIE1vdXNlVGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyByQUYgSUQsIGNhbmNlbCBpdCBzbyB3ZSBkb24ndCBvdmVyLXF1ZXVlLlxuICAgIGlmICh0aGlzLnJhZklkXykge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkXyk7XG4gICAgfVxuXG4gICAgdGhpcy5yYWZJZF8gPSB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZHVyYXRpb24gPSBfdGhpczIucGxheWVyXy5kdXJhdGlvbigpO1xuICAgICAgdmFyIGNvbnRlbnQgPSBmb3JtYXRUaW1lKHNlZWtCYXJQb2ludCAqIGR1cmF0aW9uLCBkdXJhdGlvbik7XG5cbiAgICAgIF90aGlzMi5lbF8uc3R5bGUubGVmdCA9IHNlZWtCYXJSZWN0LndpZHRoICogc2Vla0JhclBvaW50ICsgJ3B4JztcbiAgICAgIF90aGlzMi5nZXRDaGlsZCgndGltZVRvb2x0aXAnKS51cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCwgY29udGVudCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1vdXNlVGltZURpc3BsYXk7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBgTW91c2VUaW1lRGlzcGxheWBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cbk1vdXNlVGltZURpc3BsYXkucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWyd0aW1lVG9vbHRpcCddXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01vdXNlVGltZURpc3BsYXknLCBNb3VzZVRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBzZWVrLWJhci5qc1xuICovXG4vLyBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdGhlIGBzdGVwKmAgZnVuY3Rpb25zIG1vdmUgdGhlIHRpbWVsaW5lLlxudmFyIFNURVBfU0VDT05EUyA9IDU7XG5cbi8qKlxuICogU2VlayBiYXIgYW5kIGNvbnRhaW5lciBmb3IgdGhlIHByb2dyZXNzIGJhcnMuIFVzZXMge0BsaW5rIFBsYXlQcm9ncmVzc0Jhcn1cbiAqIGFzIGl0cyBgYmFyYC5cbiAqXG4gKiBAZXh0ZW5kcyBTbGlkZXJcbiAqL1xuXG52YXIgU2Vla0JhciA9IGZ1bmN0aW9uIChfU2xpZGVyKSB7XG4gIGluaGVyaXRzKFNlZWtCYXIsIF9TbGlkZXIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gU2Vla0JhcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTZWVrQmFyKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1NsaWRlci5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudXBkYXRlID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMudXBkYXRlKSwgNTApO1xuICAgIF90aGlzLm9uKHBsYXllciwgWyd0aW1ldXBkYXRlJywgJ2VuZGVkJ10sIF90aGlzLnVwZGF0ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX1NsaWRlci5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXByb2dyZXNzLWhvbGRlcidcbiAgICB9LCB7XG4gICAgICAnYXJpYS1sYWJlbCc6IHRoaXMubG9jYWxpemUoJ1Byb2dyZXNzIEJhcicpXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgc2VlayBiYXIncyBVSS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGB0aW1ldXBkYXRlYCBvciBgZW5kZWRgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGltZXVwZGF0ZVxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZW5kZWRcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIHBlcmNlbnQgPSBfU2xpZGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcblxuICAgIC8vIEFsbG93cyBmb3Igc21vb3RoIHNjcnViYmluZywgd2hlbiBwbGF5ZXIgY2FuJ3Qga2VlcCB1cC5cbiAgICB2YXIgdGltZSA9IHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG5cbiAgICAvLyBtYWNoaW5lIHJlYWRhYmxlIHZhbHVlIG9mIHByb2dyZXNzIGJhciAocGVyY2VudGFnZSBjb21wbGV0ZSlcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCAocGVyY2VudCAqIDEwMCkudG9GaXhlZCgyKSk7XG5cbiAgICAvLyBodW1hbiByZWFkYWJsZSB2YWx1ZSBvZiBwcm9ncmVzcyBiYXIgKHRpbWUgY29tcGxldGUpXG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVldGV4dCcsIHRoaXMubG9jYWxpemUoJ3Byb2dyZXNzIGJhciB0aW1pbmc6IGN1cnJlbnRUaW1lPXsxfSBkdXJhdGlvbj17Mn0nLCBbZm9ybWF0VGltZSh0aW1lLCBkdXJhdGlvbiksIGZvcm1hdFRpbWUoZHVyYXRpb24sIGR1cmF0aW9uKV0sICd7MX0gb2YgezJ9JykpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBgUGxheVByb2dyZXNzQmFyYC5cbiAgICB0aGlzLmJhci51cGRhdGUoZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxfKSwgcGVyY2VudCk7XG5cbiAgICByZXR1cm4gcGVyY2VudDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwZXJjZW50YWdlIG9mIG1lZGlhIHBsYXllZCBzbyBmYXIuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGVyY2VudGFnZSBvZiBtZWRpYSBwbGF5ZWQgc28gZmFyICgwIHRvIDEpLlxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmdldFBlcmNlbnQgPSBmdW5jdGlvbiBnZXRQZXJjZW50KCkge1xuXG4gICAgLy8gQWxsb3dzIGZvciBzbW9vdGggc2NydWJiaW5nLCB3aGVuIHBsYXllciBjYW4ndCBrZWVwIHVwLlxuICAgIHZhciB0aW1lID0gdGhpcy5wbGF5ZXJfLnNjcnViYmluZygpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgOiB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKTtcblxuICAgIHZhciBwZXJjZW50ID0gdGltZSAvIHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuXG4gICAgcmV0dXJuIHBlcmNlbnQgPj0gMSA/IDEgOiBwZXJjZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgZG93biBvbiBzZWVrIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICB0aGlzLnBsYXllcl8uc2NydWJiaW5nKHRydWUpO1xuXG4gICAgdGhpcy52aWRlb1dhc1BsYXlpbmcgPSAhdGhpcy5wbGF5ZXJfLnBhdXNlZCgpO1xuICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xuXG4gICAgX1NsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duLmNhbGwodGhpcywgZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgbW92ZSBvbiBzZWVrIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZW1vdmVgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIgbmV3VGltZSA9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpICogdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG5cbiAgICAvLyBEb24ndCBsZXQgdmlkZW8gZW5kIHdoaWxlIHNjcnViYmluZy5cbiAgICBpZiAobmV3VGltZSA9PT0gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpIHtcbiAgICAgIG5ld1RpbWUgPSBuZXdUaW1lIC0gMC4xO1xuICAgIH1cblxuICAgIC8vIFNldCBuZXcgdGltZSAodGVsbCBwbGF5ZXIgdG8gc2VlayB0byBuZXcgdGltZSlcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUobmV3VGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSB1cCBvbiBzZWVrIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZXVwYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2V1cFxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgX1NsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VVcC5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIHRoaXMucGxheWVyXy5zY3J1YmJpbmcoZmFsc2UpO1xuICAgIGlmICh0aGlzLnZpZGVvV2FzUGxheWluZykge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgbW9yZSBxdWlja2x5IGZhc3QgZm9yd2FyZCBmb3Iga2V5Ym9hcmQtb25seSB1c2Vyc1xuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpICsgU1RFUF9TRUNPTkRTKTtcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSBtb3JlIHF1aWNrbHkgcmV3aW5kIGZvciBrZXlib2FyZC1vbmx5IHVzZXJzXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuc3RlcEJhY2sgPSBmdW5jdGlvbiBzdGVwQmFjaygpIHtcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCkgLSBTVEVQX1NFQ09ORFMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgcGxheWVyXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBlbnRlciBvciBzcGFjZSBpcyB1c2VkIG9uIHRoZSBzZWVrYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAqXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlQWN0aW9uID0gZnVuY3Rpb24gaGFuZGxlQWN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGlzIFNlZWtCYXIgaGFzIGZvY3VzIGFuZCBhIGtleSBnZXRzIHByZXNzZWQgZG93bi4gQnlcbiAgICogZGVmYXVsdCBpdCB3aWxsIGNhbGwgYHRoaXMuaGFuZGxlQWN0aW9uYCB3aGVuIHRoZSBrZXkgaXMgc3BhY2Ugb3IgZW50ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuXG4gICAgLy8gU3VwcG9ydCBTcGFjZSAoMzIpIG9yIEVudGVyICgxMykga2V5IG9wZXJhdGlvbiB0byBmaXJlIGEgY2xpY2sgZXZlbnRcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDMyIHx8IGV2ZW50LndoaWNoID09PSAxMykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuaGFuZGxlQWN0aW9uKGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzKSB7XG5cbiAgICAgIC8vIFBhc3Mga2V5cHJlc3MgaGFuZGxpbmcgdXAgZm9yIHVuc3VwcG9ydGVkIGtleXNcbiAgICAgIF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU2Vla0Jhcjtcbn0oU2xpZGVyKTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBgU2Vla0JhcmBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cblNlZWtCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWydsb2FkUHJvZ3Jlc3NCYXInLCAncGxheVByb2dyZXNzQmFyJ10sXG4gIGJhck5hbWU6ICdwbGF5UHJvZ3Jlc3NCYXInXG59O1xuXG4vLyBNb3VzZVRpbWVEaXNwbGF5IHRvb2x0aXBzIHNob3VsZCBub3QgYmUgYWRkZWQgdG8gYSBwbGF5ZXIgb24gbW9iaWxlIGRldmljZXMgb3IgSUU4XG5pZiAoKCFJRV9WRVJTSU9OIHx8IElFX1ZFUlNJT04gPiA4KSAmJiAhSVNfSU9TICYmICFJU19BTkRST0lEKSB7XG4gIFNlZWtCYXIucHJvdG90eXBlLm9wdGlvbnNfLmNoaWxkcmVuLnNwbGljZSgxLCAwLCAnbW91c2VUaW1lRGlzcGxheScpO1xufVxuXG4vKipcbiAqIENhbGwgdGhlIHVwZGF0ZSBldmVudCBmb3IgdGhpcyBTbGlkZXIgd2hlbiB0aGlzIGV2ZW50IGhhcHBlbnMgb24gdGhlIHBsYXllci5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5TZWVrQmFyLnByb3RvdHlwZS5wbGF5ZXJFdmVudCA9ICd0aW1ldXBkYXRlJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTZWVrQmFyJywgU2Vla0Jhcik7XG5cbi8qKlxuICogQGZpbGUgcHJvZ3Jlc3MtY29udHJvbC5qc1xuICovXG4vKipcbiAqIFRoZSBQcm9ncmVzcyBDb250cm9sIGNvbXBvbmVudCBjb250YWlucyB0aGUgc2VlayBiYXIsIGxvYWQgcHJvZ3Jlc3MsXG4gKiBhbmQgcGxheSBwcm9ncmVzcy5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUHJvZ3Jlc3NDb250cm9sID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUHJvZ3Jlc3NDb250cm9sLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFByb2dyZXNzQ29udHJvbChwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9ncmVzc0NvbnRyb2wpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpLCAyNSk7XG4gICAgX3RoaXMub24oX3RoaXMuZWxfLCAnbW91c2Vtb3ZlJywgX3RoaXMuaGFuZGxlTW91c2VNb3ZlKTtcblxuICAgIF90aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2VlayA9IHRocm90dGxlKGJpbmQoX3RoaXMsIF90aGlzLmhhbmRsZU1vdXNlU2VlayksIDI1KTtcbiAgICBfdGhpcy5vbihbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sIF90aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcHJvZ3Jlc3MtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgYFByb2dyZXNzQ29udHJvbGAsIHRoZSBwb2ludGVyIHBvc2l0aW9uXG4gICAqIGdldHMgcGFzc2VkIGRvd24gdG8gdGhlIGBNb3VzZVRpbWVEaXNwbGF5YCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYG1vdXNlbW92ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW4gbW91c2Vtb3ZlXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIgc2Vla0JhciA9IHRoaXMuZ2V0Q2hpbGQoJ3NlZWtCYXInKTtcbiAgICB2YXIgbW91c2VUaW1lRGlzcGxheSA9IHNlZWtCYXIuZ2V0Q2hpbGQoJ21vdXNlVGltZURpc3BsYXknKTtcbiAgICB2YXIgc2Vla0JhckVsID0gc2Vla0Jhci5lbCgpO1xuICAgIHZhciBzZWVrQmFyUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzZWVrQmFyRWwpO1xuICAgIHZhciBzZWVrQmFyUG9pbnQgPSBnZXRQb2ludGVyUG9zaXRpb24oc2Vla0JhckVsLCBldmVudCkueDtcblxuICAgIC8vIFRoZSBkZWZhdWx0IHNraW4gaGFzIGEgZ2FwIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBgU2Vla0JhcmAuIFRoaXMgbWVhbnNcbiAgICAvLyB0aGF0IGl0J3MgcG9zc2libGUgdG8gdHJpZ2dlciB0aGlzIGJlaGF2aW9yIG91dHNpZGUgdGhlIGJvdW5kYXJpZXMgb2ZcbiAgICAvLyB0aGUgYFNlZWtCYXJgLiBUaGlzIGVuc3VyZXMgd2Ugc3RheSB3aXRoaW4gaXQgYXQgYWxsIHRpbWVzLlxuICAgIGlmIChzZWVrQmFyUG9pbnQgPiAxKSB7XG4gICAgICBzZWVrQmFyUG9pbnQgPSAxO1xuICAgIH0gZWxzZSBpZiAoc2Vla0JhclBvaW50IDwgMCkge1xuICAgICAgc2Vla0JhclBvaW50ID0gMDtcbiAgICB9XG5cbiAgICBpZiAobW91c2VUaW1lRGlzcGxheSkge1xuICAgICAgbW91c2VUaW1lRGlzcGxheS51cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBIHRocm90dGxlZCB2ZXJzaW9uIG9mIHRoZSB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sI2hhbmRsZU1vdXNlU2Vla30gbGlzdGVuZXIuXG4gICAqXG4gICAqIEBtZXRob2QgUHJvZ3Jlc3NDb250cm9sI3Rocm90dGxlZEhhbmRsZU1vdXNlU2Vla1xuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZW1vdmVgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVuIG1vdXNlbW92ZVxuICAgKiBAbGlzdGVuIHRvdWNobW92ZVxuICAgKi9cblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZW1vdmVgIG9yIGB0b3VjaG1vdmVgIGV2ZW50cyBvbiB0aGUgYFByb2dyZXNzQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICogQGxpc3RlbnMgdG91Y2htb3ZlXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZVNlZWsgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVNlZWsoZXZlbnQpIHtcbiAgICB2YXIgc2Vla0JhciA9IHRoaXMuZ2V0Q2hpbGQoJ3NlZWtCYXInKTtcblxuICAgIHNlZWtCYXIuaGFuZGxlTW91c2VNb3ZlKGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudHMgb24gdGhlIGBQcm9ncmVzc0NvbnRyb2xgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqIEBsaXN0ZW5zIHRvdWNoc3RhcnRcbiAgICovXG5cblxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdGhpcy5vbihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2Vlayk7XG4gICAgdGhpcy5vbihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2Vlayk7XG4gICAgdGhpcy5vbihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50cyBvbiB0aGUgYFByb2dyZXNzQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbGlzdGVucyB0b3VjaGVuZFxuICAgKiBAbGlzdGVucyBtb3VzZXVwXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZVNlZWspO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrKTtcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gIH07XG5cbiAgcmV0dXJuIFByb2dyZXNzQ29udHJvbDtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBQcm9ncmVzc0NvbnRyb2xgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Qcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWydzZWVrQmFyJ11cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUHJvZ3Jlc3NDb250cm9sJywgUHJvZ3Jlc3NDb250cm9sKTtcblxuLyoqXG4gKiBAZmlsZSBmdWxsc2NyZWVuLXRvZ2dsZS5qc1xuICovXG4vKipcbiAqIFRvZ2dsZSBmdWxsc2NyZWVuIHZpZGVvXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKi9cblxudmFyIEZ1bGxzY3JlZW5Ub2dnbGUgPSBmdW5jdGlvbiAoX0J1dHRvbikge1xuICBpbmhlcml0cyhGdWxsc2NyZWVuVG9nZ2xlLCBfQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEZ1bGxzY3JlZW5Ub2dnbGUocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRnVsbHNjcmVlblRvZ2dsZSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBfdGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWZ1bGxzY3JlZW4tY29udHJvbCAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGZ1bGxzY3JlZW5jaGFuZ2Ugb24gdGhlIHBsYXllciBhbmQgY2hhbmdlIGNvbnRyb2wgdGV4dCBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZX0gZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgKi9cblxuXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgdGhpcy5jb250cm9sVGV4dCgnTm9uLUZ1bGxzY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250cm9sVGV4dCgnRnVsbHNjcmVlbicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBGdWxsc2NyZWVuVG9nZ2xlYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgRnVsbHNjcmVlblRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGlmICghdGhpcy5wbGF5ZXJfLmlzRnVsbHNjcmVlbigpKSB7XG4gICAgICB0aGlzLnBsYXllcl8ucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBGdWxsc2NyZWVuVG9nZ2xlO1xufShCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEZ1bGxzY3JlZW5Ub2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdGdWxsc2NyZWVuJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdGdWxsc2NyZWVuVG9nZ2xlJywgRnVsbHNjcmVlblRvZ2dsZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgdm9sdW1lIGNvbnRyb2wgaXMgc3VwcG9ydGVkIGFuZCBpZiBpdCBpc24ndCBoaWRlIHRoZVxuICogYENvbXBvbmVudGAgdGhhdCB3YXMgcGFzc2VkICB1c2luZyB0aGUgYHZqcy1oaWRkZW5gIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBzZWxmXG4gKiAgICAgICAgVGhlIGNvbXBvbmVudCB0aGF0IHNob3VsZCBiZSBoaWRkZW4gaWYgdm9sdW1lIGlzIHVuc3VwcG9ydGVkXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICogICAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSBwbGF5ZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY2hlY2tWb2x1bWVTdXBwb3J0ID0gZnVuY3Rpb24gY2hlY2tWb2x1bWVTdXBwb3J0KHNlbGYsIHBsYXllcikge1xuICAvLyBoaWRlIHZvbHVtZSBjb250cm9scyB3aGVuIHRoZXkncmUgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCB0ZWNoXG4gIGlmIChwbGF5ZXIudGVjaF8gJiYgIXBsYXllci50ZWNoXy5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wpIHtcbiAgICBzZWxmLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gIH1cblxuICBzZWxmLm9uKHBsYXllciwgJ2xvYWRzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBsYXllci50ZWNoXy5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wpIHtcbiAgICAgIHNlbGYuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBmaWxlIHZvbHVtZS1sZXZlbC5qc1xuICovXG4vKipcbiAqIFNob3dzIHZvbHVtZSBsZXZlbFxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBWb2x1bWVMZXZlbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFZvbHVtZUxldmVsLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBWb2x1bWVMZXZlbCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVMZXZlbCk7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgVm9sdW1lTGV2ZWwucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtbGV2ZWwnLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PC9zcGFuPidcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lTGV2ZWw7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lTGV2ZWwnLCBWb2x1bWVMZXZlbCk7XG5cbi8qKlxuICogQGZpbGUgdm9sdW1lLWJhci5qc1xuICovXG4vLyBSZXF1aXJlZCBjaGlsZHJlblxuLyoqXG4gKiBUaGUgYmFyIHRoYXQgY29udGFpbnMgdGhlIHZvbHVtZSBsZXZlbCBhbmQgY2FuIGJlIGNsaWNrZWQgb24gdG8gYWRqdXN0IHRoZSBsZXZlbFxuICpcbiAqIEBleHRlbmRzIFNsaWRlclxuICovXG5cbnZhciBWb2x1bWVCYXIgPSBmdW5jdGlvbiAoX1NsaWRlcikge1xuICBpbmhlcml0cyhWb2x1bWVCYXIsIF9TbGlkZXIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVm9sdW1lQmFyKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZvbHVtZUJhcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9TbGlkZXIuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKCdzbGlkZXJhY3RpdmUnLCBfdGhpcy51cGRhdGVMYXN0Vm9sdW1lXyk7XG4gICAgX3RoaXMub24ocGxheWVyLCAndm9sdW1lY2hhbmdlJywgX3RoaXMudXBkYXRlQVJJQUF0dHJpYnV0ZXMpO1xuICAgIHBsYXllci5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMudXBkYXRlQVJJQUF0dHJpYnV0ZXMoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9TbGlkZXIucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtYmFyIHZqcy1zbGlkZXItYmFyJ1xuICAgIH0sIHtcbiAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5sb2NhbGl6ZSgnVm9sdW1lIExldmVsJyksXG4gICAgICAnYXJpYS1saXZlJzogJ3BvbGl0ZSdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdmVtZW50IGV2ZW50cyBvbiB0aGUge0BsaW5rIFZvbHVtZU1lbnVCdXR0b259LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgIHRoaXMuY2hlY2tNdXRlZCgpO1xuICAgIHRoaXMucGxheWVyXy52b2x1bWUodGhpcy5jYWxjdWxhdGVEaXN0YW5jZShldmVudCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJZiB0aGUgcGxheWVyIGlzIG11dGVkIHVubXV0ZSBpdC5cbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmNoZWNrTXV0ZWQgPSBmdW5jdGlvbiBjaGVja011dGVkKCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8ubXV0ZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLm11dGVkKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBwZXJjZW50IG9mIHZvbHVtZSBsZXZlbFxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVm9sdW1lIGxldmVsIHBlcmNlbnQgYXMgYSBkZWNpbWFsIG51bWJlci5cbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmdldFBlcmNlbnQgPSBmdW5jdGlvbiBnZXRQZXJjZW50KCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8ubXV0ZWQoKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBsYXllcl8udm9sdW1lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlIHZvbHVtZSBsZXZlbCBmb3Iga2V5Ym9hcmQgdXNlcnNcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XG4gICAgdGhpcy5jaGVja011dGVkKCk7XG4gICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh0aGlzLnBsYXllcl8udm9sdW1lKCkgKyAwLjEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNyZWFzZSB2b2x1bWUgbGV2ZWwgZm9yIGtleWJvYXJkIHVzZXJzXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5zdGVwQmFjayA9IGZ1bmN0aW9uIHN0ZXBCYWNrKCkge1xuICAgIHRoaXMuY2hlY2tNdXRlZCgpO1xuICAgIHRoaXMucGxheWVyXy52b2x1bWUodGhpcy5wbGF5ZXJfLnZvbHVtZSgpIC0gMC4xKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIEFSSUEgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdm9sdW1lY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3ZvbHVtZWNoYW5nZVxuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUudXBkYXRlQVJJQUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiB1cGRhdGVBUklBQXR0cmlidXRlcyhldmVudCkge1xuICAgIHZhciBhcmlhVmFsdWUgPSB0aGlzLnBsYXllcl8ubXV0ZWQoKSA/IDAgOiB0aGlzLnZvbHVtZUFzUGVyY2VudGFnZV8oKTtcblxuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIGFyaWFWYWx1ZSk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVldGV4dCcsIGFyaWFWYWx1ZSArICclJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHBsYXllciB2b2x1bWUgYXMgYSBwZXJjZW50YWdlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS52b2x1bWVBc1BlcmNlbnRhZ2VfID0gZnVuY3Rpb24gdm9sdW1lQXNQZXJjZW50YWdlXygpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLnBsYXllcl8udm9sdW1lKCkgKiAxMDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBWb2x1bWVCYXIsIHN0b3JlIHRoZSB2b2x1bWUgYW5kIGxpc3RlbiBmb3JcbiAgICogdGhlIGVuZCBvZiB0aGUgZHJhZy4gV2hlbiB0aGUgZHJhZyBlbmRzLCBpZiB0aGUgdm9sdW1lIHdhcyBzZXQgdG8gemVybyxcbiAgICogc2V0IGxhc3RWb2x1bWUgdG8gdGhlIHN0b3JlZCB2b2x1bWUuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHNsaWRlcmFjdGl2ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUudXBkYXRlTGFzdFZvbHVtZV8gPSBmdW5jdGlvbiB1cGRhdGVMYXN0Vm9sdW1lXygpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciB2b2x1bWVCZWZvcmVEcmFnID0gdGhpcy5wbGF5ZXJfLnZvbHVtZSgpO1xuXG4gICAgdGhpcy5vbmUoJ3NsaWRlcmluYWN0aXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzMi5wbGF5ZXJfLnZvbHVtZSgpID09PSAwKSB7XG4gICAgICAgIF90aGlzMi5wbGF5ZXJfLmxhc3RWb2x1bWVfKHZvbHVtZUJlZm9yZURyYWcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBWb2x1bWVCYXI7XG59KFNsaWRlcik7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYFZvbHVtZUJhcmBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cblZvbHVtZUJhci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ3ZvbHVtZUxldmVsJ10sXG4gIGJhck5hbWU6ICd2b2x1bWVMZXZlbCdcbn07XG5cbi8qKlxuICogQ2FsbCB0aGUgdXBkYXRlIGV2ZW50IGZvciB0aGlzIFNsaWRlciB3aGVuIHRoaXMgZXZlbnQgaGFwcGVucyBvbiB0aGUgcGxheWVyLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblZvbHVtZUJhci5wcm90b3R5cGUucGxheWVyRXZlbnQgPSAndm9sdW1lY2hhbmdlJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdWb2x1bWVCYXInLCBWb2x1bWVCYXIpO1xuXG4vKipcbiAqIEBmaWxlIHZvbHVtZS1jb250cm9sLmpzXG4gKi9cbi8vIFJlcXVpcmVkIGNoaWxkcmVuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNvbnRyb2xsaW5nIHRoZSB2b2x1bWUgbGV2ZWxcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVm9sdW1lQ29udHJvbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFZvbHVtZUNvbnRyb2wsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVm9sdW1lQ29udHJvbChwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVm9sdW1lQ29udHJvbCk7XG5cbiAgICBvcHRpb25zLnZlcnRpY2FsID0gb3B0aW9ucy52ZXJ0aWNhbCB8fCBmYWxzZTtcblxuICAgIC8vIFBhc3MgdGhlIHZlcnRpY2FsIG9wdGlvbiBkb3duIHRvIHRoZSBWb2x1bWVCYXIgaWZcbiAgICAvLyB0aGUgVm9sdW1lQmFyIGlzIHR1cm5lZCBvbi5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudm9sdW1lQmFyID09PSAndW5kZWZpbmVkJyB8fCBpc1BsYWluKG9wdGlvbnMudm9sdW1lQmFyKSkge1xuICAgICAgb3B0aW9ucy52b2x1bWVCYXIgPSBvcHRpb25zLnZvbHVtZUJhciB8fCB7fTtcbiAgICAgIG9wdGlvbnMudm9sdW1lQmFyLnZlcnRpY2FsID0gb3B0aW9ucy52ZXJ0aWNhbDtcbiAgICB9XG5cbiAgICAvLyBoaWRlIHRoaXMgY29udHJvbCBpZiB2b2x1bWUgc3VwcG9ydCBpcyBtaXNzaW5nXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBjaGVja1ZvbHVtZVN1cHBvcnQoX3RoaXMsIHBsYXllcik7XG5cbiAgICBfdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpLCAyNSk7XG5cbiAgICBfdGhpcy5vbignbW91c2Vkb3duJywgX3RoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICBfdGhpcy5vbigndG91Y2hzdGFydCcsIF90aGlzLmhhbmRsZU1vdXNlRG93bik7XG5cbiAgICAvLyB3aGlsZSB0aGUgc2xpZGVyIGlzIGFjdGl2ZSAodGhlIG1vdXNlIGhhcyBiZWVuIHByZXNzZWQgZG93biBhbmRcbiAgICAvLyBpcyBkcmFnZ2luZykgb3IgaW4gZm9jdXMgd2UgZG8gbm90IHdhbnQgdG8gaGlkZSB0aGUgVm9sdW1lQmFyXG4gICAgX3RoaXMub24oX3RoaXMudm9sdW1lQmFyLCBbJ2ZvY3VzJywgJ3NsaWRlcmFjdGl2ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy52b2x1bWVCYXIuYWRkQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLXNsaWRlci1hY3RpdmUnKTtcbiAgICAgIF90aGlzLnRyaWdnZXIoJ3NsaWRlcmFjdGl2ZScpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMub24oX3RoaXMudm9sdW1lQmFyLCBbJ2JsdXInLCAnc2xpZGVyaW5hY3RpdmUnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMudm9sdW1lQmFyLnJlbW92ZUNsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gICAgICBfdGhpcy50cmlnZ2VyKCdzbGlkZXJpbmFjdGl2ZScpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFZvbHVtZUNvbnRyb2wucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS1ob3Jpem9udGFsJztcblxuICAgIGlmICh0aGlzLm9wdGlvbnNfLnZlcnRpY2FsKSB7XG4gICAgICBvcmllbnRhdGlvbkNsYXNzID0gJ3Zqcy12b2x1bWUtdmVydGljYWwnO1xuICAgIH1cblxuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdm9sdW1lLWNvbnRyb2wgdmpzLWNvbnRyb2wgJyArIG9yaWVudGF0aW9uQ2xhc3NcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudHMgb24gdGhlIGBWb2x1bWVDb250cm9sYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlZG93blxuICAgKiBAbGlzdGVucyB0b3VjaHN0YXJ0XG4gICAqL1xuXG5cbiAgVm9sdW1lQ29udHJvbC5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgdmFyIGRvYyA9IHRoaXMuZWxfLm93bmVyRG9jdW1lbnQ7XG5cbiAgICB0aGlzLm9uKGRvYywgJ21vdXNlbW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNobW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKGRvYywgJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIHRoaXMub24oZG9jLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNldXBgIG9yIGB0b3VjaGVuZGAgZXZlbnRzIG9uIHRoZSBgVm9sdW1lQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbGlzdGVucyB0b3VjaGVuZFxuICAgKiBAbGlzdGVucyBtb3VzZXVwXG4gICAqL1xuXG5cbiAgVm9sdW1lQ29udHJvbC5wcm90b3R5cGUuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoZXZlbnQpIHtcbiAgICB2YXIgZG9jID0gdGhpcy5lbF8ub3duZXJEb2N1bWVudDtcblxuICAgIHRoaXMub2ZmKGRvYywgJ21vdXNlbW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50cyBvbiB0aGUgYFZvbHVtZUNvbnRyb2xgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqIEBsaXN0ZW5zIHRvdWNoc3RhcnRcbiAgICovXG5cblxuICBWb2x1bWVDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB0aGlzLnZvbHVtZUJhci5oYW5kbGVNb3VzZU1vdmUoZXZlbnQpO1xuICB9O1xuXG4gIHJldHVybiBWb2x1bWVDb250cm9sO1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIGBWb2x1bWVDb250cm9sYFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuVm9sdW1lQ29udHJvbC5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ3ZvbHVtZUJhciddXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZUNvbnRyb2wnLCBWb2x1bWVDb250cm9sKTtcblxuLyoqXG4gKiBAZmlsZSBtdXRlLXRvZ2dsZS5qc1xuICovXG4vKipcbiAqIEEgYnV0dG9uIGNvbXBvbmVudCBmb3IgbXV0aW5nIHRoZSBhdWRpby5cbiAqXG4gKiBAZXh0ZW5kcyBCdXR0b25cbiAqL1xuXG52YXIgTXV0ZVRvZ2dsZSA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKE11dGVUb2dnbGUsIF9CdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTXV0ZVRvZ2dsZShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNdXRlVG9nZ2xlKTtcblxuICAgIC8vIGhpZGUgdGhpcyBjb250cm9sIGlmIHZvbHVtZSBzdXBwb3J0IGlzIG1pc3NpbmdcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIGNoZWNrVm9sdW1lU3VwcG9ydChfdGhpcywgcGxheWVyKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgWydsb2Fkc3RhcnQnLCAndm9sdW1lY2hhbmdlJ10sIF90aGlzLnVwZGF0ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1tdXRlLWNvbnRyb2wgJyArIF9CdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBNdXRlVG9nZ2xlYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIHZhciB2b2wgPSB0aGlzLnBsYXllcl8udm9sdW1lKCk7XG4gICAgdmFyIGxhc3RWb2x1bWUgPSB0aGlzLnBsYXllcl8ubGFzdFZvbHVtZV8oKTtcblxuICAgIGlmICh2b2wgPT09IDApIHtcbiAgICAgIHZhciB2b2x1bWVUb1NldCA9IGxhc3RWb2x1bWUgPCAwLjEgPyAwLjEgOiBsYXN0Vm9sdW1lO1xuXG4gICAgICB0aGlzLnBsYXllcl8udm9sdW1lKHZvbHVtZVRvU2V0KTtcbiAgICAgIHRoaXMucGxheWVyXy5tdXRlZChmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5tdXRlZCh0aGlzLnBsYXllcl8ubXV0ZWQoKSA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGBNdXRlVG9nZ2xlYCBidXR0b24gYmFzZWQgb24gdGhlIHN0YXRlIG9mIGB2b2x1bWVgIGFuZCBgbXV0ZWRgXG4gICAqIG9uIHRoZSBwbGF5ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSB7QGxpbmsgUGxheWVyI2xvYWRzdGFydH0gZXZlbnQgaWYgdGhpcyBmdW5jdGlvbiB3YXMgY2FsbGVkXG4gICAqICAgICAgICB0aHJvdWdoIGFuIGV2ZW50LlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjbG9hZHN0YXJ0XG4gICAqIEBsaXN0ZW5zIFBsYXllciN2b2x1bWVjaGFuZ2VcbiAgICovXG5cblxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICB0aGlzLnVwZGF0ZUljb25fKCk7XG4gICAgdGhpcy51cGRhdGVDb250cm9sVGV4dF8oKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBgTXV0ZVRvZ2dsZWAgaWNvbi5cbiAgICpcbiAgICogUG9zc2libGUgc3RhdGVzIChnaXZlbiBgbGV2ZWxgIHZhcmlhYmxlIGJlbG93KTpcbiAgICogLSAwOiBjcm9zc2VkIG91dFxuICAgKiAtIDE6IHplcm8gYmFycyBvZiB2b2x1bWVcbiAgICogLSAyOiBvbmUgYmFyIG9mIHZvbHVtZVxuICAgKiAtIDM6IHR3byBiYXJzIG9mIHZvbHVtZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIE11dGVUb2dnbGUucHJvdG90eXBlLnVwZGF0ZUljb25fID0gZnVuY3Rpb24gdXBkYXRlSWNvbl8oKSB7XG4gICAgdmFyIHZvbCA9IHRoaXMucGxheWVyXy52b2x1bWUoKTtcbiAgICB2YXIgbGV2ZWwgPSAzO1xuXG4gICAgaWYgKHZvbCA9PT0gMCB8fCB0aGlzLnBsYXllcl8ubXV0ZWQoKSkge1xuICAgICAgbGV2ZWwgPSAwO1xuICAgIH0gZWxzZSBpZiAodm9sIDwgMC4zMykge1xuICAgICAgbGV2ZWwgPSAxO1xuICAgIH0gZWxzZSBpZiAodm9sIDwgMC42Nykge1xuICAgICAgbGV2ZWwgPSAyO1xuICAgIH1cblxuICAgIC8vIFRPRE8gaW1wcm92ZSBtdXRlZCBpY29uIGNsYXNzZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbF8sICd2anMtdm9sLScgKyBpKTtcbiAgICB9XG4gICAgYWRkQ2xhc3ModGhpcy5lbF8sICd2anMtdm9sLScgKyBsZXZlbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIElmIGBtdXRlZGAgaGFzIGNoYW5nZWQgb24gdGhlIHBsYXllciwgdXBkYXRlIHRoZSBjb250cm9sIHRleHRcbiAgICogKGB0aXRsZWAgYXR0cmlidXRlIG9uIGB2anMtbXV0ZS1jb250cm9sYCBlbGVtZW50IGFuZCBjb250ZW50IG9mXG4gICAqIGB2anMtY29udHJvbC10ZXh0YCBlbGVtZW50KS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS51cGRhdGVDb250cm9sVGV4dF8gPSBmdW5jdGlvbiB1cGRhdGVDb250cm9sVGV4dF8oKSB7XG4gICAgdmFyIHNvdW5kT2ZmID0gdGhpcy5wbGF5ZXJfLm11dGVkKCkgfHwgdGhpcy5wbGF5ZXJfLnZvbHVtZSgpID09PSAwO1xuICAgIHZhciB0ZXh0ID0gc291bmRPZmYgPyAnVW5tdXRlJyA6ICdNdXRlJztcblxuICAgIGlmICh0aGlzLmNvbnRyb2xUZXh0KCkgIT09IHRleHQpIHtcbiAgICAgIHRoaXMuY29udHJvbFRleHQodGV4dCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBNdXRlVG9nZ2xlO1xufShCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYE11dGVUb2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbk11dGVUb2dnbGUucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdNdXRlJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNdXRlVG9nZ2xlJywgTXV0ZVRvZ2dsZSk7XG5cbi8qKlxuICogQGZpbGUgdm9sdW1lLWNvbnRyb2wuanNcbiAqL1xuLy8gUmVxdWlyZWQgY2hpbGRyZW5cbi8qKlxuICogQSBDb21wb25lbnQgdG8gY29udGFpbiB0aGUgTXV0ZVRvZ2dsZSBhbmQgVm9sdW1lQ29udHJvbCBzbyB0aGF0XG4gKiB0aGV5IGNhbiB3b3JrIHRvZ2V0aGVyLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBWb2x1bWVQYW5lbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFZvbHVtZVBhbmVsLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFZvbHVtZVBhbmVsKHBsYXllcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVQYW5lbCk7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5saW5lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucy5pbmxpbmUgPSBvcHRpb25zLmlubGluZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5pbmxpbmUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHBhc3MgdGhlIGlubGluZSBvcHRpb24gZG93biB0byB0aGUgVm9sdW1lQ29udHJvbCBhcyB2ZXJ0aWNhbCBpZlxuICAgIC8vIHRoZSBWb2x1bWVDb250cm9sIGlzIG9uLlxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy52b2x1bWVDb250cm9sID09PSAndW5kZWZpbmVkJyB8fCBpc1BsYWluKG9wdGlvbnMudm9sdW1lQ29udHJvbCkpIHtcbiAgICAgIG9wdGlvbnMudm9sdW1lQ29udHJvbCA9IG9wdGlvbnMudm9sdW1lQ29udHJvbCB8fCB7fTtcbiAgICAgIG9wdGlvbnMudm9sdW1lQ29udHJvbC52ZXJ0aWNhbCA9ICFvcHRpb25zLmlubGluZTtcbiAgICB9XG5cbiAgICAvLyBoaWRlIHRoaXMgY29udHJvbCBpZiB2b2x1bWUgc3VwcG9ydCBpcyBtaXNzaW5nXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBjaGVja1ZvbHVtZVN1cHBvcnQoX3RoaXMsIHBsYXllcik7XG5cbiAgICAvLyB3aGlsZSB0aGUgc2xpZGVyIGlzIGFjdGl2ZSAodGhlIG1vdXNlIGhhcyBiZWVuIHByZXNzZWQgZG93biBhbmRcbiAgICAvLyBpcyBkcmFnZ2luZykgb3IgaW4gZm9jdXMgd2UgZG8gbm90IHdhbnQgdG8gaGlkZSB0aGUgVm9sdW1lQmFyXG4gICAgX3RoaXMub24oX3RoaXMudm9sdW1lQ29udHJvbCwgWydzbGlkZXJhY3RpdmUnXSwgX3RoaXMuc2xpZGVyQWN0aXZlXyk7XG4gICAgX3RoaXMub24oX3RoaXMubXV0ZVRvZ2dsZSwgJ2ZvY3VzJywgX3RoaXMuc2xpZGVyQWN0aXZlXyk7XG5cbiAgICBfdGhpcy5vbihfdGhpcy52b2x1bWVDb250cm9sLCBbJ3NsaWRlcmluYWN0aXZlJ10sIF90aGlzLnNsaWRlckluYWN0aXZlXyk7XG4gICAgX3RoaXMub24oX3RoaXMubXV0ZVRvZ2dsZSwgJ2JsdXInLCBfdGhpcy5zbGlkZXJJbmFjdGl2ZV8pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdmpzLXNsaWRlci1hY3RpdmUgY2xhc3MgdG8gdGhlIFZvbHVtZVBhbmVsXG4gICAqXG4gICAqIEBsaXN0ZW5zIFZvbHVtZUNvbnRyb2wjc2xpZGVyYWN0aXZlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVm9sdW1lUGFuZWwucHJvdG90eXBlLnNsaWRlckFjdGl2ZV8gPSBmdW5jdGlvbiBzbGlkZXJBY3RpdmVfKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdmpzLXNsaWRlci1hY3RpdmUgY2xhc3MgdG8gdGhlIFZvbHVtZVBhbmVsXG4gICAqXG4gICAqIEBsaXN0ZW5zIFZvbHVtZUNvbnRyb2wjc2xpZGVyaW5hY3RpdmVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBWb2x1bWVQYW5lbC5wcm90b3R5cGUuc2xpZGVySW5hY3RpdmVfID0gZnVuY3Rpb24gc2xpZGVySW5hY3RpdmVfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVm9sdW1lUGFuZWwucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS1wYW5lbC1ob3Jpem9udGFsJztcblxuICAgIGlmICghdGhpcy5vcHRpb25zXy5pbmxpbmUpIHtcbiAgICAgIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS1wYW5lbC12ZXJ0aWNhbCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtcGFuZWwgdmpzLWNvbnRyb2wgJyArIG9yaWVudGF0aW9uQ2xhc3NcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lUGFuZWw7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYFZvbHVtZUNvbnRyb2xgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Wb2x1bWVQYW5lbC5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ211dGVUb2dnbGUnLCAndm9sdW1lQ29udHJvbCddXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZVBhbmVsJywgVm9sdW1lUGFuZWwpO1xuXG4vKipcbiAqIEBmaWxlIG1lbnUuanNcbiAqL1xuLyoqXG4gKiBUaGUgTWVudSBjb21wb25lbnQgaXMgdXNlZCB0byBidWlsZCBwb3B1cCBtZW51cywgaW5jbHVkaW5nIHN1YnRpdGxlIGFuZFxuICogY2FwdGlvbnMgc2VsZWN0aW9uIG1lbnVzLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBNZW51ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTWVudSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICB0aGUgcGxheWVyIHRoYXQgdGhpcyBjb21wb25lbnQgc2hvdWxkIGF0dGFjaCB0b1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIE1lbnUocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBfdGhpcy5tZW51QnV0dG9uXyA9IG9wdGlvbnMubWVudUJ1dHRvbjtcbiAgICB9XG5cbiAgICBfdGhpcy5mb2N1c2VkQ2hpbGRfID0gLTE7XG5cbiAgICBfdGhpcy5vbigna2V5ZG93bicsIF90aGlzLmhhbmRsZUtleVByZXNzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEge0BsaW5rIE1lbnVJdGVtfSB0byB0aGUgbWVudS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBjb21wb25lbnRcbiAgICogICAgICAgIFRoZSBuYW1lIG9yIGluc3RhbmNlIG9mIHRoZSBgTWVudUl0ZW1gIHRvIGFkZC5cbiAgICpcbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24gYWRkSXRlbShjb21wb25lbnQpIHtcbiAgICB0aGlzLmFkZENoaWxkKGNvbXBvbmVudCk7XG4gICAgY29tcG9uZW50Lm9uKCdjbGljaycsIGJpbmQodGhpcywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyBVbnByZXNzIHRoZSBhc3NvY2lhdGVkIE1lbnVCdXR0b24sIGFuZCBtb3ZlIGZvY3VzIGJhY2sgdG8gaXRcbiAgICAgIGlmICh0aGlzLm1lbnVCdXR0b25fKSB7XG4gICAgICAgIHRoaXMubWVudUJ1dHRvbl8udW5wcmVzc0J1dHRvbigpO1xuXG4gICAgICAgIC8vIGRvbid0IGZvY3VzIG1lbnUgYnV0dG9uIGlmIGl0ZW0gaXMgYSBjYXB0aW9uIHNldHRpbmdzIGl0ZW1cbiAgICAgICAgLy8gYmVjYXVzZSBmb2N1cyB3aWxsIG1vdmUgZWxzZXdoZXJlIGFuZCBpdCBsb2dzIGFuIGVycm9yIG9uIElFOFxuICAgICAgICBpZiAoY29tcG9uZW50Lm5hbWUoKSAhPT0gJ0NhcHRpb25TZXR0aW5nc01lbnVJdGVtJykge1xuICAgICAgICAgIHRoaXMubWVudUJ1dHRvbl8uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgTWVudWBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIHRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWRcbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBjb250ZW50RWxUeXBlID0gdGhpcy5vcHRpb25zXy5jb250ZW50RWxUeXBlIHx8ICd1bCc7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbChjb250ZW50RWxUeXBlLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbWVudS1jb250ZW50J1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfLnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51Jyk7XG5cbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBhcHBlbmQ6IHRoaXMuY29udGVudEVsXyxcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51J1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcblxuICAgIC8vIFByZXZlbnQgY2xpY2tzIGZyb20gYnViYmxpbmcgdXAuIE5lZWRlZCBmb3IgTWVudSBCdXR0b25zLFxuICAgIC8vIHdoZXJlIGEgY2xpY2sgb24gdGhlIHBhcmVudCBpcyBzaWduaWZpY2FudFxuICAgIG9uKGVsLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgYGtleWRvd25gIGV2ZW50IG9uIHRoaXMgbWVudS4gVGhpcyBsaXN0ZW5lciBpcyBhZGRlZCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBBIGBrZXlkb3duYCBldmVudCB0aGF0IGhhcHBlbmVkIG9uIHRoZSBtZW51LlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuICAgIC8vIExlZnQgYW5kIERvd24gQXJyb3dzXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzNyB8fCBldmVudC53aGljaCA9PT0gNDApIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnN0ZXBGb3J3YXJkKCk7XG5cbiAgICAgIC8vIFVwIGFuZCBSaWdodCBBcnJvd3NcbiAgICB9IGVsc2UgaWYgKGV2ZW50LndoaWNoID09PSAzOCB8fCBldmVudC53aGljaCA9PT0gMzkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnN0ZXBCYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRvIG5leHQgKGxvd2VyKSBtZW51IGl0ZW0gZm9yIGtleWJvYXJkIHVzZXJzLlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XG4gICAgdmFyIHN0ZXBDaGlsZCA9IDA7XG5cbiAgICBpZiAodGhpcy5mb2N1c2VkQ2hpbGRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0ZXBDaGlsZCA9IHRoaXMuZm9jdXNlZENoaWxkXyArIDE7XG4gICAgfVxuICAgIHRoaXMuZm9jdXMoc3RlcENoaWxkKTtcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSB0byBwcmV2aW91cyAoaGlnaGVyKSBtZW51IGl0ZW0gZm9yIGtleWJvYXJkIHVzZXJzLlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLnN0ZXBCYWNrID0gZnVuY3Rpb24gc3RlcEJhY2soKSB7XG4gICAgdmFyIHN0ZXBDaGlsZCA9IDA7XG5cbiAgICBpZiAodGhpcy5mb2N1c2VkQ2hpbGRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0ZXBDaGlsZCA9IHRoaXMuZm9jdXNlZENoaWxkXyAtIDE7XG4gICAgfVxuICAgIHRoaXMuZm9jdXMoc3RlcENoaWxkKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGZvY3VzIG9uIGEge0BsaW5rIE1lbnVJdGVtfSBpbiB0aGUgYE1lbnVgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtpdGVtPTBdXG4gICAqICAgICAgICBJbmRleCBvZiBjaGlsZCBpdGVtIHNldCBmb2N1cyBvbi5cbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHZhciBpdGVtID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpLnNsaWNlKCk7XG4gICAgdmFyIGhhdmVUaXRsZSA9IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlblswXS5jbGFzc05hbWUgJiYgL3Zqcy1tZW51LXRpdGxlLy50ZXN0KGNoaWxkcmVuWzBdLmNsYXNzTmFtZSk7XG5cbiAgICBpZiAoaGF2ZVRpdGxlKSB7XG4gICAgICBjaGlsZHJlbi5zaGlmdCgpO1xuICAgIH1cblxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoaXRlbSA8IDApIHtcbiAgICAgICAgaXRlbSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0gPj0gY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGl0ZW0gPSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZvY3VzZWRDaGlsZF8gPSBpdGVtO1xuXG4gICAgICBjaGlsZHJlbltpdGVtXS5lbF8uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1lbnU7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVudScsIE1lbnUpO1xuXG4vKipcbiAqIEBmaWxlIG1lbnUtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogQSBgTWVudUJ1dHRvbmAgY2xhc3MgZm9yIGFueSBwb3B1cCB7QGxpbmsgTWVudX0uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIE1lbnVCdXR0b24gPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhNZW51QnV0dG9uLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIE1lbnVCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbnVCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5tZW51QnV0dG9uXyA9IG5ldyBCdXR0b24ocGxheWVyLCBvcHRpb25zKTtcblxuICAgIF90aGlzLm1lbnVCdXR0b25fLmNvbnRyb2xUZXh0KF90aGlzLmNvbnRyb2xUZXh0Xyk7XG4gICAgX3RoaXMubWVudUJ1dHRvbl8uZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsICd0cnVlJyk7XG5cbiAgICAvLyBBZGQgYnVpbGRDU1NDbGFzcyB2YWx1ZXMgdG8gdGhlIGJ1dHRvbiwgbm90IHRoZSB3cmFwcGVyXG4gICAgdmFyIGJ1dHRvbkNsYXNzID0gQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzKCk7XG5cbiAgICBfdGhpcy5tZW51QnV0dG9uXy5lbF8uY2xhc3NOYW1lID0gX3RoaXMuYnVpbGRDU1NDbGFzcygpICsgJyAnICsgYnV0dG9uQ2xhc3M7XG4gICAgX3RoaXMubWVudUJ1dHRvbl8ucmVtb3ZlQ2xhc3MoJ3Zqcy1jb250cm9sJyk7XG5cbiAgICBfdGhpcy5hZGRDaGlsZChfdGhpcy5tZW51QnV0dG9uXyk7XG5cbiAgICBfdGhpcy51cGRhdGUoKTtcblxuICAgIF90aGlzLmVuYWJsZWRfID0gdHJ1ZTtcblxuICAgIF90aGlzLm9uKF90aGlzLm1lbnVCdXR0b25fLCAndGFwJywgX3RoaXMuaGFuZGxlQ2xpY2spO1xuICAgIF90aGlzLm9uKF90aGlzLm1lbnVCdXR0b25fLCAnY2xpY2snLCBfdGhpcy5oYW5kbGVDbGljayk7XG4gICAgX3RoaXMub24oX3RoaXMubWVudUJ1dHRvbl8sICdmb2N1cycsIF90aGlzLmhhbmRsZUZvY3VzKTtcbiAgICBfdGhpcy5vbihfdGhpcy5tZW51QnV0dG9uXywgJ2JsdXInLCBfdGhpcy5oYW5kbGVCbHVyKTtcblxuICAgIF90aGlzLm9uKCdrZXlkb3duJywgX3RoaXMuaGFuZGxlU3VibWVudUtleVByZXNzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBtZW51IGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIGl0cyBpdGVtcy5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIG1lbnUgPSB0aGlzLmNyZWF0ZU1lbnUoKTtcblxuICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5tZW51KTtcbiAgICB9XG5cbiAgICB0aGlzLm1lbnUgPSBtZW51O1xuICAgIHRoaXMuYWRkQ2hpbGQobWVudSk7XG5cbiAgICAvKipcbiAgICAgKiBUcmFjayB0aGUgc3RhdGUgb2YgdGhlIG1lbnUgYnV0dG9uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYnV0dG9uUHJlc3NlZF8gPSBmYWxzZTtcbiAgICB0aGlzLm1lbnVCdXR0b25fLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcblxuICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoIDw9IHRoaXMuaGlkZVRocmVzaG9sZF8pIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbWVudSBhbmQgYWRkIGFsbCBpdGVtcyB0byBpdC5cbiAgICpcbiAgICogQHJldHVybiB7TWVudX1cbiAgICogICAgICAgICBUaGUgY29uc3RydWN0ZWQgbWVudVxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmNyZWF0ZU1lbnUgPSBmdW5jdGlvbiBjcmVhdGVNZW51KCkge1xuICAgIHZhciBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXJfLCB7IG1lbnVCdXR0b246IHRoaXMgfSk7XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBtZW51IGlmIHRoZSBudW1iZXIgb2YgaXRlbXMgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoaXMgdGhyZXNob2xkLiBUaGlzIGRlZmF1bHRzXG4gICAgICogdG8gMCBhbmQgd2hlbmV2ZXIgd2UgYWRkIGl0ZW1zIHdoaWNoIGNhbiBiZSBoaWRkZW4gdG8gdGhlIG1lbnUgd2UnbGwgaW5jcmVtZW50IGl0LiBXZSBsaXN0XG4gICAgICogaXQgaGVyZSBiZWNhdXNlIGV2ZXJ5IHRpbWUgd2UgcnVuIGBjcmVhdGVNZW51YCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gPSAwO1xuXG4gICAgLy8gQWRkIGEgdGl0bGUgbGlzdCBpdGVtIHRvIHRoZSB0b3BcbiAgICBpZiAodGhpcy5vcHRpb25zXy50aXRsZSkge1xuICAgICAgdmFyIHRpdGxlID0gY3JlYXRlRWwoJ2xpJywge1xuICAgICAgICBjbGFzc05hbWU6ICd2anMtbWVudS10aXRsZScsXG4gICAgICAgIGlubmVySFRNTDogdG9UaXRsZUNhc2UodGhpcy5vcHRpb25zXy50aXRsZSksXG4gICAgICAgIHRhYkluZGV4OiAtMVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gKz0gMTtcblxuICAgICAgbWVudS5jaGlsZHJlbl8udW5zaGlmdCh0aXRsZSk7XG4gICAgICBwcmVwZW5kVG8odGl0bGUsIG1lbnUuY29udGVudEVsKCkpO1xuICAgIH1cblxuICAgIHRoaXMuaXRlbXMgPSB0aGlzLmNyZWF0ZUl0ZW1zKCk7XG5cbiAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgLy8gQWRkIG1lbnUgaXRlbXMgdG8gdGhlIG1lbnVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtZW51LmFkZEl0ZW0odGhpcy5pdGVtc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbGlzdCBvZiBtZW51IGl0ZW1zLiBTcGVjaWZpYyB0byBlYWNoIHN1YmNsYXNzLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge307XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYE1lbnVCdXR0b25zYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkV3JhcHBlckNTU0NsYXNzKClcbiAgICB9LCB7fSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsbG93IHN1YiBjb21wb25lbnRzIHRvIHN0YWNrIENTUyBjbGFzcyBuYW1lcyBmb3IgdGhlIHdyYXBwZXIgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGNvbnN0cnVjdGVkIHdyYXBwZXIgRE9NIGBjbGFzc05hbWVgXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICB2YXIgbWVudUJ1dHRvbkNsYXNzID0gJ3Zqcy1tZW51LWJ1dHRvbic7XG5cbiAgICAvLyBJZiB0aGUgaW5saW5lIG9wdGlvbiBpcyBwYXNzZWQsIHdlIHdhbnQgdG8gdXNlIGRpZmZlcmVudCBzdHlsZXMgYWx0b2dldGhlci5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5pbmxpbmUgPT09IHRydWUpIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLWlubGluZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLXBvcHVwJztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBGaXggdGhlIENTUyBzbyB0aGF0IHRoaXMgaXNuJ3QgbmVjZXNzYXJ5XG4gICAgdmFyIGJ1dHRvbkNsYXNzID0gQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzKCk7XG5cbiAgICByZXR1cm4gJ3Zqcy1tZW51LWJ1dHRvbiAnICsgbWVudUJ1dHRvbkNsYXNzICsgJyAnICsgYnV0dG9uQ2xhc3MgKyAnICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICB2YXIgbWVudUJ1dHRvbkNsYXNzID0gJ3Zqcy1tZW51LWJ1dHRvbic7XG5cbiAgICAvLyBJZiB0aGUgaW5saW5lIG9wdGlvbiBpcyBwYXNzZWQsIHdlIHdhbnQgdG8gdXNlIGRpZmZlcmVudCBzdHlsZXMgYWx0b2dldGhlci5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5pbmxpbmUgPT09IHRydWUpIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLWlubGluZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLXBvcHVwJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ3Zqcy1tZW51LWJ1dHRvbiAnICsgbWVudUJ1dHRvbkNsYXNzICsgJyAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBsb2NhbGl6ZWQgY29udHJvbCB0ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiA+IE5PVEU6IFRoaXMgd2lsbCBjb21lIGZyb20gdGhlIGludGVybmFsIGBtZW51QnV0dG9uX2AgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0XVxuICAgKiAgICAgICAgQ29udHJvbCB0ZXh0IGZvciBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtlbD10aGlzLm1lbnVCdXR0b25fLmVsKCldXG4gICAqICAgICAgICBFbGVtZW50IHRvIHNldCB0aGUgdGl0bGUgb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAtIFRoZSBjb250cm9sIHRleHQgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHQgPSBmdW5jdGlvbiBjb250cm9sVGV4dCh0ZXh0KSB7XG4gICAgdmFyIGVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLm1lbnVCdXR0b25fLmVsKCk7XG5cbiAgICByZXR1cm4gdGhpcy5tZW51QnV0dG9uXy5jb250cm9sVGV4dCh0ZXh0LCBlbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGNsaWNrIG9uIGEgYE1lbnVCdXR0b25gLlxuICAgKiBTZWUge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVDbGlja30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIC8vIFdoZW4geW91IGNsaWNrIHRoZSBidXR0b24gaXQgYWRkcyBmb2N1cywgd2hpY2ggd2lsbCBzaG93IHRoZSBtZW51LlxuICAgIC8vIFNvIHdlJ2xsIHJlbW92ZSBmb2N1cyB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGJ1dHRvbi4gRm9jdXMgaXMgbmVlZGVkXG4gICAgLy8gZm9yIHRhYiBuYXZpZ2F0aW9uLlxuXG4gICAgdGhpcy5vbmUodGhpcy5tZW51LmNvbnRlbnRFbCgpLCAnbW91c2VsZWF2ZScsIGJpbmQodGhpcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgdGhpcy5lbF8uYmx1cigpO1xuICAgIH0pKTtcbiAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJlc3NCdXR0b24oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZm9jdXMgdG8gdGhlIGFjdHVhbCBidXR0b24sIG5vdCB0byB0aGlzIGVsZW1lbnRcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHRoaXMubWVudUJ1dHRvbl8uZm9jdXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBmb2N1cyBmcm9tIHRoZSBhY3R1YWwgYnV0dG9uLCBub3QgdGhpcyBlbGVtZW50XG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgdGhpcy5tZW51QnV0dG9uXy5ibHVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhIGBNZW51QnV0dG9uYCBnYWlucyBmb2N1cyB2aWEgYSBgZm9jdXNgIGV2ZW50LlxuICAgKiBUdXJucyBvbiBsaXN0ZW5pbmcgZm9yIGBrZXlkb3duYCBldmVudHMuIFdoZW4gdGhleSBoYXBwZW4gaXRcbiAgICogY2FsbHMgYHRoaXMuaGFuZGxlS2V5UHJlc3NgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBmb2N1c2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGZvY3VzXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cygpIHtcbiAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBgTWVudUJ1dHRvbmAgbG9zZXMgZm9jdXMuIFR1cm5zIG9mZiB0aGUgbGlzdGVuZXIgZm9yXG4gICAqIGBrZXlkb3duYCBldmVudHMuIFdoaWNoIFN0b3BzIGB0aGlzLmhhbmRsZUtleVByZXNzYCBmcm9tIGdldHRpbmcgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBibHVyYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgYmx1clxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICAgIG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRhYiwgZXNjYXBlLCBkb3duIGFycm93LCBhbmQgdXAgYXJyb3cga2V5cyBmb3IgYE1lbnVCdXR0b25gLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVLZXlQcmVzc30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBFc2NhcGUgKDI3KSBrZXkgb3IgVGFiICg5KSBrZXkgdW5wcmVzcyB0aGUgJ2J1dHRvbidcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDI3IHx8IGV2ZW50LndoaWNoID09PSA5KSB7XG4gICAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHByZXZlbnREZWZhdWx0IGZvciBUYWIga2V5IC0gd2Ugc3RpbGwgd2FudCB0byBsb3NlIGZvY3VzXG4gICAgICBpZiAoZXZlbnQud2hpY2ggIT09IDkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gU2V0IGZvY3VzIGJhY2sgdG8gdGhlIG1lbnUgYnV0dG9uJ3MgYnV0dG9uXG4gICAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLmZvY3VzKCk7XG4gICAgICB9XG4gICAgICAvLyBVcCAoMzgpIGtleSBvciBEb3duICg0MCkga2V5IHByZXNzIHRoZSAnYnV0dG9uJ1xuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4IHx8IGV2ZW50LndoaWNoID09PSA0MCkge1xuICAgICAgaWYgKCF0aGlzLmJ1dHRvblByZXNzZWRfKSB7XG4gICAgICAgIHRoaXMucHJlc3NCdXR0b24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBrZXlkb3duYCBldmVudCBvbiBhIHN1Yi1tZW51LiBUaGUgbGlzdGVuZXIgZm9yIHRoaXMgaXMgYWRkZWQgaW5cbiAgICogdGhlIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgS2V5IHByZXNzIGV2ZW50XG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVTdWJtZW51S2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVTdWJtZW51S2V5UHJlc3MoZXZlbnQpIHtcblxuICAgIC8vIEVzY2FwZSAoMjcpIGtleSBvciBUYWIgKDkpIGtleSB1bnByZXNzIHRoZSAnYnV0dG9uJ1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMjcgfHwgZXZlbnQud2hpY2ggPT09IDkpIHtcbiAgICAgIGlmICh0aGlzLmJ1dHRvblByZXNzZWRfKSB7XG4gICAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcHJldmVudERlZmF1bHQgZm9yIFRhYiBrZXkgLSB3ZSBzdGlsbCB3YW50IHRvIGxvc2UgZm9jdXNcbiAgICAgIGlmIChldmVudC53aGljaCAhPT0gOSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBTZXQgZm9jdXMgYmFjayB0byB0aGUgbWVudSBidXR0b24ncyBidXR0b25cbiAgICAgICAgdGhpcy5tZW51QnV0dG9uXy5lbF8uZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1dCB0aGUgY3VycmVudCBgTWVudUJ1dHRvbmAgaW50byBhIHByZXNzZWQgc3RhdGUuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUucHJlc3NCdXR0b24gPSBmdW5jdGlvbiBwcmVzc0J1dHRvbigpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkXykge1xuICAgICAgdGhpcy5idXR0b25QcmVzc2VkXyA9IHRydWU7XG4gICAgICB0aGlzLm1lbnUubG9ja1Nob3dpbmcoKTtcbiAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG4gICAgICAvLyBzZXQgdGhlIGZvY3VzIGludG8gdGhlIHN1Ym1lbnVcbiAgICAgIHRoaXMubWVudS5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGFrZSB0aGUgY3VycmVudCBgTWVudUJ1dHRvbmAgb3V0IG9mIGEgcHJlc3NlZCBzdGF0ZS5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS51bnByZXNzQnV0dG9uID0gZnVuY3Rpb24gdW5wcmVzc0J1dHRvbigpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkXykge1xuICAgICAgdGhpcy5idXR0b25QcmVzc2VkXyA9IGZhbHNlO1xuICAgICAgdGhpcy5tZW51LnVubG9ja1Nob3dpbmcoKTtcbiAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZSB0aGUgYE1lbnVCdXR0b25gLiBEb24ndCBhbGxvdyBpdCB0byBiZSBjbGlja2VkLlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuXG4gICAgdGhpcy5lbmFibGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1kaXNhYmxlZCcpO1xuXG4gICAgdGhpcy5tZW51QnV0dG9uXy5kaXNhYmxlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGUgYE1lbnVCdXR0b25gLiBBbGxvdyBpdCB0byBiZSBjbGlja2VkLlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWRfID0gdHJ1ZTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZGlzYWJsZWQnKTtcblxuICAgIHRoaXMubWVudUJ1dHRvbl8uZW5hYmxlKCk7XG4gIH07XG5cbiAgcmV0dXJuIE1lbnVCdXR0b247XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVudUJ1dHRvbicsIE1lbnVCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHRyYWNrLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBidXR0b25zIHRoYXQgdG9nZ2xlIHNwZWNpZmljICB0cmFjayB0eXBlcyAoZS5nLiBzdWJ0aXRsZXMpLlxuICpcbiAqIEBleHRlbmRzIE1lbnVCdXR0b25cbiAqL1xuXG52YXIgVHJhY2tCdXR0b24gPSBmdW5jdGlvbiAoX01lbnVCdXR0b24pIHtcbiAgaW5oZXJpdHMoVHJhY2tCdXR0b24sIF9NZW51QnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFRyYWNrQnV0dG9uKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNrQnV0dG9uKTtcblxuICAgIHZhciB0cmFja3MgPSBvcHRpb25zLnRyYWNrcztcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIGlmIChfdGhpcy5pdGVtcy5sZW5ndGggPD0gMSkge1xuICAgICAgX3RoaXMuaGlkZSgpO1xuICAgIH1cblxuICAgIGlmICghdHJhY2tzKSB7XG4gICAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUhhbmRsZXIgPSBiaW5kKF90aGlzLCBfdGhpcy51cGRhdGUpO1xuXG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgX3RoaXMucGxheWVyXy5vbigncmVhZHknLCB1cGRhdGVIYW5kbGVyKTtcblxuICAgIF90aGlzLnBsYXllcl8ub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHVwZGF0ZUhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBUcmFja0J1dHRvbjtcbn0oTWVudUJ1dHRvbik7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVHJhY2tCdXR0b24nLCBUcmFja0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogVGhlIGNvbXBvbmVudCBmb3IgYSBtZW51IGl0ZW0uIGA8bGk+YFxuICpcbiAqIEBleHRlbmRzIENsaWNrYWJsZUNvbXBvbmVudFxuICovXG5cbnZhciBNZW51SXRlbSA9IGZ1bmN0aW9uIChfQ2xpY2thYmxlQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1lbnVJdGVtLCBfQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNZW51SXRlbSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9DbGlja2FibGVDb21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnNlbGVjdGFibGUgPSBvcHRpb25zLnNlbGVjdGFibGU7XG5cbiAgICBfdGhpcy5zZWxlY3RlZChvcHRpb25zLnNlbGVjdGVkKTtcblxuICAgIGlmIChfdGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAvLyBUT0RPOiBNYXkgbmVlZCB0byBiZSBlaXRoZXIgbWVudWl0ZW1jaGVja2JveCBvciBtZW51aXRlbXJhZGlvLFxuICAgICAgLy8gICAgICAgYW5kIG1heSBuZWVkIGxvZ2ljYWwgZ3JvdXBpbmcgb2YgbWVudSBpdGVtcy5cbiAgICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbWVudWl0ZW1jaGVja2JveCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ21lbnVpdGVtJyk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBNZW51SXRlbSdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT1saV1cbiAgICogICAgICAgIEVsZW1lbnQncyBub2RlIHR5cGUsIG5vdCBhY3R1YWxseSB1c2VkLCBhbHdheXMgc2V0IHRvIGBsaWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRycz17fV1cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKHR5cGUsIHByb3BzLCBhdHRycykge1xuICAgIC8vIFRoZSBjb250cm9sIGlzIHRleHR1YWwsIG5vdCBqdXN0IGFuIGljb25cbiAgICB0aGlzLm5vbkljb25Db250cm9sID0gdHJ1ZTtcblxuICAgIHJldHVybiBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdsaScsIGFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbWVudS1pdGVtJyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLW1lbnUtaXRlbS10ZXh0XCI+JyArIHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5sYWJlbCkgKyAnPC9zcGFuPicsXG4gICAgICB0YWJJbmRleDogLTFcbiAgICB9LCBwcm9wcyksIGF0dHJzKTtcbiAgfTtcblxuICAvKipcbiAgICogQW55IGNsaWNrIG9uIGEgYE1lbnVJdGVtYCBwdXRzIGludCBpbnRvIHRoZSBzZWxlY3RlZCBzdGF0ZS5cbiAgICogU2VlIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlQ2xpY2t9IGZvciBpbnN0YW5jZXMgd2hlcmUgdGhpcyBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZCh0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzdGF0ZSBmb3IgdGhpcyBtZW51IGl0ZW0gYXMgc2VsZWN0ZWQgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqICAgICAgICBpZiB0aGUgbWVudSBpdGVtIGlzIHNlbGVjdGVkIG9yIG5vdFxuICAgKi9cblxuXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5zZWxlY3RlZCA9IGZ1bmN0aW9uIHNlbGVjdGVkKF9zZWxlY3RlZCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgIGlmIChfc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNlbGVjdGVkJyk7XG4gICAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJywgJ3RydWUnKTtcbiAgICAgICAgLy8gYXJpYS1jaGVja2VkIGlzbid0IGZ1bGx5IHN1cHBvcnRlZCBieSBicm93c2Vycy9zY3JlZW4gcmVhZGVycyxcbiAgICAgICAgLy8gc28gaW5kaWNhdGUgc2VsZWN0ZWQgc3RhdGUgdG8gc2NyZWVuIHJlYWRlciBpbiB0aGUgY29udHJvbCB0ZXh0LlxuICAgICAgICB0aGlzLmNvbnRyb2xUZXh0KCcsIHNlbGVjdGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2VsZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgLy8gSW5kaWNhdGUgdW4tc2VsZWN0ZWQgc3RhdGUgdG8gc2NyZWVuIHJlYWRlclxuICAgICAgICAvLyBOb3RlIHRoYXQgYSBzcGFjZSBjbGVhcnMgb3V0IHRoZSBzZWxlY3RlZCBzdGF0ZSB0ZXh0XG4gICAgICAgIHRoaXMuY29udHJvbFRleHQoJyAnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1lbnVJdGVtO1xufShDbGlja2FibGVDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01lbnVJdGVtJywgTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogVGhlIHNwZWNpZmljIG1lbnUgaXRlbSB0eXBlIGZvciBzZWxlY3RpbmcgYSBsYW5ndWFnZSB3aXRoaW4gYSB0ZXh0IHRyYWNrIGtpbmRcbiAqXG4gKiBAZXh0ZW5kcyBNZW51SXRlbVxuICovXG5cbnZhciBUZXh0VHJhY2tNZW51SXRlbSA9IGZ1bmN0aW9uIChfTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoVGV4dFRyYWNrTWVudUl0ZW0sIF9NZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgICB2YXIgdHJhY2sgPSBvcHRpb25zLnRyYWNrO1xuICAgIHZhciB0cmFja3MgPSBwbGF5ZXIudGV4dFRyYWNrcygpO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9ucy5sYWJlbCA9IHRyYWNrLmxhYmVsIHx8IHRyYWNrLmxhbmd1YWdlIHx8ICdVbmtub3duJztcbiAgICBvcHRpb25zLnNlbGVjdGVkID0gdHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnRyYWNrID0gdHJhY2s7XG4gICAgdmFyIGNoYW5nZUhhbmRsZXIgPSBiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UpO1xuICAgIHZhciBzZWxlY3RlZExhbmd1YWdlQ2hhbmdlSGFuZGxlciA9IGJpbmQoX3RoaXMsIF90aGlzLmhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UpO1xuXG4gICAgcGxheWVyLm9uKFsnbG9hZHN0YXJ0JywgJ3RleHR0cmFja2NoYW5nZSddLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVkbGFuZ3VhZ2VjaGFuZ2UnLCBzZWxlY3RlZExhbmd1YWdlQ2hhbmdlSGFuZGxlcik7XG4gICAgX3RoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0ZWRsYW5ndWFnZWNoYW5nZScsIHNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2VIYW5kbGVyKTtcbiAgICB9KTtcblxuICAgIC8vIGlPUzcgZG9lc24ndCBkaXNwYXRjaCBjaGFuZ2UgZXZlbnRzIHRvIFRleHRUcmFja0xpc3RzIHdoZW4gYW5cbiAgICAvLyBhc3NvY2lhdGVkIHRyYWNrJ3MgbW9kZSBjaGFuZ2VzLiBXaXRob3V0IHNvbWV0aGluZyBsaWtlXG4gICAgLy8gT2JqZWN0Lm9ic2VydmUoKSAoYWxzbyBub3QgcHJlc2VudCBvbiBpT1M3KSwgaXQncyBub3RcbiAgICAvLyBwb3NzaWJsZSB0byBkZXRlY3QgY2hhbmdlcyB0byB0aGUgbW9kZSBhdHRyaWJ1dGUgYW5kIHBvbHlmaWxsXG4gICAgLy8gdGhlIGNoYW5nZSBldmVudC4gQXMgYSBwb29yIHN1YnN0aXR1dGUsIHdlIG1hbnVhbGx5IGRpc3BhdGNoXG4gICAgLy8gY2hhbmdlIGV2ZW50cyB3aGVuZXZlciB0aGUgY29udHJvbHMgbW9kaWZ5IHRoZSBtb2RlLlxuICAgIGlmICh0cmFja3Mub25jaGFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGV2ZW50ID0gdm9pZCAwO1xuXG4gICAgICBfdGhpcy5vbihbJ3RhcCcsICdjbGljayddLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKHdpbmRvdy5FdmVudCkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgLy8gQW5kcm9pZCAyLjMgdGhyb3dzIGFuIElsbGVnYWwgQ29uc3RydWN0b3IgZXJyb3IgZm9yIHdpbmRvdy5FdmVudFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldmVudCA9IG5ldyB3aW5kb3cuRXZlbnQoJ2NoYW5nZScpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgIGV2ZW50LmluaXRFdmVudCgnY2hhbmdlJywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFja3MuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgVGV4dFRyYWNrTWVudUl0ZW1gIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICB2YXIga2luZCA9IHRoaXMudHJhY2sua2luZDtcbiAgICB2YXIga2luZHMgPSB0aGlzLnRyYWNrLmtpbmRzO1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKCFraW5kcykge1xuICAgICAga2luZHMgPSBba2luZF07XG4gICAgfVxuXG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIGlmICghdHJhY2tzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRyYWNrID09PSB0aGlzLnRyYWNrICYmIGtpbmRzLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSkge1xuICAgICAgICBpZiAodHJhY2subW9kZSAhPT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgICAgdHJhY2subW9kZSA9ICdzaG93aW5nJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFjay5tb2RlICE9PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgIHRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRleHQgdHJhY2sgbGlzdCBjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrTGlzdCNjaGFuZ2VcbiAgICovXG5cblxuICBUZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlVHJhY2tzQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlVHJhY2tzQ2hhbmdlKGV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZCh0aGlzLnRyYWNrLm1vZGUgPT09ICdzaG93aW5nJyk7XG4gIH07XG5cbiAgVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVTZWxlY3RlZExhbmd1YWdlQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMudHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICB2YXIgc2VsZWN0ZWRMYW5ndWFnZSA9IHRoaXMucGxheWVyXy5jYWNoZV8uc2VsZWN0ZWRMYW5ndWFnZTtcblxuICAgICAgLy8gRG9uJ3QgcmVwbGFjZSB0aGUga2luZCBvZiB0cmFjayBhY3Jvc3MgdGhlIHNhbWUgbGFuZ3VhZ2VcbiAgICAgIGlmIChzZWxlY3RlZExhbmd1YWdlICYmIHNlbGVjdGVkTGFuZ3VhZ2UuZW5hYmxlZCAmJiBzZWxlY3RlZExhbmd1YWdlLmxhbmd1YWdlID09PSB0aGlzLnRyYWNrLmxhbmd1YWdlICYmIHNlbGVjdGVkTGFuZ3VhZ2Uua2luZCAhPT0gdGhpcy50cmFjay5raW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wbGF5ZXJfLmNhY2hlXy5zZWxlY3RlZExhbmd1YWdlID0ge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBsYW5ndWFnZTogdGhpcy50cmFjay5sYW5ndWFnZSxcbiAgICAgICAga2luZDogdGhpcy50cmFjay5raW5kXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrTWVudUl0ZW07XG59KE1lbnVJdGVtKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tNZW51SXRlbScsIFRleHRUcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBvZmYtdGV4dC10cmFjay1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBBIHNwZWNpYWwgbWVudSBpdGVtIGZvciB0dXJuaW5nIG9mIGEgc3BlY2lmaWMgdHlwZSBvZiB0ZXh0IHRyYWNrXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrTWVudUl0ZW1cbiAqL1xuXG52YXIgT2ZmVGV4dFRyYWNrTWVudUl0ZW0gPSBmdW5jdGlvbiAoX1RleHRUcmFja01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKE9mZlRleHRUcmFja01lbnVJdGVtLCBfVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gT2ZmVGV4dFRyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgT2ZmVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG4gICAgLy8gQ3JlYXRlIHBzZXVkbyB0cmFjayBpbmZvXG4gICAgLy8gUmVxdWlyZXMgb3B0aW9uc1sna2luZCddXG4gICAgb3B0aW9ucy50cmFjayA9IHtcbiAgICAgIHBsYXllcjogcGxheWVyLFxuICAgICAga2luZDogb3B0aW9ucy5raW5kLFxuICAgICAga2luZHM6IG9wdGlvbnMua2luZHMsXG4gICAgICAnZGVmYXVsdCc6IGZhbHNlLFxuICAgICAgbW9kZTogJ2Rpc2FibGVkJ1xuICAgIH07XG5cbiAgICBpZiAoIW9wdGlvbnMua2luZHMpIHtcbiAgICAgIG9wdGlvbnMua2luZHMgPSBbb3B0aW9ucy5raW5kXTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5sYWJlbCkge1xuICAgICAgb3B0aW9ucy50cmFjay5sYWJlbCA9IG9wdGlvbnMubGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMudHJhY2subGFiZWwgPSBvcHRpb25zLmtpbmRzLmpvaW4oJyBhbmQgJykgKyAnIG9mZic7XG4gICAgfVxuXG4gICAgLy8gTWVudUl0ZW0gaXMgc2VsZWN0YWJsZVxuICAgIG9wdGlvbnMuc2VsZWN0YWJsZSA9IHRydWU7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tNZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuc2VsZWN0ZWQodHJ1ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0ZXh0IHRyYWNrIGNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuXG4gICAqL1xuXG5cbiAgT2ZmVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcigpLnRleHRUcmFja3MoKTtcbiAgICB2YXIgc2VsZWN0ZWQgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0cmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmtpbmRzLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSAmJiB0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RlZChzZWxlY3RlZCk7XG4gIH07XG5cbiAgT2ZmVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVTZWxlY3RlZExhbmd1YWdlQ2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyKCkudGV4dFRyYWNrcygpO1xuICAgIHZhciBhbGxIaWRkZW4gPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0cmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmIChbJ2NhcHRpb25zJywgJ2Rlc2NyaXB0aW9ucycsICdzdWJ0aXRsZXMnXS5pbmRleE9mKHRyYWNrLmtpbmQpID4gLTEgJiYgdHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgIGFsbEhpZGRlbiA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWxsSGlkZGVuKSB7XG4gICAgICB0aGlzLnBsYXllcl8uY2FjaGVfLnNlbGVjdGVkTGFuZ3VhZ2UgPSB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gT2ZmVGV4dFRyYWNrTWVudUl0ZW07XG59KFRleHRUcmFja01lbnVJdGVtKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdPZmZUZXh0VHJhY2tNZW51SXRlbScsIE9mZlRleHRUcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBidXR0b25zIHRoYXQgdG9nZ2xlIHNwZWNpZmljIHRleHQgdHJhY2sgdHlwZXMgKGUuZy4gc3VidGl0bGVzKVxuICpcbiAqIEBleHRlbmRzIE1lbnVCdXR0b25cbiAqL1xuXG52YXIgVGV4dFRyYWNrQnV0dG9uID0gZnVuY3Rpb24gKF9UcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhUZXh0VHJhY2tCdXR0b24sIF9UcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFja0J1dHRvbik7XG5cbiAgICBvcHRpb25zLnRyYWNrcyA9IHBsYXllci50ZXh0VHJhY2tzKCk7XG5cbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtZW51IGl0ZW0gZm9yIGVhY2ggdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja01lbnVJdGVtW119IFtpdGVtcz1bXV1cbiAgICogICAgICAgIEV4aXN0aW5nIGFycmF5IG9mIGl0ZW1zIHRvIHVzZSBkdXJpbmcgY3JlYXRpb25cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBBcnJheSBvZiBtZW51IGl0ZW1zIHRoYXQgd2VyZSBjcmVhdGVkXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgdmFyIFRyYWNrTWVudUl0ZW0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFRleHRUcmFja01lbnVJdGVtO1xuXG5cbiAgICAvLyBMYWJlbCBpcyBhbiBvdmVyaWRlIGZvciB0aGUgW3RyYWNrXSBvZmYgbGFiZWxcbiAgICAvLyBVU2VkIHRvIGxvY2FsaXNlIGNhcHRpb25zL3N1YnRpdGxlc1xuICAgIHZhciBsYWJlbCA9IHZvaWQgMDtcblxuICAgIGlmICh0aGlzLmxhYmVsXykge1xuICAgICAgbGFiZWwgPSB0aGlzLmxhYmVsXyArICcgb2ZmJztcbiAgICB9XG4gICAgLy8gQWRkIGFuIE9GRiBtZW51IGl0ZW0gdG8gdHVybiBhbGwgdHJhY2tzIG9mZlxuICAgIGl0ZW1zLnB1c2gobmV3IE9mZlRleHRUcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywge1xuICAgICAga2luZHM6IHRoaXMua2luZHNfLFxuICAgICAga2luZDogdGhpcy5raW5kXyxcbiAgICAgIGxhYmVsOiBsYWJlbFxuICAgIH0pKTtcblxuICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gKz0gMTtcblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMua2luZHNfKSkge1xuICAgICAgdGhpcy5raW5kc18gPSBbdGhpcy5raW5kX107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgLy8gb25seSBhZGQgdHJhY2tzIHRoYXQgYXJlIG9mIGFuIGFwcHJvcHJpYXRlIGtpbmQgYW5kIGhhdmUgYSBsYWJlbFxuICAgICAgaWYgKHRoaXMua2luZHNfLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSkge1xuXG4gICAgICAgIHZhciBpdGVtID0gbmV3IFRyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7XG4gICAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICAgIC8vIE1lbnVJdGVtIGlzIHNlbGVjdGFibGVcbiAgICAgICAgICBzZWxlY3RhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0uYWRkQ2xhc3MoJ3Zqcy0nICsgdHJhY2sua2luZCArICctbWVudS1pdGVtJyk7XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2tCdXR0b247XG59KFRyYWNrQnV0dG9uKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tCdXR0b24nLCBUZXh0VHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGNoYXB0ZXJzLXRyYWNrLW1lbnUtaXRlbS5qc1xuICovXG4vKipcbiAqIFRoZSBjaGFwdGVyIHRyYWNrIG1lbnUgaXRlbVxuICpcbiAqIEBleHRlbmRzIE1lbnVJdGVtXG4gKi9cblxudmFyIENoYXB0ZXJzVHJhY2tNZW51SXRlbSA9IGZ1bmN0aW9uIChfTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoQ2hhcHRlcnNUcmFja01lbnVJdGVtLCBfTWVudUl0ZW0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2hhcHRlcnNUcmFja01lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENoYXB0ZXJzVHJhY2tNZW51SXRlbSk7XG5cbiAgICB2YXIgdHJhY2sgPSBvcHRpb25zLnRyYWNrO1xuICAgIHZhciBjdWUgPSBvcHRpb25zLmN1ZTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBwbGF5ZXIuY3VycmVudFRpbWUoKTtcblxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxuICAgIG9wdGlvbnMuc2VsZWN0YWJsZSA9IHRydWU7XG4gICAgb3B0aW9ucy5sYWJlbCA9IGN1ZS50ZXh0O1xuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSBjdWUuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lICYmIGN1cnJlbnRUaW1lIDwgY3VlLmVuZFRpbWU7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9NZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudHJhY2sgPSB0cmFjaztcbiAgICBfdGhpcy5jdWUgPSBjdWU7XG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgYmluZChfdGhpcywgX3RoaXMudXBkYXRlKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgQ2hhcHRlcnNUcmFja01lbnVJdGVtYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMpO1xuICAgIHRoaXMucGxheWVyXy5jdXJyZW50VGltZSh0aGlzLmN1ZS5zdGFydFRpbWUpO1xuICAgIHRoaXMudXBkYXRlKHRoaXMuY3VlLnN0YXJ0VGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjaGFwdGVyIG1lbnUgaXRlbVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGN1ZWNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFjayNjdWVjaGFuZ2VcbiAgICovXG5cblxuICBDaGFwdGVyc1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIHZhciBjdWUgPSB0aGlzLmN1ZTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKTtcblxuICAgIC8vIHZqcy5sb2coY3VycmVudFRpbWUsIGN1ZS5zdGFydFRpbWUpO1xuICAgIHRoaXMuc2VsZWN0ZWQoY3VlLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSAmJiBjdXJyZW50VGltZSA8IGN1ZS5lbmRUaW1lKTtcbiAgfTtcblxuICByZXR1cm4gQ2hhcHRlcnNUcmFja01lbnVJdGVtO1xufShNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2hhcHRlcnNUcmFja01lbnVJdGVtJywgQ2hhcHRlcnNUcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBjaGFwdGVycy1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBjaGFwdGVyc1xuICogQ2hhcHRlcnMgYWN0IG11Y2ggZGlmZmVyZW50bHkgdGhhbiBvdGhlciB0ZXh0IHRyYWNrc1xuICogQ3VlcyBhcmUgbmF2aWdhdGlvbiB2cy4gb3RoZXIgdHJhY2tzIG9mIGFsdGVybmF0aXZlIGxhbmd1YWdlc1xuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja0J1dHRvblxuICovXG5cbnZhciBDaGFwdGVyc0J1dHRvbiA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrQnV0dG9uKSB7XG4gIGluaGVyaXRzKENoYXB0ZXJzQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIGZ1bmN0aW9uIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gQ2hhcHRlcnNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENoYXB0ZXJzQnV0dG9uKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2hhcHRlcnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2hhcHRlcnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIG1lbnUgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgaXRzIGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBBbiBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrTGlzdCNhZGR0cmFja1xuICAgKiBAbGlzdGVucyBUZXh0VHJhY2tMaXN0I3JlbW92ZXRyYWNrXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFja0xpc3QjY2hhbmdlXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIGlmICghdGhpcy50cmFja18gfHwgZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdhZGR0cmFjaycgfHwgZXZlbnQudHlwZSA9PT0gJ3JlbW92ZXRyYWNrJykpIHtcbiAgICAgIHRoaXMuc2V0VHJhY2sodGhpcy5maW5kQ2hhcHRlcnNUcmFjaygpKTtcbiAgICB9XG4gICAgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRyYWNrIGZvciB0aGUgY2hhcHRlcnMgYnV0dG9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSBuZXcgdHJhY2sgdG8gc2VsZWN0LiBOb3RoaW5nIHdpbGwgY2hhbmdlIGlmIHRoaXMgaXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgKiAgICAgICAgdHJhY2suXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLnNldFRyYWNrID0gZnVuY3Rpb24gc2V0VHJhY2sodHJhY2spIHtcbiAgICBpZiAodGhpcy50cmFja18gPT09IHRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnVwZGF0ZUhhbmRsZXJfKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhhbmRsZXJfID0gdGhpcy51cGRhdGUuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBoZXJlIHRoaXMudHJhY2tfIHJlZmVycyB0byB0aGUgb2xkIHRyYWNrIGluc3RhbmNlXG4gICAgaWYgKHRoaXMudHJhY2tfKSB7XG4gICAgICB2YXIgcmVtb3RlVGV4dFRyYWNrRWwgPSB0aGlzLnBsYXllcl8ucmVtb3RlVGV4dFRyYWNrRWxzKCkuZ2V0VHJhY2tFbGVtZW50QnlUcmFja18odGhpcy50cmFja18pO1xuXG4gICAgICBpZiAocmVtb3RlVGV4dFRyYWNrRWwpIHtcbiAgICAgICAgcmVtb3RlVGV4dFRyYWNrRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMudXBkYXRlSGFuZGxlcl8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyYWNrXyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy50cmFja18gPSB0cmFjaztcblxuICAgIC8vIGhlcmUgdGhpcy50cmFja18gcmVmZXJzIHRvIHRoZSBuZXcgdHJhY2sgaW5zdGFuY2VcbiAgICBpZiAodGhpcy50cmFja18pIHtcbiAgICAgIHRoaXMudHJhY2tfLm1vZGUgPSAnaGlkZGVuJztcblxuICAgICAgdmFyIF9yZW1vdGVUZXh0VHJhY2tFbCA9IHRoaXMucGxheWVyXy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5nZXRUcmFja0VsZW1lbnRCeVRyYWNrXyh0aGlzLnRyYWNrXyk7XG5cbiAgICAgIGlmIChfcmVtb3RlVGV4dFRyYWNrRWwpIHtcbiAgICAgICAgX3JlbW90ZVRleHRUcmFja0VsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLnVwZGF0ZUhhbmRsZXJfKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHRyYWNrIG9iamVjdCB0aGF0IGlzIGN1cnJlbnRseSBpbiB1c2UgYnkgdGhpcyBDaGFwdGVyc0J1dHRvblxuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2t8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHRyYWNrIG9yIHVuZGVmaW5lZCBpZiBub25lIHdhcyBmb3VuZC5cbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuZmluZENoYXB0ZXJzVHJhY2sgPSBmdW5jdGlvbiBmaW5kQ2hhcHRlcnNUcmFjaygpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKSB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSB0cmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIC8vIFdlIHdpbGwgYWx3YXlzIGNob29zZSB0aGUgbGFzdCB0cmFjayBhcyBvdXIgY2hhcHRlcnNUcmFja1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpZiAodHJhY2sua2luZCA9PT0gdGhpcy5raW5kXykge1xuICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNhcHRpb24gZm9yIHRoZSBDaGFwdGVyc0J1dHRvbiBiYXNlZCBvbiB0aGUgdHJhY2sgbGFiZWwuIFRoaXMgd2lsbCBhbHNvXG4gICAqIHVzZSB0aGUgY3VycmVudCB0cmFja3MgbG9jYWxpemVkIGtpbmQgYXMgYSBmYWxsYmFjayBpZiBhIGxhYmVsIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIHRyYWNrcyBjdXJyZW50IGxhYmVsIG9yIHRoZSBsb2NhbGl6ZWQgdHJhY2sga2luZC5cbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuZ2V0TWVudUNhcHRpb24gPSBmdW5jdGlvbiBnZXRNZW51Q2FwdGlvbigpIHtcbiAgICBpZiAodGhpcy50cmFja18gJiYgdGhpcy50cmFja18ubGFiZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrXy5sYWJlbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9jYWxpemUodG9UaXRsZUNhc2UodGhpcy5raW5kXykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgbWVudSBmcm9tIGNoYXB0ZXIgdHJhY2tcbiAgICpcbiAgICogQHJldHVybiB7TWVudX1cbiAgICogICAgICAgICBOZXcgbWVudSBmb3IgdGhlIGNoYXB0ZXIgYnV0dG9uc1xuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51ID0gZnVuY3Rpb24gY3JlYXRlTWVudSgpIHtcbiAgICB0aGlzLm9wdGlvbnNfLnRpdGxlID0gdGhpcy5nZXRNZW51Q2FwdGlvbigpO1xuICAgIHJldHVybiBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51LmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lbnUgaXRlbSBmb3IgZWFjaCB0ZXh0IHRyYWNrXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja01lbnVJdGVtW119XG4gICAqICAgICAgICAgQXJyYXkgb2YgbWVudSBpdGVtc1xuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKCF0aGlzLnRyYWNrXykge1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIHZhciBjdWVzID0gdGhpcy50cmFja18uY3VlcztcblxuICAgIGlmICghY3Vlcykge1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3Vlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjdWUgPSBjdWVzW2ldO1xuICAgICAgdmFyIG1pID0gbmV3IENoYXB0ZXJzVHJhY2tNZW51SXRlbSh0aGlzLnBsYXllcl8sIHsgdHJhY2s6IHRoaXMudHJhY2tfLCBjdWU6IGN1ZSB9KTtcblxuICAgICAgaXRlbXMucHVzaChtaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIHJldHVybiBDaGFwdGVyc0J1dHRvbjtcbn0oVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBga2luZGAgb2YgVGV4dFRyYWNrIHRvIGxvb2sgZm9yIHRvIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMgbWVudS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkNoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdjaGFwdGVycyc7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgQ2hhcHRlcnNCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdDaGFwdGVycyc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2hhcHRlcnNCdXR0b24nLCBDaGFwdGVyc0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgZGVzY3JpcHRpb25zLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIGRlc2NyaXB0aW9uc1xuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja0J1dHRvblxuICovXG5cbnZhciBEZXNjcmlwdGlvbnNCdXR0b24gPSBmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhEZXNjcmlwdGlvbnNCdXR0b24sIF9UZXh0VHJhY2tCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gRGVzY3JpcHRpb25zQnV0dG9uKHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBEZXNjcmlwdGlvbnNCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xuXG4gICAgdmFyIHRyYWNrcyA9IHBsYXllci50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIGNoYW5nZUhhbmRsZXIgPSBiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UpO1xuXG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgIF90aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGV4dCB0cmFjayBjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1blxuICAgKlxuICAgKiBAbGlzdGVucyBUZXh0VHJhY2tMaXN0I2NoYW5nZVxuICAgKi9cblxuXG4gIERlc2NyaXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuaGFuZGxlVHJhY2tzQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlVHJhY2tzQ2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyKCkudGV4dFRyYWNrcygpO1xuICAgIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgd2hldGhlciBhIHRyYWNrIG9mIGEgZGlmZmVyZW50IGtpbmQgaXMgc2hvd2luZ1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdHJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpZiAodHJhY2sua2luZCAhPT0gdGhpcy5raW5kXyAmJiB0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBhbm90aGVyIHRyYWNrIGlzIHNob3dpbmcsIGRpc2FibGUgdGhpcyBtZW51IGJ1dHRvblxuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1kZXNjcmlwdGlvbnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWRlc2NyaXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIERlc2NyaXB0aW9uc0J1dHRvbjtcbn0oVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBga2luZGAgb2YgVGV4dFRyYWNrIHRvIGxvb2sgZm9yIHRvIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMgbWVudS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkRlc2NyaXB0aW9uc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnZGVzY3JpcHRpb25zJztcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBEZXNjcmlwdGlvbnNCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnRGVzY3JpcHRpb25zJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdEZXNjcmlwdGlvbnNCdXR0b24nLCBEZXNjcmlwdGlvbnNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHN1YnRpdGxlcy1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBzdWJ0aXRsZXNcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b25cbiAqL1xuXG52YXIgU3VidGl0bGVzQnV0dG9uID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoU3VidGl0bGVzQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyByZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIFN1YnRpdGxlc0J1dHRvbihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3VidGl0bGVzQnV0dG9uKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBTdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXN1YnRpdGxlcy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBTdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtc3VidGl0bGVzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gU3VidGl0bGVzQnV0dG9uO1xufShUZXh0VHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIGBraW5kYCBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdzdWJ0aXRsZXMnO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFN1YnRpdGxlc0J1dHRvbmBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5TdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdTdWJ0aXRsZXMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1N1YnRpdGxlc0J1dHRvbicsIFN1YnRpdGxlc0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgY2FwdGlvbi1zZXR0aW5ncy1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBUaGUgbWVudSBpdGVtIGZvciBjYXB0aW9uIHRyYWNrIHNldHRpbmdzIG1lbnVcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tNZW51SXRlbVxuICovXG5cbnZhciBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0sIF9UZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSk7XG5cbiAgICBvcHRpb25zLnRyYWNrID0ge1xuICAgICAgcGxheWVyOiBwbGF5ZXIsXG4gICAgICBraW5kOiBvcHRpb25zLmtpbmQsXG4gICAgICBsYWJlbDogb3B0aW9ucy5raW5kICsgJyBzZXR0aW5ncycsXG4gICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgICdkZWZhdWx0JzogZmFsc2UsXG4gICAgICBtb2RlOiAnZGlzYWJsZWQnXG4gICAgfTtcblxuICAgIC8vIENhcHRpb25TZXR0aW5nc01lbnVJdGVtIGhhcyBubyBjb25jZXB0IG9mICdzZWxlY3RlZCdcbiAgICBvcHRpb25zLnNlbGVjdGFibGUgPSBmYWxzZTtcblxuICAgIG9wdGlvbnMubmFtZSA9ICdDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSc7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tNZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy10ZXh0dHJhY2stc2V0dGluZ3MnKTtcbiAgICBfdGhpcy5jb250cm9sVGV4dCgnLCBvcGVucyAnICsgb3B0aW9ucy5raW5kICsgJyBzZXR0aW5ncyBkaWFsb2cnKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIENhcHRpb25TZXR0aW5nc01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdGhpcy5wbGF5ZXIoKS5nZXRDaGlsZCgndGV4dFRyYWNrU2V0dGluZ3MnKS5vcGVuKCk7XG4gIH07XG5cbiAgcmV0dXJuIENhcHRpb25TZXR0aW5nc01lbnVJdGVtO1xufShUZXh0VHJhY2tNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0nLCBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgY2FwdGlvbnMtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3RpbmcgY2FwdGlvbnNcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b25cbiAqL1xuXG52YXIgQ2FwdGlvbnNCdXR0b24gPSBmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhDYXB0aW9uc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBDYXB0aW9uc0J1dHRvbihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FwdGlvbnNCdXR0b24pO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIENhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jYXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBDYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jYXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjYXB0aW9uIG1lbnUgaXRlbXNcbiAgICpcbiAgICogQHJldHVybiB7Q2FwdGlvblNldHRpbmdzTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBUaGUgYXJyYXkgb2YgY3VycmVudCBtZW51IGl0ZW1zLlxuICAgKi9cblxuXG4gIENhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKCEodGhpcy5wbGF5ZXIoKS50ZWNoXyAmJiB0aGlzLnBsYXllcigpLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmV3IENhcHRpb25TZXR0aW5nc01lbnVJdGVtKHRoaXMucGxheWVyXywgeyBraW5kOiB0aGlzLmtpbmRfIH0pKTtcblxuICAgICAgdGhpcy5oaWRlVGhyZXNob2xkXyArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcy5jYWxsKHRoaXMsIGl0ZW1zKTtcbiAgfTtcblxuICByZXR1cm4gQ2FwdGlvbnNCdXR0b247XG59KFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogYGtpbmRgIG9mIFRleHRUcmFjayB0byBsb29rIGZvciB0byBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzIG1lbnUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5DYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnY2FwdGlvbnMnO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYENhcHRpb25zQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbkNhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnQ2FwdGlvbnMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NhcHRpb25zQnV0dG9uJywgQ2FwdGlvbnNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHN1YnMtY2Fwcy1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBTdWJzQ2Fwc01lbnVJdGVtIGhhcyBhbiBbY2NdIGljb24gdG8gZGlzdGluZ3Vpc2ggY2FwdGlvbnMgZnJvbSBzdWJ0aXRsZXNcbiAqIGluIHRoZSBTdWJzQ2Fwc01lbnUuXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrTWVudUl0ZW1cbiAqL1xuXG52YXIgU3Vic0NhcHNNZW51SXRlbSA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoU3Vic0NhcHNNZW51SXRlbSwgX1RleHRUcmFja01lbnVJdGVtKTtcblxuICBmdW5jdGlvbiBTdWJzQ2Fwc01lbnVJdGVtKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnNDYXBzTWVudUl0ZW0pO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tNZW51SXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFN1YnNDYXBzTWVudUl0ZW0ucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwodHlwZSwgcHJvcHMsIGF0dHJzKSB7XG4gICAgdmFyIGlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cInZqcy1tZW51LWl0ZW0tdGV4dFwiPicgKyB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubGFiZWwpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9uc18udHJhY2sua2luZCA9PT0gJ2NhcHRpb25zJykge1xuICAgICAgaW5uZXJIVE1MICs9ICdcXG4gICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwidmpzLWljb24tcGxhY2Vob2xkZXJcIj48L3NwYW4+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4gJyArIHRoaXMubG9jYWxpemUoJ0NhcHRpb25zJykgKyAnPC9zcGFuPlxcbiAgICAgICc7XG4gICAgfVxuXG4gICAgaW5uZXJIVE1MICs9ICc8L3NwYW4+JztcblxuICAgIHZhciBlbCA9IF9UZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB0eXBlLCBhc3NpZ24oe1xuICAgICAgaW5uZXJIVE1MOiBpbm5lckhUTUxcbiAgICB9LCBwcm9wcyksIGF0dHJzKTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICByZXR1cm4gU3Vic0NhcHNNZW51SXRlbTtcbn0oVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1N1YnNDYXBzTWVudUl0ZW0nLCBTdWJzQ2Fwc01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBzdWItY2Fwcy1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBjYXB0aW9ucyBhbmQvb3Igc3VidGl0bGVzXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKi9cblxudmFyIFN1YnNDYXBzQnV0dG9uID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoU3Vic0NhcHNCdXR0b24sIF9UZXh0VHJhY2tCdXR0b24pO1xuXG4gIGZ1bmN0aW9uIFN1YnNDYXBzQnV0dG9uKHBsYXllcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJzQ2Fwc0J1dHRvbik7XG5cbiAgICAvLyBBbHRob3VnaCBOb3J0aCBBbWVyaWNhIHVzZXMgXCJjYXB0aW9uc1wiIGluIG1vc3QgY2FzZXMgZm9yXG4gICAgLy8gXCJjYXB0aW9ucyBhbmQgc3VidGl0bGVzXCIgb3RoZXIgbG9jYWxlcyB1c2UgXCJzdWJ0aXRsZXNcIlxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMubGFiZWxfID0gJ3N1YnRpdGxlcyc7XG4gICAgaWYgKFsnZW4nLCAnZW4tdXMnLCAnZW4tY2EnLCAnZnItY2EnXS5pbmRleE9mKF90aGlzLnBsYXllcl8ubGFuZ3VhZ2VfKSA+IC0xKSB7XG4gICAgICBfdGhpcy5sYWJlbF8gPSAnY2FwdGlvbnMnO1xuICAgIH1cbiAgICBfdGhpcy5tZW51QnV0dG9uXy5jb250cm9sVGV4dCh0b1RpdGxlQ2FzZShfdGhpcy5sYWJlbF8pKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIFN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1zdWJzLWNhcHMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgU3Vic0NhcHNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtc3Vicy1jYXBzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGNhcHRpb24vc3VidGl0bGVzIG1lbnUgaXRlbXNcbiAgICpcbiAgICogQHJldHVybiB7Q2FwdGlvblNldHRpbmdzTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBUaGUgYXJyYXkgb2YgY3VycmVudCBtZW51IGl0ZW1zLlxuICAgKi9cblxuXG4gIFN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKCEodGhpcy5wbGF5ZXIoKS50ZWNoXyAmJiB0aGlzLnBsYXllcigpLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmV3IENhcHRpb25TZXR0aW5nc01lbnVJdGVtKHRoaXMucGxheWVyXywgeyBraW5kOiB0aGlzLmxhYmVsXyB9KSk7XG5cbiAgICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gKz0gMTtcbiAgICB9XG5cbiAgICBpdGVtcyA9IF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zLmNhbGwodGhpcywgaXRlbXMsIFN1YnNDYXBzTWVudUl0ZW0pO1xuICAgIHJldHVybiBpdGVtcztcbiAgfTtcblxuICByZXR1cm4gU3Vic0NhcHNCdXR0b247XG59KFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogYGtpbmRgcyBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxuICpcbiAqIEB0eXBlIHthcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5TdWJzQ2Fwc0J1dHRvbi5wcm90b3R5cGUua2luZHNfID0gWydjYXB0aW9ucycsICdzdWJ0aXRsZXMnXTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBTdWJzQ2Fwc0J1dHRvbmBzIGNvbnRyb2xzLlxuICpcbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuU3Vic0NhcHNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdTdWJ0aXRsZXMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1N1YnNDYXBzQnV0dG9uJywgU3Vic0NhcHNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGF1ZGlvLXRyYWNrLW1lbnUtaXRlbS5qc1xuICovXG4vKipcbiAqIEFuIHtAbGluayBBdWRpb1RyYWNrfSB7QGxpbmsgTWVudUl0ZW19XG4gKlxuICogQGV4dGVuZHMgTWVudUl0ZW1cbiAqL1xuXG52YXIgQXVkaW9UcmFja01lbnVJdGVtID0gZnVuY3Rpb24gKF9NZW51SXRlbSkge1xuICBpbmhlcml0cyhBdWRpb1RyYWNrTWVudUl0ZW0sIF9NZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBBdWRpb1RyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9UcmFja01lbnVJdGVtKTtcblxuICAgIHZhciB0cmFjayA9IG9wdGlvbnMudHJhY2s7XG4gICAgdmFyIHRyYWNrcyA9IHBsYXllci5hdWRpb1RyYWNrcygpO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9ucy5sYWJlbCA9IHRyYWNrLmxhYmVsIHx8IHRyYWNrLmxhbmd1YWdlIHx8ICdVbmtub3duJztcbiAgICBvcHRpb25zLnNlbGVjdGVkID0gdHJhY2suZW5hYmxlZDtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy50cmFjayA9IHRyYWNrO1xuXG4gICAgdmFyIGNoYW5nZUhhbmRsZXIgPSBiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UpO1xuXG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgIF90aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYEF1ZGlvVHJhY2tNZW51SXRlbSBpcyBcImNsaWNrZWRcIi4gU2VlIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9XG4gICAqIGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgQXVkaW9UcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpO1xuXG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIHRyYWNrLmVuYWJsZWQgPSB0cmFjayA9PT0gdGhpcy50cmFjaztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhbnkge0BsaW5rIEF1ZGlvVHJhY2t9IGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBBdWRpb1RyYWNrTGlzdCNjaGFuZ2V9IGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBBdWRpb1RyYWNrTGlzdCNjaGFuZ2VcbiAgICovXG5cblxuICBBdWRpb1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xuICAgIHRoaXMuc2VsZWN0ZWQodGhpcy50cmFjay5lbmFibGVkKTtcbiAgfTtcblxuICByZXR1cm4gQXVkaW9UcmFja01lbnVJdGVtO1xufShNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQXVkaW9UcmFja01lbnVJdGVtJywgQXVkaW9UcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBhdWRpby10cmFjay1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYnV0dG9ucyB0aGF0IHRvZ2dsZSBzcGVjaWZpYyB7QGxpbmsgQXVkaW9UcmFja30gdHlwZXMuXG4gKlxuICogQGV4dGVuZHMgVHJhY2tCdXR0b25cbiAqL1xuXG52YXIgQXVkaW9UcmFja0J1dHRvbiA9IGZ1bmN0aW9uIChfVHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoQXVkaW9UcmFja0J1dHRvbiwgX1RyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2tCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvVHJhY2tCdXR0b24pO1xuXG4gICAgb3B0aW9ucy50cmFja3MgPSBwbGF5ZXIuYXVkaW9UcmFja3MoKTtcblxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBBdWRpb1RyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1hdWRpby1idXR0b24gJyArIF9UcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIEF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtYXVkaW8tYnV0dG9uICcgKyBfVHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lbnUgaXRlbSBmb3IgZWFjaCBhdWRpbyB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2tNZW51SXRlbVtdfSBbaXRlbXM9W11dXG4gICAqICAgICAgICBBbiBhcnJheSBvZiBleGlzdGluZyBtZW51IGl0ZW1zIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7QXVkaW9UcmFja01lbnVJdGVtW119XG4gICAqICAgICAgICAgQW4gYXJyYXkgb2YgbWVudSBpdGVtc1xuICAgKi9cblxuXG4gIEF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7XG4gICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcblxuICAgIC8vIGlmIHRoZXJlJ3Mgb25seSBvbmUgYXVkaW8gdHJhY2ssIHRoZXJlIG5vIHBvaW50IGluIHNob3dpbmcgaXRcbiAgICB0aGlzLmhpZGVUaHJlc2hvbGRfID0gMTtcblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGl0ZW1zLnB1c2gobmV3IEF1ZGlvVHJhY2tNZW51SXRlbSh0aGlzLnBsYXllcl8sIHtcbiAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICAvLyBNZW51SXRlbSBpcyBzZWxlY3RhYmxlXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWVcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2tCdXR0b247XG59KFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBBdWRpb1RyYWNrQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5BdWRpb1RyYWNrQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnQXVkaW8gVHJhY2snO1xuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdBdWRpb1RyYWNrQnV0dG9uJywgQXVkaW9UcmFja0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgcGxheWJhY2stcmF0ZS1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBUaGUgc3BlY2lmaWMgbWVudSBpdGVtIHR5cGUgZm9yIHNlbGVjdGluZyBhIHBsYXliYWNrIHJhdGUuXG4gKlxuICogQGV4dGVuZHMgTWVudUl0ZW1cbiAqL1xuXG52YXIgUGxheWJhY2tSYXRlTWVudUl0ZW0gPSBmdW5jdGlvbiAoX01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKFBsYXliYWNrUmF0ZU1lbnVJdGVtLCBfTWVudUl0ZW0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUGxheWJhY2tSYXRlTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheWJhY2tSYXRlTWVudUl0ZW0pO1xuXG4gICAgdmFyIGxhYmVsID0gb3B0aW9ucy5yYXRlO1xuICAgIHZhciByYXRlID0gcGFyc2VGbG9hdChsYWJlbCwgMTApO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9ucy5sYWJlbCA9IGxhYmVsO1xuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSByYXRlID09PSAxO1xuICAgIG9wdGlvbnMuc2VsZWN0YWJsZSA9IHRydWU7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9NZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMubGFiZWwgPSBsYWJlbDtcbiAgICBfdGhpcy5yYXRlID0gcmF0ZTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ3JhdGVjaGFuZ2UnLCBfdGhpcy51cGRhdGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYFBsYXliYWNrUmF0ZU1lbnVJdGVtYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBfTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcyk7XG4gICAgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUodGhpcy5yYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBQbGF5YmFja1JhdGVNZW51SXRlbSB3aGVuIHRoZSBwbGF5YmFja3JhdGUgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGByYXRlY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3JhdGVjaGFuZ2VcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51SXRlbS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZCh0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpID09PSB0aGlzLnJhdGUpO1xuICB9O1xuXG4gIHJldHVybiBQbGF5YmFja1JhdGVNZW51SXRlbTtcbn0oTWVudUl0ZW0pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFBsYXliYWNrUmF0ZU1lbnVJdGVtYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5QbGF5YmFja1JhdGVNZW51SXRlbS5wcm90b3R5cGUuY29udGVudEVsVHlwZSA9ICdidXR0b24nO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXliYWNrUmF0ZU1lbnVJdGVtJywgUGxheWJhY2tSYXRlTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIHBsYXliYWNrLXJhdGUtbWVudS1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBjb250cm9sbGluZyB0aGUgcGxheWJhY2sgcmF0ZS5cbiAqXG4gKiBAZXh0ZW5kcyBNZW51QnV0dG9uXG4gKi9cblxudmFyIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24gPSBmdW5jdGlvbiAoX01lbnVCdXR0b24pIHtcbiAgaW5oZXJpdHMoUGxheWJhY2tSYXRlTWVudUJ1dHRvbiwgX01lbnVCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUGxheWJhY2tSYXRlTWVudUJ1dHRvbihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5YmFja1JhdGVNZW51QnV0dG9uKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICBfdGhpcy51cGRhdGVMYWJlbCgpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnbG9hZHN0YXJ0JywgX3RoaXMudXBkYXRlVmlzaWJpbGl0eSk7XG4gICAgX3RoaXMub24ocGxheWVyLCAncmF0ZWNoYW5nZScsIF90aGlzLnVwZGF0ZUxhYmVsKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IF9NZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5sYWJlbEVsXyA9IGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcGxheWJhY2stcmF0ZS12YWx1ZScsXG4gICAgICBpbm5lckhUTUw6IDEuMFxuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5sYWJlbEVsXyk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1wbGF5YmFjay1yYXRlICcgKyBfTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtcGxheWJhY2stcmF0ZSAnICsgX01lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgcGxheWJhY2sgcmF0ZSBtZW51XG4gICAqXG4gICAqIEByZXR1cm4ge01lbnV9XG4gICAqICAgICAgICAgTWVudSBvYmplY3QgcG9wdWxhdGVkIHdpdGgge0BsaW5rIFBsYXliYWNrUmF0ZU1lbnVJdGVtfXNcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51ID0gZnVuY3Rpb24gY3JlYXRlTWVudSgpIHtcbiAgICB2YXIgbWVudSA9IG5ldyBNZW51KHRoaXMucGxheWVyKCkpO1xuICAgIHZhciByYXRlcyA9IHRoaXMucGxheWJhY2tSYXRlcygpO1xuXG4gICAgaWYgKHJhdGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gcmF0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbWVudS5hZGRDaGlsZChuZXcgUGxheWJhY2tSYXRlTWVudUl0ZW0odGhpcy5wbGF5ZXIoKSwgeyByYXRlOiByYXRlc1tpXSArICd4JyB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgQVJJQSBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXNcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS51cGRhdGVBUklBQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHVwZGF0ZUFSSUFBdHRyaWJ1dGVzKCkge1xuICAgIC8vIEN1cnJlbnQgcGxheWJhY2sgcmF0ZVxuICAgIHRoaXMuZWwoKS5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBQbGF5YmFja1JhdGVNZW51QnV0dG9uYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIC8vIHNlbGVjdCBuZXh0IHJhdGUgb3B0aW9uXG4gICAgdmFyIGN1cnJlbnRSYXRlID0gdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKTtcbiAgICB2YXIgcmF0ZXMgPSB0aGlzLnBsYXliYWNrUmF0ZXMoKTtcblxuICAgIC8vIHRoaXMgd2lsbCBzZWxlY3QgZmlyc3Qgb25lIGlmIHRoZSBsYXN0IG9uZSBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICB2YXIgbmV3UmF0ZSA9IHJhdGVzWzBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJhdGVzW2ldID4gY3VycmVudFJhdGUpIHtcbiAgICAgICAgbmV3UmF0ZSA9IHJhdGVzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUobmV3UmF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBwb3NzaWJsZSBwbGF5YmFjayByYXRlc1xuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogICAgICAgICBBbGwgcG9zc2libGUgcGxheWJhY2sgcmF0ZXNcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5wbGF5YmFja1JhdGVzID0gZnVuY3Rpb24gcGxheWJhY2tSYXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zXy5wbGF5YmFja1JhdGVzIHx8IHRoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMucGxheWJhY2tSYXRlcztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgcGxheWJhY2sgcmF0ZXMgaXMgc3VwcG9ydGVkIGJ5IHRoZSB0ZWNoXG4gICAqIGFuZCBhbiBhcnJheSBvZiBwbGF5YmFjayByYXRlcyBleGlzdHNcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBXaGV0aGVyIGNoYW5naW5nIHBsYXliYWNrIHJhdGUgaXMgc3VwcG9ydGVkXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUucGxheWJhY2tSYXRlU3VwcG9ydGVkID0gZnVuY3Rpb24gcGxheWJhY2tSYXRlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXllcigpLnRlY2hfICYmIHRoaXMucGxheWVyKCkudGVjaF8uZmVhdHVyZXNQbGF5YmFja1JhdGUgJiYgdGhpcy5wbGF5YmFja1JhdGVzKCkgJiYgdGhpcy5wbGF5YmFja1JhdGVzKCkubGVuZ3RoID4gMDtcbiAgfTtcblxuICAvKipcbiAgICogSGlkZSBwbGF5YmFjayByYXRlIGNvbnRyb2xzIHdoZW4gdGhleSdyZSBubyBwbGF5YmFjayByYXRlIG9wdGlvbnMgdG8gc2VsZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRzdGFydFxuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnVwZGF0ZVZpc2liaWxpdHkgPSBmdW5jdGlvbiB1cGRhdGVWaXNpYmlsaXR5KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWJhY2tSYXRlU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGJ1dHRvbiBsYWJlbCB3aGVuIHJhdGUgY2hhbmdlZFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNyYXRlY2hhbmdlXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUudXBkYXRlTGFiZWwgPSBmdW5jdGlvbiB1cGRhdGVMYWJlbChldmVudCkge1xuICAgIGlmICh0aGlzLnBsYXliYWNrUmF0ZVN1cHBvcnRlZCgpKSB7XG4gICAgICB0aGlzLmxhYmVsRWxfLmlubmVySFRNTCA9IHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKCkgKyAneCc7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQbGF5YmFja1JhdGVNZW51QnV0dG9uO1xufShNZW51QnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBGdWxsc2NyZWVuVG9nZ2xlYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5QbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnUGxheWJhY2sgUmF0ZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUGxheWJhY2tSYXRlTWVudUJ1dHRvbicsIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHNwYWNlci5qc1xuICovXG4vKipcbiAqIEp1c3QgYW4gZW1wdHkgc3BhY2VyIGVsZW1lbnQgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBhcHBlbmQgcG9pbnQgZm9yIHBsdWdpbnMsIGV0Yy5cbiAqIEFsc28gY2FuIGJlIHVzZWQgdG8gY3JlYXRlIHNwYWNlIGJldHdlZW4gZWxlbWVudHMgd2hlbiBuZWNlc3NhcnkuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFNwYWNlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFNwYWNlciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3BhY2VyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFNwYWNlcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuICBTcGFjZXIucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXNwYWNlciAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFNwYWNlci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTcGFjZXI7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU3BhY2VyJywgU3BhY2VyKTtcblxuLyoqXG4gKiBAZmlsZSBjdXN0b20tY29udHJvbC1zcGFjZXIuanNcbiAqL1xuLyoqXG4gKiBTcGFjZXIgc3BlY2lmaWNhbGx5IG1lYW50IHRvIGJlIHVzZWQgYXMgYW4gaW5zZXJ0aW9uIHBvaW50IGZvciBuZXcgcGx1Z2lucywgZXRjLlxuICpcbiAqIEBleHRlbmRzIFNwYWNlclxuICovXG5cbnZhciBDdXN0b21Db250cm9sU3BhY2VyID0gZnVuY3Rpb24gKF9TcGFjZXIpIHtcbiAgaW5oZXJpdHMoQ3VzdG9tQ29udHJvbFNwYWNlciwgX1NwYWNlcik7XG5cbiAgZnVuY3Rpb24gQ3VzdG9tQ29udHJvbFNwYWNlcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDdXN0b21Db250cm9sU3BhY2VyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU3BhY2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG4gIEN1c3RvbUNvbnRyb2xTcGFjZXIucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWN1c3RvbS1jb250cm9sLXNwYWNlciAnICsgX1NwYWNlci5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIEN1c3RvbUNvbnRyb2xTcGFjZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIGVsID0gX1NwYWNlci5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpXG4gICAgfSk7XG5cbiAgICAvLyBOby1mbGV4L3RhYmxlLWNlbGwgbW9kZSByZXF1aXJlcyB0aGVyZSBiZSBzb21lIGNvbnRlbnRcbiAgICAvLyBpbiB0aGUgY2VsbCB0byBmaWxsIHRoZSByZW1haW5pbmcgc3BhY2Ugb2YgdGhlIHRhYmxlLlxuICAgIGVsLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICByZXR1cm4gQ3VzdG9tQ29udHJvbFNwYWNlcjtcbn0oU3BhY2VyKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDdXN0b21Db250cm9sU3BhY2VyJywgQ3VzdG9tQ29udHJvbFNwYWNlcik7XG5cbi8qKlxuICogQGZpbGUgY29udHJvbC1iYXIuanNcbiAqL1xuLy8gUmVxdWlyZWQgY2hpbGRyZW5cbi8qKlxuICogQ29udGFpbmVyIG9mIG1haW4gY29udHJvbHMuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIENvbnRyb2xCYXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhDb250cm9sQmFyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBDb250cm9sQmFyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRyb2xCYXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIENvbnRyb2xCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLWJhcicsXG4gICAgICBkaXI6ICdsdHInXG4gICAgfSwge1xuICAgICAgLy8gVGhlIGNvbnRyb2wgYmFyIGlzIGEgZ3JvdXAsIGJ1dCB3ZSBkb24ndCBhcmlhLWxhYmVsIGl0IHRvIGF2b2lkXG4gICAgICAvLyAgb3Zlci1hbm5vdW5jaW5nIGJ5IEpBV1NcbiAgICAgIHJvbGU6ICdncm91cCdcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ29udHJvbEJhcjtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBDb250cm9sQmFyYFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQ29udHJvbEJhci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ3BsYXlUb2dnbGUnLCAndm9sdW1lUGFuZWwnLCAnY3VycmVudFRpbWVEaXNwbGF5JywgJ3RpbWVEaXZpZGVyJywgJ2R1cmF0aW9uRGlzcGxheScsICdwcm9ncmVzc0NvbnRyb2wnLCAnbGl2ZURpc3BsYXknLCAncmVtYWluaW5nVGltZURpc3BsYXknLCAnY3VzdG9tQ29udHJvbFNwYWNlcicsICdwbGF5YmFja1JhdGVNZW51QnV0dG9uJywgJ2NoYXB0ZXJzQnV0dG9uJywgJ2Rlc2NyaXB0aW9uc0J1dHRvbicsICdzdWJzQ2Fwc0J1dHRvbicsICdhdWRpb1RyYWNrQnV0dG9uJywgJ2Z1bGxzY3JlZW5Ub2dnbGUnXVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDb250cm9sQmFyJywgQ29udHJvbEJhcik7XG5cbi8qKlxuICogQGZpbGUgZXJyb3ItZGlzcGxheS5qc1xuICovXG4vKipcbiAqIEEgZGlzcGxheSB0aGF0IGluZGljYXRlcyBhbiBlcnJvciBoYXMgb2NjdXJyZWQuIFRoaXMgbWVhbnMgdGhhdCB0aGUgdmlkZW9cbiAqIGlzIHVucGxheWFibGUuXG4gKlxuICogQGV4dGVuZHMgTW9kYWxEaWFsb2dcbiAqL1xuXG52YXIgRXJyb3JEaXNwbGF5ID0gZnVuY3Rpb24gKF9Nb2RhbERpYWxvZykge1xuICBpbmhlcml0cyhFcnJvckRpc3BsYXksIF9Nb2RhbERpYWxvZyk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gRXJyb3JEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEVycm9yRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Nb2RhbERpYWxvZy5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnZXJyb3InLCBfdGhpcy5vcGVuKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2ZXJzaW9uIDUuXG4gICAqL1xuXG5cbiAgRXJyb3JEaXNwbGF5LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1lcnJvci1kaXNwbGF5ICcgKyBfTW9kYWxEaWFsb2cucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbG9jYWxpemVkIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gdGhlIGBQbGF5ZXJgcyBlcnJvci5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBgUGxheWVyYHMgZXJyb3IgbWVzc2FnZSBsb2NhbGl6ZWQgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICAgKi9cblxuXG4gIEVycm9yRGlzcGxheS5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5wbGF5ZXIoKS5lcnJvcigpO1xuXG4gICAgcmV0dXJuIGVycm9yID8gdGhpcy5sb2NhbGl6ZShlcnJvci5tZXNzYWdlKSA6ICcnO1xuICB9O1xuXG4gIHJldHVybiBFcnJvckRpc3BsYXk7XG59KE1vZGFsRGlhbG9nKTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciBhbiBgRXJyb3JEaXNwbGF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuRXJyb3JEaXNwbGF5LnByb3RvdHlwZS5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyhNb2RhbERpYWxvZy5wcm90b3R5cGUub3B0aW9uc18sIHtcbiAgcGF1c2VPbk9wZW46IGZhbHNlLFxuICBmaWxsQWx3YXlzOiB0cnVlLFxuICB0ZW1wb3Jhcnk6IGZhbHNlLFxuICB1bmNsb3NlYWJsZTogdHJ1ZVxufSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRXJyb3JEaXNwbGF5JywgRXJyb3JEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLXNldHRpbmdzLmpzXG4gKi9cbnZhciBMT0NBTF9TVE9SQUdFX0tFWSA9ICd2anMtdGV4dC10cmFjay1zZXR0aW5ncyc7XG5cbnZhciBDT0xPUl9CTEFDSyA9IFsnIzAwMCcsICdCbGFjayddO1xudmFyIENPTE9SX0JMVUUgPSBbJyMwMEYnLCAnQmx1ZSddO1xudmFyIENPTE9SX0NZQU4gPSBbJyMwRkYnLCAnQ3lhbiddO1xudmFyIENPTE9SX0dSRUVOID0gWycjMEYwJywgJ0dyZWVuJ107XG52YXIgQ09MT1JfTUFHRU5UQSA9IFsnI0YwRicsICdNYWdlbnRhJ107XG52YXIgQ09MT1JfUkVEID0gWycjRjAwJywgJ1JlZCddO1xudmFyIENPTE9SX1dISVRFID0gWycjRkZGJywgJ1doaXRlJ107XG52YXIgQ09MT1JfWUVMTE9XID0gWycjRkYwJywgJ1llbGxvdyddO1xuXG52YXIgT1BBQ0lUWV9PUEFRVUUgPSBbJzEnLCAnT3BhcXVlJ107XG52YXIgT1BBQ0lUWV9TRU1JID0gWycwLjUnLCAnU2VtaS1UcmFuc3BhcmVudCddO1xudmFyIE9QQUNJVFlfVFJBTlMgPSBbJzAnLCAnVHJhbnNwYXJlbnQnXTtcblxuLy8gQ29uZmlndXJhdGlvbiBmb3IgdGhlIHZhcmlvdXMgPHNlbGVjdD4gZWxlbWVudHMgaW4gdGhlIERPTSBvZiB0aGlzIGNvbXBvbmVudC5cbi8vXG4vLyBQb3NzaWJsZSBrZXlzIGluY2x1ZGU6XG4vL1xuLy8gYGRlZmF1bHRgOlxuLy8gICBUaGUgZGVmYXVsdCBvcHRpb24gaW5kZXguIE9ubHkgbmVlZHMgdG8gYmUgcHJvdmlkZWQgaWYgbm90IHplcm8uXG4vLyBgcGFyc2VyYDpcbi8vICAgQSBmdW5jdGlvbiB3aGljaCBpcyB1c2VkIHRvIHBhcnNlIHRoZSB2YWx1ZSBmcm9tIHRoZSBzZWxlY3RlZCBvcHRpb24gaW5cbi8vICAgYSBjdXN0b21pemVkIHdheS5cbi8vIGBzZWxlY3RvcmA6XG4vLyAgIFRoZSBzZWxlY3RvciB1c2VkIHRvIGZpbmQgdGhlIGFzc29jaWF0ZWQgPHNlbGVjdD4gZWxlbWVudC5cbnZhciBzZWxlY3RDb25maWdzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICBzZWxlY3RvcjogJy52anMtYmctY29sb3IgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtYmFja2dyb3VuZC1jb2xvci0lcycsXG4gICAgbGFiZWw6ICdDb2xvcicsXG4gICAgb3B0aW9uczogW0NPTE9SX0JMQUNLLCBDT0xPUl9XSElURSwgQ09MT1JfUkVELCBDT0xPUl9HUkVFTiwgQ09MT1JfQkxVRSwgQ09MT1JfWUVMTE9XLCBDT0xPUl9NQUdFTlRBLCBDT0xPUl9DWUFOXVxuICB9LFxuXG4gIGJhY2tncm91bmRPcGFjaXR5OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWJnLW9wYWNpdHkgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtYmFja2dyb3VuZC1vcGFjaXR5LSVzJyxcbiAgICBsYWJlbDogJ1RyYW5zcGFyZW5jeScsXG4gICAgb3B0aW9uczogW09QQUNJVFlfT1BBUVVFLCBPUEFDSVRZX1NFTUksIE9QQUNJVFlfVFJBTlNdXG4gIH0sXG5cbiAgY29sb3I6IHtcbiAgICBzZWxlY3RvcjogJy52anMtZmctY29sb3IgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtZm9yZWdyb3VuZC1jb2xvci0lcycsXG4gICAgbGFiZWw6ICdDb2xvcicsXG4gICAgb3B0aW9uczogW0NPTE9SX1dISVRFLCBDT0xPUl9CTEFDSywgQ09MT1JfUkVELCBDT0xPUl9HUkVFTiwgQ09MT1JfQkxVRSwgQ09MT1JfWUVMTE9XLCBDT0xPUl9NQUdFTlRBLCBDT0xPUl9DWUFOXVxuICB9LFxuXG4gIGVkZ2VTdHlsZToge1xuICAgIHNlbGVjdG9yOiAnLnZqcy1lZGdlLXN0eWxlID4gc2VsZWN0JyxcbiAgICBpZDogJyVzJyxcbiAgICBsYWJlbDogJ1RleHQgRWRnZSBTdHlsZScsXG4gICAgb3B0aW9uczogW1snbm9uZScsICdOb25lJ10sIFsncmFpc2VkJywgJ1JhaXNlZCddLCBbJ2RlcHJlc3NlZCcsICdEZXByZXNzZWQnXSwgWyd1bmlmb3JtJywgJ1VuaWZvcm0nXSwgWydkcm9wc2hhZG93JywgJ0Ryb3BzaGFkb3cnXV1cbiAgfSxcblxuICBmb250RmFtaWx5OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWZvbnQtZmFtaWx5ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLWZvbnQtZmFtaWx5LSVzJyxcbiAgICBsYWJlbDogJ0ZvbnQgRmFtaWx5JyxcbiAgICBvcHRpb25zOiBbWydwcm9wb3J0aW9uYWxTYW5zU2VyaWYnLCAnUHJvcG9ydGlvbmFsIFNhbnMtU2VyaWYnXSwgWydtb25vc3BhY2VTYW5zU2VyaWYnLCAnTW9ub3NwYWNlIFNhbnMtU2VyaWYnXSwgWydwcm9wb3J0aW9uYWxTZXJpZicsICdQcm9wb3J0aW9uYWwgU2VyaWYnXSwgWydtb25vc3BhY2VTZXJpZicsICdNb25vc3BhY2UgU2VyaWYnXSwgWydjYXN1YWwnLCAnQ2FzdWFsJ10sIFsnc2NyaXB0JywgJ1NjcmlwdCddLCBbJ3NtYWxsLWNhcHMnLCAnU21hbGwgQ2FwcyddXVxuICB9LFxuXG4gIGZvbnRQZXJjZW50OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWZvbnQtcGVyY2VudCA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy1mb250LXNpemUtJXMnLFxuICAgIGxhYmVsOiAnRm9udCBTaXplJyxcbiAgICBvcHRpb25zOiBbWycwLjUwJywgJzUwJSddLCBbJzAuNzUnLCAnNzUlJ10sIFsnMS4wMCcsICcxMDAlJ10sIFsnMS4yNScsICcxMjUlJ10sIFsnMS41MCcsICcxNTAlJ10sIFsnMS43NScsICcxNzUlJ10sIFsnMi4wMCcsICcyMDAlJ10sIFsnMy4wMCcsICczMDAlJ10sIFsnNC4wMCcsICc0MDAlJ11dLFxuICAgICdkZWZhdWx0JzogMixcbiAgICBwYXJzZXI6IGZ1bmN0aW9uIHBhcnNlcih2KSB7XG4gICAgICByZXR1cm4gdiA9PT0gJzEuMDAnID8gbnVsbCA6IE51bWJlcih2KTtcbiAgICB9XG4gIH0sXG5cbiAgdGV4dE9wYWNpdHk6IHtcbiAgICBzZWxlY3RvcjogJy52anMtdGV4dC1vcGFjaXR5ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLWZvcmVncm91bmQtb3BhY2l0eS0lcycsXG4gICAgbGFiZWw6ICdUcmFuc3BhcmVuY3knLFxuICAgIG9wdGlvbnM6IFtPUEFDSVRZX09QQVFVRSwgT1BBQ0lUWV9TRU1JXVxuICB9LFxuXG4gIC8vIE9wdGlvbnMgZm9yIHRoaXMgb2JqZWN0IGFyZSBkZWZpbmVkIGJlbG93LlxuICB3aW5kb3dDb2xvcjoge1xuICAgIHNlbGVjdG9yOiAnLnZqcy13aW5kb3ctY29sb3IgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtd2luZG93LWNvbG9yLSVzJyxcbiAgICBsYWJlbDogJ0NvbG9yJ1xuICB9LFxuXG4gIC8vIE9wdGlvbnMgZm9yIHRoaXMgb2JqZWN0IGFyZSBkZWZpbmVkIGJlbG93LlxuICB3aW5kb3dPcGFjaXR5OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLXdpbmRvdy1vcGFjaXR5ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLXdpbmRvdy1vcGFjaXR5LSVzJyxcbiAgICBsYWJlbDogJ1RyYW5zcGFyZW5jeScsXG4gICAgb3B0aW9uczogW09QQUNJVFlfVFJBTlMsIE9QQUNJVFlfU0VNSSwgT1BBQ0lUWV9PUEFRVUVdXG4gIH1cbn07XG5cbnNlbGVjdENvbmZpZ3Mud2luZG93Q29sb3Iub3B0aW9ucyA9IHNlbGVjdENvbmZpZ3MuYmFja2dyb3VuZENvbG9yLm9wdGlvbnM7XG5cbi8qKlxuICogR2V0IHRoZSBhY3R1YWwgdmFsdWUgb2YgYW4gb3B0aW9uLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWVcbiAqICAgICAgICAgVGhlIHZhbHVlIHRvIGdldFxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbcGFyc2VyXVxuICogICAgICAgICBPcHRpb25hbCBmdW5jdGlvbiB0byBhZGp1c3QgdGhlIHZhbHVlLlxuICpcbiAqIEByZXR1cm4ge01peGVkfVxuICogICAgICAgICAtIFdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgbm8gdmFsdWUgZXhpc3RzXG4gKiAgICAgICAgIC0gV2lsbCBiZSBgdW5kZWZpbmVkYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgXCJub25lXCIuXG4gKiAgICAgICAgIC0gV2lsbCBiZSB0aGUgYWN0dWFsIHZhbHVlIG90aGVyd2lzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZU9wdGlvblZhbHVlKHZhbHVlLCBwYXJzZXIpIHtcbiAgaWYgKHBhcnNlcikge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNlbGVjdGVkIDxvcHRpb24+IGVsZW1lbnQgd2l0aGluIGEgPHNlbGVjdD4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogICAgICAgICB0aGUgZWxlbWVudCB0byBsb29rIGluXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IFtwYXJzZXJdXG4gKiAgICAgICAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFkanVzdCB0aGUgdmFsdWUuXG4gKlxuICogQHJldHVybiB7TWl4ZWR9XG4gKiAgICAgICAgIC0gV2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBleGlzdHNcbiAqICAgICAgICAgLSBXaWxsIGJlIGB1bmRlZmluZWRgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBcIm5vbmVcIi5cbiAqICAgICAgICAgLSBXaWxsIGJlIHRoZSBhY3R1YWwgdmFsdWUgb3RoZXJ3aXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoZWwsIHBhcnNlcikge1xuICB2YXIgdmFsdWUgPSBlbC5vcHRpb25zW2VsLm9wdGlvbnMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG5cbiAgcmV0dXJuIHBhcnNlT3B0aW9uVmFsdWUodmFsdWUsIHBhcnNlcik7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc2VsZWN0ZWQgPG9wdGlvbj4gZWxlbWVudCB3aXRoaW4gYSA8c2VsZWN0PiBlbGVtZW50IGJhc2VkIG9uIGFcbiAqIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byBsb29rIGluLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogICAgICAgIHRoZSBwcm9wZXJ0eSB0byBsb29rIG9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJzZXJdXG4gKiAgICAgICAgT3B0aW9uYWwgZnVuY3Rpb24gdG8gYWRqdXN0IHRoZSB2YWx1ZSBiZWZvcmUgY29tcGFyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGVkT3B0aW9uKGVsLCB2YWx1ZSwgcGFyc2VyKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFyc2VPcHRpb25WYWx1ZShlbC5vcHRpb25zW2ldLnZhbHVlLCBwYXJzZXIpID09PSB2YWx1ZSkge1xuICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYW5pcHVsYXRlIFRleHQgVHJhY2tzIHNldHRpbmdzLlxuICpcbiAqIEBleHRlbmRzIE1vZGFsRGlhbG9nXG4gKi9cblxudmFyIFRleHRUcmFja1NldHRpbmdzID0gZnVuY3Rpb24gKF9Nb2RhbERpYWxvZykge1xuICBpbmhlcml0cyhUZXh0VHJhY2tTZXR0aW5ncywgX01vZGFsRGlhbG9nKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrU2V0dGluZ3MocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrU2V0dGluZ3MpO1xuXG4gICAgb3B0aW9ucy50ZW1wb3JhcnkgPSBmYWxzZTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01vZGFsRGlhbG9nLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGVEaXNwbGF5ID0gYmluZChfdGhpcywgX3RoaXMudXBkYXRlRGlzcGxheSk7XG5cbiAgICAvLyBmaWxsIHRoZSBtb2RhbCBhbmQgcHJldGVuZCB3ZSBoYXZlIG9wZW5lZCBpdFxuICAgIF90aGlzLmZpbGwoKTtcbiAgICBfdGhpcy5oYXNCZWVuT3BlbmVkXyA9IF90aGlzLmhhc0JlZW5GaWxsZWRfID0gdHJ1ZTtcblxuICAgIF90aGlzLmVuZERpYWxvZyA9IGNyZWF0ZUVsKCdwJywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCcsXG4gICAgICB0ZXh0Q29udGVudDogX3RoaXMubG9jYWxpemUoJ0VuZCBvZiBkaWFsb2cgd2luZG93LicpXG4gICAgfSk7XG4gICAgX3RoaXMuZWwoKS5hcHBlbmRDaGlsZChfdGhpcy5lbmREaWFsb2cpO1xuXG4gICAgX3RoaXMuc2V0RGVmYXVsdHMoKTtcblxuICAgIC8vIEdyYWIgYHBlcnNpc3RUZXh0VHJhY2tTZXR0aW5nc2AgZnJvbSB0aGUgcGxheWVyIG9wdGlvbnMgaWYgbm90IHBhc3NlZCBpbiBjaGlsZCBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMucGVyc2lzdFRleHRUcmFja1NldHRpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIF90aGlzLm9wdGlvbnNfLnBlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncyA9IF90aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMucGVyc2lzdFRleHRUcmFja1NldHRpbmdzO1xuICAgIH1cblxuICAgIF90aGlzLm9uKF90aGlzLiQoJy52anMtZG9uZS1idXR0b24nKSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2F2ZVNldHRpbmdzKCk7XG4gICAgICBfdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMub24oX3RoaXMuJCgnLnZqcy1kZWZhdWx0LWJ1dHRvbicpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXREZWZhdWx0cygpO1xuICAgICAgX3RoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuXG4gICAgZWFjaChzZWxlY3RDb25maWdzLCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICBfdGhpcy5vbihfdGhpcy4kKGNvbmZpZy5zZWxlY3RvciksICdjaGFuZ2UnLCBfdGhpcy51cGRhdGVEaXNwbGF5KTtcbiAgICB9KTtcblxuICAgIGlmIChfdGhpcy5vcHRpb25zXy5wZXJzaXN0VGV4dFRyYWNrU2V0dGluZ3MpIHtcbiAgICAgIF90aGlzLnJlc3RvcmVTZXR0aW5ncygpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgPHNlbGVjdD4gZWxlbWVudCB3aXRoIGNvbmZpZ3VyZWQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiAgICAgICAgQ29uZmlndXJhdGlvbiBrZXkgdG8gdXNlIGR1cmluZyBjcmVhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEFuIEhUTUwgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbFNlbGVjdF8gPSBmdW5jdGlvbiBjcmVhdGVFbFNlbGVjdF8oa2V5KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgbGVnZW5kSWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnbGFiZWwnO1xuXG4gICAgdmFyIGNvbmZpZyA9IHNlbGVjdENvbmZpZ3Nba2V5XTtcbiAgICB2YXIgaWQgPSBjb25maWcuaWQucmVwbGFjZSgnJXMnLCB0aGlzLmlkXyk7XG5cbiAgICByZXR1cm4gWyc8JyArIHR5cGUgKyAnIGlkPVwiJyArIGlkICsgJ1wiIGNsYXNzPVwiJyArICh0eXBlID09PSAnbGFiZWwnID8gJ3Zqcy1sYWJlbCcgOiAnJykgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZShjb25maWcubGFiZWwpLCAnPC8nICsgdHlwZSArICc+JywgJzxzZWxlY3QgYXJpYS1sYWJlbGxlZGJ5PVwiJyArIGxlZ2VuZElkICsgJyAnICsgaWQgKyAnXCI+J10uY29uY2F0KGNvbmZpZy5vcHRpb25zLm1hcChmdW5jdGlvbiAobykge1xuICAgICAgdmFyIG9wdGlvbklkID0gaWQgKyAnLScgKyBvWzFdO1xuXG4gICAgICByZXR1cm4gWyc8b3B0aW9uIGlkPVwiJyArIG9wdGlvbklkICsgJ1wiIHZhbHVlPVwiJyArIG9bMF0gKyAnXCIgJywgJ2FyaWEtbGFiZWxsZWRieT1cIicgKyBsZWdlbmRJZCArICcgJyArIGlkICsgJyAnICsgb3B0aW9uSWQgKyAnXCI+JywgX3RoaXMyLmxvY2FsaXplKG9bMV0pLCAnPC9vcHRpb24+J10uam9pbignJyk7XG4gICAgfSkpLmNvbmNhdCgnPC9zZWxlY3Q+Jykuam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBmb3JlZ3JvdW5kIGNvbG9yIGVsZW1lbnQgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEFuIEhUTUwgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbEZnQ29sb3JfID0gZnVuY3Rpb24gY3JlYXRlRWxGZ0NvbG9yXygpIHtcbiAgICB2YXIgbGVnZW5kSWQgPSAnY2FwdGlvbnMtdGV4dC1sZWdlbmQtJyArIHRoaXMuaWRfO1xuXG4gICAgcmV0dXJuIFsnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWZnLWNvbG9yIHZqcy10cmFjay1zZXR0aW5nXCI+JywgJzxsZWdlbmQgaWQ9XCInICsgbGVnZW5kSWQgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnVGV4dCcpLCAnPC9sZWdlbmQ+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2NvbG9yJywgbGVnZW5kSWQpLCAnPHNwYW4gY2xhc3M9XCJ2anMtdGV4dC1vcGFjaXR5IHZqcy1vcGFjaXR5XCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ3RleHRPcGFjaXR5JywgbGVnZW5kSWQpLCAnPC9zcGFuPicsICc8L2ZpZWxkc2V0PiddLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYmFja2dyb3VuZCBjb2xvciBlbGVtZW50IGZvciB0aGUgY29tcG9uZW50XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBBbiBIVE1MIHN0cmluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxCZ0NvbG9yXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsQmdDb2xvcl8oKSB7XG4gICAgdmFyIGxlZ2VuZElkID0gJ2NhcHRpb25zLWJhY2tncm91bmQtJyArIHRoaXMuaWRfO1xuXG4gICAgcmV0dXJuIFsnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWJnLWNvbG9yIHZqcy10cmFjay1zZXR0aW5nXCI+JywgJzxsZWdlbmQgaWQ9XCInICsgbGVnZW5kSWQgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnQmFja2dyb3VuZCcpLCAnPC9sZWdlbmQ+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2JhY2tncm91bmRDb2xvcicsIGxlZ2VuZElkKSwgJzxzcGFuIGNsYXNzPVwidmpzLWJnLW9wYWNpdHkgdmpzLW9wYWNpdHlcIj4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygnYmFja2dyb3VuZE9wYWNpdHknLCBsZWdlbmRJZCksICc8L3NwYW4+JywgJzwvZmllbGRzZXQ+J10uam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB3aW5kb3cgY29sb3IgZWxlbWVudCBmb3IgdGhlIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgQW4gSFRNTCBzdHJpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNyZWF0ZUVsV2luQ29sb3JfID0gZnVuY3Rpb24gY3JlYXRlRWxXaW5Db2xvcl8oKSB7XG4gICAgdmFyIGxlZ2VuZElkID0gJ2NhcHRpb25zLXdpbmRvdy0nICsgdGhpcy5pZF87XG5cbiAgICByZXR1cm4gWyc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtd2luZG93LWNvbG9yIHZqcy10cmFjay1zZXR0aW5nXCI+JywgJzxsZWdlbmQgaWQ9XCInICsgbGVnZW5kSWQgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnV2luZG93JyksICc8L2xlZ2VuZD4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0Xygnd2luZG93Q29sb3InLCBsZWdlbmRJZCksICc8c3BhbiBjbGFzcz1cInZqcy13aW5kb3ctb3BhY2l0eSB2anMtb3BhY2l0eVwiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCd3aW5kb3dPcGFjaXR5JywgbGVnZW5kSWQpLCAnPC9zcGFuPicsICc8L2ZpZWxkc2V0PiddLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgY29sb3IgZWxlbWVudHMgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNyZWF0ZUVsQ29sb3JzXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsQ29sb3JzXygpIHtcbiAgICByZXR1cm4gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10cmFjay1zZXR0aW5ncy1jb2xvcnMnLFxuICAgICAgaW5uZXJIVE1MOiBbdGhpcy5jcmVhdGVFbEZnQ29sb3JfKCksIHRoaXMuY3JlYXRlRWxCZ0NvbG9yXygpLCB0aGlzLmNyZWF0ZUVsV2luQ29sb3JfKCldLmpvaW4oJycpXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBmb250IGVsZW1lbnRzIGZvciB0aGUgY29tcG9uZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxGb250XyA9IGZ1bmN0aW9uIGNyZWF0ZUVsRm9udF8oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdHJhY2stc2V0dGluZ3MtZm9udFwiPicsXG4gICAgICBpbm5lckhUTUw6IFsnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWZvbnQtcGVyY2VudCB2anMtdHJhY2stc2V0dGluZ1wiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCdmb250UGVyY2VudCcsICcnLCAnbGVnZW5kJyksICc8L2ZpZWxkc2V0PicsICc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtZWRnZS1zdHlsZSB2anMtdHJhY2stc2V0dGluZ1wiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCdlZGdlU3R5bGUnLCAnJywgJ2xlZ2VuZCcpLCAnPC9maWVsZHNldD4nLCAnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWZvbnQtZmFtaWx5IHZqcy10cmFjay1zZXR0aW5nXCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2ZvbnRGYW1pbHknLCAnJywgJ2xlZ2VuZCcpLCAnPC9maWVsZHNldD4nXS5qb2luKCcnKVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgY29udHJvbHMgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbENvbnRyb2xzXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsQ29udHJvbHNfKCkge1xuICAgIHZhciBkZWZhdWx0c0Rlc2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6ZSgncmVzdG9yZSBhbGwgc2V0dGluZ3MgdG8gdGhlIGRlZmF1bHQgdmFsdWVzJyk7XG5cbiAgICByZXR1cm4gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10cmFjay1zZXR0aW5ncy1jb250cm9scycsXG4gICAgICBpbm5lckhUTUw6IFsnPGJ1dHRvbiBjbGFzcz1cInZqcy1kZWZhdWx0LWJ1dHRvblwiIHRpdGxlPVwiJyArIGRlZmF1bHRzRGVzY3JpcHRpb24gKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnUmVzZXQnKSwgJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPiAnICsgZGVmYXVsdHNEZXNjcmlwdGlvbiArICc8L3NwYW4+JywgJzwvYnV0dG9uPicsICc8YnV0dG9uIGNsYXNzPVwidmpzLWRvbmUtYnV0dG9uXCI+JyArIHRoaXMubG9jYWxpemUoJ0RvbmUnKSArICc8L2J1dHRvbj4nXS5qb2luKCcnKVxuICAgIH0pO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICByZXR1cm4gW3RoaXMuY3JlYXRlRWxDb2xvcnNfKCksIHRoaXMuY3JlYXRlRWxGb250XygpLCB0aGlzLmNyZWF0ZUVsQ29udHJvbHNfKCldO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uIGxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKCdDYXB0aW9uIFNldHRpbmdzIERpYWxvZycpO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKCdCZWdpbm5pbmcgb2YgZGlhbG9nIHdpbmRvdy4gRXNjYXBlIHdpbGwgY2FuY2VsIGFuZCBjbG9zZSB0aGUgd2luZG93LicpO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gX01vZGFsRGlhbG9nLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcykgKyAnIHZqcy10ZXh0LXRyYWNrLXNldHRpbmdzJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3Qgb2YgdGV4dCB0cmFjayBzZXR0aW5ncyAob3IgbnVsbCkuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBBbiBvYmplY3Qgd2l0aCBjb25maWcgdmFsdWVzIHBhcnNlZCBmcm9tIHRoZSBET00gb3IgbG9jYWxTdG9yYWdlLlxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiBnZXRWYWx1ZXMoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICByZXR1cm4gcmVkdWNlKHNlbGVjdENvbmZpZ3MsIGZ1bmN0aW9uIChhY2N1bSwgY29uZmlnLCBrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoX3RoaXMzLiQoY29uZmlnLnNlbGVjdG9yKSwgY29uZmlnLnBhcnNlcik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFjY3VtW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0ZXh0IHRyYWNrIHNldHRpbmdzIGZyb20gYW4gb2JqZWN0IG9mIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlc1xuICAgKiAgICAgICAgQW4gb2JqZWN0IHdpdGggY29uZmlnIHZhbHVlcyBwYXJzZWQgZnJvbSB0aGUgRE9NIG9yIGxvY2FsU3RvcmFnZS5cbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gc2V0VmFsdWVzKHZhbHVlcykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgZWFjaChzZWxlY3RDb25maWdzLCBmdW5jdGlvbiAoY29uZmlnLCBrZXkpIHtcbiAgICAgIHNldFNlbGVjdGVkT3B0aW9uKF90aGlzNC4kKGNvbmZpZy5zZWxlY3RvciksIHZhbHVlc1trZXldLCBjb25maWcucGFyc2VyKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhbGwgYDxzZWxlY3Q+YCBlbGVtZW50cyB0byB0aGVpciBkZWZhdWx0IHZhbHVlcy5cbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiBzZXREZWZhdWx0cygpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIGVhY2goc2VsZWN0Q29uZmlncywgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgdmFyIGluZGV4ID0gY29uZmlnLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBjb25maWdbJ2RlZmF1bHQnXSA6IDA7XG5cbiAgICAgIF90aGlzNS4kKGNvbmZpZy5zZWxlY3Rvcikuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXN0b3JlIHRleHR0cmFjayBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5yZXN0b3JlU2V0dGluZ3MgPSBmdW5jdGlvbiByZXN0b3JlU2V0dGluZ3MoKSB7XG4gICAgdmFyIHZhbHVlcyA9IHZvaWQgMDtcblxuICAgIHRyeSB7XG4gICAgICB2YWx1ZXMgPSBKU09OLnBhcnNlKHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nJDEud2FybihlcnIpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKHZhbHVlcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTYXZlIHRleHQgdHJhY2sgc2V0dGluZ3MgdG8gbG9jYWxTdG9yYWdlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLnNhdmVTZXR0aW5ncyA9IGZ1bmN0aW9uIHNhdmVTZXR0aW5ncygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9uc18ucGVyc2lzdFRleHRUcmFja1NldHRpbmdzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkodmFsdWVzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oTE9DQUxfU1RPUkFHRV9LRVkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nJDEud2FybihlcnIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGRpc3BsYXkgb2YgdGV4dCB0cmFjayBzZXR0aW5nc1xuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5ID0gZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICB2YXIgdHREaXNwbGF5ID0gdGhpcy5wbGF5ZXJfLmdldENoaWxkKCd0ZXh0VHJhY2tEaXNwbGF5Jyk7XG5cbiAgICBpZiAodHREaXNwbGF5KSB7XG4gICAgICB0dERpc3BsYXkudXBkYXRlRGlzcGxheSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogY29uZGl0aW9uYWxseSBibHVyIHRoZSBlbGVtZW50IGFuZCByZWZvY3VzIHRoZSBjYXB0aW9ucyBidXR0b25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY29uZGl0aW9uYWxCbHVyXyA9IGZ1bmN0aW9uIGNvbmRpdGlvbmFsQmx1cl8oKSB7XG4gICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gbnVsbDtcbiAgICB0aGlzLm9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuXG4gICAgdmFyIGNiID0gdGhpcy5wbGF5ZXJfLmNvbnRyb2xCYXI7XG4gICAgdmFyIHN1YnNDYXBzQnRuID0gY2IgJiYgY2Iuc3Vic0NhcHNCdXR0b247XG4gICAgdmFyIGNjQnRuID0gY2IgJiYgY2IuY2FwdGlvbnNCdXR0b247XG5cbiAgICBpZiAoc3Vic0NhcHNCdG4pIHtcbiAgICAgIHN1YnNDYXBzQnRuLmZvY3VzKCk7XG4gICAgfSBlbHNlIGlmIChjY0J0bikge1xuICAgICAgY2NCdG4uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja1NldHRpbmdzO1xufShNb2RhbERpYWxvZyk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGV4dFRyYWNrU2V0dGluZ3MnLCBUZXh0VHJhY2tTZXR0aW5ncyk7XG5cbnZhciBfdGVtcGxhdGVPYmplY3QkMiA9IHRhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFsnVGV4dCBUcmFja3MgYXJlIGJlaW5nIGxvYWRlZCBmcm9tIGFub3RoZXIgb3JpZ2luIGJ1dCB0aGUgY3Jvc3NvcmlnaW4gYXR0cmlidXRlIGlzblxcJ3QgdXNlZC5cXG4gICAgICAgICAgICBUaGlzIG1heSBwcmV2ZW50IHRleHQgdHJhY2tzIGZyb20gbG9hZGluZy4nXSwgWydUZXh0IFRyYWNrcyBhcmUgYmVpbmcgbG9hZGVkIGZyb20gYW5vdGhlciBvcmlnaW4gYnV0IHRoZSBjcm9zc29yaWdpbiBhdHRyaWJ1dGUgaXNuXFwndCB1c2VkLlxcbiAgICAgICAgICAgIFRoaXMgbWF5IHByZXZlbnQgdGV4dCB0cmFja3MgZnJvbSBsb2FkaW5nLiddKTtcblxuLyoqXG4gKiBAZmlsZSBodG1sNS5qc1xuICovXG4vKipcbiAqIEhUTUw1IE1lZGlhIENvbnRyb2xsZXIgLSBXcmFwcGVyIGZvciBIVE1MNSBNZWRpYSBBUElcbiAqXG4gKiBAbWl4ZXMgVGVjaH5Tb3VjZUhhbmRsZXJBZGRpdGlvbnNcbiAqIEBleHRlbmRzIFRlY2hcbiAqL1xuXG52YXIgSHRtbDUgPSBmdW5jdGlvbiAoX1RlY2gpIHtcbiAgaW5oZXJpdHMoSHRtbDUsIF9UZWNoKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgVGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gcmVhZHlcbiAgICogICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgYEhUTUw1YCBUZWNoIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gSHRtbDUob3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sNSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZWNoLmNhbGwodGhpcywgb3B0aW9ucywgcmVhZHkpKTtcblxuICAgIHZhciBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcbiAgICB2YXIgY3Jvc3NvcmlnaW5UcmFja3MgPSBmYWxzZTtcblxuICAgIC8vIFNldCB0aGUgc291cmNlIGlmIG9uZSBpcyBwcm92aWRlZFxuICAgIC8vIDEpIENoZWNrIGlmIHRoZSBzb3VyY2UgaXMgbmV3IChpZiBub3QsIHdlIHdhbnQgdG8ga2VlcCB0aGUgb3JpZ2luYWwgc28gcGxheWJhY2sgaXNuJ3QgaW50ZXJydXB0ZWQpXG4gICAgLy8gMikgQ2hlY2sgdG8gc2VlIGlmIHRoZSBuZXR3b3JrIHN0YXRlIG9mIHRoZSB0YWcgd2FzIGZhaWxlZCBhdCBpbml0LCBhbmQgaWYgc28sIHJlc2V0IHRoZSBzb3VyY2VcbiAgICAvLyBhbnl3YXkgc28gdGhlIGVycm9yIGdldHMgZmlyZWQuXG4gICAgaWYgKHNvdXJjZSAmJiAoX3RoaXMuZWxfLmN1cnJlbnRTcmMgIT09IHNvdXJjZS5zcmMgfHwgb3B0aW9ucy50YWcgJiYgb3B0aW9ucy50YWcuaW5pdE5ldHdvcmtTdGF0ZV8gPT09IDMpKSB7XG4gICAgICBfdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuaGFuZGxlTGF0ZUluaXRfKF90aGlzLmVsXyk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmVsXy5oYXNDaGlsZE5vZGVzKCkpIHtcblxuICAgICAgdmFyIG5vZGVzID0gX3RoaXMuZWxfLmNoaWxkTm9kZXM7XG4gICAgICB2YXIgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgcmVtb3ZlTm9kZXMgPSBbXTtcblxuICAgICAgd2hpbGUgKG5vZGVzTGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tub2Rlc0xlbmd0aF07XG4gICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICd0cmFjaycpIHtcbiAgICAgICAgICBpZiAoIV90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgICAgICAgLy8gRW1wdHkgdmlkZW8gdGFnIHRyYWNrcyBzbyB0aGUgYnVpbHQtaW4gcGxheWVyIGRvZXNuJ3QgdXNlIHRoZW0gYWxzby5cbiAgICAgICAgICAgIC8vIFRoaXMgbWF5IG5vdCBiZSBmYXN0IGVub3VnaCB0byBzdG9wIEhUTUw1IGJyb3dzZXJzIGZyb20gcmVhZGluZyB0aGUgdGFnc1xuICAgICAgICAgICAgLy8gc28gd2UnbGwgbmVlZCB0byB0dXJuIG9mZiBhbnkgZGVmYXVsdCB0cmFja3MgaWYgd2UncmUgbWFudWFsbHkgZG9pbmdcbiAgICAgICAgICAgIC8vIGNhcHRpb25zIGFuZCBzdWJ0aXRsZXMuIHZpZGVvRWxlbWVudC50ZXh0VHJhY2tzXG4gICAgICAgICAgICByZW1vdmVOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzdG9yZSBIVE1MVHJhY2tFbGVtZW50IGFuZCBUZXh0VHJhY2sgdG8gcmVtb3RlIGxpc3RcbiAgICAgICAgICAgIF90aGlzLnJlbW90ZVRleHRUcmFja0VscygpLmFkZFRyYWNrRWxlbWVudF8obm9kZSk7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkuYWRkVHJhY2sobm9kZS50cmFjayk7XG4gICAgICAgICAgICBfdGhpcy50ZXh0VHJhY2tzKCkuYWRkVHJhY2sobm9kZS50cmFjayk7XG4gICAgICAgICAgICBpZiAoIWNyb3Nzb3JpZ2luVHJhY2tzICYmICFfdGhpcy5lbF8uaGFzQXR0cmlidXRlKCdjcm9zc29yaWdpbicpICYmIGlzQ3Jvc3NPcmlnaW4obm9kZS5zcmMpKSB7XG4gICAgICAgICAgICAgIGNyb3Nzb3JpZ2luVHJhY2tzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdmVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfdGhpcy5lbF8ucmVtb3ZlQ2hpbGQocmVtb3ZlTm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzLnByb3h5TmF0aXZlVHJhY2tzXygpO1xuICAgIGlmIChfdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgJiYgY3Jvc3NvcmlnaW5UcmFja3MpIHtcbiAgICAgIGxvZyQxLndhcm4odHNtbChfdGVtcGxhdGVPYmplY3QkMikpO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBpZiBuYXRpdmUgY29udHJvbHMgc2hvdWxkIGJlIHVzZWRcbiAgICAvLyBPdXIgZ29hbCBzaG91bGQgYmUgdG8gZ2V0IHRoZSBjdXN0b20gY29udHJvbHMgb24gbW9iaWxlIHNvbGlkIGV2ZXJ5d2hlcmVcbiAgICAvLyBzbyB3ZSBjYW4gcmVtb3ZlIHRoaXMgYWxsIHRvZ2V0aGVyLiBSaWdodCBub3cgdGhpcyB3aWxsIGJsb2NrIGN1c3RvbVxuICAgIC8vIGNvbnRyb2xzIG9uIHRvdWNoIGVuYWJsZWQgbGFwdG9wcyBsaWtlIHRoZSBDaHJvbWUgUGl4ZWxcbiAgICBpZiAoKFRPVUNIX0VOQUJMRUQgfHwgSVNfSVBIT05FIHx8IElTX05BVElWRV9BTkRST0lEKSAmJiBvcHRpb25zLm5hdGl2ZUNvbnRyb2xzRm9yVG91Y2ggPT09IHRydWUpIHtcbiAgICAgIF90aGlzLnNldENvbnRyb2xzKHRydWUpO1xuICAgIH1cblxuICAgIC8vIG9uIGlPUywgd2Ugd2FudCB0byBwcm94eSBgd2Via2l0YmVnaW5mdWxsc2NyZWVuYCBhbmQgYHdlYmtpdGVuZGZ1bGxzY3JlZW5gXG4gICAgLy8gaW50byBhIGBmdWxsc2NyZWVuY2hhbmdlYCBldmVudFxuICAgIF90aGlzLnByb3h5V2Via2l0RnVsbHNjcmVlbl8oKTtcblxuICAgIF90aGlzLnRyaWdnZXJSZWFkeSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIGBIVE1MNWAgbWVkaWEgZWxlbWVudCBhbmQgcmVtb3ZlIGFsbCB0cmFja3MuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIEh0bWw1LmRpc3Bvc2VNZWRpYUVsZW1lbnQodGhpcy5lbF8pO1xuICAgIC8vIHRlY2ggd2lsbCBoYW5kbGUgY2xlYXJpbmcgb2YgdGhlIGVtdWxhdGVkIHRyYWNrIGxpc3RcbiAgICBfVGVjaC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm94eSBhbGwgbmF0aXZlIHRyYWNrIGxpc3QgZXZlbnRzIHRvIG91ciB0cmFjayBsaXN0cyBpZiB0aGUgYnJvd3NlciB3ZSBhcmUgcGxheWluZ1xuICAgKiBpbiBzdXBwb3J0cyB0aGF0IHR5cGUgb2YgdHJhY2sgbGlzdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucHJveHlOYXRpdmVUcmFja3NfID0gZnVuY3Rpb24gcHJveHlOYXRpdmVUcmFja3NfKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgTk9STUFMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBwcm9wcyA9IE5PUk1BTFtuYW1lXTtcbiAgICAgIHZhciBlbFRyYWNrcyA9IF90aGlzMi5lbCgpW3Byb3BzLmdldHRlck5hbWVdO1xuICAgICAgdmFyIHRlY2hUcmFja3MgPSBfdGhpczJbcHJvcHMuZ2V0dGVyTmFtZV0oKTtcblxuICAgICAgaWYgKCFfdGhpczJbJ2ZlYXR1cmVzTmF0aXZlJyArIHByb3BzLmNhcGl0YWxOYW1lICsgJ1RyYWNrcyddIHx8ICFlbFRyYWNrcyB8fCAhZWxUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbGlzdGVuZXJzID0ge1xuICAgICAgICBjaGFuZ2U6IGZ1bmN0aW9uIGNoYW5nZShlKSB7XG4gICAgICAgICAgdGVjaFRyYWNrcy50cmlnZ2VyKHtcbiAgICAgICAgICAgIHR5cGU6ICdjaGFuZ2UnLFxuICAgICAgICAgICAgdGFyZ2V0OiB0ZWNoVHJhY2tzLFxuICAgICAgICAgICAgY3VycmVudFRhcmdldDogdGVjaFRyYWNrcyxcbiAgICAgICAgICAgIHNyY0VsZW1lbnQ6IHRlY2hUcmFja3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkdHJhY2s6IGZ1bmN0aW9uIGFkZHRyYWNrKGUpIHtcbiAgICAgICAgICB0ZWNoVHJhY2tzLmFkZFRyYWNrKGUudHJhY2spO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmV0cmFjazogZnVuY3Rpb24gcmVtb3ZldHJhY2soZSkge1xuICAgICAgICAgIHRlY2hUcmFja3MucmVtb3ZlVHJhY2soZS50cmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgcmVtb3ZlT2xkVHJhY2tzID0gZnVuY3Rpb24gcmVtb3ZlT2xkVHJhY2tzKCkge1xuICAgICAgICB2YXIgcmVtb3ZlVHJhY2tzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZWNoVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsVHJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoZWxUcmFja3Nbal0gPT09IHRlY2hUcmFja3NbaV0pIHtcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICByZW1vdmVUcmFja3MucHVzaCh0ZWNoVHJhY2tzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocmVtb3ZlVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIHRlY2hUcmFja3MucmVtb3ZlVHJhY2socmVtb3ZlVHJhY2tzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBPYmplY3Qua2V5cyhsaXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbZXZlbnROYW1lXTtcblxuICAgICAgICBlbFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICBfdGhpczIub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlbFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW1vdmUgKG5hdGl2ZSkgdHJhY2tzIHRoYXQgYXJlIG5vdCB1c2VkIGFueW1vcmVcbiAgICAgIF90aGlzMi5vbignbG9hZHN0YXJ0JywgcmVtb3ZlT2xkVHJhY2tzKTtcbiAgICAgIF90aGlzMi5vbignZGlzcG9zZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIub2ZmKCdsb2Fkc3RhcnQnLCByZW1vdmVPbGRUcmFja3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYEh0bWw1YCBUZWNoJ3MgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5vcHRpb25zXy50YWc7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgbW92aW5nIHRoZSBlbGVtZW50IGludG8gdGhlIGJveC5cbiAgICAvLyBPbiB0aGUgaVBob25lIHZpZGVvIHdpbGwgYnJlYWsgaWYgeW91IG1vdmUgdGhlIGVsZW1lbnQsXG4gICAgLy8gU28gd2UgaGF2ZSB0byBjcmVhdGUgYSBicmFuZCBuZXcgZWxlbWVudC5cbiAgICAvLyBJZiB3ZSBpbmdlc3RlZCB0aGUgcGxheWVyIGRpdiwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSB0aGUgbWVkaWEgZWxlbWVudC5cbiAgICBpZiAoIWVsIHx8ICEodGhpcy5vcHRpb25zXy5wbGF5ZXJFbEluZ2VzdCB8fCB0aGlzLm1vdmluZ01lZGlhRWxlbWVudEluRE9NKSkge1xuXG4gICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgdGFnIGlzIHN0aWxsIHRoZXJlLCBjbG9uZSBhbmQgcmVtb3ZlIGl0LlxuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lLCBlbCk7XG4gICAgICAgIH1cbiAgICAgICAgSHRtbDUuZGlzcG9zZU1lZGlhRWxlbWVudChlbCk7XG4gICAgICAgIGVsID0gY2xvbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgdXNlZFxuICAgICAgICB2YXIgdGFnQXR0cmlidXRlcyA9IHRoaXMub3B0aW9uc18udGFnICYmIGdldEF0dHJpYnV0ZXModGhpcy5vcHRpb25zXy50YWcpO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IG1lcmdlT3B0aW9ucyh7fSwgdGFnQXR0cmlidXRlcyk7XG5cbiAgICAgICAgaWYgKCFUT1VDSF9FTkFCTEVEIHx8IHRoaXMub3B0aW9uc18ubmF0aXZlQ29udHJvbHNGb3JUb3VjaCAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmNvbnRyb2xzO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0QXR0cmlidXRlcyhlbCwgYXNzaWduKGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICBpZDogdGhpcy5vcHRpb25zXy50ZWNoSWQsXG4gICAgICAgICAgJ2NsYXNzJzogJ3Zqcy10ZWNoJ1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGVsLnBsYXllcklkID0gdGhpcy5vcHRpb25zXy5wbGF5ZXJJZDtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc3BlY2lmaWMgdGFnIHNldHRpbmdzLCBpbiBjYXNlIHRoZXkgd2VyZSBvdmVycmlkZGVuXG4gICAgdmFyIHNldHRpbmdzQXR0cnMgPSBbJ2F1dG9wbGF5JywgJ3ByZWxvYWQnLCAnbG9vcCcsICdtdXRlZCcsICdwbGF5c2lubGluZSddO1xuXG4gICAgZm9yICh2YXIgaSA9IHNldHRpbmdzQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhdHRyID0gc2V0dGluZ3NBdHRyc1tpXTtcbiAgICAgIHZhciBvdmVyd3JpdGVBdHRycyA9IHt9O1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc19bYXR0cl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG92ZXJ3cml0ZUF0dHJzW2F0dHJdID0gdGhpcy5vcHRpb25zX1thdHRyXTtcbiAgICAgIH1cbiAgICAgIHNldEF0dHJpYnV0ZXMoZWwsIG92ZXJ3cml0ZUF0dHJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCBiZSB0cmlnZ2VyZWQgaWYgdGhlIGxvYWRzdGFydCBldmVudCBoYXMgYWxyZWFkeSBmaXJlZCwgYmVmb3JlIHZpZGVvanMgd2FzXG4gICAqIHJlYWR5LiBUd28ga25vd24gZXhhbXBsZXMgb2Ygd2hlbiB0aGlzIGNhbiBoYXBwZW4gYXJlOlxuICAgKiAxLiBJZiB3ZSdyZSBsb2FkaW5nIHRoZSBwbGF5YmFjayBvYmplY3QgYWZ0ZXIgaXQgaGFzIHN0YXJ0ZWQgbG9hZGluZ1xuICAgKiAyLiBUaGUgbWVkaWEgaXMgYWxyZWFkeSBwbGF5aW5nIHRoZSAob2Z0ZW4gd2l0aCBhdXRvcGxheSBvbikgdGhlblxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgZmlyZSBhbm90aGVyIGxvYWRzdGFydCBzbyB0aGF0IHZpZGVvanMgY2FuIGNhdGNodXAuXG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI2xvYWRzdGFydFxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqICAgICAgICAgcmV0dXJucyBub3RoaW5nLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5oYW5kbGVMYXRlSW5pdF8gPSBmdW5jdGlvbiBoYW5kbGVMYXRlSW5pdF8oZWwpIHtcbiAgICBpZiAoZWwubmV0d29ya1N0YXRlID09PSAwIHx8IGVsLm5ldHdvcmtTdGF0ZSA9PT0gMykge1xuICAgICAgLy8gVGhlIHZpZGVvIGVsZW1lbnQgaGFzbid0IHN0YXJ0ZWQgbG9hZGluZyB0aGUgc291cmNlIHlldFxuICAgICAgLy8gb3IgZGlkbid0IGZpbmQgYSBzb3VyY2VcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwucmVhZHlTdGF0ZSA9PT0gMCkge1xuICAgICAgLy8gTmV0d29ya1N0YXRlIGlzIHNldCBzeW5jaHJvbm91c2x5IEJVVCBsb2Fkc3RhcnQgaXMgZmlyZWQgYXQgdGhlXG4gICAgICAvLyBlbmQgb2YgdGhlIGN1cnJlbnQgc3RhY2ssIHVzdWFsbHkgYmVmb3JlIHNldEludGVydmFsKGZuLCAwKS5cbiAgICAgIC8vIFNvIGF0IHRoaXMgcG9pbnQgd2Uga25vdyBsb2Fkc3RhcnQgbWF5IGhhdmUgYWxyZWFkeSBmaXJlZCBvciBpc1xuICAgICAgLy8gYWJvdXQgdG8gZmlyZSwgYW5kIGVpdGhlciB3YXkgdGhlIHBsYXllciBoYXNuJ3Qgc2VlbiBpdCB5ZXQuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGZpcmUgbG9hZHN0YXJ0IHByZW1hdHVyZWx5IGhlcmUgYW5kIGNhdXNlIGFcbiAgICAgIC8vIGRvdWJsZSBsb2Fkc3RhcnQgc28gd2UnbGwgd2FpdCBhbmQgc2VlIGlmIGl0IGhhcHBlbnMgYmV0d2VlbiBub3dcbiAgICAgIC8vIGFuZCB0aGUgbmV4dCBsb29wLCBhbmQgZmlyZSBpdCBpZiBub3QuXG4gICAgICAvLyBIT1dFVkVSLCB3ZSBhbHNvIHdhbnQgdG8gbWFrZSBzdXJlIGl0IGZpcmVzIGJlZm9yZSBsb2FkZWRtZXRhZGF0YVxuICAgICAgLy8gd2hpY2ggY291bGQgYWxzbyBoYXBwZW4gYmV0d2VlbiBub3cgYW5kIHRoZSBuZXh0IGxvb3AsIHNvIHdlJ2xsXG4gICAgICAvLyB3YXRjaCBmb3IgdGhhdCBhbHNvLlxuICAgICAgdmFyIGxvYWRzdGFydEZpcmVkID0gZmFsc2U7XG4gICAgICB2YXIgc2V0TG9hZHN0YXJ0RmlyZWQgPSBmdW5jdGlvbiBzZXRMb2Fkc3RhcnRGaXJlZCgpIHtcbiAgICAgICAgbG9hZHN0YXJ0RmlyZWQgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5vbignbG9hZHN0YXJ0Jywgc2V0TG9hZHN0YXJ0RmlyZWQpO1xuXG4gICAgICB2YXIgdHJpZ2dlckxvYWRzdGFydCA9IGZ1bmN0aW9uIHRyaWdnZXJMb2Fkc3RhcnQoKSB7XG4gICAgICAgIC8vIFdlIGRpZCBtaXNzIHRoZSBvcmlnaW5hbCBsb2Fkc3RhcnQuIE1ha2Ugc3VyZSB0aGUgcGxheWVyXG4gICAgICAgIC8vIHNlZXMgbG9hZHN0YXJ0IGJlZm9yZSBsb2FkZWRtZXRhZGF0YVxuICAgICAgICBpZiAoIWxvYWRzdGFydEZpcmVkKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vbignbG9hZGVkbWV0YWRhdGEnLCB0cmlnZ2VyTG9hZHN0YXJ0KTtcblxuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2ZmKCdsb2Fkc3RhcnQnLCBzZXRMb2Fkc3RhcnRGaXJlZCk7XG4gICAgICAgIHRoaXMub2ZmKCdsb2FkZWRtZXRhZGF0YScsIHRyaWdnZXJMb2Fkc3RhcnQpO1xuXG4gICAgICAgIGlmICghbG9hZHN0YXJ0RmlyZWQpIHtcbiAgICAgICAgICAvLyBXZSBkaWQgbWlzcyB0aGUgb3JpZ2luYWwgbmF0aXZlIGxvYWRzdGFydC4gRmlyZSBpdCBub3cuXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGcm9tIGhlcmUgb24gd2Uga25vdyB0aGF0IGxvYWRzdGFydCBhbHJlYWR5IGZpcmVkIGFuZCB3ZSBtaXNzZWQgaXQuXG4gICAgLy8gVGhlIG90aGVyIHJlYWR5U3RhdGUgZXZlbnRzIGFyZW4ndCBhcyBtdWNoIG9mIGEgcHJvYmxlbSBpZiB3ZSBkb3VibGVcbiAgICAvLyB0aGVtLCBzbyBub3QgZ29pbmcgdG8gZ28gdG8gYXMgbXVjaCB0cm91YmxlIGFzIGxvYWRzdGFydCB0byBwcmV2ZW50XG4gICAgLy8gdGhhdCB1bmxlc3Mgd2UgZmluZCByZWFzb24gdG8uXG4gICAgdmFyIGV2ZW50c1RvVHJpZ2dlciA9IFsnbG9hZHN0YXJ0J107XG5cbiAgICAvLyBsb2FkZWRtZXRhZGF0YTogbmV3bHkgZXF1YWwgdG8gSEFWRV9NRVRBREFUQSAoMSkgb3IgZ3JlYXRlclxuICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKCdsb2FkZWRtZXRhZGF0YScpO1xuXG4gICAgLy8gbG9hZGVkZGF0YTogbmV3bHkgaW5jcmVhc2VkIHRvIEhBVkVfQ1VSUkVOVF9EQVRBICgyKSBvciBncmVhdGVyXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2goJ2xvYWRlZGRhdGEnKTtcbiAgICB9XG5cbiAgICAvLyBjYW5wbGF5OiBuZXdseSBpbmNyZWFzZWQgdG8gSEFWRV9GVVRVUkVfREFUQSAoMykgb3IgZ3JlYXRlclxuICAgIGlmIChlbC5yZWFkeVN0YXRlID49IDMpIHtcbiAgICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKCdjYW5wbGF5Jyk7XG4gICAgfVxuXG4gICAgLy8gY2FucGxheXRocm91Z2g6IG5ld2x5IGVxdWFsIHRvIEhBVkVfRU5PVUdIX0RBVEEgKDQpXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPj0gNCkge1xuICAgICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2goJ2NhbnBsYXl0aHJvdWdoJyk7XG4gICAgfVxuXG4gICAgLy8gV2Ugc3RpbGwgbmVlZCB0byBnaXZlIHRoZSBwbGF5ZXIgdGltZSB0byBhZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICBldmVudHNUb1RyaWdnZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0aGlzLnRyaWdnZXIodHlwZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGN1cnJlbnQgdGltZSBmb3IgdGhlIGBIVE1MNWAgdGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHNcbiAgICogICAgICAgIFNldCB0aGUgY3VycmVudCB0aW1lIG9mIHRoZSBtZWRpYSB0byB0aGlzLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uIHNldEN1cnJlbnRUaW1lKHNlY29uZHMpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbF8uY3VycmVudFRpbWUgPSBzZWNvbmRzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZyQxKGUsICdWaWRlbyBpcyBub3QgcmVhZHkuIChWaWRlby5qcyknKTtcbiAgICAgIC8vIHRoaXMud2FybmluZyhWaWRlb0pTLndhcm5pbmdzLnZpZGVvTm90UmVhZHkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGR1cmF0aW9uIG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBtZWRpYSBvciAwIGlmIHRoZXJlIGlzIG5vIGR1cmF0aW9uLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgLy8gQW5kcm9pZCBDaHJvbWUgd2lsbCByZXBvcnQgZHVyYXRpb24gYXMgSW5maW5pdHkgZm9yIFZPRCBITFMgdW50aWwgYWZ0ZXJcbiAgICAvLyBwbGF5YmFjayBoYXMgc3RhcnRlZCwgd2hpY2ggdHJpZ2dlcnMgdGhlIGxpdmUgZGlzcGxheSBlcnJvbmVvdXNseS5cbiAgICAvLyBSZXR1cm4gTmFOIGlmIHBsYXliYWNrIGhhcyBub3Qgc3RhcnRlZCBhbmQgdHJpZ2dlciBhIGR1cmF0aW9udXBkYXRlIG9uY2VcbiAgICAvLyB0aGUgZHVyYXRpb24gY2FuIGJlIHJlbGlhYmx5IGtub3duLlxuICAgIGlmICh0aGlzLmVsXy5kdXJhdGlvbiA9PT0gSW5maW5pdHkgJiYgSVNfQU5EUk9JRCAmJiBJU19DSFJPTUUgJiYgdGhpcy5lbF8uY3VycmVudFRpbWUgPT09IDApIHtcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBmaXJzdCBgdGltZXVwZGF0ZWAgd2l0aCBjdXJyZW50VGltZSA+IDAgLSB0aGVyZSBtYXkgYmVcbiAgICAgIC8vIHNldmVyYWwgd2l0aCAwXG4gICAgICB2YXIgY2hlY2tQcm9ncmVzcyA9IGZ1bmN0aW9uIGNoZWNrUHJvZ3Jlc3MoKSB7XG4gICAgICAgIGlmIChfdGhpczMuZWxfLmN1cnJlbnRUaW1lID4gMCkge1xuICAgICAgICAgIC8vIFRyaWdnZXIgZHVyYXRpb25jaGFuZ2UgZm9yIGdlbnVpbmVseSBsaXZlIHZpZGVvXG4gICAgICAgICAgaWYgKF90aGlzMy5lbF8uZHVyYXRpb24gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICBfdGhpczMudHJpZ2dlcignZHVyYXRpb25jaGFuZ2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMzLm9mZigndGltZXVwZGF0ZScsIGNoZWNrUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uKCd0aW1ldXBkYXRlJywgY2hlY2tQcm9ncmVzcyk7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbF8uZHVyYXRpb24gfHwgTmFOO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIEhUTUw1IG1lZGlhIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgd2lkdGggb2YgdGhlIEhUTUw1IG1lZGlhIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfLm9mZnNldFdpZHRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGhlaWd0aCBvZiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5vZmZzZXRIZWlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3h5IGlPUyBgd2Via2l0YmVnaW5mdWxsc2NyZWVuYCBhbmQgYHdlYmtpdGVuZGZ1bGxzY3JlZW5gIGludG9cbiAgICogYGZ1bGxzY3JlZW5jaGFuZ2VgIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZmlyZXMgZnVsbHNjcmVlbmNoYW5nZVxuICAgKiBAbGlzdGVucyB3ZWJraXRlbmRmdWxsc2NyZWVuXG4gICAqIEBsaXN0ZW5zIHdlYmtpdGJlZ2luZnVsbHNjcmVlblxuICAgKiBAbGlzdGVucyB3ZWJraXRiZWdpbmZ1bGxzY3JlZW5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucHJveHlXZWJraXRGdWxsc2NyZWVuXyA9IGZ1bmN0aW9uIHByb3h5V2Via2l0RnVsbHNjcmVlbl8oKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAoISgnd2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW4nIGluIHRoaXMuZWxfKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbmRGbiA9IGZ1bmN0aW9uIGVuZEZuKCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJywgeyBpc0Z1bGxzY3JlZW46IGZhbHNlIH0pO1xuICAgIH07XG5cbiAgICB2YXIgYmVnaW5GbiA9IGZ1bmN0aW9uIGJlZ2luRm4oKSB7XG4gICAgICBpZiAoJ3dlYmtpdFByZXNlbnRhdGlvbk1vZGUnIGluIHRoaXMuZWxfICYmIHRoaXMuZWxfLndlYmtpdFByZXNlbnRhdGlvbk1vZGUgIT09ICdwaWN0dXJlLWluLXBpY3R1cmUnKSB7XG4gICAgICAgIHRoaXMub25lKCd3ZWJraXRlbmRmdWxsc2NyZWVuJywgZW5kRm4pO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScsIHsgaXNGdWxsc2NyZWVuOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uKCd3ZWJraXRiZWdpbmZ1bGxzY3JlZW4nLCBiZWdpbkZuKTtcbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXM0Lm9mZignd2Via2l0YmVnaW5mdWxsc2NyZWVuJywgYmVnaW5Gbik7XG4gICAgICBfdGhpczQub2ZmKCd3ZWJraXRlbmRmdWxsc2NyZWVuJywgZW5kRm4pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBmdWxsc2NyZWVuIGlzIHN1cHBvcnRlZCBvbiB0aGUgY3VycmVudCBwbGF5YmFjayBkZXZpY2UuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSBUcnVlIGlmIGZ1bGxzY3JlZW4gaXMgc3VwcG9ydGVkLlxuICAgKiAgICAgICAgIC0gRmFsc2UgaWYgZnVsbHNjcmVlbiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5zdXBwb3J0c0Z1bGxTY3JlZW4gPSBmdW5jdGlvbiBzdXBwb3J0c0Z1bGxTY3JlZW4oKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmVsXy53ZWJraXRFbnRlckZ1bGxTY3JlZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuXG4gICAgICAvLyBTZWVtcyB0byBiZSBicm9rZW4gaW4gQ2hyb21pdW0vQ2hyb21lICYmIFNhZmFyaSBpbiBMZW9wYXJkXG4gICAgICBpZiAoL0FuZHJvaWQvLnRlc3QodXNlckFnZW50KSB8fCAhL0Nocm9tZXxNYWMgT1MgWCAxMC41Ly50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVxdWVzdCB0aGF0IHRoZSBgSFRNTDVgIFRlY2ggZW50ZXIgZnVsbHNjcmVlbi5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuZW50ZXJGdWxsU2NyZWVuID0gZnVuY3Rpb24gZW50ZXJGdWxsU2NyZWVuKCkge1xuICAgIHZhciB2aWRlbyA9IHRoaXMuZWxfO1xuXG4gICAgaWYgKHZpZGVvLnBhdXNlZCAmJiB2aWRlby5uZXR3b3JrU3RhdGUgPD0gdmlkZW8uSEFWRV9NRVRBREFUQSkge1xuICAgICAgLy8gYXR0ZW1wdCB0byBwcmltZSB0aGUgdmlkZW8gZWxlbWVudCBmb3IgcHJvZ3JhbW1hdGljIGFjY2Vzc1xuICAgICAgLy8gdGhpcyBpc24ndCBuZWNlc3Nhcnkgb24gdGhlIGRlc2t0b3AgYnV0IHNob3VsZG4ndCBodXJ0XG4gICAgICB0aGlzLmVsXy5wbGF5KCk7XG5cbiAgICAgIC8vIHBsYXlpbmcgYW5kIHBhdXNpbmcgc3luY2hyb25vdXNseSBkdXJpbmcgdGhlIHRyYW5zaXRpb24gdG8gZnVsbHNjcmVlblxuICAgICAgLy8gY2FuIGdldCBpT1MgfjYuMSBkZXZpY2VzIGludG8gYSBwbGF5L3BhdXNlIGxvb3BcbiAgICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZpZGVvLnBhdXNlKCk7XG4gICAgICAgIHZpZGVvLndlYmtpdEVudGVyRnVsbFNjcmVlbigpO1xuICAgICAgfSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvLndlYmtpdEVudGVyRnVsbFNjcmVlbigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVxdWVzdCB0aGF0IHRoZSBgSFRNTDVgIFRlY2ggZXhpdCBmdWxsc2NyZWVuLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5leGl0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uIGV4aXRGdWxsU2NyZWVuKCkge1xuICAgIHRoaXMuZWxfLndlYmtpdEV4aXRGdWxsU2NyZWVuKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBIdG1sNWAgVGVjaCdzIHNvdXJjZSBvYmplY3QuXG4gICAqID4gTm90ZTogUGxlYXNlIHVzZSB7QGxpbmsgSHRtbDUjc2V0U291cmNlfVxuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBbc3JjXVxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3QgeW91IHdhbnQgdG8gc2V0IG9uIHRoZSBgSFRNTDVgIHRlY2hzIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1RlY2h+U291cmNlT2JqZWN0fHVuZGVmaW5lZH1cbiAgICogICAgICAgICAtIFRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3Qgd2hlbiBhIHNvdXJjZSBpcyBub3QgcGFzc2VkIGluLlxuICAgKiAgICAgICAgIC0gdW5kZWZpbmVkIHdoZW4gc2V0dGluZ1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2ZXJzaW9uIDUuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uIHNyYyhfc3JjKSB7XG4gICAgaWYgKF9zcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxfLnNyYztcbiAgICB9XG5cbiAgICAvLyBTZXR0aW5nIHNyYyB0aHJvdWdoIGBzcmNgIGluc3RlYWQgb2YgYHNldFNyY2Agd2lsbCBiZSBkZXByZWNhdGVkXG4gICAgdGhpcy5zZXRTcmMoX3NyYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSB0ZWNoIGJ5IHJlbW92aW5nIGFsbCBzb3VyY2VzIGFuZCB0aGVuIGNhbGxpbmdcbiAgICoge0BsaW5rIEh0bWw1LnJlc2V0TWVkaWFFbGVtZW50fS5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBIdG1sNS5yZXNldE1lZGlhRWxlbWVudCh0aGlzLmVsXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzb3VyY2Ugb24gdGhlIGBIVE1MNWAgVGVjaC4gRmFsbHMgYmFjayB0byByZXR1cm5pbmcgdGhlIHNvdXJjZSBmcm9tXG4gICAqIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0IGZyb20gdGhlIEhUTUw1IHRlY2guIFdpdGggYSBmYWxsYmFjayB0byB0aGVcbiAgICogICAgICAgICBlbGVtZW50cyBzb3VyY2UuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmN1cnJlbnRTcmMgPSBmdW5jdGlvbiBjdXJyZW50U3JjKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTb3VyY2VfKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50U291cmNlXy5zcmM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVsXy5jdXJyZW50U3JjO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgY29udHJvbHMgYXR0cmlidXRlIGZvciB0aGUgSFRNTDUgbWVkaWEgRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICAgKiAgICAgICAgVmFsdWUgdG8gc2V0IHRoZSBjb250cm9scyBhdHRyaWJ1dGUgdG9cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuc2V0Q29udHJvbHMgPSBmdW5jdGlvbiBzZXRDb250cm9scyh2YWwpIHtcbiAgICB0aGlzLmVsXy5jb250cm9scyA9ICEhdmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJldHVybnMgYSByZW1vdGUge0BsaW5rIFRleHRUcmFja30gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2luZFxuICAgKiAgICAgICAgYFRleHRUcmFja2Aga2luZCAoc3VidGl0bGVzLCBjYXB0aW9ucywgZGVzY3JpcHRpb25zLCBjaGFwdGVycywgb3IgbWV0YWRhdGEpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdXG4gICAqICAgICAgICBMYWJlbCB0byBpZGVudGlmeSB0aGUgdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlXVxuICAgKiAgICAgICAgVHdvIGxldHRlciBsYW5ndWFnZSBhYmJyZXZpYXRpb25cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrfVxuICAgKiAgICAgICAgIFRoZSBUZXh0VHJhY2sgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmFkZFRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICByZXR1cm4gX1RlY2gucHJvdG90eXBlLmFkZFRleHRUcmFjay5jYWxsKHRoaXMsIGtpbmQsIGxhYmVsLCBsYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZWxfLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGVpdGhlciBuYXRpdmUgVGV4dFRyYWNrIG9yIGFuIGVtdWxhdGVkIFRleHRUcmFjayBkZXBlbmRpbmdcbiAgICogb24gdGhlIHZhbHVlIG9mIGBmZWF0dXJlc05hdGl2ZVRleHRUcmFja3NgXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIHRoZSBvcHRpb25zIHRvIGludGlhbGl6ZSB0aGUgVGV4dFRyYWNrIHdpdGguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5raW5kXVxuICAgKiAgICAgICAgYFRleHRUcmFja2Aga2luZCAoc3VidGl0bGVzLCBjYXB0aW9ucywgZGVzY3JpcHRpb25zLCBjaGFwdGVycywgb3IgbWV0YWRhdGEpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWxdLlxuICAgKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlXVxuICAgKiAgICAgICAgVHdvIGxldHRlciBsYW5ndWFnZSBhYmJyZXZpYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVmYXVsdF1cbiAgICogICAgICAgIERlZmF1bHQgdGhpcyB0cmFjayB0byBvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkXVxuICAgKiAgICAgICAgVGhlIGludGVybmFsIGlkIHRvIGFzc2lnbiB0aGlzIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3JjXVxuICAgKiAgICAgICAgQSBzb3VyY2UgdXJsIGZvciB0aGUgdHJhY2suXG4gICAqXG4gICAqIEByZXR1cm4ge0hUTUxUcmFja0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIHRyYWNrIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmNyZWF0ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGNyZWF0ZVJlbW90ZVRleHRUcmFjayhvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgcmV0dXJuIF9UZWNoLnByb3RvdHlwZS5jcmVhdGVSZW1vdGVUZXh0VHJhY2suY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdmFyIGh0bWxUcmFja0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFjaycpO1xuXG4gICAgaWYgKG9wdGlvbnMua2luZCkge1xuICAgICAgaHRtbFRyYWNrRWxlbWVudC5raW5kID0gb3B0aW9ucy5raW5kO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sYWJlbCkge1xuICAgICAgaHRtbFRyYWNrRWxlbWVudC5sYWJlbCA9IG9wdGlvbnMubGFiZWw7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxhbmd1YWdlIHx8IG9wdGlvbnMuc3JjbGFuZykge1xuICAgICAgaHRtbFRyYWNrRWxlbWVudC5zcmNsYW5nID0gb3B0aW9ucy5sYW5ndWFnZSB8fCBvcHRpb25zLnNyY2xhbmc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zWydkZWZhdWx0J10pIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnRbJ2RlZmF1bHQnXSA9IG9wdGlvbnNbJ2RlZmF1bHQnXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQuaWQgPSBvcHRpb25zLmlkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zcmMpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQuc3JjID0gb3B0aW9ucy5zcmM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWxUcmFja0VsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZW1vdGUgdGV4dCB0cmFjayBvYmplY3QgYW5kIHJldHVybnMgYW4gaHRtbCB0cmFjayBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIHZhbHVlcyBmb3JcbiAgICoga2luZCwgbGFuZ3VhZ2UsIGxhYmVsLCBhbmQgc3JjIChsb2NhdGlvbiBvZiB0aGUgV2ViVlRUIGZpbGUpXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hbnVhbENsZWFudXA9dHJ1ZV0gaWYgc2V0IHRvIGZhbHNlLCB0aGUgVGV4dFRyYWNrIHdpbGwgYmVcbiAgICogYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQgd2hlbmV2ZXIgdGhlIHNvdXJjZSBjaGFuZ2VzXG4gICAqIEByZXR1cm4ge0hUTUxUcmFja0VsZW1lbnR9IEFuIEh0bWwgVHJhY2sgRWxlbWVudC5cbiAgICogVGhpcyBjYW4gYmUgYW4gZW11bGF0ZWQge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9IG9yIGEgbmF0aXZlIG9uZS5cbiAgICogQGRlcHJlY2F0ZWQgVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIFwibWFudWFsQ2xlYW51cFwiIHBhcmFtZXRlciB3aWxsIGRlZmF1bHRcbiAgICogdG8gXCJmYWxzZVwiIGluIHVwY29taW5nIHZlcnNpb25zIG9mIFZpZGVvLmpzXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFJlbW90ZVRleHRUcmFjayhvcHRpb25zLCBtYW51YWxDbGVhbnVwKSB7XG4gICAgdmFyIGh0bWxUcmFja0VsZW1lbnQgPSBfVGVjaC5wcm90b3R5cGUuYWRkUmVtb3RlVGV4dFRyYWNrLmNhbGwodGhpcywgb3B0aW9ucywgbWFudWFsQ2xlYW51cCk7XG5cbiAgICBpZiAodGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIHRoaXMuZWwoKS5hcHBlbmRDaGlsZChodG1sVHJhY2tFbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbFRyYWNrRWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHJlbW90ZSBgVGV4dFRyYWNrYCBmcm9tIGBUZXh0VHJhY2tMaXN0YCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBgVGV4dFRyYWNrYCBvYmplY3QgdG8gcmVtb3ZlXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnJlbW92ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjaykge1xuICAgIF9UZWNoLnByb3RvdHlwZS5yZW1vdmVSZW1vdGVUZXh0VHJhY2suY2FsbCh0aGlzLCB0cmFjayk7XG5cbiAgICBpZiAodGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIHZhciB0cmFja3MgPSB0aGlzLiQkKCd0cmFjaycpO1xuXG4gICAgICB2YXIgaSA9IHRyYWNrcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKHRyYWNrID09PSB0cmFja3NbaV0gfHwgdHJhY2sgPT09IHRyYWNrc1tpXS50cmFjaykge1xuICAgICAgICAgIHRoaXMuZWwoKS5yZW1vdmVDaGlsZCh0cmFja3NbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIGBwbGF5c2lubGluZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHBsYXlzaW5saW5lYCBpbmRpY2F0ZXNcbiAgICogdG8gdGhlIGJyb3dzZXIgdGhhdCBub24tZnVsbHNjcmVlbiBwbGF5YmFjayBpcyBwcmVmZXJyZWQgd2hlbiBmdWxsc2NyZWVuXG4gICAqIHBsYXliYWNrIGlzIHRoZSBuYXRpdmUgZGVmYXVsdCwgc3VjaCBhcyBpbiBpT1MgU2FmYXJpLlxuICAgKlxuICAgKiBAbWV0aG9kIEh0bWw1I3BsYXlzaW5saW5lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYHBsYXlzaW5saW5lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICAgKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgaW5saW5lLlxuICAgKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBub3QgcGxheSBpbmxpbmUuXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2F0dHItdmlkZW8tcGxheXNpbmxpbmV9XG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnBsYXlzaW5saW5lID0gZnVuY3Rpb24gcGxheXNpbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfLmhhc0F0dHJpYnV0ZSgncGxheXNpbmxpbmUnKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZSBvZiBgcGxheXNpbmxpbmVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwbGF5c2lubGluZWAgaW5kaWNhdGVzXG4gICAqIHRvIHRoZSBicm93c2VyIHRoYXQgbm9uLWZ1bGxzY3JlZW4gcGxheWJhY2sgaXMgcHJlZmVycmVkIHdoZW4gZnVsbHNjcmVlblxuICAgKiBwbGF5YmFjayBpcyB0aGUgbmF0aXZlIGRlZmF1bHQsIHN1Y2ggYXMgaW4gaU9TIFNhZmFyaS5cbiAgICpcbiAgICogQG1ldGhvZCBIdG1sNSNzZXRQbGF5c2lubGluZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBsYXlzaW5saW5lXG4gICAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgcGxheSBpbmxpbmUuXG4gICAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBwbGF5IGlubGluZS5cbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jYXR0ci12aWRlby1wbGF5c2lubGluZX1cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuc2V0UGxheXNpbmxpbmUgPSBmdW5jdGlvbiBzZXRQbGF5c2lubGluZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICdwbGF5c2lubGluZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsXy5yZW1vdmVBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGF2YWlsYWJsZSBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBXM0MncyBNZWRpYVxuICAgKiBQbGF5YmFjayBRdWFsaXR5IEFQSS5cbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9tZWRpYS1wbGF5YmFjay1xdWFsaXR5fVxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgQW4gb2JqZWN0IHdpdGggc3VwcG9ydGVkIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljc1xuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9IGZ1bmN0aW9uIGdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5lbCgpLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbCgpLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XG4gICAgfVxuXG4gICAgdmFyIHZpZGVvUGxheWJhY2tRdWFsaXR5ID0ge307XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuZWwoKS53ZWJraXREcm9wcGVkRnJhbWVDb3VudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXMuZWwoKS53ZWJraXREZWNvZGVkRnJhbWVDb3VudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LmRyb3BwZWRWaWRlb0ZyYW1lcyA9IHRoaXMuZWwoKS53ZWJraXREcm9wcGVkRnJhbWVDb3VudDtcbiAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMgPSB0aGlzLmVsKCkud2Via2l0RGVjb2RlZEZyYW1lQ291bnQ7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB0eXBlb2Ygd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmlkZW9QbGF5YmFja1F1YWxpdHkuY3JlYXRpb25UaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH0gZWxzZSBpZiAod2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS50aW1pbmcgJiYgdHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgdmlkZW9QbGF5YmFja1F1YWxpdHkuY3JlYXRpb25UaW1lID0gd2luZG93LkRhdGUubm93KCkgLSB3aW5kb3cucGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlkZW9QbGF5YmFja1F1YWxpdHk7XG4gIH07XG5cbiAgcmV0dXJuIEh0bWw1O1xufShUZWNoKTtcblxuLyogSFRNTDUgU3VwcG9ydCBUZXN0aW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuaWYgKGlzUmVhbCgpKSB7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgZm9yIHRlc3RpbmcgYnJvd3NlciBIVE1MNSBtZWRpYSBjYXBhYmlsaXRpZXNcbiAgICpcbiAgICogQHR5cGUge0VsZW1lbnR9XG4gICAqIEBjb25zdGFudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSHRtbDUuVEVTVF9WSUQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICB2YXIgdHJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFjaycpO1xuXG4gIHRyYWNrLmtpbmQgPSAnY2FwdGlvbnMnO1xuICB0cmFjay5zcmNsYW5nID0gJ2VuJztcbiAgdHJhY2subGFiZWwgPSAnRW5nbGlzaCc7XG4gIEh0bWw1LlRFU1RfVklELmFwcGVuZENoaWxkKHRyYWNrKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBIVE1MNSBtZWRpYSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyL2RldmljZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgSFRNTDUgbWVkaWEgaXMgc3VwcG9ydGVkLlxuICogICAgICAgICAtIEZhbHNlIGlmIEhUTUw1IG1lZGlhIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKi9cbkh0bWw1LmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAvLyBJRTkgd2l0aCBubyBNZWRpYSBQbGF5ZXIgaXMgYSBMSUFSISAoIzk4NClcbiAgdHJ5IHtcbiAgICBIdG1sNS5URVNUX1ZJRC52b2x1bWUgPSAwLjU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gISEoSHRtbDUuVEVTVF9WSUQgJiYgSHRtbDUuVEVTVF9WSUQuY2FuUGxheVR5cGUpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gdHlwZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gKi9cbkh0bWw1LmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgcmV0dXJuIEh0bWw1LlRFU1RfVklELmNhblBsYXlUeXBlKHR5cGUpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gc291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjT2JqXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB0ZWNoXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gKi9cbkh0bWw1LmNhblBsYXlTb3VyY2UgPSBmdW5jdGlvbiAoc3JjT2JqLCBvcHRpb25zKSB7XG4gIHJldHVybiBIdG1sNS5jYW5QbGF5VHlwZShzcmNPYmoudHlwZSk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB2b2x1bWUgY2FuIGJlIGNoYW5nZWQgaW4gdGhpcyBicm93c2VyL2RldmljZS5cbiAqIFZvbHVtZSBjYW5ub3QgYmUgY2hhbmdlZCBpbiBhIGxvdCBvZiBtb2JpbGUgZGV2aWNlcy5cbiAqIFNwZWNpZmljYWxseSwgaXQgY2FuJ3QgYmUgY2hhbmdlZCBmcm9tIDEgb24gaU9TLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB2b2x1bWUgY2FuIGJlIGNvbnRyb2xsZWRcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuY2FuQ29udHJvbFZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gSUUgd2lsbCBlcnJvciBpZiBXaW5kb3dzIE1lZGlhIFBsYXllciBub3QgaW5zdGFsbGVkICMzMzE1XG4gIHRyeSB7XG4gICAgdmFyIHZvbHVtZSA9IEh0bWw1LlRFU1RfVklELnZvbHVtZTtcblxuICAgIEh0bWw1LlRFU1RfVklELnZvbHVtZSA9IHZvbHVtZSAvIDIgKyAwLjE7XG4gICAgcmV0dXJuIHZvbHVtZSAhPT0gSHRtbDUuVEVTVF9WSUQudm9sdW1lO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwbGF5YmFjayByYXRlIGNhbiBiZSBjaGFuZ2VkIGluIHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHBsYXliYWNrIHJhdGUgY2FuIGJlIGNvbnRyb2xsZWRcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUGxheWJhY2sgcmF0ZSBBUEkgaXMgaW1wbGVtZW50ZWQgaW4gQW5kcm9pZCBDaHJvbWUsIGJ1dCBkb2Vzbid0IGRvIGFueXRoaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8zMTgwXG4gIGlmIChJU19BTkRST0lEICYmIElTX0NIUk9NRSAmJiBDSFJPTUVfVkVSU0lPTiA8IDU4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIElFIHdpbGwgZXJyb3IgaWYgV2luZG93cyBNZWRpYSBQbGF5ZXIgbm90IGluc3RhbGxlZCAjMzMxNVxuICB0cnkge1xuICAgIHZhciBwbGF5YmFja1JhdGUgPSBIdG1sNS5URVNUX1ZJRC5wbGF5YmFja1JhdGU7XG5cbiAgICBIdG1sNS5URVNUX1ZJRC5wbGF5YmFja1JhdGUgPSBwbGF5YmFja1JhdGUgLyAyICsgMC4xO1xuICAgIHJldHVybiBwbGF5YmFja1JhdGUgIT09IEh0bWw1LlRFU1RfVklELnBsYXliYWNrUmF0ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgbmF0aXZlIGBUZXh0VHJhY2tgcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIG5hdGl2ZSBgVGV4dFRyYWNrYHMgYXJlIHN1cHBvcnRlZC5cbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuc3VwcG9ydHNOYXRpdmVUZXh0VHJhY2tzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gSVNfQU5ZX1NBRkFSSTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIG5hdGl2ZSBgVmlkZW9UcmFja2BzIGFyZSBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyL2RldmljZVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgLSBUcnVlIGlmIG5hdGl2ZSBgVmlkZW9UcmFja2BzIGFyZSBzdXBwb3J0ZWQuXG4gKiAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuc3VwcG9ydHNOYXRpdmVWaWRlb1RyYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhKEh0bWw1LlRFU1RfVklEICYmIEh0bWw1LlRFU1RfVklELnZpZGVvVHJhY2tzKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIG5hdGl2ZSBgQXVkaW9UcmFja2BzIGFyZSBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyL2RldmljZVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgLSBUcnVlIGlmIG5hdGl2ZSBgQXVkaW9UcmFja2BzIGFyZSBzdXBwb3J0ZWQuXG4gKiAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuc3VwcG9ydHNOYXRpdmVBdWRpb1RyYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhKEh0bWw1LlRFU1RfVklEICYmIEh0bWw1LlRFU1RfVklELmF1ZGlvVHJhY2tzKTtcbn07XG5cbi8qKlxuICogQW4gYXJyYXkgb2YgZXZlbnRzIGF2YWlsYWJsZSBvbiB0aGUgSHRtbDUgdGVjaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge0FycmF5fVxuICovXG5IdG1sNS5FdmVudHMgPSBbJ2xvYWRzdGFydCcsICdzdXNwZW5kJywgJ2Fib3J0JywgJ2Vycm9yJywgJ2VtcHRpZWQnLCAnc3RhbGxlZCcsICdsb2FkZWRtZXRhZGF0YScsICdsb2FkZWRkYXRhJywgJ2NhbnBsYXknLCAnY2FucGxheXRocm91Z2gnLCAncGxheWluZycsICd3YWl0aW5nJywgJ3NlZWtpbmcnLCAnc2Vla2VkJywgJ2VuZGVkJywgJ2R1cmF0aW9uY2hhbmdlJywgJ3RpbWV1cGRhdGUnLCAncHJvZ3Jlc3MnLCAncGxheScsICdwYXVzZScsICdyYXRlY2hhbmdlJywgJ3Jlc2l6ZScsICd2b2x1bWVjaGFuZ2UnXTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHZvbHVtZSBjb250cm9sLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LmNhbkNvbnRyb2xWb2x1bWV9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wgPSBIdG1sNS5jYW5Db250cm9sVm9sdW1lKCk7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyBjaGFuZ2luZyB0aGUgc3BlZWQgYXQgd2hpY2ggdGhlIG1lZGlhXG4gKiBwbGF5cy4gRXhhbXBsZXM6XG4gKiAgIC0gU2V0IHBsYXllciB0byBwbGF5IDJ4ICh0d2ljZSkgYXMgZmFzdFxuICogICAtIFNldCBwbGF5ZXIgdG8gcGxheSAwLjV4IChoYWxmKSBhcyBmYXN0XG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdCB7QGxpbmsgSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZX1cbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzUGxheWJhY2tSYXRlID0gSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZSgpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIHRoZSBtZWRpYSBlbGVtZW50XG4gKiBtb3ZpbmcgaW4gdGhlIERPTS4gaU9TIGJyZWFrcyBpZiB5b3UgbW92ZSB0aGUgbWVkaWEgZWxlbWVudCwgc28gdGhpcyBpcyBzZXQgdGhpcyB0b1xuICogZmFsc2UgdGhlcmUuIEV2ZXJ5d2hlcmUgZWxzZSB0aGlzIHNob3VsZCBiZSB0cnVlLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuSHRtbDUucHJvdG90eXBlLm1vdmluZ01lZGlhRWxlbWVudEluRE9NID0gIUlTX0lPUztcblxuLy8gVE9ETzogUHJldmlvdXMgY29tbWVudDogTm8gbG9uZ2VyIGFwcGVhcnMgdG8gYmUgdXNlZC4gQ2FuIHByb2JhYmx5IGJlIHJlbW92ZWQuXG4vLyAgICAgICBJcyB0aGlzIHRydWU/XG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIGF1dG9tYXRpYyBtZWRpYSByZXNpemVcbiAqIHdoZW4gZ29pbmcgaW50byBmdWxsc2NyZWVuLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzRnVsbHNjcmVlblJlc2l6ZSA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgdGhlIHByb2dyZXNzIGV2ZW50LlxuICogSWYgdGhpcyBpcyBmYWxzZSwgbWFudWFsIGBwcm9ncmVzc2AgZXZlbnRzIHdpbGwgYmUgdHJpZ2dyZWQgaW5zdGVhZC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzID0gdHJ1ZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyB0aGUgdGltZXVwZGF0ZSBldmVudC5cbiAqIElmIHRoaXMgaXMgZmFsc2UsIG1hbnVhbCBgdGltZXVwZGF0ZWAgZXZlbnRzIHdpbGwgYmUgdHJpZ2dyZWQgaW5zdGVhZC5cbiAqXG4gKiBAZGVmYXVsdFxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNUaW1ldXBkYXRlRXZlbnRzID0gdHJ1ZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyBuYXRpdmUgYFRleHRUcmFja2BzLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LnN1cHBvcnRzTmF0aXZlVGV4dFRyYWNrc31cbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IEh0bWw1LnN1cHBvcnRzTmF0aXZlVGV4dFRyYWNrcygpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIG5hdGl2ZSBgVmlkZW9UcmFja2BzLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LnN1cHBvcnRzTmF0aXZlVmlkZW9UcmFja3N9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc05hdGl2ZVZpZGVvVHJhY2tzID0gSHRtbDUuc3VwcG9ydHNOYXRpdmVWaWRlb1RyYWNrcygpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIG5hdGl2ZSBgQXVkaW9UcmFja2BzLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LnN1cHBvcnRzTmF0aXZlQXVkaW9UcmFja3N9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc05hdGl2ZUF1ZGlvVHJhY2tzID0gSHRtbDUuc3VwcG9ydHNOYXRpdmVBdWRpb1RyYWNrcygpO1xuXG4vLyBIVE1MNSBGZWF0dXJlIGRldGVjdGlvbiBhbmQgRGV2aWNlIEZpeGVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xudmFyIGNhblBsYXlUeXBlID0gSHRtbDUuVEVTVF9WSUQgJiYgSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlO1xudmFyIG1wZWd1cmxSRSA9IC9eYXBwbGljYXRpb25cXC8oPzp4LXx2bmRcXC5hcHBsZVxcLiltcGVndXJsL2k7XG52YXIgbXA0UkUgPSAvXnZpZGVvXFwvbXA0L2k7XG5cbkh0bWw1LnBhdGNoQ2FuUGxheVR5cGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLy8gQW5kcm9pZCA0LjAgYW5kIGFib3ZlIGNhbiBwbGF5IEhMUyB0byBzb21lIGV4dGVudCBidXQgaXQgcmVwb3J0cyBiZWluZyB1bmFibGUgdG8gZG8gc29cbiAgaWYgKEFORFJPSURfVkVSU0lPTiA+PSA0LjAgJiYgIUlTX0ZJUkVGT1gpIHtcbiAgICBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgaWYgKHR5cGUgJiYgbXBlZ3VybFJFLnRlc3QodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuICdtYXliZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuUGxheVR5cGUuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICB9O1xuXG4gICAgLy8gT3ZlcnJpZGUgQW5kcm9pZCAyLjIgYW5kIGxlc3MgY2FuUGxheVR5cGUgbWV0aG9kIHdoaWNoIGlzIGJyb2tlblxuICB9IGVsc2UgaWYgKElTX09MRF9BTkRST0lEKSB7XG4gICAgSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlICYmIG1wNFJFLnRlc3QodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuICdtYXliZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuUGxheVR5cGUuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICB9O1xuICB9XG59O1xuXG5IdG1sNS51bnBhdGNoQ2FuUGxheVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlO1xuXG4gIEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGNhblBsYXlUeXBlO1xuICByZXR1cm4gcjtcbn07XG5cbi8vIGJ5IGRlZmF1bHQsIHBhdGNoIHRoZSBtZWRpYSBlbGVtZW50XG5IdG1sNS5wYXRjaENhblBsYXlUeXBlKCk7XG5cbkh0bWw1LmRpc3Bvc2VNZWRpYUVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gIH1cblxuICAvLyByZW1vdmUgYW55IGNoaWxkIHRyYWNrIG9yIHNvdXJjZSBub2RlcyB0byBwcmV2ZW50IHRoZWlyIGxvYWRpbmdcbiAgd2hpbGUgKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBzcmMgcmVmZXJlbmNlLiBub3Qgc2V0dGluZyBgc3JjPScnYCBiZWNhdXNlIHRoYXQgY2F1c2VzIGEgd2FybmluZ1xuICAvLyBpbiBmaXJlZm94XG4gIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG5cbiAgLy8gZm9yY2UgdGhlIG1lZGlhIGVsZW1lbnQgdG8gdXBkYXRlIGl0cyBsb2FkaW5nIHN0YXRlIGJ5IGNhbGxpbmcgbG9hZCgpXG4gIC8vIGhvd2V2ZXIgSUUgb24gV2luZG93cyA3TiBoYXMgYSBidWcgdGhhdCB0aHJvd3MgYW4gZXJyb3Igc28gbmVlZCBhIHRyeS9jYXRjaCAoIzc5MylcbiAgaWYgKHR5cGVvZiBlbC5sb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gd3JhcHBpbmcgaW4gYW4gaWlmZSBzbyBpdCdzIG5vdCBkZW9wdGltaXplZCAoIzEwNjAjZGlzY3Vzc2lvbl9yMTAzMjQ0NzMpXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsLmxvYWQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZFxuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cbn07XG5cbkh0bWw1LnJlc2V0TWVkaWFFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gIGlmICghZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc291cmNlcyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NvdXJjZScpO1xuICB2YXIgaSA9IHNvdXJjZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBlbC5yZW1vdmVDaGlsZChzb3VyY2VzW2ldKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBhbnkgc3JjIHJlZmVyZW5jZS5cbiAgLy8gbm90IHNldHRpbmcgYHNyYz0nJ2AgYmVjYXVzZSB0aGF0IHRocm93cyBhbiBlcnJvclxuICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gIGlmICh0eXBlb2YgZWwubG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHdyYXBwaW5nIGluIGFuIGlpZmUgc28gaXQncyBub3QgZGVvcHRpbWl6ZWQgKCMxMDYwI2Rpc2N1c3Npb25fcjEwMzI0NDczKVxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBlbC5sb2FkKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHNhdGlzZnkgbGludGVyXG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxufTtcblxuLyogTmF0aXZlIEhUTUw1IGVsZW1lbnQgcHJvcGVydHkgd3JhcHBpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbi8vIFdyYXAgbmF0aXZlIHByb3BlcnRpZXMgd2l0aCBhIGdldHRlclxuW1xuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwYXVzZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwYXVzZWRgIGluZGljYXRlcyB3aGV0aGVyIHRoZSBtZWRpYSBlbGVtZW50XG4gKiBpcyBjdXJyZW50bHkgcGF1c2VkIG9yIG5vdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3BhdXNlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwYXVzZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wYXVzZWR9XG4gKi9cbidwYXVzZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGN1cnJlbnRUaW1lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgY3VycmVudFRpbWVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgc2Vjb25kIHRoYXQgdGhlIG1lZGlhIGlzIGF0IGluIHBsYXliYWNrLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjY3VycmVudFRpbWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBjdXJyZW50VGltZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWN1cnJlbnR0aW1lfVxuICovXG4nY3VycmVudFRpbWUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGJ1ZmZlcmVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgYnVmZmVyZWRgIGlzIGEgYFRpbWVSYW5nZWBcbiAqIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhcnRzIG9mIHRoZSBtZWRpYSB0aGF0IGFyZSBhbHJlYWR5IGRvd25sb2FkZWQgYW5kXG4gKiBhdmFpbGFibGUgZm9yIHBsYXliYWNrLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjYnVmZmVyZWRcbiAqIEByZXR1cm4ge1RpbWVSYW5nZX1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBidWZmZXJlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWJ1ZmZlcmVkfVxuICovXG4nYnVmZmVyZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHZvbHVtZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHZvbHVtZWAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCBwbGF5YmFjayB2b2x1bWUgb2YgYXVkaW8gZm9yIGEgbWVkaWEuIGB2b2x1bWVgIHdpbGwgYmUgYSB2YWx1ZSBmcm9tIDBcbiAqIChzaWxlbnQpIHRvIDEgKGxvdWRlc3QgYW5kIGRlZmF1bHQpLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjdm9sdW1lXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBWYWx1ZSB3aWxsIGJlIGJldHdlZW4gMC0xLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tYS12b2x1bWV9XG4gKi9cbid2b2x1bWUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYG11dGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgbXV0ZWRgIGluZGljYXRlc1xuICogdGhhdCB0aGUgdm9sdW1lIGZvciB0aGUgbWVkaWEgc2hvdWxkIGJlIHNldCB0byBzaWxlbnQuIFRoaXMgZG9lcyBub3QgYWN0dWFsbHkgY2hhbmdlXG4gKiB0aGUgYHZvbHVtZWAgYXR0cmlidXRlLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjbXV0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgdmFsdWUgb2YgYHZvbHVtZWAgc2hvdWxkIGJlIGlnbm9yZWQgYW5kIHRoZSBhdWRpbyBzZXQgdG8gc2lsZW50LlxuICogICAgICAgICAtIEZhbHNlIGlmIHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBzaG91bGQgYmUgdXNlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLW11dGVkfVxuICovXG4nbXV0ZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRNdXRlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGRlZmF1bHRNdXRlZGAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSB2b2x1bWUgZm9yIHRoZSBtZWRpYSBzaG91bGQgYmUgc2V0IHRvIHNpbGVudCB3aGVuIHRoZSB2aWRlbyBmaXJzdCBzdGFydHMuXG4gKiBUaGlzIGRvZXMgbm90IGFjdHVhbGx5IGNoYW5nZSB0aGUgYHZvbHVtZWAgYXR0cmlidXRlLiBBZnRlciBwbGF5YmFjayBoYXMgc3RhcnRlZCBgbXV0ZWRgXG4gKiB3aWxsIGluZGljYXRlIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgdm9sdW1lIGFuZCBgZGVmYXVsdE11dGVkYCB3aWxsIG5vdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1LnByb3RvdHlwZS5kZWZhdWx0TXV0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgdmFsdWUgb2YgYHZvbHVtZWAgc2hvdWxkIGJlIGlnbm9yZWQgYW5kIHRoZSBhdWRpbyBzZXQgdG8gc2lsZW50LlxuICogICAgICAgICAtIEZhbHNlIGlmIHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBzaG91bGQgYmUgdXNlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWRlZmF1bHRtdXRlZH1cbiAqL1xuJ2RlZmF1bHRNdXRlZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcG9zdGVyYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcG9zdGVyYCBpbmRpY2F0ZXNcbiAqIHRoYXQgdGhlIHVybCBvZiBhbiBpbWFnZSBmaWxlIHRoYXQgY2FuL3dpbGwgYmUgc2hvd24gd2hlbiBubyBtZWRpYSBkYXRhIGlzIGF2YWlsYWJsZS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3Bvc3RlclxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHBvc3RlcmAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gVmFsdWUgd2lsbCBiZSBhIHVybCB0byBhblxuICogICAgICAgICBpbWFnZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci12aWRlby1wb3N0ZXJ9XG4gKi9cbidwb3N0ZXInLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHByZWxvYWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwcmVsb2FkYCBpbmRpY2F0ZXNcbiAqIHdoYXQgc2hvdWxkIGRvd25sb2FkIGJlZm9yZSB0aGUgbWVkaWEgaXMgaW50ZXJhY3RlZCB3aXRoLiBJdCBjYW4gaGF2ZSB0aGUgZm9sbG93aW5nXG4gKiB2YWx1ZXM6XG4gKiAtIG5vbmU6IG5vdGhpbmcgc2hvdWxkIGJlIGRvd25sb2FkZWRcbiAqIC0gbWV0YWRhdGE6IHBvc3RlciBhbmQgdGhlIGZpcnN0IGZldyBmcmFtZXMgb2YgdGhlIG1lZGlhIG1heSBiZSBkb3dubG9hZGVkIHRvIGdldFxuICogICBtZWRpYSBkaW1lbnNpb25zIGFuZCBvdGhlciBtZXRhZGF0YVxuICogLSBhdXRvOiBhbGxvdyB0aGUgbWVkaWEgYW5kIG1ldGFkYXRhIGZvciB0aGUgbWVkaWEgdG8gYmUgZG93bmxvYWRlZCBiZWZvcmVcbiAqICAgIGludGVyYWN0aW9uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwcmVsb2FkXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcHJlbG9hZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gV2lsbCBiZSAnbm9uZScsICdtZXRhZGF0YScsXG4gKiAgICAgICAgIG9yICdhdXRvJy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1wcmVsb2FkfVxuICovXG4ncHJlbG9hZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgYXV0b3BsYXlgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBhdXRvcGxheWAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgdG8gcGxheSBhcyBzb29uIGFzIHRoZSBwYWdlIGlzIHJlYWR5LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjYXV0b3BsYXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBhdXRvcGxheWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgYXMgc29vbiBhcyB0aGUgcGFnZSBsb2Fkcy5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBzdGFydCBhcyBzb29uIGFzIHRoZSBwYWdlIGxvYWRzLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLWF1dG9wbGF5fVxuICovXG4nYXV0b3BsYXknLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGNvbnRyb2xzYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgY29udHJvbHNgIGluZGljYXRlc1xuICogd2hldGhlciB0aGUgbmF0aXZlIG1lZGlhIGNvbnRyb2xzIHNob3VsZCBiZSBzaG93biBvciBoaWRkZW4uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNjb250cm9sc1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGNvbnRyb2xzYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgbmF0aXZlIGNvbnRyb2xzIHNob3VsZCBiZSBzaG93aW5nLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgaGlkZGVuLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLWNvbnRyb2xzfVxuICovXG4nY29udHJvbHMnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGxvb3BgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBsb29wYCBpbmRpY2F0ZXNcbiAqIHRoYXQgdGhlIG1lZGlhIHNob3VsZCByZXR1cm4gdG8gdGhlIHN0YXJ0IG9mIHRoZSBtZWRpYSBhbmQgY29udGludWUgcGxheWluZyBvbmNlXG4gKiBpdCByZWFjaGVzIHRoZSBlbmQuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNsb29wXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgbG9vcGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHBsYXliYWNrIHNob3VsZCBzZWVrIGJhY2sgdG8gc3RhcnQgb25jZVxuICogICAgICAgICAgIHRoZSBlbmQgb2YgYSBtZWRpYSBpcyByZWFjaGVkLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHBsYXliYWNrIHNob3VsZCBub3QgbG9vcCBiYWNrIHRvIHRoZSBzdGFydCB3aGVuIHRoZVxuICogICAgICAgICAgIGVuZCBvZiB0aGUgbWVkaWEgaXMgcmVhY2hlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1sb29wfVxuICovXG4nbG9vcCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgYGVycm9yYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgZXJyb3JgIGluZGljYXRlcyBhbnlcbiAqIE1lZGlhRXJyb3IgdGhhdCBtYXkgaGF2ZSBvY2N1cmVkIGR1cmluZyBwbGF5YmFjay4gSWYgZXJyb3IgcmV0dXJucyBudWxsIHRoZXJlIGlzIG5vXG4gKiBjdXJyZW50IGVycm9yLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjZXJyb3JcbiAqIEByZXR1cm4ge01lZGlhRXJyb3J8bnVsbH1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBlcnJvcmAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gV2lsbCBiZSBgTWVkaWFFcnJvcmAgaWYgdGhlcmVcbiAqICAgICAgICAgaXMgYSBjdXJyZW50IGVycm9yIGFuZCBudWxsIG90aGVyd2lzZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWVycm9yfVxuICovXG4nZXJyb3InLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHNlZWtpbmdgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBzZWVraW5nYCBpbmRpY2F0ZXMgd2hldGhlciB0aGVcbiAqIG1lZGlhIGlzIGN1cnJlbnRseSBzZWVraW5nIHRvIGEgbmV3IHBvc2l0aW9uIG9yIG5vdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NlZWtpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBzZWVraW5nYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBzZWVraW5nIHRvIGEgbmV3IHBvc2l0aW9uLlxuICogICAgICAgICAtIEZsYXNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBpcyBub3Qgc2Vla2luZyB0byBhIG5ldyBwb3NpdGlvbiBhdCB0aGlzIHRpbWUuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1zZWVraW5nfVxuICovXG4nc2Vla2luZycsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgc2Vla2FibGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBzZWVrYWJsZWAgcmV0dXJucyBhXG4gKiBgVGltZVJhbmdlYCBvYmplY3QgaW5kaWNhdGluZyByYW5nZXMgb2YgdGltZSB0aGF0IGNhbiBjdXJyZW50bHkgYmUgYHNlZWtlZGAgdG8uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZWVrYWJsZVxuICogQHJldHVybiB7VGltZVJhbmdlfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHNlZWthYmxlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIGBUaW1lUmFuZ2VgIG9iamVjdFxuICogICAgICAgICBpbmRpY2F0aW5nIHRoZSBjdXJyZW50IHJhbmdlcyBvZiB0aW1lIHRoYXQgY2FuIGJlIHNlZWtlZCB0by5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXNlZWthYmxlfVxuICovXG4nc2Vla2FibGUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGVuZGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgZW5kZWRgIGluZGljYXRlcyB3aGV0aGVyXG4gKiB0aGUgbWVkaWEgaGFzIHJlYWNoZWQgdGhlIGVuZCBvciBub3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNlbmRlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGVuZGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIGhhcyBlbmRlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgaGFzIG5vdCBlbmRlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWVuZGVkfVxuICovXG4nZW5kZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRNdXRlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGRlZmF1bHRNdXRlZGAgaW5kaWNhdGVzXG4gKiB3aGV0aGVyIHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgbXV0ZWQgb3Igbm90LiBPbmx5IGNoYW5nZXMgdGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlXG4gKiBtZWRpYS4gYG11dGVkYCBhbmQgYGRlZmF1bHRNdXRlZGAgY2FuIGhhdmUgZGlmZmVyZW50IHZhbHVlcy4ge0BsaW5rIEh0bWw1I211dGVkfSBpbmRpY2F0ZXMgdGhlXG4gKiBjdXJyZW50IHN0YXRlLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjZGVmYXVsdE11dGVkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgZGVmYXVsdE11dGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBzdGFydCBtdXRlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBzdGFydCBtdXRlZFxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZGVmYXVsdG11dGVkfVxuICovXG4nZGVmYXVsdE11dGVkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwbGF5YmFja1JhdGVgIGluZGljYXRlc1xuICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBwbGF5aW5nIGJhY2suIEV4YW1wbGVzOlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMiwgbWVkaWEgd2lsbCBwbGF5IHR3aWNlIGFzIGZhc3QuXG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAwLjUsIG1lZGlhIHdpbGwgcGxheSBoYWxmIGFzIGZhc3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwbGF5YmFja1JhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgbnVtYmVyIGluZGljYXRpbmdcbiAqICAgICAgICAgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG1lZGlhLCB3aGVyZSAxIGlzIG5vcm1hbCBzcGVlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBsYXliYWNrcmF0ZX1cbiAqL1xuJ3BsYXliYWNrUmF0ZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgZGVmYXVsdFBsYXliYWNrUmF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGRlZmF1bHRQbGF5YmFja1JhdGVgIGluZGljYXRlc1xuICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBwbGF5aW5nIGJhY2suIFRoaXMgdmFsdWUgd2lsbCBub3QgaW5kaWNhdGUgdGhlIGN1cnJlbnRcbiAqIGBwbGF5YmFja1JhdGVgIGFmdGVyIHBsYXliYWNrIGhhcyBzdGFydGVkLCB1c2Uge0BsaW5rIEh0bWw1I3BsYXliYWNrUmF0ZX0gZm9yIHRoYXQuXG4gKlxuICogRXhhbXBsZXM6XG4gKiAgIC0gaWYgZGVmYXVsdFBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMiwgbWVkaWEgd2lsbCBwbGF5IHR3aWNlIGFzIGZhc3QuXG4gKiAgIC0gaWYgZGVmYXVsdFBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMC41LCBtZWRpYSB3aWxsIHBsYXkgaGFsZiBhcyBmYXN0LlxuICpcbiAqIEBtZXRob2QgSHRtbDUucHJvdG90eXBlLmRlZmF1bHRQbGF5YmFja1JhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIG51bWJlciBpbmRpY2F0aW5nXG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHBsYXliYWNrIHNwZWVkIG9mIHRoZSBtZWRpYSwgd2hlcmUgMSBpcyBub3JtYWwgc3BlZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5YmFja3JhdGV9XG4gKi9cbidkZWZhdWx0UGxheWJhY2tSYXRlJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwbGF5ZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwbGF5ZWRgIHJldHVybnMgYSBgVGltZVJhbmdlYFxuICogb2JqZWN0IHJlcHJlc2VudGluZyBwb2ludHMgaW4gdGhlIG1lZGlhIHRpbWVsaW5lIHRoYXQgaGF2ZSBiZWVuIHBsYXllZC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3BsYXllZFxuICogQHJldHVybiB7VGltZVJhbmdlfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHBsYXllZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gQSBgVGltZVJhbmdlYCBvYmplY3QgaW5kaWNhdGluZ1xuICogICAgICAgICB0aGUgcmFuZ2VzIG9mIHRpbWUgdGhhdCBoYXZlIGJlZW4gcGxheWVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGxheWVkfVxuICovXG4ncGxheWVkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBuZXR3b3JrU3RhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBuZXR3b3JrU3RhdGVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgbmV0d29yayBzdGF0ZS4gSXQgcmV0dXJucyBhbiBlbnVtZXJhdGlvbiBmcm9tIHRoZSBmb2xsb3dpbmcgbGlzdDpcbiAqIC0gMDogTkVUV09SS19FTVBUWVxuICogLSAxOiBORVdPUktfSURMRVxuICogLSAyOiBORVRXT1JLX0xPQURJTkdcbiAqIC0gMzogTkVUV09SS19OT19TT1VSQ0VcbiAqXG4gKiBAbWV0aG9kIEh0bWw1I25ldHdvcmtTdGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYG5ldHdvcmtTdGF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyXG4gKiAgICAgICAgIGZyb20gdGhlIGxpc3QgaW4gdGhlIGRlc2NyaXB0aW9uLlxuICpcbiAqIEBzZWUgW1NwZWNdIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLW5ldHdvcmtzdGF0ZX1cbiAqL1xuJ25ldHdvcmtTdGF0ZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcmVhZHlTdGF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHJlYWR5U3RhdGVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIG1lZGlhIGVsZW1lbnQuIEl0IHJldHVybnMgYW4gZW51bWVyYXRpb24gZnJvbSB0aGVcbiAqIGZvbGxvd2luZyBsaXN0OlxuICogLSAwOiBIQVZFX05PVEhJTkdcbiAqIC0gMTogSEFWRV9NRVRBREFUQVxuICogLSAyOiBIQVZFX0NVUlJFTlRfREFUQVxuICogLSAzOiBIQVZFX0ZVVFVSRV9EQVRBXG4gKiAtIDQ6IEhBVkVfRU5PVUdIX0RBVEFcbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3JlYWR5U3RhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGByZWFkeVN0YXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBUaGlzIHdpbGwgYmUgYSBudW1iZXJcbiAqICAgICAgICAgZnJvbSB0aGUgbGlzdCBpbiB0aGUgZGVzY3JpcHRpb24uXG4gKlxuICogQHNlZSBbU3BlY10ge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNyZWFkeS1zdGF0ZXN9XG4gKi9cbidyZWFkeVN0YXRlJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGB2aWRlb1dpZHRoYCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBgdmlkZW9XaWR0aGAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCB3aWR0aCBvZiB0aGUgdmlkZW8gaW4gY3NzIHBpeGVscy5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3ZpZGVvV2lkdGhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGB2aWRlb1dpZHRoYCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBUaGlzIHdpbGwgYmUgYSBudW1iZXJcbiAqICAgICAgICAgaW4gY3NzIHBpeGVscy5cbiAqXG4gKiBAc2VlIFtTcGVjXSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS12aWRlby12aWRlb3dpZHRofVxuICovXG4ndmlkZW9XaWR0aCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgdmlkZW9IZWlnaHRgIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQuIGB2aWRlb0hlaWd0aGAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIHZpZGVvIGluIGNzcyBwaXhlbHMuXG4gKlxuICogQG1ldGhvZCBIdG1sNSN2aWRlb0hlaWdodFxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHZpZGVvSGVpZ2h0YCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBUaGlzIHdpbGwgYmUgYSBudW1iZXJcbiAqICAgICAgICAgaW4gY3NzIHBpeGVscy5cbiAqXG4gKiBAc2VlIFtTcGVjXSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS12aWRlby12aWRlb3dpZHRofVxuICovXG4ndmlkZW9IZWlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIEh0bWw1LnByb3RvdHlwZVtwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF9bcHJvcF07XG4gIH07XG59KTtcblxuLy8gV3JhcCBuYXRpdmUgcHJvcGVydGllcyB3aXRoIGEgc2V0dGVyIGluIHRoaXMgZm9ybWF0OlxuLy8gc2V0ICsgdG9UaXRsZUNhc2UobmFtZSlcbltcbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYHZvbHVtZWAgaW5kaWNhdGVzIHRoZSBjdXJyZW50XG4gKiBhdWRpbyBsZXZlbCBhcyBhIHBlcmNlbnRhZ2UgaW4gZGVjaW1hbCBmb3JtLiBUaGlzIG1lYW5zIHRoYXQgMSBpcyAxMDAlLCAwLjUgaXMgNTAlLCBhbmRcbiAqIHNvIG9uLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0Vm9sdW1lXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudEFzRGVjaW1hbFxuICogICAgICAgIFRoZSB2b2x1bWUgcGVyY2VudCBhcyBhIGRlY2ltYWwuIFZhbGlkIHJhbmdlIGlzIGZyb20gMC0xLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tYS12b2x1bWV9XG4gKi9cbid2b2x1bWUnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYG11dGVkYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYG11dGVkYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudFxuICogYXVkaW8gbGV2ZWwgc2hvdWxkIGJlIHNpbGVudC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldE11dGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG11dGVkXG4gKiAgICAgICAgLSBUcnVlIGlmIHRoZSBhdWRpbyBzaG91bGQgYmUgc2V0IHRvIHNpbGVudFxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1tdXRlZH1cbiAqL1xuJ211dGVkJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBkZWZhdWx0TXV0ZWRgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgZGVmYXVsdE11dGVkYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudFxuICogYXVkaW8gbGV2ZWwgc2hvdWxkIGJlIHNpbGVudCwgYnV0IHdpbGwgb25seSBlZmZlY3QgdGhlIG11dGVkIGxldmVsIG9uIGludGlhbCBwbGF5YmFjay4uXG4gKlxuICogQG1ldGhvZCBIdG1sNS5wcm90b3R5cGUuc2V0RGVmYXVsdE11dGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRlZmF1bHRNdXRlZFxuICogICAgICAgIC0gVHJ1ZSBpZiB0aGUgYXVkaW8gc2hvdWxkIGJlIHNldCB0byBzaWxlbnRcbiAqICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZGVmYXVsdG11dGVkfVxuICovXG4nZGVmYXVsdE11dGVkJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBzcmNgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgc3JjYCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnRcbiAqIHtAbGluayBUZWNoflNvdXJjZU9iamVjdH0gZm9yIHRoZSBtZWRpYS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFNyY1xuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc3JjXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3QgdG8gc2V0IGFzIHRoZSBjdXJyZW50IHNvdXJjZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXNyY31cbiAqL1xuJ3NyYycsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgcG9zdGVyYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYHBvc3RlcmAgaXMgdGhlIHVybCB0b1xuICogYW4gaW1hZ2UgZmlsZSB0aGF0IGNhbi93aWxsIGJlIHNob3duIHdoZW4gbm8gbWVkaWEgZGF0YSBpcyBhdmFpbGFibGUuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRQb3N0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3N0ZXJcbiAqICAgICAgICBUaGUgdXJsIHRvIGFuIGltYWdlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGBwb3N0ZXJgIGZvciB0aGUgbWVkaWFcbiAqICAgICAgICBlbGVtZW50LlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLXBvc3Rlcn1cbiAqL1xuJ3Bvc3RlcicsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgcHJlbG9hZGAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBwcmVsb2FkYCBpbmRpY2F0ZXNcbiAqIHdoYXQgc2hvdWxkIGRvd25sb2FkIGJlZm9yZSB0aGUgbWVkaWEgaXMgaW50ZXJhY3RlZCB3aXRoLiBJdCBjYW4gaGF2ZSB0aGUgZm9sbG93aW5nXG4gKiB2YWx1ZXM6XG4gKiAtIG5vbmU6IG5vdGhpbmcgc2hvdWxkIGJlIGRvd25sb2FkZWRcbiAqIC0gbWV0YWRhdGE6IHBvc3RlciBhbmQgdGhlIGZpcnN0IGZldyBmcmFtZXMgb2YgdGhlIG1lZGlhIG1heSBiZSBkb3dubG9hZGVkIHRvIGdldFxuICogICBtZWRpYSBkaW1lbnNpb25zIGFuZCBvdGhlciBtZXRhZGF0YVxuICogLSBhdXRvOiBhbGxvdyB0aGUgbWVkaWEgYW5kIG1ldGFkYXRhIGZvciB0aGUgbWVkaWEgdG8gYmUgZG93bmxvYWRlZCBiZWZvcmVcbiAqICAgIGludGVyYWN0aW9uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRQcmVsb2FkXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlbG9hZFxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHByZWxvYWRgIHRvIHNldCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gTXVzdCBiZSAnbm9uZScsICdtZXRhZGF0YScsXG4gKiAgICAgICAgIG9yICdhdXRvJy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1wcmVsb2FkfVxuICovXG4ncHJlbG9hZCcsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgYXV0b3BsYXlgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgYXV0b3BsYXlgIGluZGljYXRlc1xuICogdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IHRvIHBsYXkgYXMgc29vbiBhcyB0aGUgcGFnZSBpcyByZWFkeS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldEF1dG9wbGF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGF1dG9wbGF5XG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IGFzIHNvb24gYXMgdGhlIHBhZ2UgbG9hZHMuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBub3Qgc3RhcnQgYXMgc29vbiBhcyB0aGUgcGFnZSBsb2Fkcy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1hdXRvcGxheX1cbiAqL1xuJ2F1dG9wbGF5JyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBsb29wYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYGxvb3BgIGluZGljYXRlc1xuICogdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHJldHVybiB0byB0aGUgc3RhcnQgb2YgdGhlIG1lZGlhIGFuZCBjb250aW51ZSBwbGF5aW5nIG9uY2VcbiAqIGl0IHJlYWNoZXMgdGhlIGVuZC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldExvb3BcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgcGxheWJhY2sgc2hvdWxkIHNlZWsgYmFjayB0byBzdGFydCBvbmNlXG4gKiAgICAgICAgICAgdGhlIGVuZCBvZiBhIG1lZGlhIGlzIHJlYWNoZWQuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgcGxheWJhY2sgc2hvdWxkIG5vdCBsb29wIGJhY2sgdG8gdGhlIHN0YXJ0IHdoZW4gdGhlXG4gKiAgICAgICAgICAgZW5kIG9mIHRoZSBtZWRpYSBpcyByZWFjaGVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLWxvb3B9XG4gKi9cbidsb29wJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBwbGF5YmFja1JhdGVgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheWJhY2tSYXRlYCBpbmRpY2F0ZXNcbiAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBtZWRpYSBzaG91bGQgcGxheSBiYWNrLiBFeGFtcGxlczpcbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDIsIG1lZGlhIHdpbGwgcGxheSB0d2ljZSBhcyBmYXN0LlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMC41LCBtZWRpYSB3aWxsIHBsYXkgaGFsZiBhcyBmYXN0LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0UGxheWJhY2tSYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIG51bWJlciBpbmRpY2F0aW5nXG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHBsYXliYWNrIHNwZWVkIG9mIHRoZSBtZWRpYSwgd2hlcmUgMSBpcyBub3JtYWwgc3BlZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5YmFja3JhdGV9XG4gKi9cbidwbGF5YmFja1JhdGUnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgZGVmYXVsdFBsYXliYWNrUmF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgYmFjayB1cG9uIGluaXRpYWwgc3RhcnR1cC4gQ2hhbmdpbmcgdGhpcyB2YWx1ZVxuICogYWZ0ZXIgYSB2aWRlbyBoYXMgc3RhcnRlZCB3aWxsIGRvIG5vdGhpbmcuIEluc3RlYWQgeW91IHNob3VsZCB1c2VkIHtAbGluayBIdG1sNSNzZXRQbGF5YmFja1JhdGV9LlxuICpcbiAqIEV4YW1wbGUgVmFsdWVzOlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMiwgbWVkaWEgd2lsbCBwbGF5IHR3aWNlIGFzIGZhc3QuXG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAwLjUsIG1lZGlhIHdpbGwgcGxheSBoYWxmIGFzIGZhc3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNS5wcm90b3R5cGUuc2V0RGVmYXVsdFBsYXliYWNrUmF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgbnVtYmVyIGluZGljYXRpbmdcbiAqICAgICAgICAgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG1lZGlhLCB3aGVyZSAxIGlzIG5vcm1hbCBzcGVlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWRlZmF1bHRwbGF5YmFja3JhdGV9XG4gKi9cbidkZWZhdWx0UGxheWJhY2tSYXRlJ10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBIdG1sNS5wcm90b3R5cGVbJ3NldCcgKyB0b1RpdGxlQ2FzZShwcm9wKV0gPSBmdW5jdGlvbiAodikge1xuICAgIHRoaXMuZWxfW3Byb3BdID0gdjtcbiAgfTtcbn0pO1xuXG4vLyB3cmFwIG5hdGl2ZSBmdW5jdGlvbnMgd2l0aCBhIGZ1bmN0aW9uXG5bXG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIG1lZGlhIGVsZW1lbnRzIGBwYXVzZWAgZnVuY3Rpb24uIFRoaXMgd2lsbCBjYWxsIHRoZSBgSFRNTDVgXG4gKiBtZWRpYSBlbGVtZW50cyBgcGF1c2VgIGZ1bmN0aW9uLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcGF1c2VcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGF1c2V9XG4gKi9cbidwYXVzZScsXG5cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgbWVkaWEgZWxlbWVudHMgYGxvYWRgIGZ1bmN0aW9uLiBUaGlzIHdpbGwgY2FsbCB0aGUgYEhUTUw1YHNcbiAqIG1lZGlhIGVsZW1lbnQgYGxvYWRgIGZ1bmN0aW9uLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjbG9hZFxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1sb2FkfVxuICovXG4nbG9hZCcsXG5cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgbWVkaWEgZWxlbWVudHMgYHBsYXlgIGZ1bmN0aW9uLiBUaGlzIHdpbGwgY2FsbCB0aGUgYEhUTUw1YHNcbiAqIG1lZGlhIGVsZW1lbnQgYHBsYXlgIGZ1bmN0aW9uLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcGxheVxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5fVxuICovXG4ncGxheSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgSHRtbDUucHJvdG90eXBlW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsX1twcm9wXSgpO1xuICB9O1xufSk7XG5cblRlY2gud2l0aFNvdXJjZUhhbmRsZXJzKEh0bWw1KTtcblxuLyoqXG4gKiBOYXRpdmUgc291cmNlIGhhbmRsZXIgZm9yIEh0bWw1LCBzaW1wbHkgcGFzc2VzIHRoZSBzb3VyY2UgdG8gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHByb3ByZXR5IHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqXG4gKiBAcHJvcHJldHkge0h0bWw1fSB0ZWNoXG4gKiAgICAgICAgVGhlIGluc3RhbmNlIG9mIHRoZSBIVE1MNSB0ZWNoLlxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyID0ge307XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIG1lZGlhIGVsZW1lbnQgY2FuIHBsYXkgdGhlIGdpdmVuIG1pbWUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFRoZSBtaW1ldHlwZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIC8vIElFOSBvbiBXaW5kb3dzIDcgd2l0aG91dCBNZWRpYVBsYXllciB0aHJvd3MgYW4gZXJyb3IgaGVyZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvNTE5XG4gIHRyeSB7XG4gICAgcmV0dXJuIEh0bWw1LlRFU1RfVklELmNhblBsYXlUeXBlKHR5cGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBtZWRpYSBlbGVtZW50IGNhbiBoYW5kbGUgYSBzb3VyY2UgbmF0aXZlbHkuXG4gKlxuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gKiAgICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgICBPcHRpb25zIHRvIGJlIHBhc3NlZCB0byB0aGUgdGVjaC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpLlxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhbkhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAvLyBJZiBhIHR5cGUgd2FzIHByb3ZpZGVkIHdlIHNob3VsZCByZWx5IG9uIHRoYXRcbiAgaWYgKHNvdXJjZS50eXBlKSB7XG4gICAgcmV0dXJuIEh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuY2FuUGxheVR5cGUoc291cmNlLnR5cGUpO1xuXG4gICAgLy8gSWYgbm8gdHlwZSwgZmFsbCBiYWNrIHRvIGNoZWNraW5nICd2aWRlby9bRVhURU5TSU9OXSdcbiAgfSBlbHNlIGlmIChzb3VyY2Uuc3JjKSB7XG4gICAgdmFyIGV4dCA9IGdldEZpbGVFeHRlbnNpb24oc291cmNlLnNyYyk7XG5cbiAgICByZXR1cm4gSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZSgndmlkZW8vJyArIGV4dCk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xuXG4vKipcbiAqIFBhc3MgdGhlIHNvdXJjZSB0byB0aGUgbmF0aXZlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge0h0bWw1fSB0ZWNoXG4gKiAgICAgICAgVGhlIGluc3RhbmNlIG9mIHRoZSBIdG1sNSB0ZWNoXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZVxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRlY2gsIG9wdGlvbnMpIHtcbiAgdGVjaC5zZXRTcmMoc291cmNlLnNyYyk7XG59O1xuXG4vKipcbiAqIEEgbm9vcCBmb3IgdGhlIG5hdGl2ZSBkaXNwb3NlIGZ1bmN0aW9uLCBhcyBjbGVhbnVwIGlzIG5vdCBuZWVkZWQuXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBSZWdpc3RlciB0aGUgbmF0aXZlIHNvdXJjZSBoYW5kbGVyXG5IdG1sNS5yZWdpc3RlclNvdXJjZUhhbmRsZXIoSHRtbDUubmF0aXZlU291cmNlSGFuZGxlcik7XG5cblRlY2gucmVnaXN0ZXJUZWNoKCdIdG1sNScsIEh0bWw1KTtcblxudmFyIF90ZW1wbGF0ZU9iamVjdCQxID0gdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UoWydcXG4gICAgICAgIFVzaW5nIHRoZSB0ZWNoIGRpcmVjdGx5IGNhbiBiZSBkYW5nZXJvdXMuIEkgaG9wZSB5b3Uga25vdyB3aGF0IHlvdVxcJ3JlIGRvaW5nLlxcbiAgICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8yNjE3IGZvciBtb3JlIGluZm8uXFxuICAgICAgJ10sIFsnXFxuICAgICAgICBVc2luZyB0aGUgdGVjaCBkaXJlY3RseSBjYW4gYmUgZGFuZ2Vyb3VzLiBJIGhvcGUgeW91IGtub3cgd2hhdCB5b3VcXCdyZSBkb2luZy5cXG4gICAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMjYxNyBmb3IgbW9yZSBpbmZvLlxcbiAgICAgICddKTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5ZXIuanNcbiAqL1xuLy8gU3ViY2xhc3NlcyBDb21wb25lbnRcbi8vIFRoZSBmb2xsb3dpbmcgaW1wb3J0cyBhcmUgdXNlZCBvbmx5IHRvIGVuc3VyZSB0aGF0IHRoZSBjb3JyZXNwb25kaW5nIG1vZHVsZXNcbi8vIGFyZSBhbHdheXMgaW5jbHVkZWQgaW4gdGhlIHZpZGVvLmpzIHBhY2thZ2UuIEltcG9ydGluZyB0aGUgbW9kdWxlcyB3aWxsXG4vLyBleGVjdXRlIHRoZW0gYW5kIHRoZXkgd2lsbCByZWdpc3RlciB0aGVtc2VsdmVzIHdpdGggdmlkZW8uanMuXG4vLyBJbXBvcnQgSHRtbDUgdGVjaCwgYXQgbGVhc3QgZm9yIGRpc3Bvc2luZyB0aGUgb3JpZ2luYWwgdmlkZW8gdGFnLlxuLy8gVGhlIGZvbGxvd2luZyB0ZWNoIGV2ZW50cyBhcmUgc2ltcGx5IHJlLXRyaWdnZXJlZFxuLy8gb24gdGhlIHBsYXllciB3aGVuIHRoZXkgaGFwcGVuXG52YXIgVEVDSF9FVkVOVFNfUkVUUklHR0VSID0gW1xuLyoqXG4gKiBGaXJlZCB3aGlsZSB0aGUgdXNlciBhZ2VudCBpcyBkb3dubG9hZGluZyBtZWRpYSBkYXRhLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjcHJvZ3Jlc3NcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGBwcm9ncmVzc2AgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hQcm9ncmVzc19cbiAqIEBmaXJlcyBQbGF5ZXIjcHJvZ3Jlc3NcbiAqIEBsaXN0ZW5zIFRlY2gjcHJvZ3Jlc3NcbiAqL1xuJ3Byb2dyZXNzJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBsb2FkaW5nIG9mIGFuIGF1ZGlvL3ZpZGVvIGlzIGFib3J0ZWQuXG4gKlxuICogQGV2ZW50IFBsYXllciNhYm9ydFxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYGFib3J0YCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaEFib3J0X1xuICogQGZpcmVzIFBsYXllciNhYm9ydFxuICogQGxpc3RlbnMgVGVjaCNhYm9ydFxuICovXG4nYWJvcnQnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaXMgaW50ZW50aW9uYWxseSBub3QgZ2V0dGluZyBtZWRpYSBkYXRhLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjc3VzcGVuZFxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHN1c3BlbmRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoU3VzcGVuZF9cbiAqIEBmaXJlcyBQbGF5ZXIjc3VzcGVuZFxuICogQGxpc3RlbnMgVGVjaCNzdXNwZW5kXG4gKi9cbidzdXNwZW5kJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBjdXJyZW50IHBsYXlsaXN0IGlzIGVtcHR5LlxuICpcbiAqIEBldmVudCBQbGF5ZXIjZW1wdGllZFxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYGVtcHRpZWRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoRW1wdGllZF9cbiAqIEBmaXJlcyBQbGF5ZXIjZW1wdGllZFxuICogQGxpc3RlbnMgVGVjaCNlbXB0aWVkXG4gKi9cbidlbXB0aWVkJyxcbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgYnJvd3NlciBpcyB0cnlpbmcgdG8gZ2V0IG1lZGlhIGRhdGEsIGJ1dCBkYXRhIGlzIG5vdCBhdmFpbGFibGUuXG4gKlxuICogQGV2ZW50IFBsYXllciNzdGFsbGVkXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgc3RhbGxlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hTdGFsbGVkX1xuICogQGZpcmVzIFBsYXllciNzdGFsbGVkXG4gKiBAbGlzdGVucyBUZWNoI3N0YWxsZWRcbiAqL1xuJ3N0YWxsZWQnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaGFzIGxvYWRlZCBtZXRhIGRhdGEgZm9yIHRoZSBhdWRpby92aWRlby5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI2xvYWRlZG1ldGFkYXRhXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgc3RhbGxlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hMb2FkZWRtZXRhZGF0YV9cbiAqIEBmaXJlcyBQbGF5ZXIjbG9hZGVkbWV0YWRhdGFcbiAqIEBsaXN0ZW5zIFRlY2gjbG9hZGVkbWV0YWRhdGFcbiAqL1xuJ2xvYWRlZG1ldGFkYXRhJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGhhcyBsb2FkZWQgdGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhlIGF1ZGlvL3ZpZGVvLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjbG9hZGVkZGF0YVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYGxvYWRlZGRhdGFgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoTG9hZGRlZGRhdGFfXG4gKiBAZmlyZXMgUGxheWVyI2xvYWRlZGRhdGFcbiAqIEBsaXN0ZW5zIFRlY2gjbG9hZGVkZGF0YVxuICovXG4nbG9hZGVkZGF0YScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBoYXMgY2hhbmdlZC5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI3RpbWV1cGRhdGVcbiAqIEB0eXBlIHtldmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGB0aW1ldXBkYXRlYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFRpbWVVcGRhdGVfXG4gKiBAZmlyZXMgUGxheWVyI3RpbWV1cGRhdGVcbiAqIEBsaXN0ZW5zIFRlY2gjdGltZXVwZGF0ZVxuICovXG4ndGltZXVwZGF0ZScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgcGxheWluZyBzcGVlZCBvZiB0aGUgYXVkaW8vdmlkZW8gaXMgY2hhbmdlZFxuICpcbiAqIEBldmVudCBQbGF5ZXIjcmF0ZWNoYW5nZVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHJhdGVjaGFuZ2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoUmF0ZWNoYW5nZV9cbiAqIEBmaXJlcyBQbGF5ZXIjcmF0ZWNoYW5nZVxuICogQGxpc3RlbnMgVGVjaCNyYXRlY2hhbmdlXG4gKi9cbidyYXRlY2hhbmdlJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSB2aWRlbydzIGludHJpbnNpYyBkaW1lbnNpb25zIGNoYW5nZVxuICpcbiAqIEBldmVudCBQbGF5ZXIjcmVzaXplXG4gKiBAdHlwZSB7ZXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgcmVzaXplYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFJlc2l6ZV9cbiAqIEBmaXJlcyBQbGF5ZXIjcmVzaXplXG4gKiBAbGlzdGVucyBUZWNoI3Jlc2l6ZVxuICovXG4ncmVzaXplJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSB2b2x1bWUgaGFzIGJlZW4gY2hhbmdlZFxuICpcbiAqIEBldmVudCBQbGF5ZXIjdm9sdW1lY2hhbmdlXG4gKiBAdHlwZSB7ZXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgdm9sdW1lY2hhbmdlYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFZvbHVtZWNoYW5nZV9cbiAqIEBmaXJlcyBQbGF5ZXIjdm9sdW1lY2hhbmdlXG4gKiBAbGlzdGVucyBUZWNoI3ZvbHVtZWNoYW5nZVxuICovXG4ndm9sdW1lY2hhbmdlJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSB0ZXh0IHRyYWNrIGhhcyBiZWVuIGNoYW5nZWRcbiAqXG4gKiBAZXZlbnQgUGxheWVyI3RleHR0cmFja2NoYW5nZVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHRleHR0cmFja2NoYW5nZWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hUZXh0dHJhY2tjaGFuZ2VfXG4gKiBAZmlyZXMgUGxheWVyI3RleHR0cmFja2NoYW5nZVxuICogQGxpc3RlbnMgVGVjaCN0ZXh0dHJhY2tjaGFuZ2VcbiAqL1xuJ3RleHR0cmFja2NoYW5nZSddO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBgUGxheWVyYCBjbGFzcyBpcyBjcmVhdGVkIHdoZW4gYW55IG9mIHRoZSBWaWRlby5qcyBzZXR1cCBtZXRob2RzXG4gKiBhcmUgdXNlZCB0byBpbml0aWFsaXplIGEgdmlkZW8uXG4gKlxuICogQWZ0ZXIgYW4gaW5zdGFuY2UgaGFzIGJlZW4gY3JlYXRlZCBpdCBjYW4gYmUgYWNjZXNzZWQgZ2xvYmFsbHkgaW4gdHdvIHdheXM6XG4gKiAxLiBCeSBjYWxsaW5nIGB2aWRlb2pzKCdleGFtcGxlX3ZpZGVvXzEnKTtgXG4gKiAyLiBCeSB1c2luZyBpdCBkaXJlY3RseSB2aWEgIGB2aWRlb2pzLnBsYXllcnMuZXhhbXBsZV92aWRlb18xO2BcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUGxheWVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUGxheWVyLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFnXG4gICAqICAgICAgICBUaGUgb3JpZ2luYWwgdmlkZW8gRE9NIGVsZW1lbnQgdXNlZCBmb3IgY29uZmlndXJpbmcgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBSZWFkeSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIFBsYXllcih0YWcsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheWVyKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0YWcgSUQgZXhpc3RzXG4gICAgdGFnLmlkID0gdGFnLmlkIHx8ICd2anNfdmlkZW9fJyArIG5ld0dVSUQoKTtcblxuICAgIC8vIFNldCBPcHRpb25zXG4gICAgLy8gVGhlIG9wdGlvbnMgYXJndW1lbnQgb3ZlcnJpZGVzIG9wdGlvbnMgc2V0IGluIHRoZSB2aWRlbyB0YWdcbiAgICAvLyB3aGljaCBvdmVycmlkZXMgZ2xvYmFsbHkgc2V0IG9wdGlvbnMuXG4gICAgLy8gVGhpcyBsYXR0ZXIgcGFydCBjb2luY2lkZXMgd2l0aCB0aGUgbG9hZCBvcmRlclxuICAgIC8vICh0YWcgbXVzdCBleGlzdCBiZWZvcmUgUGxheWVyKVxuICAgIG9wdGlvbnMgPSBhc3NpZ24oUGxheWVyLmdldFRhZ1NldHRpbmdzKHRhZyksIG9wdGlvbnMpO1xuXG4gICAgLy8gRGVsYXkgdGhlIGluaXRpYWxpemF0aW9uIG9mIGNoaWxkcmVuIGJlY2F1c2Ugd2UgbmVlZCB0byBzZXQgdXBcbiAgICAvLyBwbGF5ZXIgcHJvcGVydGllcyBmaXJzdCwgYW5kIGNhbid0IHVzZSBgdGhpc2AgYmVmb3JlIGBzdXBlcigpYFxuICAgIG9wdGlvbnMuaW5pdENoaWxkcmVuID0gZmFsc2U7XG5cbiAgICAvLyBTYW1lIHdpdGggY3JlYXRpbmcgdGhlIGVsZW1lbnRcbiAgICBvcHRpb25zLmNyZWF0ZUVsID0gZmFsc2U7XG5cbiAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBwbGF5ZXIgdG8gcmVwb3J0IHRvdWNoIGFjdGl2aXR5IG9uIGl0c2VsZlxuICAgIC8vIHNlZSBlbmFibGVUb3VjaEFjdGl2aXR5IGluIENvbXBvbmVudFxuICAgIG9wdGlvbnMucmVwb3J0VG91Y2hBY3Rpdml0eSA9IGZhbHNlO1xuXG4gICAgLy8gSWYgbGFuZ3VhZ2UgaXMgbm90IHNldCwgZ2V0IHRoZSBjbG9zZXN0IGxhbmcgYXR0cmlidXRlXG4gICAgaWYgKCFvcHRpb25zLmxhbmd1YWdlKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZy5jbG9zZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjbG9zZXN0ID0gdGFnLmNsb3Nlc3QoJ1tsYW5nXScpO1xuXG4gICAgICAgIGlmIChjbG9zZXN0KSB7XG4gICAgICAgICAgb3B0aW9ucy5sYW5ndWFnZSA9IGNsb3Nlc3QuZ2V0QXR0cmlidXRlKCdsYW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGFnO1xuXG4gICAgICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICBpZiAoZ2V0QXR0cmlidXRlcyhlbGVtZW50KS5oYXNPd25Qcm9wZXJ0eSgnbGFuZycpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmxhbmd1YWdlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2xhbmcnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUnVuIGJhc2UgY29tcG9uZW50IGluaXRpYWxpemluZyB3aXRoIG5ldyBvcHRpb25zXG5cbiAgICAvLyBUdXJuIG9mZiBBUEkgYWNjZXNzIGJlY2F1c2Ugd2UncmUgbG9hZGluZyBhIG5ldyB0ZWNoIHRoYXQgbWlnaHQgbG9hZCBhc3luY2hyb25vdXNseVxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIG51bGwsIG9wdGlvbnMsIHJlYWR5KSk7XG5cbiAgICBfdGhpcy5pc1JlYWR5XyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgdGhlIGdsb2JhbCBvcHRpb24gb2JqZWN0IHdhcyBhY2NpZGVudGFsbHkgYmxvd24gYXdheSBieVxuICAgIC8vIHNvbWVvbmUsIGJhaWwgZWFybHkgd2l0aCBhbiBpbmZvcm1hdGl2ZSBlcnJvclxuICAgIGlmICghX3RoaXMub3B0aW9uc18gfHwgIV90aGlzLm9wdGlvbnNfLnRlY2hPcmRlciB8fCAhX3RoaXMub3B0aW9uc18udGVjaE9yZGVyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0ZWNoT3JkZXIgc3BlY2lmaWVkLiBEaWQgeW91IG92ZXJ3cml0ZSAnICsgJ3ZpZGVvanMub3B0aW9ucyBpbnN0ZWFkIG9mIGp1c3QgY2hhbmdpbmcgdGhlICcgKyAncHJvcGVydGllcyB5b3Ugd2FudCB0byBvdmVycmlkZT8nKTtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgdGFnIHVzZWQgdG8gc2V0IG9wdGlvbnNcbiAgICBfdGhpcy50YWcgPSB0YWc7XG5cbiAgICAvLyBTdG9yZSB0aGUgdGFnIGF0dHJpYnV0ZXMgdXNlZCB0byByZXN0b3JlIGh0bWw1IGVsZW1lbnRcbiAgICBfdGhpcy50YWdBdHRyaWJ1dGVzID0gdGFnICYmIGdldEF0dHJpYnV0ZXModGFnKTtcblxuICAgIC8vIFVwZGF0ZSBjdXJyZW50IGxhbmd1YWdlXG4gICAgX3RoaXMubGFuZ3VhZ2UoX3RoaXMub3B0aW9uc18ubGFuZ3VhZ2UpO1xuXG4gICAgLy8gVXBkYXRlIFN1cHBvcnRlZCBMYW5ndWFnZXNcbiAgICBpZiAob3B0aW9ucy5sYW5ndWFnZXMpIHtcbiAgICAgIC8vIE5vcm1hbGlzZSBwbGF5ZXIgb3B0aW9uIGxhbmd1YWdlcyB0byBsb3dlcmNhc2VcbiAgICAgIHZhciBsYW5ndWFnZXNUb0xvd2VyID0ge307XG5cbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9wdGlvbnMubGFuZ3VhZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gICAgICAgIGxhbmd1YWdlc1RvTG93ZXJbbmFtZSQkMS50b0xvd2VyQ2FzZSgpXSA9IG9wdGlvbnMubGFuZ3VhZ2VzW25hbWUkJDFdO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy5sYW5ndWFnZXNfID0gbGFuZ3VhZ2VzVG9Mb3dlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMubGFuZ3VhZ2VzXyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc18ubGFuZ3VhZ2VzO1xuICAgIH1cblxuICAgIC8vIENhY2hlIGZvciB2aWRlbyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgX3RoaXMuY2FjaGVfID0ge307XG5cbiAgICAvLyBTZXQgcG9zdGVyXG4gICAgX3RoaXMucG9zdGVyXyA9IG9wdGlvbnMucG9zdGVyIHx8ICcnO1xuXG4gICAgLy8gU2V0IGNvbnRyb2xzXG4gICAgX3RoaXMuY29udHJvbHNfID0gISFvcHRpb25zLmNvbnRyb2xzO1xuXG4gICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIGZvciBsYXN0Vm9sdW1lXG4gICAgX3RoaXMuY2FjaGVfLmxhc3RWb2x1bWUgPSAxO1xuXG4gICAgLy8gT3JpZ2luYWwgdGFnIHNldHRpbmdzIHN0b3JlZCBpbiBvcHRpb25zXG4gICAgLy8gbm93IHJlbW92ZSBpbW1lZGlhdGVseSBzbyBuYXRpdmUgY29udHJvbHMgZG9uJ3QgZmxhc2guXG4gICAgLy8gTWF5IGJlIHR1cm5lZCBiYWNrIG9uIGJ5IEhUTUw1IHRlY2ggaWYgbmF0aXZlQ29udHJvbHNGb3JUb3VjaCBpcyB0cnVlXG4gICAgdGFnLmNvbnRyb2xzID0gZmFsc2U7XG5cbiAgICAvKlxuICAgICAqIFN0b3JlIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBzY3J1YmJpbmdcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdXNlciBpcyBzY3J1YmJpbmdcbiAgICAgKi9cbiAgICBfdGhpcy5zY3J1YmJpbmdfID0gZmFsc2U7XG5cbiAgICBfdGhpcy5lbF8gPSBfdGhpcy5jcmVhdGVFbCgpO1xuXG4gICAgLy8gTWFrZSB0aGlzIGFuIGV2ZW50ZWQgb2JqZWN0IGFuZCB1c2UgYGVsX2AgYXMgaXRzIGV2ZW50IGJ1cy5cbiAgICBldmVudGVkKF90aGlzLCB7IGV2ZW50QnVzS2V5OiAnZWxfJyB9KTtcblxuICAgIC8vIFdlIGFsc28gd2FudCB0byBwYXNzIHRoZSBvcmlnaW5hbCBwbGF5ZXIgb3B0aW9ucyB0byBlYWNoIGNvbXBvbmVudCBhbmQgcGx1Z2luXG4gICAgLy8gYXMgd2VsbCBzbyB0aGV5IGRvbid0IG5lZWQgdG8gcmVhY2ggYmFjayBpbnRvIHRoZSBwbGF5ZXIgZm9yIG9wdGlvbnMgbGF0ZXIuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGRvIGFub3RoZXIgY29weSBvZiB0aGlzLm9wdGlvbnNfIHNvIHdlIGRvbid0IGVuZCB1cCB3aXRoXG4gICAgLy8gYW4gaW5maW5pdGUgbG9vcC5cbiAgICB2YXIgcGxheWVyT3B0aW9uc0NvcHkgPSBtZXJnZU9wdGlvbnMoX3RoaXMub3B0aW9uc18pO1xuXG4gICAgLy8gTG9hZCBwbHVnaW5zXG4gICAgaWYgKG9wdGlvbnMucGx1Z2lucykge1xuICAgICAgdmFyIHBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnM7XG5cbiAgICAgIE9iamVjdC5rZXlzKHBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUkJDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW25hbWUkJDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpc1tuYW1lJCQxXShwbHVnaW5zW25hbWUkJDFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BsdWdpbiBcIicgKyBuYW1lJCQxICsgJ1wiIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sIF90aGlzKTtcbiAgICB9XG5cbiAgICBfdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zID0gcGxheWVyT3B0aW9uc0NvcHk7XG5cbiAgICBfdGhpcy5taWRkbGV3YXJlXyA9IFtdO1xuXG4gICAgX3RoaXMuaW5pdENoaWxkcmVuKCk7XG5cbiAgICAvLyBTZXQgaXNBdWRpbyBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBhbiBhdWRpbyB0YWcgd2FzIHVzZWRcbiAgICBfdGhpcy5pc0F1ZGlvKHRhZy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYXVkaW8nKTtcblxuICAgIC8vIFVwZGF0ZSBjb250cm9scyBjbGFzc05hbWUuIENhbid0IGRvIHRoaXMgd2hlbiB0aGUgY29udHJvbHMgYXJlIGluaXRpYWxseVxuICAgIC8vIHNldCBiZWNhdXNlIHRoZSBlbGVtZW50IGRvZXNuJ3QgZXhpc3QgeWV0LlxuICAgIGlmIChfdGhpcy5jb250cm9scygpKSB7XG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWVuYWJsZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1kaXNhYmxlZCcpO1xuICAgIH1cblxuICAgIC8vIFNldCBBUklBIGxhYmVsIGFuZCByZWdpb24gcm9sZSBkZXBlbmRpbmcgb24gcGxheWVyIHR5cGVcbiAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ3JlZ2lvbicpO1xuICAgIGlmIChfdGhpcy5pc0F1ZGlvKCkpIHtcbiAgICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBfdGhpcy5sb2NhbGl6ZSgnQXVkaW8gUGxheWVyJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgX3RoaXMubG9jYWxpemUoJ1ZpZGVvIFBsYXllcicpKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuaXNBdWRpbygpKSB7XG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLWF1ZGlvJyk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmZsZXhOb3RTdXBwb3J0ZWRfKCkpIHtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtbm8tZmxleCcpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IE1ha2UgdGhpcyBzbWFydGVyLiBUb2dnbGUgdXNlciBzdGF0ZSBiZXR3ZWVuIHRvdWNoaW5nL21vdXNpbmdcbiAgICAvLyB1c2luZyBldmVudHMsIHNpbmNlIGRldmljZXMgY2FuIGhhdmUgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzLlxuICAgIC8vIGlmIChicm93c2VyLlRPVUNIX0VOQUJMRUQpIHtcbiAgICAvLyAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy10b3VjaC1lbmFibGVkJyk7XG4gICAgLy8gfVxuXG4gICAgLy8gaU9TIFNhZmFyaSBoYXMgYnJva2VuIGhvdmVyIGhhbmRsaW5nXG4gICAgaWYgKCFJU19JT1MpIHtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtd29ya2luZ2hvdmVyJyk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBwbGF5ZXIgZWFzaWx5IGZpbmRhYmxlIGJ5IElEXG4gICAgUGxheWVyLnBsYXllcnNbX3RoaXMuaWRfXSA9IF90aGlzO1xuXG4gICAgLy8gQWRkIGEgbWFqb3IgdmVyc2lvbiBjbGFzcyB0byBhaWQgY3NzIGluIHBsdWdpbnNcbiAgICB2YXIgbWFqb3JWZXJzaW9uID0gdmVyc2lvbi5zcGxpdCgnLicpWzBdO1xuXG4gICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy12JyArIG1ham9yVmVyc2lvbik7XG5cbiAgICAvLyBXaGVuIHRoZSBwbGF5ZXIgaXMgZmlyc3QgaW5pdGlhbGl6ZWQsIHRyaWdnZXIgYWN0aXZpdHkgc28gY29tcG9uZW50c1xuICAgIC8vIGxpa2UgdGhlIGNvbnRyb2wgYmFyIHNob3cgdGhlbXNlbHZlcyBpZiBuZWVkZWRcbiAgICBfdGhpcy51c2VyQWN0aXZlKHRydWUpO1xuICAgIF90aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSgpO1xuICAgIF90aGlzLmxpc3RlbkZvclVzZXJBY3Rpdml0eV8oKTtcblxuICAgIF90aGlzLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgX3RoaXMuaGFuZGxlRnVsbHNjcmVlbkNoYW5nZV8pO1xuICAgIF90aGlzLm9uKCdzdGFnZWNsaWNrJywgX3RoaXMuaGFuZGxlU3RhZ2VDbGlja18pO1xuXG4gICAgX3RoaXMuY2hhbmdpbmdTcmNfID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSB2aWRlbyBwbGF5ZXIgYW5kIGRvZXMgYW55IG5lY2Vzc2FyeSBjbGVhbnVwLlxuICAgKlxuICAgKiBUaGlzIGlzIGVzcGVjaWFsbHkgaGVscGZ1bCBpZiB5b3UgYXJlIGR5bmFtaWNhbGx5IGFkZGluZyBhbmQgcmVtb3ZpbmcgdmlkZW9zXG4gICAqIHRvL2Zyb20gdGhlIERPTS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNkaXNwb3NlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcGxheWVyIGlzIGJlaW5nIGRpc3Bvc2VkIG9mLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNkaXNwb3NlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignZGlzcG9zZScpO1xuICAgIC8vIHByZXZlbnQgZGlzcG9zZSBmcm9tIGJlaW5nIGNhbGxlZCB0d2ljZVxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJyk7XG5cbiAgICBpZiAodGhpcy5zdHlsZUVsXyAmJiB0aGlzLnN0eWxlRWxfLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuc3R5bGVFbF8ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnN0eWxlRWxfKTtcbiAgICB9XG5cbiAgICAvLyBLaWxsIHJlZmVyZW5jZSB0byB0aGlzIHBsYXllclxuICAgIFBsYXllci5wbGF5ZXJzW3RoaXMuaWRfXSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy50YWcgJiYgdGhpcy50YWcucGxheWVyKSB7XG4gICAgICB0aGlzLnRhZy5wbGF5ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsXyAmJiB0aGlzLmVsXy5wbGF5ZXIpIHtcbiAgICAgIHRoaXMuZWxfLnBsYXllciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHRoaXMudGVjaF8uZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgUGxheWVyYCdzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBET00gZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnO1xuICAgIHZhciBlbCA9IHZvaWQgMDtcbiAgICB2YXIgcGxheWVyRWxJbmdlc3QgPSB0aGlzLnBsYXllckVsSW5nZXN0XyA9IHRhZy5wYXJlbnROb2RlICYmIHRhZy5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSAmJiB0YWcucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtdmpzLXBsYXllcicpO1xuXG4gICAgaWYgKHBsYXllckVsSW5nZXN0KSB7XG4gICAgICBlbCA9IHRoaXMuZWxfID0gdGFnLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsID0gdGhpcy5lbF8gPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGFiaW5kZXggdG8gLTEgc28gd2UgY291bGQgZm9jdXMgb24gdGhlIHBsYXllciBlbGVtZW50XG4gICAgdGFnLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcblxuICAgIC8vIFJlbW92ZSB3aWR0aC9oZWlnaHQgYXR0cnMgZnJvbSB0YWcgc28gQ1NTIGNhbiBtYWtlIGl0IDEwMCUgd2lkdGgvaGVpZ2h0XG4gICAgdGFnLnJlbW92ZUF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICB0YWcucmVtb3ZlQXR0cmlidXRlKCdoZWlnaHQnKTtcblxuICAgIC8vIENvcHkgb3ZlciBhbGwgdGhlIGF0dHJpYnV0ZXMgZnJvbSB0aGUgdGFnLCBpbmNsdWRpbmcgSUQgYW5kIGNsYXNzXG4gICAgLy8gSUQgd2lsbCBub3cgcmVmZXJlbmNlIHBsYXllciBib3gsIG5vdCB0aGUgdmlkZW8gdGFnXG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cmlidXRlcyh0YWcpO1xuXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgc28gd2UgZG9uJ3QgdG90YWxseSBicmVhayBJRTdcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzY1MzQ0NC9jc3Mtc3R5bGVzLW5vdC1hcHBsaWVkLW9uLWR5bmFtaWMtZWxlbWVudHMtaW4taW50ZXJuZXQtZXhwbG9yZXItN1xuICAgICAgaWYgKGF0dHIgPT09ICdjbGFzcycpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lICs9ICcgJyArIGF0dHJzW2F0dHJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSB0YWcgaWQvY2xhc3MgZm9yIHVzZSBhcyBIVE1MNSBwbGF5YmFjayB0ZWNoXG4gICAgLy8gTWlnaHQgdGhpbmsgd2Ugc2hvdWxkIGRvIHRoaXMgYWZ0ZXIgZW1iZWRkaW5nIGluIGNvbnRhaW5lciBzbyAudmpzLXRlY2ggY2xhc3NcbiAgICAvLyBkb2Vzbid0IGZsYXNoIDEwMCUgd2lkdGgvaGVpZ2h0LCBidXQgY2xhc3Mgb25seSBhcHBsaWVzIHdpdGggLnZpZGVvLWpzIHBhcmVudFxuICAgIHRhZy5wbGF5ZXJJZCA9IHRhZy5pZDtcbiAgICB0YWcuaWQgKz0gJ19odG1sNV9hcGknO1xuICAgIHRhZy5jbGFzc05hbWUgPSAndmpzLXRlY2gnO1xuXG4gICAgLy8gTWFrZSBwbGF5ZXIgZmluZGFibGUgb24gZWxlbWVudHNcbiAgICB0YWcucGxheWVyID0gZWwucGxheWVyID0gdGhpcztcbiAgICAvLyBEZWZhdWx0IHN0YXRlIG9mIHZpZGVvIGlzIHBhdXNlZFxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcblxuICAgIC8vIEFkZCBhIHN0eWxlIGVsZW1lbnQgaW4gdGhlIHBsYXllciB0aGF0IHdlJ2xsIHVzZSB0byBzZXQgdGhlIHdpZHRoL2hlaWdodFxuICAgIC8vIG9mIHRoZSBwbGF5ZXIgaW4gYSB3YXkgdGhhdCdzIHN0aWxsIG92ZXJyaWRlYWJsZSBieSBDU1MsIGp1c3QgbGlrZSB0aGVcbiAgICAvLyB2aWRlbyBlbGVtZW50XG4gICAgaWYgKHdpbmRvdy5WSURFT0pTX05PX0RZTkFNSUNfU1RZTEUgIT09IHRydWUpIHtcbiAgICAgIHRoaXMuc3R5bGVFbF8gPSBjcmVhdGVTdHlsZUVsZW1lbnQoJ3Zqcy1zdHlsZXMtZGltZW5zaW9ucycpO1xuICAgICAgdmFyIGRlZmF1bHRzU3R5bGVFbCA9ICQoJy52anMtc3R5bGVzLWRlZmF1bHRzJyk7XG4gICAgICB2YXIgaGVhZCA9ICQoJ2hlYWQnKTtcblxuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUodGhpcy5zdHlsZUVsXywgZGVmYXVsdHNTdHlsZUVsID8gZGVmYXVsdHNTdHlsZUVsLm5leHRTaWJsaW5nIDogaGVhZC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICAvLyBQYXNzIGluIHRoZSB3aWR0aC9oZWlnaHQvYXNwZWN0UmF0aW8gb3B0aW9ucyB3aGljaCB3aWxsIHVwZGF0ZSB0aGUgc3R5bGUgZWxcbiAgICB0aGlzLndpZHRoKHRoaXMub3B0aW9uc18ud2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0KHRoaXMub3B0aW9uc18uaGVpZ2h0KTtcbiAgICB0aGlzLmZsdWlkKHRoaXMub3B0aW9uc18uZmx1aWQpO1xuICAgIHRoaXMuYXNwZWN0UmF0aW8odGhpcy5vcHRpb25zXy5hc3BlY3RSYXRpbyk7XG5cbiAgICAvLyBIaWRlIGFueSBsaW5rcyB3aXRoaW4gdGhlIHZpZGVvL2F1ZGlvIHRhZywgYmVjYXVzZSBJRSBkb2Vzbid0IGhpZGUgdGhlbSBjb21wbGV0ZWx5LlxuICAgIHZhciBsaW5rcyA9IHRhZy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmtFbCA9IGxpbmtzLml0ZW0oaSk7XG5cbiAgICAgIGFkZENsYXNzKGxpbmtFbCwgJ3Zqcy1oaWRkZW4nKTtcbiAgICAgIGxpbmtFbC5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICdoaWRkZW4nKTtcbiAgICB9XG5cbiAgICAvLyBpbnNlcnRFbEZpcnN0IHNlZW1zIHRvIGNhdXNlIHRoZSBuZXR3b3JrU3RhdGUgdG8gZmxpY2tlciBmcm9tIDMgdG8gMiwgc29cbiAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBvcmlnaW5hbCBmb3IgbGF0ZXIgc28gd2UgY2FuIGtub3cgaWYgdGhlIHNvdXJjZSBvcmlnaW5hbGx5IGZhaWxlZFxuICAgIHRhZy5pbml0TmV0d29ya1N0YXRlXyA9IHRhZy5uZXR3b3JrU3RhdGU7XG5cbiAgICAvLyBXcmFwIHZpZGVvIHRhZyBpbiBkaXYgKGVsL2JveCkgY29udGFpbmVyXG4gICAgaWYgKHRhZy5wYXJlbnROb2RlICYmICFwbGF5ZXJFbEluZ2VzdCkge1xuICAgICAgdGFnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCB0YWcpO1xuICAgIH1cblxuICAgIC8vIGluc2VydCB0aGUgdGFnIGFzIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgcGxheWVyIGVsZW1lbnRcbiAgICAvLyB0aGVuIG1hbnVhbGx5IGFkZCBpdCB0byB0aGUgY2hpbGRyZW4gYXJyYXkgc28gdGhhdCB0aGlzLmFkZENoaWxkXG4gICAgLy8gd2lsbCB3b3JrIHByb3Blcmx5IGZvciBvdGhlciBjb21wb25lbnRzXG4gICAgLy9cbiAgICAvLyBCcmVha3MgaVBob25lLCBmaXhlZCBpbiBIVE1MNSBzZXR1cC5cbiAgICBwcmVwZW5kVG8odGFnLCBlbCk7XG4gICAgdGhpcy5jaGlsZHJlbl8udW5zaGlmdCh0YWcpO1xuXG4gICAgLy8gU2V0IGxhbmcgYXR0ciBvbiBwbGF5ZXIgdG8gZW5zdXJlIENTUyA6bGFuZygpIGluIGNvbnNpc3RlbnQgd2l0aCBwbGF5ZXJcbiAgICAvLyBpZiBpdCdzIGJlZW4gc2V0IHRvIHNvbWV0aGluZyBkaWZmZXJlbnQgdG8gdGhlIGRvY1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnbGFuZycsIHRoaXMubGFuZ3VhZ2VfKTtcblxuICAgIHRoaXMuZWxfID0gZWw7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3Mgd2lkdGguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWVdXG4gICAqICAgICAgICBUaGUgdmFsdWUgdG8gc2V0IHRoZSBgUGxheWVyJ3Mgd2lkdGggdG8uXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB3aWR0aCBvZiB0aGUgYFBsYXllcmAgd2hlbiBnZXR0aW5nLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbiB3aWR0aCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignd2lkdGgnLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3MgaGVpZ2h0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlXVxuICAgKiAgICAgICAgVGhlIHZhbHVlIHRvIHNldCB0aGUgYFBsYXllcidzIGhlaWd0aCB0by5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgYFBsYXllcmAgd2hlbiBnZXR0aW5nLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gaGVpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCdoZWlnaHQnLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3Mgd2lkdGggJiBoZWlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1lbnNpb25cbiAgICogICAgICAgIFRoaXMgc3RyaW5nIGNhbiBiZTpcbiAgICogICAgICAgIC0gJ3dpZHRoJ1xuICAgKiAgICAgICAgLSAnaGVpZ2h0J1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlXVxuICAgKiAgICAgICAgVmFsdWUgZm9yIGRpbWVuc2lvbiBzcGVjaWZpZWQgaW4gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGRpbWVuc2lvbiBhcmd1bWVudHMgdmFsdWUgd2hlbiBnZXR0aW5nICh3aWR0aC9oZWlnaHQpLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gZGltZW5zaW9uKF9kaW1lbnNpb24sIHZhbHVlKSB7XG4gICAgdmFyIHByaXZEaW1lbnNpb24gPSBfZGltZW5zaW9uICsgJ18nO1xuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzW3ByaXZEaW1lbnNpb25dIHx8IDA7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgLy8gSWYgYW4gZW1wdHkgc3RyaW5nIGlzIGdpdmVuLCByZXNldCB0aGUgZGltZW5zaW9uIHRvIGJlIGF1dG9tYXRpY1xuICAgICAgdGhpc1twcml2RGltZW5zaW9uXSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnNlZFZhbCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgICBpZiAoaXNOYU4ocGFyc2VkVmFsKSkge1xuICAgICAgICBsb2ckMS5lcnJvcignSW1wcm9wZXIgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgc3VwcGxpZWQgZm9yIGZvciAnICsgX2RpbWVuc2lvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpc1twcml2RGltZW5zaW9uXSA9IHBhcnNlZFZhbDtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlRWxfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlci90b2dnbGVyIGZvciB0aGUgdmpzLWZsdWlkIGBjbGFzc05hbWVgIG9uIHRoZSBgUGxheWVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cbiAgICogICAgICAgIC0gQSB2YWx1ZSBvZiB0cnVlIGFkZHMgdGhlIGNsYXNzLlxuICAgKiAgICAgICAgLSBBIHZhbHVlIG9mIGZhbHNlIHJlbW92ZXMgdGhlIGNsYXNzLlxuICAgKiAgICAgICAgLSBObyB2YWx1ZSB3aWxsIHRvZ2dsZSB0aGUgZmx1aWQgY2xhc3MuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGZsdWlkIHdoZW4gZ2V0dGluZy5cbiAgICogICAgICAgICAtIGB1bmRlZmluZWRgIHdoZW4gc2V0dGluZy5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmZsdWlkID0gZnVuY3Rpb24gZmx1aWQoYm9vbCkge1xuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuZmx1aWRfO1xuICAgIH1cblxuICAgIHRoaXMuZmx1aWRfID0gISFib29sO1xuXG4gICAgaWYgKGJvb2wpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1mbHVpZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZmx1aWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlRWxfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9TZXQgdGhlIGFzcGVjdCByYXRpb1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JhdGlvXVxuICAgKiAgICAgICAgQXNwZWN0IHJhdGlvIGZvciBwbGF5ZXJcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICogICAgICAgICByZXR1cm5zIHRoZSBjdXJyZW50IGFzcGVjdCByYXRpbyB3aGVuIGdldHRpbmdcbiAgICovXG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3MgYXNwZWN0IHJhdGlvLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JhdGlvXVxuICAgKiAgICAgICAgVGhlIHZhbHVlIHRvIHNldCB0aGUgYFBsYXllcidzIGFzcGVjdCByYXRpbyB0by5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICogICAgICAgICAtIFRoZSBjdXJyZW50IGFzcGVjdCByYXRpbyBvZiB0aGUgYFBsYXllcmAgd2hlbiBnZXR0aW5nLlxuICAgKiAgICAgICAgIC0gdW5kZWZpbmVkIHdoZW4gc2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYXNwZWN0UmF0aW8gPSBmdW5jdGlvbiBhc3BlY3RSYXRpbyhyYXRpbykge1xuICAgIGlmIChyYXRpbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5hc3BlY3RSYXRpb187XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHdpZHRoOmhlaWdodCBmb3JtYXRcbiAgICBpZiAoIS9eXFxkK1xcOlxcZCskLy50ZXN0KHJhdGlvKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXByb3BlciB2YWx1ZSBzdXBwbGllZCBmb3IgYXNwZWN0IHJhdGlvLiBUaGUgZm9ybWF0IHNob3VsZCBiZSB3aWR0aDpoZWlnaHQsIGZvciBleGFtcGxlIDE2OjkuJyk7XG4gICAgfVxuICAgIHRoaXMuYXNwZWN0UmF0aW9fID0gcmF0aW87XG5cbiAgICAvLyBXZSdyZSBhc3N1bWluZyBpZiB5b3Ugc2V0IGFuIGFzcGVjdCByYXRpbyB5b3Ugd2FudCBmbHVpZCBtb2RlLFxuICAgIC8vIGJlY2F1c2UgaW4gZml4ZWQgbW9kZSB5b3UgY291bGQgY2FsY3VsYXRlIHdpZHRoIGFuZCBoZWlnaHQgeW91cnNlbGYuXG4gICAgdGhpcy5mbHVpZCh0cnVlKTtcblxuICAgIHRoaXMudXBkYXRlU3R5bGVFbF8oKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHN0eWxlcyBvZiB0aGUgYFBsYXllcmAgZWxlbWVudCAoaGVpZ2h0LCB3aWR0aCBhbmQgYXNwZWN0IHJhdGlvKS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGxpc3RlbnMgVGVjaCNsb2FkZWRtZXRhZGF0YVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudXBkYXRlU3R5bGVFbF8gPSBmdW5jdGlvbiB1cGRhdGVTdHlsZUVsXygpIHtcbiAgICBpZiAod2luZG93LlZJREVPSlNfTk9fRFlOQU1JQ19TVFlMRSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIF93aWR0aCA9IHR5cGVvZiB0aGlzLndpZHRoXyA9PT0gJ251bWJlcicgPyB0aGlzLndpZHRoXyA6IHRoaXMub3B0aW9uc18ud2lkdGg7XG4gICAgICB2YXIgX2hlaWdodCA9IHR5cGVvZiB0aGlzLmhlaWdodF8gPT09ICdudW1iZXInID8gdGhpcy5oZWlnaHRfIDogdGhpcy5vcHRpb25zXy5oZWlnaHQ7XG4gICAgICB2YXIgdGVjaEVsID0gdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLmVsKCk7XG5cbiAgICAgIGlmICh0ZWNoRWwpIHtcbiAgICAgICAgaWYgKF93aWR0aCA+PSAwKSB7XG4gICAgICAgICAgdGVjaEVsLndpZHRoID0gX3dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaGVpZ2h0ID49IDApIHtcbiAgICAgICAgICB0ZWNoRWwuaGVpZ2h0ID0gX2hlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoID0gdm9pZCAwO1xuICAgIHZhciBoZWlnaHQgPSB2b2lkIDA7XG4gICAgdmFyIGFzcGVjdFJhdGlvID0gdm9pZCAwO1xuICAgIHZhciBpZENsYXNzID0gdm9pZCAwO1xuXG4gICAgLy8gVGhlIGFzcGVjdCByYXRpbyBpcyBlaXRoZXIgdXNlZCBkaXJlY3RseSBvciB0byBjYWxjdWxhdGUgd2lkdGggYW5kIGhlaWdodC5cbiAgICBpZiAodGhpcy5hc3BlY3RSYXRpb18gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmFzcGVjdFJhdGlvXyAhPT0gJ2F1dG8nKSB7XG4gICAgICAvLyBVc2UgYW55IGFzcGVjdFJhdGlvIHRoYXQncyBiZWVuIHNwZWNpZmljYWxseSBzZXRcbiAgICAgIGFzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpb187XG4gICAgfSBlbHNlIGlmICh0aGlzLnZpZGVvV2lkdGgoKSA+IDApIHtcbiAgICAgIC8vIE90aGVyd2lzZSB0cnkgdG8gZ2V0IHRoZSBhc3BlY3QgcmF0aW8gZnJvbSB0aGUgdmlkZW8gbWV0YWRhdGFcbiAgICAgIGFzcGVjdFJhdGlvID0gdGhpcy52aWRlb1dpZHRoKCkgKyAnOicgKyB0aGlzLnZpZGVvSGVpZ2h0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9yIHVzZSBhIGRlZmF1bHQuIFRoZSB2aWRlbyBlbGVtZW50J3MgaXMgMjoxLCBidXQgMTY6OSBpcyBtb3JlIGNvbW1vbi5cbiAgICAgIGFzcGVjdFJhdGlvID0gJzE2OjknO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgcmF0aW8gYXMgYSBkZWNpbWFsIHdlIGNhbiB1c2UgdG8gY2FsY3VsYXRlIGRpbWVuc2lvbnNcbiAgICB2YXIgcmF0aW9QYXJ0cyA9IGFzcGVjdFJhdGlvLnNwbGl0KCc6Jyk7XG4gICAgdmFyIHJhdGlvTXVsdGlwbGllciA9IHJhdGlvUGFydHNbMV0gLyByYXRpb1BhcnRzWzBdO1xuXG4gICAgaWYgKHRoaXMud2lkdGhfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFVzZSBhbnkgd2lkdGggdGhhdCdzIGJlZW4gc3BlY2lmaWNhbGx5IHNldFxuICAgICAgd2lkdGggPSB0aGlzLndpZHRoXztcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGVpZ2h0XyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBPciBjYWx1bGF0ZSB0aGUgd2lkdGggZnJvbSB0aGUgYXNwZWN0IHJhdGlvIGlmIGEgaGVpZ2h0IGhhcyBiZWVuIHNldFxuICAgICAgd2lkdGggPSB0aGlzLmhlaWdodF8gLyByYXRpb011bHRpcGxpZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9yIHVzZSB0aGUgdmlkZW8ncyBtZXRhZGF0YSwgb3IgdXNlIHRoZSB2aWRlbyBlbCdzIGRlZmF1bHQgb2YgMzAwXG4gICAgICB3aWR0aCA9IHRoaXMudmlkZW9XaWR0aCgpIHx8IDMwMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oZWlnaHRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFVzZSBhbnkgaGVpZ2h0IHRoYXQncyBiZWVuIHNwZWNpZmljYWxseSBzZXRcbiAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0XztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IGZyb20gdGhlIHJhdGlvIGFuZCB0aGUgd2lkdGhcbiAgICAgIGhlaWdodCA9IHdpZHRoICogcmF0aW9NdWx0aXBsaWVyO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGUgQ1NTIGNsYXNzIGlzIHZhbGlkIGJ5IHN0YXJ0aW5nIHdpdGggYW4gYWxwaGEgY2hhcmFjdGVyXG4gICAgaWYgKC9eW15hLXpBLVpdLy50ZXN0KHRoaXMuaWQoKSkpIHtcbiAgICAgIGlkQ2xhc3MgPSAnZGltZW5zaW9ucy0nICsgdGhpcy5pZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZENsYXNzID0gdGhpcy5pZCgpICsgJy1kaW1lbnNpb25zJztcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhlIHJpZ2h0IGNsYXNzIGlzIHN0aWxsIG9uIHRoZSBwbGF5ZXIgZm9yIHRoZSBzdHlsZSBlbGVtZW50XG4gICAgdGhpcy5hZGRDbGFzcyhpZENsYXNzKTtcblxuICAgIHNldFRleHRDb250ZW50KHRoaXMuc3R5bGVFbF8sICdcXG4gICAgICAuJyArIGlkQ2xhc3MgKyAnIHtcXG4gICAgICAgIHdpZHRoOiAnICsgd2lkdGggKyAncHg7XFxuICAgICAgICBoZWlnaHQ6ICcgKyBoZWlnaHQgKyAncHg7XFxuICAgICAgfVxcblxcbiAgICAgIC4nICsgaWRDbGFzcyArICcudmpzLWZsdWlkIHtcXG4gICAgICAgIHBhZGRpbmctdG9wOiAnICsgcmF0aW9NdWx0aXBsaWVyICogMTAwICsgJyU7XFxuICAgICAgfVxcbiAgICAnKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9hZC9DcmVhdGUgYW4gaW5zdGFuY2Ugb2YgcGxheWJhY2sge0BsaW5rIFRlY2h9IGluY2x1ZGluZyBlbGVtZW50XG4gICAqIGFuZCBBUEkgbWV0aG9kcy4gVGhlbiBhcHBlbmQgdGhlIGBUZWNoYCBlbGVtZW50IGluIGBQbGF5ZXJgIGFzIGEgY2hpbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWNoTmFtZVxuICAgKiAgICAgICAgbmFtZSBvZiB0aGUgcGxheWJhY2sgdGVjaG5vbG9neVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlXG4gICAqICAgICAgICB2aWRlbyBzb3VyY2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxvYWRUZWNoXyA9IGZ1bmN0aW9uIGxvYWRUZWNoXyh0ZWNoTmFtZSwgc291cmNlKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBQYXVzZSBhbmQgcmVtb3ZlIGN1cnJlbnQgcGxheWJhY2sgdGVjaG5vbG9neVxuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICB0aGlzLnVubG9hZFRlY2hfKCk7XG4gICAgfVxuXG4gICAgdmFyIHRpdGxlVGVjaE5hbWUgPSB0b1RpdGxlQ2FzZSh0ZWNoTmFtZSk7XG4gICAgdmFyIGNhbWVsVGVjaE5hbWUgPSB0ZWNoTmFtZS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHRlY2hOYW1lLnNsaWNlKDEpO1xuXG4gICAgLy8gZ2V0IHJpZCBvZiB0aGUgSFRNTDUgdmlkZW8gdGFnIGFzIHNvb24gYXMgd2UgYXJlIHVzaW5nIGFub3RoZXIgdGVjaFxuICAgIGlmICh0aXRsZVRlY2hOYW1lICE9PSAnSHRtbDUnICYmIHRoaXMudGFnKSB7XG4gICAgICBUZWNoLmdldFRlY2goJ0h0bWw1JykuZGlzcG9zZU1lZGlhRWxlbWVudCh0aGlzLnRhZyk7XG4gICAgICB0aGlzLnRhZy5wbGF5ZXIgPSBudWxsO1xuICAgICAgdGhpcy50YWcgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMudGVjaE5hbWVfID0gdGl0bGVUZWNoTmFtZTtcblxuICAgIC8vIFR1cm4gb2ZmIEFQSSBhY2Nlc3MgYmVjYXVzZSB3ZSdyZSBsb2FkaW5nIGEgbmV3IHRlY2ggdGhhdCBtaWdodCBsb2FkIGFzeW5jaHJvbm91c2x5XG4gICAgdGhpcy5pc1JlYWR5XyA9IGZhbHNlO1xuXG4gICAgLy8gR3JhYiB0ZWNoLXNwZWNpZmljIG9wdGlvbnMgZnJvbSBwbGF5ZXIgb3B0aW9ucyBhbmQgYWRkIHNvdXJjZSBhbmQgcGFyZW50IGVsZW1lbnQgdG8gdXNlLlxuICAgIHZhciB0ZWNoT3B0aW9ucyA9IHtcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgJ25hdGl2ZUNvbnRyb2xzRm9yVG91Y2gnOiB0aGlzLm9wdGlvbnNfLm5hdGl2ZUNvbnRyb2xzRm9yVG91Y2gsXG4gICAgICAncGxheWVySWQnOiB0aGlzLmlkKCksXG4gICAgICAndGVjaElkJzogdGhpcy5pZCgpICsgJ18nICsgdGl0bGVUZWNoTmFtZSArICdfYXBpJyxcbiAgICAgICdhdXRvcGxheSc6IHRoaXMub3B0aW9uc18uYXV0b3BsYXksXG4gICAgICAncGxheXNpbmxpbmUnOiB0aGlzLm9wdGlvbnNfLnBsYXlzaW5saW5lLFxuICAgICAgJ3ByZWxvYWQnOiB0aGlzLm9wdGlvbnNfLnByZWxvYWQsXG4gICAgICAnbG9vcCc6IHRoaXMub3B0aW9uc18ubG9vcCxcbiAgICAgICdtdXRlZCc6IHRoaXMub3B0aW9uc18ubXV0ZWQsXG4gICAgICAncG9zdGVyJzogdGhpcy5wb3N0ZXIoKSxcbiAgICAgICdsYW5ndWFnZSc6IHRoaXMubGFuZ3VhZ2UoKSxcbiAgICAgICdwbGF5ZXJFbEluZ2VzdCc6IHRoaXMucGxheWVyRWxJbmdlc3RfIHx8IGZhbHNlLFxuICAgICAgJ3Z0dC5qcyc6IHRoaXMub3B0aW9uc19bJ3Z0dC5qcyddXG4gICAgfTtcblxuICAgIEFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gICAgICB2YXIgcHJvcHMgPSBBTExbbmFtZSQkMV07XG5cbiAgICAgIHRlY2hPcHRpb25zW3Byb3BzLmdldHRlck5hbWVdID0gX3RoaXMyW3Byb3BzLnByaXZhdGVOYW1lXTtcbiAgICB9KTtcblxuICAgIGFzc2lnbih0ZWNoT3B0aW9ucywgdGhpcy5vcHRpb25zX1t0aXRsZVRlY2hOYW1lXSk7XG4gICAgYXNzaWduKHRlY2hPcHRpb25zLCB0aGlzLm9wdGlvbnNfW2NhbWVsVGVjaE5hbWVdKTtcbiAgICBhc3NpZ24odGVjaE9wdGlvbnMsIHRoaXMub3B0aW9uc19bdGVjaE5hbWUudG9Mb3dlckNhc2UoKV0pO1xuXG4gICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICB0ZWNoT3B0aW9ucy50YWcgPSB0aGlzLnRhZztcbiAgICB9XG5cbiAgICBpZiAoc291cmNlICYmIHNvdXJjZS5zcmMgPT09IHRoaXMuY2FjaGVfLnNyYyAmJiB0aGlzLmNhY2hlXy5jdXJyZW50VGltZSA+IDApIHtcbiAgICAgIHRlY2hPcHRpb25zLnN0YXJ0VGltZSA9IHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGVjaCBpbnN0YW5jZVxuICAgIHZhciBUZWNoQ2xhc3MgPSBUZWNoLmdldFRlY2godGVjaE5hbWUpO1xuXG4gICAgaWYgKCFUZWNoQ2xhc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gVGVjaCBuYW1lZCBcXCcnICsgdGl0bGVUZWNoTmFtZSArICdcXCcgZXhpc3RzISBcXCcnICsgdGl0bGVUZWNoTmFtZSArICdcXCcgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgdXNpbmcgdmlkZW9qcy5yZWdpc3RlclRlY2goKVxcJycpO1xuICAgIH1cblxuICAgIHRoaXMudGVjaF8gPSBuZXcgVGVjaENsYXNzKHRlY2hPcHRpb25zKTtcblxuICAgIC8vIHBsYXllci50cmlnZ2VyUmVhZHkgaXMgYWx3YXlzIGFzeW5jLCBzbyBkb24ndCBuZWVkIHRoaXMgdG8gYmUgYXN5bmNcbiAgICB0aGlzLnRlY2hfLnJlYWR5KGJpbmQodGhpcywgdGhpcy5oYW5kbGVUZWNoUmVhZHlfKSwgdHJ1ZSk7XG5cbiAgICB0ZXh0VHJhY2tDb252ZXJ0ZXIuanNvblRvVGV4dFRyYWNrcyh0aGlzLnRleHRUcmFja3NKc29uXyB8fCBbXSwgdGhpcy50ZWNoXyk7XG5cbiAgICAvLyBMaXN0ZW4gdG8gYWxsIEhUTUw1LWRlZmluZWQgZXZlbnRzIGFuZCB0cmlnZ2VyIHRoZW0gb24gdGhlIHBsYXllclxuICAgIFRFQ0hfRVZFTlRTX1JFVFJJR0dFUi5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgX3RoaXMyLm9uKF90aGlzMi50ZWNoXywgZXZlbnQsIF90aGlzMlsnaGFuZGxlVGVjaCcgKyB0b1RpdGxlQ2FzZShldmVudCkgKyAnXyddKTtcbiAgICB9KTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdsb2Fkc3RhcnQnLCB0aGlzLmhhbmRsZVRlY2hMb2FkU3RhcnRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd3YWl0aW5nJywgdGhpcy5oYW5kbGVUZWNoV2FpdGluZ18pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2NhbnBsYXknLCB0aGlzLmhhbmRsZVRlY2hDYW5QbGF5Xyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnY2FucGxheXRocm91Z2gnLCB0aGlzLmhhbmRsZVRlY2hDYW5QbGF5VGhyb3VnaF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3BsYXlpbmcnLCB0aGlzLmhhbmRsZVRlY2hQbGF5aW5nXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZW5kZWQnLCB0aGlzLmhhbmRsZVRlY2hFbmRlZF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3NlZWtpbmcnLCB0aGlzLmhhbmRsZVRlY2hTZWVraW5nXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnc2Vla2VkJywgdGhpcy5oYW5kbGVUZWNoU2Vla2VkXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncGxheScsIHRoaXMuaGFuZGxlVGVjaFBsYXlfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdmaXJzdHBsYXknLCB0aGlzLmhhbmRsZVRlY2hGaXJzdFBsYXlfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdwYXVzZScsIHRoaXMuaGFuZGxlVGVjaFBhdXNlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZHVyYXRpb25jaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZXJyb3InLCB0aGlzLmhhbmRsZVRlY2hFcnJvcl8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2xvYWRlZG1ldGFkYXRhJywgdGhpcy51cGRhdGVTdHlsZUVsXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncG9zdGVyY2hhbmdlJywgdGhpcy5oYW5kbGVUZWNoUG9zdGVyQ2hhbmdlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndGV4dGRhdGEnLCB0aGlzLmhhbmRsZVRlY2hUZXh0RGF0YV8pO1xuXG4gICAgdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKHRoaXMudGVjaEdldF8oJ2NvbnRyb2xzJykpO1xuXG4gICAgaWYgKHRoaXMuY29udHJvbHMoKSAmJiAhdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKCkpIHtcbiAgICAgIHRoaXMuYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgdGVjaCBlbGVtZW50IGluIHRoZSBET00gaWYgaXQgd2FzIG5vdCBhbHJlYWR5IHRoZXJlXG4gICAgLy8gTWFrZSBzdXJlIHRvIG5vdCBpbnNlcnQgdGhlIG9yaWdpbmFsIHZpZGVvIGVsZW1lbnQgaWYgdXNpbmcgSHRtbDVcbiAgICBpZiAodGhpcy50ZWNoXy5lbCgpLnBhcmVudE5vZGUgIT09IHRoaXMuZWwoKSAmJiAodGl0bGVUZWNoTmFtZSAhPT0gJ0h0bWw1JyB8fCAhdGhpcy50YWcpKSB7XG4gICAgICBwcmVwZW5kVG8odGhpcy50ZWNoXy5lbCgpLCB0aGlzLmVsKCkpO1xuICAgIH1cblxuICAgIC8vIEdldCByaWQgb2YgdGhlIG9yaWdpbmFsIHZpZGVvIHRhZyByZWZlcmVuY2UgYWZ0ZXIgdGhlIGZpcnN0IHRlY2ggaXMgbG9hZGVkXG4gICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICB0aGlzLnRhZy5wbGF5ZXIgPSBudWxsO1xuICAgICAgdGhpcy50YWcgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVW5sb2FkIGFuZCBkaXNwb3NlIG9mIHRoZSBjdXJyZW50IHBsYXliYWNrIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnVubG9hZFRlY2hfID0gZnVuY3Rpb24gdW5sb2FkVGVjaF8oKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHRleHQgdHJhY2tzIHNvIHRoYXQgd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRleHQgdHJhY2tzIHdpdGggdGhlIG5leHQgdGVjaFxuICAgIEFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gICAgICB2YXIgcHJvcHMgPSBBTExbbmFtZSQkMV07XG5cbiAgICAgIF90aGlzM1twcm9wcy5wcml2YXRlTmFtZV0gPSBfdGhpczNbcHJvcHMuZ2V0dGVyTmFtZV0oKTtcbiAgICB9KTtcbiAgICB0aGlzLnRleHRUcmFja3NKc29uXyA9IHRleHRUcmFja0NvbnZlcnRlci50ZXh0VHJhY2tzVG9Kc29uKHRoaXMudGVjaF8pO1xuXG4gICAgdGhpcy5pc1JlYWR5XyA9IGZhbHNlO1xuXG4gICAgdGhpcy50ZWNoXy5kaXNwb3NlKCk7XG5cbiAgICB0aGlzLnRlY2hfID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCB7QGxpbmsgVGVjaH0uXG4gICAqIEl0IHdpbGwgcHJpbnQgYSB3YXJuaW5nIGJ5IGRlZmF1bHQgYWJvdXQgdGhlIGRhbmdlciBvZiB1c2luZyB0aGUgdGVjaCBkaXJlY3RseVxuICAgKiBidXQgYW55IGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIGluIHdpbGwgc2lsZW5jZSB0aGUgd2FybmluZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbc2FmZXR5XVxuICAgKiAgICAgICAgQW55dGhpbmcgcGFzc2VkIGluIHRvIHNpbGVuY2UgdGhlIHdhcm5pbmdcbiAgICpcbiAgICogQHJldHVybiB7VGVjaH1cbiAgICogICAgICAgICBUaGUgVGVjaFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudGVjaCA9IGZ1bmN0aW9uIHRlY2goc2FmZXR5KSB7XG4gICAgaWYgKHNhZmV0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2ckMS53YXJuKHRzbWwoX3RlbXBsYXRlT2JqZWN0JDEpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50ZWNoXztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHVwIGNsaWNrIGFuZCB0b3VjaCBsaXN0ZW5lcnMgZm9yIHRoZSBwbGF5YmFjayBlbGVtZW50XG4gICAqXG4gICAqIC0gT24gZGVza3RvcHM6IGEgY2xpY2sgb24gdGhlIHZpZGVvIGl0c2VsZiB3aWxsIHRvZ2dsZSBwbGF5YmFja1xuICAgKiAtIE9uIG1vYmlsZSBkZXZpY2VzOiBhIGNsaWNrIG9uIHRoZSB2aWRlbyB0b2dnbGVzIGNvbnRyb2xzXG4gICAqICAgd2hpY2ggaXMgZG9uZSBieSB0b2dnbGluZyB0aGUgdXNlciBzdGF0ZSBiZXR3ZWVuIGFjdGl2ZSBhbmRcbiAgICogICBpbmFjdGl2ZVxuICAgKiAtIEEgdGFwIGNhbiBzaWduYWwgdGhhdCBhIHVzZXIgaGFzIGJlY29tZSBhY3RpdmUgb3IgaGFzIGJlY29tZSBpbmFjdGl2ZVxuICAgKiAgIGUuZy4gYSBxdWljayB0YXAgb24gYW4gaVBob25lIG1vdmllIHNob3VsZCByZXZlYWwgdGhlIGNvbnRyb2xzLiBBbm90aGVyXG4gICAqICAgcXVpY2sgdGFwIHNob3VsZCBoaWRlIHRoZW0gYWdhaW4gKHNpZ25hbGluZyB0aGUgdXNlciBpcyBpbiBhbiBpbmFjdGl2ZVxuICAgKiAgIHZpZXdpbmcgc3RhdGUpXG4gICAqIC0gSW4gYWRkaXRpb24gdG8gdGhpcywgd2Ugc3RpbGwgd2FudCB0aGUgdXNlciB0byBiZSBjb25zaWRlcmVkIGluYWN0aXZlIGFmdGVyXG4gICAqICAgYSBmZXcgc2Vjb25kcyBvZiBpbmFjdGl2aXR5LlxuICAgKlxuICAgKiA+IE5vdGU6IHRoZSBvbmx5IHBhcnQgb2YgaU9TIGludGVyYWN0aW9uIHdlIGNhbid0IG1pbWljIHdpdGggdGhpcyBzZXR1cFxuICAgKiBpcyBhIHRvdWNoIGFuZCBob2xkIG9uIHRoZSB2aWRlbyBlbGVtZW50IGNvdW50aW5nIGFzIGFjdGl2aXR5IGluIG9yZGVyIHRvXG4gICAqIGtlZXAgdGhlIGNvbnRyb2xzIHNob3dpbmcsIGJ1dCB0aGF0IHNob3VsZG4ndCBiZSBhbiBpc3N1ZS4gQSB0b3VjaCBhbmQgaG9sZFxuICAgKiBvbiBhbnkgY29udHJvbHMgd2lsbCBzdGlsbCBrZWVwIHRoZSB1c2VyIGFjdGl2ZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXyA9IGZ1bmN0aW9uIGFkZFRlY2hDb250cm9sc0xpc3RlbmVyc18oKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRvIHJlbW92ZSBhbGwgdGhlIHByZXZpb3VzIGxpc3RlbmVycyBpbiBjYXNlIHdlIGFyZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgdGhpcy5yZW1vdmVUZWNoQ29udHJvbHNMaXN0ZW5lcnNfKCk7XG5cbiAgICAvLyBTb21lIGJyb3dzZXJzIChDaHJvbWUgJiBJRSkgZG9uJ3QgdHJpZ2dlciBhIGNsaWNrIG9uIGEgZmxhc2ggc3dmLCBidXQgZG9cbiAgICAvLyB0cmlnZ2VyIG1vdXNlZG93bi91cC5cbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0NDQ1NjIvamF2YXNjcmlwdC1vbmNsaWNrLWV2ZW50LW92ZXItZmxhc2gtb2JqZWN0XG4gICAgLy8gQW55IHRvdWNoIGV2ZW50cyBhcmUgc2V0IHRvIGJsb2NrIHRoZSBtb3VzZWRvd24gZXZlbnQgZnJvbSBoYXBwZW5pbmdcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZVRlY2hDbGlja18pO1xuXG4gICAgLy8gSWYgdGhlIGNvbnRyb2xzIHdlcmUgaGlkZGVuIHdlIGRvbid0IHdhbnQgdGhhdCB0byBjaGFuZ2Ugd2l0aG91dCBhIHRhcCBldmVudFxuICAgIC8vIHNvIHdlJ2xsIGNoZWNrIGlmIHRoZSBjb250cm9scyB3ZXJlIGFscmVhZHkgc2hvd2luZyBiZWZvcmUgcmVwb3J0aW5nIHVzZXJcbiAgICAvLyBhY3Rpdml0eVxuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaFN0YXJ0Xyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUZWNoVG91Y2hNb3ZlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaEVuZF8pO1xuXG4gICAgLy8gVGhlIHRhcCBsaXN0ZW5lciBuZWVkcyB0byBjb21lIGFmdGVyIHRoZSB0b3VjaGVuZCBsaXN0ZW5lciBiZWNhdXNlIHRoZSB0YXBcbiAgICAvLyBsaXN0ZW5lciBjYW5jZWxzIG91dCBhbnkgcmVwb3J0ZWRVc2VyQWN0aXZpdHkgd2hlbiBzZXR0aW5nIHVzZXJBY3RpdmUoZmFsc2UpXG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndGFwJywgdGhpcy5oYW5kbGVUZWNoVGFwXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIHVzZWQgZm9yIGNsaWNrIGFuZCB0YXAgY29udHJvbHMuIFRoaXMgaXMgbmVlZGVkIGZvclxuICAgKiB0b2dnbGluZyB0byBjb250cm9scyBkaXNhYmxlZCwgd2hlcmUgYSB0YXAvdG91Y2ggc2hvdWxkIGRvIG5vdGhpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZW1vdmVUZWNoQ29udHJvbHNMaXN0ZW5lcnNfID0gZnVuY3Rpb24gcmVtb3ZlVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpIHtcbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIGp1c3QgdXNlIGB0aGlzLm9mZigpYCBiZWNhdXNlIHRoZXJlIG1pZ2h0IGJlIG90aGVyIG5lZWRlZFxuICAgIC8vIGxpc3RlbmVycyBhZGRlZCBieSB0ZWNocyB0aGF0IGV4dGVuZCB0aGlzLlxuICAgIHRoaXMub2ZmKHRoaXMudGVjaF8sICd0YXAnLCB0aGlzLmhhbmRsZVRlY2hUYXBfKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoU3RhcnRfKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUZWNoVG91Y2hNb3ZlXyk7XG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUZWNoVG91Y2hFbmRfKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAnbW91c2Vkb3duJywgdGhpcy5oYW5kbGVUZWNoQ2xpY2tfKTtcbiAgfTtcblxuICAvKipcbiAgICogUGxheWVyIHdhaXRzIGZvciB0aGUgdGVjaCB0byBiZSByZWFkeVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFJlYWR5XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hSZWFkeV8oKSB7XG4gICAgdGhpcy50cmlnZ2VyUmVhZHkoKTtcblxuICAgIC8vIEtlZXAgdGhlIHNhbWUgdm9sdW1lIGFzIGJlZm9yZVxuICAgIGlmICh0aGlzLmNhY2hlXy52b2x1bWUpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRWb2x1bWUnLCB0aGlzLmNhY2hlXy52b2x1bWUpO1xuICAgIH1cblxuICAgIC8vIExvb2sgaWYgdGhlIHRlY2ggZm91bmQgYSBoaWdoZXIgcmVzb2x1dGlvbiBwb3N0ZXIgd2hpbGUgbG9hZGluZ1xuICAgIHRoaXMuaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8oKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgZHVyYXRpb24gaWYgYXZhaWxhYmxlXG4gICAgdGhpcy5oYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2VfKCk7XG5cbiAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSBib3RoIGhhdmUgaXNzdWVzIHdpdGggYXV0b3BsYXkuXG4gICAgLy8gSW4gU2FmYXJpICg1LjEuMSksIHdoZW4gd2UgbW92ZSB0aGUgdmlkZW8gZWxlbWVudCBpbnRvIHRoZSBjb250YWluZXIgZGl2LCBhdXRvcGxheSBkb2Vzbid0IHdvcmsuXG4gICAgLy8gSW4gQ2hyb21lICgxNSksIGlmIHlvdSBoYXZlIGF1dG9wbGF5ICsgYSBwb3N0ZXIgKyBubyBjb250cm9scywgdGhlIHZpZGVvIGdldHMgaGlkZGVuIChidXQgYXVkaW8gcGxheXMpXG4gICAgLy8gVGhpcyBmaXhlcyBib3RoIGlzc3Vlcy4gTmVlZCB0byB3YWl0IGZvciBBUEksIHNvIGl0IHVwZGF0ZXMgZGlzcGxheXMgY29ycmVjdGx5XG4gICAgaWYgKCh0aGlzLnNyYygpIHx8IHRoaXMuY3VycmVudFNyYygpKSAmJiB0aGlzLnRhZyAmJiB0aGlzLm9wdGlvbnNfLmF1dG9wbGF5ICYmIHRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENocm9tZSBGaXguIEZpeGVkIGluIENocm9tZSB2MTYuXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRhZy5wb3N0ZXI7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZyQxKCdkZWxldGluZyB0YWcucG9zdGVyIHRocm93cyBpbiBzb21lIGJyb3dzZXJzJywgZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYGxvYWRzdGFydGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uIFRoaXNcbiAgICogZnVuY3Rpb24gd2lsbCBhbHNvIHRyaWdnZXIge0BsaW5rIFBsYXllciNmaXJzdHBsYXl9IGlmIGl0IGlzIHRoZSBmaXJzdCBsb2Fkc3RhcnRcbiAgICogZm9yIGEgdmlkZW8uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjbG9hZHN0YXJ0XG4gICAqIEBmaXJlcyBQbGF5ZXIjZmlyc3RwbGF5XG4gICAqIEBsaXN0ZW5zIFRlY2gjbG9hZHN0YXJ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoTG9hZFN0YXJ0XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hMb2FkU3RhcnRfKCkge1xuICAgIC8vIFRPRE86IFVwZGF0ZSB0byB1c2UgYGVtcHRpZWRgIGV2ZW50IGluc3RlYWQuIFNlZSAjMTI3Ny5cblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zZWVraW5nJyk7XG5cbiAgICAvLyByZXNldCB0aGUgZXJyb3Igc3RhdGVcbiAgICB0aGlzLmVycm9yKG51bGwpO1xuXG4gICAgLy8gSWYgaXQncyBhbHJlYWR5IHBsYXlpbmcgd2Ugd2FudCB0byB0cmlnZ2VyIGEgZmlyc3RwbGF5IGV2ZW50IG5vdy5cbiAgICAvLyBUaGUgZmlyc3RwbGF5IGV2ZW50IHJlbGllcyBvbiBib3RoIHRoZSBwbGF5IGFuZCBsb2Fkc3RhcnQgZXZlbnRzXG4gICAgLy8gd2hpY2ggY2FuIGhhcHBlbiBpbiBhbnkgb3JkZXIgZm9yIGEgbmV3IHNvdXJjZVxuICAgIGlmICghdGhpcy5wYXVzZWQoKSkge1xuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGFnZW50IGJlZ2lucyBsb29raW5nIGZvciBtZWRpYSBkYXRhXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IFBsYXllciNsb2Fkc3RhcnRcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZmlyc3RwbGF5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlc2V0IHRoZSBoYXNTdGFydGVkIHN0YXRlXG4gICAgICB0aGlzLmhhc1N0YXJ0ZWQoZmFsc2UpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZC9yZW1vdmUgdGhlIHZqcy1oYXMtc3RhcnRlZCBjbGFzc1xuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2ZpcnN0cGxheVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1N0YXJ0ZWRcbiAgICogICAgICAgIC0gdHJ1ZTogYWRkcyB0aGUgY2xhc3NcbiAgICogICAgICAgIC0gZmFsc2U6IHJlbW92ZSB0aGUgY2xhc3NcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICB0aGUgYm9vbGVhbiB2YWx1ZSBvZiBoYXNTdGFydGVkXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYXNTdGFydGVkID0gZnVuY3Rpb24gaGFzU3RhcnRlZChfaGFzU3RhcnRlZCkge1xuICAgIGlmIChfaGFzU3RhcnRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBvbmx5IHVwZGF0ZSBpZiB0aGlzIGlzIGEgbmV3IHZhbHVlXG4gICAgICBpZiAodGhpcy5oYXNTdGFydGVkXyAhPT0gX2hhc1N0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5oYXNTdGFydGVkXyA9IF9oYXNTdGFydGVkO1xuICAgICAgICBpZiAoX2hhc1N0YXJ0ZWQpIHtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdHBsYXkgZXZlbnQgaWYgdGhpcyBuZXdseSBoYXMgcGxheWVkXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLmhhc1N0YXJ0ZWRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgbWVkaWEgYmVnaW5zIG9yIHJlc3VtZXMgcGxheWJhY2tcbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS1tZWRpYS1wbGF5fVxuICAgKiBAZmlyZXMgUGxheWVyI3BsYXlcbiAgICogQGxpc3RlbnMgVGVjaCNwbGF5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUGxheV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUGxheV8oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG5cbiAgICAvLyBoaWRlIHRoZSBwb3N0ZXIgd2hlbiB0aGUgdXNlciBoaXRzIHBsYXlcbiAgICB0aGlzLmhhc1N0YXJ0ZWQodHJ1ZSk7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW5ldmVyIGFuIHtAbGluayBUZWNoI3BsYXl9IGV2ZW50IGhhcHBlbnMuIEluZGljYXRlcyB0aGF0XG4gICAgICogcGxheWJhY2sgaGFzIHN0YXJ0ZWQgb3IgcmVzdW1lZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcGxheVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3BsYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgd2FpdGluZ2AgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjd2FpdGluZ1xuICAgKiBAbGlzdGVucyBUZWNoI3dhaXRpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hXYWl0aW5nXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hXYWl0aW5nXygpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgLyoqXG4gICAgICogQSByZWFkeVN0YXRlIGNoYW5nZSBvbiB0aGUgRE9NIGVsZW1lbnQgaGFzIGNhdXNlZCBwbGF5YmFjayB0byBzdG9wLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciN3YWl0aW5nXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignd2FpdGluZycpO1xuICAgIHRoaXMub25lKCd0aW1ldXBkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzNC5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgY2FucGxheWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqID4gTm90ZTogVGhpcyBpcyBub3QgY29uc2lzdGVudCBiZXR3ZWVuIGJyb3dzZXJzLiBTZWUgIzEzNTFcbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNjYW5wbGF5XG4gICAqIEBsaXN0ZW5zIFRlY2gjY2FucGxheVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaENhblBsYXlfID0gZnVuY3Rpb24gaGFuZGxlVGVjaENhblBsYXlfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgLyoqXG4gICAgICogVGhlIG1lZGlhIGhhcyBhIHJlYWR5U3RhdGUgb2YgSEFWRV9GVVRVUkVfREFUQSBvciBncmVhdGVyLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNjYW5wbGF5XG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignY2FucGxheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBjYW5wbGF5dGhyb3VnaGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjY2FucGxheXRocm91Z2hcbiAgICogQGxpc3RlbnMgVGVjaCNjYW5wbGF5dGhyb3VnaFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaENhblBsYXlUaHJvdWdoXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hDYW5QbGF5VGhyb3VnaF8oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWVkaWEgaGFzIGEgcmVhZHlTdGF0ZSBvZiBIQVZFX0VOT1VHSF9EQVRBIG9yIGdyZWF0ZXIuIFRoaXMgbWVhbnMgdGhhdCB0aGVcbiAgICAgKiBlbnRpcmUgbWVkaWEgZmlsZSBjYW4gYmUgcGxheWVkIHdpdGhvdXQgYnVmZmVyaW5nLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNjYW5wbGF5dGhyb3VnaFxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2NhbnBsYXl0aHJvdWdoJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHBsYXlpbmdgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3BsYXlpbmdcbiAgICogQGxpc3RlbnMgVGVjaCNwbGF5aW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUGxheWluZ18gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUGxheWluZ18oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWVkaWEgaXMgbm8gbG9uZ2VyIGJsb2NrZWQgZnJvbSBwbGF5YmFjaywgYW5kIGhhcyBzdGFydGVkIHBsYXlpbmcuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3BsYXlpbmdcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdwbGF5aW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHNlZWtpbmdgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3NlZWtpbmdcbiAgICogQGxpc3RlbnMgVGVjaCNzZWVraW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoU2Vla2luZ18gPSBmdW5jdGlvbiBoYW5kbGVUZWNoU2Vla2luZ18oKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXNlZWtpbmcnKTtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgcGxheWVyIGlzIGp1bXBpbmcgdG8gYSBuZXcgdGltZVxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNzZWVraW5nXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignc2Vla2luZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBzZWVrZWRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3NlZWtlZFxuICAgKiBAbGlzdGVucyBUZWNoI3NlZWtlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFNlZWtlZF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoU2Vla2VkXygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2Vla2luZycpO1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBoYXMgZmluaXNoZWQganVtcGluZyB0byBhIG5ldyB0aW1lXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3NlZWtlZFxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3NlZWtlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBmaXJzdHBsYXlgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2ZpcnN0cGxheVxuICAgKiBAbGlzdGVucyBUZWNoI2ZpcnN0cGxheVxuICAgKiBAZGVwcmVjYXRlZCBBcyBvZiA2LjAgZmlyc3RwbGF5IGV2ZW50IGlzIGRlcHJlY2F0ZWQuXG4gICAqIEBkZXByZWNhdGVkIEFzIG9mIDYuMCBwYXNzaW5nIHRoZSBgc3RhcnR0aW1lYCBvcHRpb24gdG8gdGhlIHBsYXllciBhbmQgdGhlIGZpcnN0cGxheSBldmVudCBhcmUgZGVwcmVjYXRlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hGaXJzdFBsYXlfID0gZnVuY3Rpb24gaGFuZGxlVGVjaEZpcnN0UGxheV8oKSB7XG4gICAgLy8gSWYgdGhlIGZpcnN0IHN0YXJ0dGltZSBhdHRyaWJ1dGUgaXMgc3BlY2lmaWVkXG4gICAgLy8gdGhlbiB3ZSB3aWxsIHN0YXJ0IGF0IHRoZSBnaXZlbiBvZmZzZXQgaW4gc2Vjb25kc1xuICAgIGlmICh0aGlzLm9wdGlvbnNfLnN0YXJ0dGltZSkge1xuICAgICAgbG9nJDEud2FybignUGFzc2luZyB0aGUgYHN0YXJ0dGltZWAgb3B0aW9uIHRvIHRoZSBwbGF5ZXIgd2lsbCBiZSBkZXByZWNhdGVkIGluIDYuMCcpO1xuICAgICAgdGhpcy5jdXJyZW50VGltZSh0aGlzLm9wdGlvbnNfLnN0YXJ0dGltZSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWhhcy1zdGFydGVkJyk7XG4gICAgLyoqXG4gICAgICogRmlyZWQgdGhlIGZpcnN0IHRpbWUgYSB2aWRlbyBpcyBwbGF5ZWQuIE5vdCBwYXJ0IG9mIHRoZSBITFMgc3BlYywgYW5kIHRoaXMgaXNcbiAgICAgKiBwcm9iYWJseSBub3QgdGhlIGJlc3QgaW1wbGVtZW50YXRpb24geWV0LCBzbyB1c2Ugc3BhcmluZ2x5LiBJZiB5b3UgZG9uJ3QgaGF2ZSBhXG4gICAgICogcmVhc29uIHRvIHByZXZlbnQgcGxheWJhY2ssIHVzZSBgbXlQbGF5ZXIub25lKCdwbGF5Jyk7YCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNmaXJzdHBsYXlcbiAgICAgKiBAZGVwcmVjYXRlZCBBcyBvZiA2LjAgZmlyc3RwbGF5IGV2ZW50IGlzIGRlcHJlY2F0ZWQuXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignZmlyc3RwbGF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHBhdXNlYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNwYXVzZVxuICAgKiBAbGlzdGVucyBUZWNoI3BhdXNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUGF1c2VfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFBhdXNlXygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGxheWluZycpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgbWVkaWEgaGFzIGJlZW4gcGF1c2VkXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3BhdXNlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcigncGF1c2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgZW5kZWRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2VuZGVkXG4gICAqIEBsaXN0ZW5zIFRlY2gjZW5kZWRcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hFbmRlZF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRW5kZWRfKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuICAgIGlmICh0aGlzLm9wdGlvbnNfLmxvb3ApIHtcbiAgICAgIHRoaXMuY3VycmVudFRpbWUoMCk7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnBhdXNlZCgpKSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgZW5kIG9mIHRoZSBtZWRpYSByZXNvdXJjZSBpcyByZWFjaGVkIChjdXJyZW50VGltZSA9PSBkdXJhdGlvbilcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZW5kZWRcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdlbmRlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBkdXJhdGlvbiBvZiB0aGUgbWVkaWEgcmVzb3VyY2UgaXMgZmlyc3Qga25vd24gb3IgY2hhbmdlZFxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI2R1cmF0aW9uY2hhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlVGVjaER1cmF0aW9uQ2hhbmdlXygpIHtcbiAgICB0aGlzLmR1cmF0aW9uKHRoaXMudGVjaEdldF8oJ2R1cmF0aW9uJykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBjbGljayBvbiB0aGUgbWVkaWEgZWxlbWVudCB0byBwbGF5L3BhdXNlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICB0aGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byB0cmlnZ2VyXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjbW91c2Vkb3duXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoQ2xpY2tfID0gZnVuY3Rpb24gaGFuZGxlVGVjaENsaWNrXyhldmVudCkge1xuICAgIC8vIFdlJ3JlIHVzaW5nIG1vdXNlZG93biB0byBkZXRlY3QgY2xpY2tzIHRoYW5rcyB0byBGbGFzaCwgYnV0IG1vdXNlZG93blxuICAgIC8vIHdpbGwgYWxzbyBiZSB0cmlnZ2VyZWQgd2l0aCByaWdodC1jbGlja3MsIHNvIHdlIG5lZWQgdG8gcHJldmVudCB0aGF0XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdoZW4gY29udHJvbHMgYXJlIGRpc2FibGVkIGEgY2xpY2sgc2hvdWxkIG5vdCB0b2dnbGUgcGxheWJhY2sgYmVjYXVzZVxuICAgIC8vIHRoZSBjbGljayBpcyBjb25zaWRlcmVkIGEgY29udHJvbFxuICAgIGlmICh0aGlzLmNvbnRyb2xzKCkpIHtcbiAgICAgIGlmICh0aGlzLnBhdXNlZCgpKSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgdGFwIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBJdCB3aWxsIHRvZ2dsZSB0aGUgdXNlclxuICAgKiBhY3Rpdml0eSBzdGF0ZSwgd2hpY2ggaGlkZXMgYW5kIHNob3dzIHRoZSBjb250cm9scy5cbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCN0YXBcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUYXBfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRhcF8oKSB7XG4gICAgdGhpcy51c2VyQWN0aXZlKCF0aGlzLnVzZXJBY3RpdmUoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0b3VjaCB0byBzdGFydFxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3RvdWNoc3RhcnRcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUb3VjaFN0YXJ0XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUb3VjaFN0YXJ0XygpIHtcbiAgICB0aGlzLnVzZXJXYXNBY3RpdmUgPSB0aGlzLnVzZXJBY3RpdmUoKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRvdWNoIHRvIG1vdmVcbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCN0b3VjaG1vdmVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUb3VjaE1vdmVfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRvdWNoTW92ZV8oKSB7XG4gICAgaWYgKHRoaXMudXNlcldhc0FjdGl2ZSkge1xuICAgICAgdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0b3VjaCB0byBlbmRcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIHRoZSB0b3VjaGVuZCBldmVudCB0aGF0IHRyaWdnZXJlZFxuICAgKiAgICAgICAgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3RvdWNoZW5kXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVG91Y2hFbmRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRvdWNoRW5kXyhldmVudCkge1xuICAgIC8vIFN0b3AgdGhlIG1vdXNlIGV2ZW50cyBmcm9tIGFsc28gaGFwcGVuaW5nXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIHN3aXRjaGVzIGluIG9yIG91dCBvZiBmdWxsc2NyZWVuIG1vZGVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGxpc3RlbnMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlRnVsbHNjcmVlbkNoYW5nZV8oKSB7XG4gICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1mdWxsc2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1mdWxsc2NyZWVuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBuYXRpdmUgY2xpY2sgZXZlbnRzIG9uIHRoZSBTV0YgYXJlbid0IHRyaWdnZXJlZCBvbiBJRTExLCBXaW44LjFSVFxuICAgKiB1c2Ugc3RhZ2VjbGljayBldmVudHMgdHJpZ2dlcmVkIGZyb20gaW5zaWRlIHRoZSBTV0YgaW5zdGVhZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbGlzdGVucyBzdGFnZWNsaWNrXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVTdGFnZUNsaWNrXyA9IGZ1bmN0aW9uIGhhbmRsZVN0YWdlQ2xpY2tfKCkge1xuICAgIHRoaXMucmVwb3J0VXNlckFjdGl2aXR5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBUZWNoIEZ1bGxzY3JlZW4gQ2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICB0aGUgZnVsbHNjcmVlbmNoYW5nZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqICAgICAgICB0aGUgZGF0YSB0aGF0IHdhcyBzZW50IHdpdGggdGhlIGV2ZW50XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBsaXN0ZW5zIFRlY2gjZnVsbHNjcmVlbmNoYW5nZVxuICAgKiBAZmlyZXMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlXyhldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLmlzRnVsbHNjcmVlbihkYXRhLmlzRnVsbHNjcmVlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gZ29pbmcgaW4gYW5kIG91dCBvZiBmdWxsc2NyZWVuLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgbG9hZGluZyBvZiBhbiBhdWRpby92aWRlby5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGxpc3RlbnMgVGVjaCNlcnJvclxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEVycm9yXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hFcnJvcl8oKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy50ZWNoXy5lcnJvcigpO1xuXG4gICAgdGhpcy5lcnJvcihlcnJvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHRleHRkYXRhYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciN0ZXh0ZGF0YVxuICAgKiBAbGlzdGVucyBUZWNoI3RleHRkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVGV4dERhdGFfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRleHREYXRhXygpIHtcbiAgICB2YXIgZGF0YSA9IG51bGw7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB3ZSBnZXQgYSB0ZXh0ZGF0YSBldmVudCBmcm9tIHRlY2hcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjdGV4dGRhdGFcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCd0ZXh0ZGF0YScsIGRhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb2JqZWN0IGZvciBjYWNoZWQgdmFsdWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgZ2V0IHRoZSBjdXJyZW50IG9iamVjdCBjYWNoZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZ2V0Q2FjaGUgPSBmdW5jdGlvbiBnZXRDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhc3MgdmFsdWVzIHRvIHRoZSBwbGF5YmFjayB0ZWNoXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kXVxuICAgKiAgICAgICAgdGhlIG1ldGhvZCB0byBjYWxsXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdcbiAgICogICAgICAgIHRoZSBhcmd1bWVudCB0byBwYXNzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS50ZWNoQ2FsbF8gPSBmdW5jdGlvbiB0ZWNoQ2FsbF8obWV0aG9kLCBhcmcpIHtcbiAgICAvLyBJZiBpdCdzIG5vdCByZWFkeSB5ZXQsIGNhbGwgbWV0aG9kIHdoZW4gaXQgaXNcblxuICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1ldGhvZCBpbiBhbGxvd2VkU2V0dGVycykge1xuICAgICAgICByZXR1cm4gc2V0JDEodGhpcy5taWRkbGV3YXJlXywgdGhpcy50ZWNoXywgbWV0aG9kLCBhcmcpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgICAgIHRoaXMudGVjaF9bbWV0aG9kXShhcmcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZyQxKGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0sIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgY2FsbHMgY2FuJ3Qgd2FpdCBmb3IgdGhlIHRlY2gsIGFuZCBzb21ldGltZXMgZG9uJ3QgbmVlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICAgKiAgICAgICAgVGVjaCBtZXRob2RcbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIHRoZSBtZXRob2Qgb3IgdW5kZWZpbmVkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS50ZWNoR2V0XyA9IGZ1bmN0aW9uIHRlY2hHZXRfKG1ldGhvZCkge1xuICAgIGlmICh0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8uaXNSZWFkeV8pIHtcblxuICAgICAgaWYgKG1ldGhvZCBpbiBhbGxvd2VkR2V0dGVycykge1xuICAgICAgICByZXR1cm4gZ2V0JDEodGhpcy5taWRkbGV3YXJlXywgdGhpcy50ZWNoXywgbWV0aG9kKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmxhc2ggbGlrZXMgdG8gZGllIGFuZCByZWxvYWQgd2hlbiB5b3UgaGlkZSBvciByZXBvc2l0aW9uIGl0LlxuICAgICAgLy8gSW4gdGhlc2UgY2FzZXMgdGhlIG9iamVjdCBtZXRob2RzIGdvIGF3YXkgYW5kIHdlIGdldCBlcnJvcnMuXG4gICAgICAvLyBXaGVuIHRoYXQgaGFwcGVucyB3ZSdsbCBjYXRjaCB0aGUgZXJyb3JzIGFuZCBpbmZvcm0gdGVjaCB0aGF0IGl0J3Mgbm90IHJlYWR5IGFueSBtb3JlLlxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVjaF9bbWV0aG9kXSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBXaGVuIGJ1aWxkaW5nIGFkZGl0aW9uYWwgdGVjaCBsaWJzLCBhbiBleHBlY3RlZCBtZXRob2QgbWF5IG5vdCBiZSBkZWZpbmVkIHlldFxuICAgICAgICBpZiAodGhpcy50ZWNoX1ttZXRob2RdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsb2ckMSgnVmlkZW8uanM6ICcgKyBtZXRob2QgKyAnIG1ldGhvZCBub3QgZGVmaW5lZCBmb3IgJyArIHRoaXMudGVjaE5hbWVfICsgJyBwbGF5YmFjayB0ZWNobm9sb2d5LicsIGUpO1xuXG4gICAgICAgICAgLy8gV2hlbiBhIG1ldGhvZCBpc24ndCBhdmFpbGFibGUgb24gdGhlIG9iamVjdCBpdCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAgICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgICAgbG9nJDEoJ1ZpZGVvLmpzOiAnICsgbWV0aG9kICsgJyB1bmF2YWlsYWJsZSBvbiAnICsgdGhpcy50ZWNoTmFtZV8gKyAnIHBsYXliYWNrIHRlY2hub2xvZ3kgZWxlbWVudC4nLCBlKTtcbiAgICAgICAgICB0aGlzLnRlY2hfLmlzUmVhZHlfID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nJDEoZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH07XG5cbiAgLyoqXG4gICAqIHN0YXJ0IG1lZGlhIHBsYXliYWNrXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFJldHVybnMgYSBgUHJvbWlzZWAgaWYgdGhlIGJyb3dzZXIgcmV0dXJucyBvbmUsIGZvciBtb3N0IGJyb3dzZXJzIHRoaXMgd2lsbFxuICAgKiAgICAgICAgIHJldHVybiB1bmRlZmluZWQuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gcGxheSgpIHtcbiAgICBpZiAodGhpcy5jaGFuZ2luZ1NyY18pIHtcbiAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmV0dmFsID0gdGhpcy50ZWNoR2V0XygncGxheScpO1xuXG4gICAgICAgIC8vIHNpbGVuY2UgZXJyb3JzICh1bmhhbmRsZWQgcHJvbWlzZSBmcm9tIHBsYXkpXG4gICAgICAgIGlmIChyZXR2YWwgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmV0dmFsLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR2YWwudGhlbihudWxsLCBmdW5jdGlvbiAoZSkge30pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gT25seSBjYWxscyB0aGUgdGVjaCdzIHBsYXkgaWYgd2UgYWxyZWFkeSBoYXZlIGEgc3JjIGxvYWRlZFxuICAgIH0gZWxzZSBpZiAodGhpcy5pc1JlYWR5XyAmJiAodGhpcy5zcmMoKSB8fCB0aGlzLmN1cnJlbnRTcmMoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwbGF5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRlY2hfLm9uZSgnbG9hZHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXR2YWwgPSB0aGlzLnBsYXkoKTtcblxuICAgICAgICAgIC8vIHNpbGVuY2UgZXJyb3JzICh1bmhhbmRsZWQgcHJvbWlzZSBmcm9tIHBsYXkpXG4gICAgICAgICAgaWYgKHJldHZhbCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXR2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dmFsLnRoZW4obnVsbCwgZnVuY3Rpb24gKGUpIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgdmlkZW8gcGxheWJhY2tcbiAgICpcbiAgICogQHJldHVybiB7UGxheWVyfVxuICAgKiAgICAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSBwbGF5ZXIgb2JqZWN0IHRoaXMgZnVuY3Rpb24gd2FzIGNhbGxlZCBvblxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICB0aGlzLnRlY2hDYWxsXygncGF1c2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHBsYXllciBpcyBwYXVzZWQgb3IgaGFzIHlldCB0byBwbGF5XG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSBmYWxzZTogaWYgdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBwbGF5aW5nXG4gICAqICAgICAgICAgLSB0cnVlOiBpZiBtZWRpYSBpcyBub3QgY3VycmVudGx5IHBsYXlpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnBhdXNlZCA9IGZ1bmN0aW9uIHBhdXNlZCgpIHtcbiAgICAvLyBUaGUgaW5pdGlhbCBzdGF0ZSBvZiBwYXVzZWQgc2hvdWxkIGJlIHRydWUgKGluIFNhZmFyaSBpdCdzIGFjdHVhbGx5IGZhbHNlKVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwYXVzZWQnKSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIFRpbWVSYW5nZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHJhbmdlcyBvZiB0aW1lIHRoYXQgdGhlIHVzZXJcbiAgICogaGFzIHBsYXllZC5cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIEEgdGltZSByYW5nZSBvYmplY3QgdGhhdCByZXByZXNlbnRzIGFsbCB0aGUgaW5jcmVtZW50cyBvZiB0aW1lIHRoYXQgaGF2ZVxuICAgKiAgICAgICAgIGJlZW4gcGxheWVkLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGxheWVkID0gZnVuY3Rpb24gcGxheWVkKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwbGF5ZWQnKSB8fCBjcmVhdGVUaW1lUmFuZ2VzKDAsIDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIGlzIFwic2NydWJiaW5nXCIuIFNjcnViYmluZyBpc1xuICAgKiB3aGVuIHRoZSB1c2VyIGhhcyBjbGlja2VkIHRoZSBwcm9ncmVzcyBiYXIgaGFuZGxlIGFuZCBpc1xuICAgKiBkcmFnZ2luZyBpdCBhbG9uZyB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NjcnViYmluZ11cbiAgICogICAgICAgIHdldGhlciB0aGUgdXNlciBpcyBvciBpcyBub3Qgc2NydWJiaW5nXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgVGhlIHZhbHVlIG9mIHNjcnViYmluZyB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnNjcnViYmluZyA9IGZ1bmN0aW9uIHNjcnViYmluZyhpc1NjcnViYmluZykge1xuICAgIGlmICh0eXBlb2YgaXNTY3J1YmJpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3J1YmJpbmdfO1xuICAgIH1cbiAgICB0aGlzLnNjcnViYmluZ18gPSAhIWlzU2NydWJiaW5nO1xuXG4gICAgaWYgKGlzU2NydWJiaW5nKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2NydWJiaW5nJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zY3J1YmJpbmcnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGN1cnJlbnQgdGltZSAoaW4gc2Vjb25kcylcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbc2Vjb25kc11cbiAgICogICAgICAgIFRoZSB0aW1lIHRvIHNlZWsgdG8gaW4gc2Vjb25kc1xuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgLSB0aGUgY3VycmVudCB0aW1lIGluIHNlY29uZHMgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50VGltZSA9IGZ1bmN0aW9uIGN1cnJlbnRUaW1lKHNlY29uZHMpIHtcbiAgICBpZiAodHlwZW9mIHNlY29uZHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0Q3VycmVudFRpbWUnLCBzZWNvbmRzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjYWNoZSBsYXN0IGN1cnJlbnRUaW1lIGFuZCByZXR1cm4uIGRlZmF1bHQgdG8gMCBzZWNvbmRzXG4gICAgLy9cbiAgICAvLyBDYWNoaW5nIHRoZSBjdXJyZW50VGltZSBpcyBtZWFudCB0byBwcmV2ZW50IGEgbWFzc2l2ZSBhbW91bnQgb2YgcmVhZHMgb24gdGhlIHRlY2gnc1xuICAgIC8vIGN1cnJlbnRUaW1lIHdoZW4gc2NydWJiaW5nLCBidXQgbWF5IG5vdCBwcm92aWRlIG11Y2ggcGVyZm9ybWFuY2UgYmVuZWZpdCBhZnRlcmFsbC5cbiAgICAvLyBTaG91bGQgYmUgdGVzdGVkLiBBbHNvIHNvbWV0aGluZyBoYXMgdG8gcmVhZCB0aGUgYWN0dWFsIGN1cnJlbnQgdGltZSBvciB0aGUgY2FjaGUgd2lsbFxuICAgIC8vIG5ldmVyIGdldCB1cGRhdGVkLlxuICAgIHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lID0gdGhpcy50ZWNoR2V0XygnY3VycmVudFRpbWUnKSB8fCAwO1xuICAgIHJldHVybiB0aGlzLmNhY2hlXy5jdXJyZW50VGltZTtcbiAgfTtcblxuICAvKipcbiAgICogTm9ybWFsbHkgZ2V0cyB0aGUgbGVuZ3RoIGluIHRpbWUgb2YgdGhlIHZpZGVvIGluIHNlY29uZHM7XG4gICAqIGluIGFsbCBidXQgdGhlIHJhcmVzdCB1c2UgY2FzZXMgYW4gYXJndW1lbnQgd2lsbCBOT1QgYmUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICpcbiAgICogPiAqKk5PVEUqKjogVGhlIHZpZGVvIG11c3QgaGF2ZSBzdGFydGVkIGxvYWRpbmcgYmVmb3JlIHRoZSBkdXJhdGlvbiBjYW4gYmVcbiAgICoga25vd24sIGFuZCBpbiB0aGUgY2FzZSBvZiBGbGFzaCwgbWF5IG5vdCBiZSBrbm93biB1bnRpbCB0aGUgdmlkZW8gc3RhcnRzXG4gICAqIHBsYXlpbmcuXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmRzXVxuICAgKiAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSB2aWRlbyB0byBzZXQgaW4gc2Vjb25kc1xuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgLSBUaGUgZHVyYXRpb24gb2YgdGhlIHZpZGVvIGluIHNlY29uZHMgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKHNlY29uZHMpIHtcbiAgICBpZiAoc2Vjb25kcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gTmFOIGlmIHRoZSBkdXJhdGlvbiBpcyBub3Qga25vd25cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlXy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5jYWNoZV8uZHVyYXRpb24gOiBOYU47XG4gICAgfVxuXG4gICAgc2Vjb25kcyA9IHBhcnNlRmxvYXQoc2Vjb25kcyk7XG5cbiAgICAvLyBTdGFuZGFyZGl6ZSBvbiBJbmlmaXR5IGZvciBzaWduYWxpbmcgdmlkZW8gaXMgbGl2ZVxuICAgIGlmIChzZWNvbmRzIDwgMCkge1xuICAgICAgc2Vjb25kcyA9IEluZmluaXR5O1xuICAgIH1cblxuICAgIGlmIChzZWNvbmRzICE9PSB0aGlzLmNhY2hlXy5kdXJhdGlvbikge1xuICAgICAgLy8gQ2FjaGUgdGhlIGxhc3Qgc2V0IHZhbHVlIGZvciBvcHRpbWl6ZWQgc2NydWJiaW5nIChlc3AuIEZsYXNoKVxuICAgICAgdGhpcy5jYWNoZV8uZHVyYXRpb24gPSBzZWNvbmRzO1xuXG4gICAgICBpZiAoc2Vjb25kcyA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWxpdmUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1saXZlJyk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdkdXJhdGlvbmNoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBob3cgbXVjaCB0aW1lIGlzIGxlZnQgaW4gdGhlIHZpZGVvLiBOb3QgcGFydFxuICAgKiBvZiB0aGUgbmF0aXZlIHZpZGVvIEFQSS5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSB0aW1lIHJlbWFpbmluZyBpbiBzZWNvbmRzXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZW1haW5pbmdUaW1lID0gZnVuY3Rpb24gcmVtYWluaW5nVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kdXJhdGlvbigpIC0gdGhpcy5jdXJyZW50VGltZSgpO1xuICB9O1xuXG4gIC8vXG4gIC8vIEtpbmQgb2YgbGlrZSBhbiBhcnJheSBvZiBwb3J0aW9ucyBvZiB0aGUgdmlkZW8gdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC5cblxuICAvKipcbiAgICogR2V0IGEgVGltZVJhbmdlIG9iamVjdCB3aXRoIGFuIGFycmF5IG9mIHRoZSB0aW1lcyBvZiB0aGUgdmlkZW9cbiAgICogdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC4gSWYgeW91IGp1c3Qgd2FudCB0aGUgcGVyY2VudCBvZiB0aGVcbiAgICogdmlkZW8gdGhhdCdzIGJlZW4gZG93bmxvYWRlZCwgdXNlIGJ1ZmZlcmVkUGVyY2VudC5cbiAgICpcbiAgICogQHNlZSBbQnVmZmVyZWQgU3BlY117QGxpbmsgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy92aWRlby5odG1sI2RvbS1tZWRpYS1idWZmZXJlZH1cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIEEgbW9jayBUaW1lUmFuZ2Ugb2JqZWN0IChmb2xsb3dpbmcgSFRNTCBzcGVjKVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYnVmZmVyZWQgPSBmdW5jdGlvbiBidWZmZXJlZCgpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnRlY2hHZXRfKCdidWZmZXJlZCcpO1xuXG4gICAgaWYgKCFidWZmZXJlZCB8fCAhYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICBidWZmZXJlZCA9IGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBlcmNlbnQgKGFzIGEgZGVjaW1hbCkgb2YgdGhlIHZpZGVvIHRoYXQncyBiZWVuIGRvd25sb2FkZWQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhIHBhcnQgb2YgdGhlIG5hdGl2ZSBIVE1MIHZpZGVvIEFQSS5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIEEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDEgcmVwcmVzZW50aW5nIHRoZSBwZXJjZW50XG4gICAqICAgICAgICAgdGhhdCBpcyBidWZmZXJyZWQgMCBiZWluZyAwJSBhbmQgMSBiZWluZyAxMDAlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5idWZmZXJlZFBlcmNlbnQgPSBmdW5jdGlvbiBidWZmZXJlZFBlcmNlbnQkJDEoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcmVkUGVyY2VudCh0aGlzLmJ1ZmZlcmVkKCksIHRoaXMuZHVyYXRpb24oKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZW5kaW5nIHRpbWUgb2YgdGhlIGxhc3QgYnVmZmVyZWQgdGltZSByYW5nZVxuICAgKiBUaGlzIGlzIHVzZWQgaW4gdGhlIHByb2dyZXNzIGJhciB0byBlbmNhcHN1bGF0ZSBhbGwgdGltZSByYW5nZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZW5kIG9mIHRoZSBsYXN0IGJ1ZmZlcmVkIHRpbWUgcmFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmJ1ZmZlcmVkRW5kID0gZnVuY3Rpb24gYnVmZmVyZWRFbmQoKSB7XG4gICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy5idWZmZXJlZCgpO1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKTtcbiAgICB2YXIgZW5kID0gYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkLmxlbmd0aCAtIDEpO1xuXG4gICAgaWYgKGVuZCA+IGR1cmF0aW9uKSB7XG4gICAgICBlbmQgPSBkdXJhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgbWVkaWFcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbcGVyY2VudEFzRGVjaW1hbF1cbiAgICogICAgICAgICBUaGUgbmV3IHZvbHVtZSBhcyBhIGRlY2ltYWwgcGVyY2VudDpcbiAgICogICAgICAgICAtIDAgaXMgbXV0ZWQvMCUvb2ZmXG4gICAqICAgICAgICAgLSAxLjAgaXMgMTAwJS9mdWxsXG4gICAqICAgICAgICAgLSAwLjUgaXMgaGFsZiB2b2x1bWUgb3IgNTAlXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2b2x1bWUgYXMgYSBwZXJjZW50IHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24gdm9sdW1lKHBlcmNlbnRBc0RlY2ltYWwpIHtcbiAgICB2YXIgdm9sID0gdm9pZCAwO1xuXG4gICAgaWYgKHBlcmNlbnRBc0RlY2ltYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRm9yY2UgdmFsdWUgdG8gYmV0d2VlbiAwIGFuZCAxXG4gICAgICB2b2wgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0KHBlcmNlbnRBc0RlY2ltYWwpKSk7XG4gICAgICB0aGlzLmNhY2hlXy52b2x1bWUgPSB2b2w7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0Vm9sdW1lJywgdm9sKTtcblxuICAgICAgaWYgKHZvbCA+IDApIHtcbiAgICAgICAgdGhpcy5sYXN0Vm9sdW1lXyh2b2wpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byAxIHdoZW4gcmV0dXJuaW5nIGN1cnJlbnQgdm9sdW1lLlxuICAgIHZvbCA9IHBhcnNlRmxvYXQodGhpcy50ZWNoR2V0Xygndm9sdW1lJykpO1xuICAgIHJldHVybiBpc05hTih2b2wpID8gMSA6IHZvbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG11dGVkIHN0YXRlLCBvciB0dXJuIG11dGUgb24gb3Igb2ZmXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211dGVkXVxuICAgKiAgICAgICAgLSB0cnVlIHRvIG11dGVcbiAgICogICAgICAgIC0gZmFsc2UgdG8gdW5tdXRlXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSB0cnVlIGlmIG11dGUgaXMgb24gYW5kIGdldHRpbmdcbiAgICogICAgICAgICAtIGZhbHNlIGlmIG11dGUgaXMgb2ZmIGFuZCBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5tdXRlZCA9IGZ1bmN0aW9uIG11dGVkKF9tdXRlZCkge1xuICAgIGlmIChfbXV0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldE11dGVkJywgX211dGVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ211dGVkJykgfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBkZWZhdWx0TXV0ZWQgc3RhdGUsIG9yIHR1cm4gZGVmYXVsdE11dGVkIG9uIG9yIG9mZi4gZGVmYXVsdE11dGVkXG4gICAqIGluZGljYXRlcyB0aGUgc3RhdGUgb2YgbXV0ZWQgb24gaW50aWFsIHBsYXliYWNrLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAgIHZhciBteVBsYXllciA9IHZpZGVvanMoJ3NvbWUtcGxheWVyLWlkJyk7XG4gICAqXG4gICAqICAgbXlQbGF5ZXIuc3JjKFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9wYXRoL3RvL3ZpZGVvLm1wNFwiKTtcbiAgICpcbiAgICogICAvLyBnZXQsIHNob3VsZCBiZSBmYWxzZVxuICAgKiAgIGNvbnNvbGUubG9nKG15UGxheWVyLmRlZmF1bHRNdXRlZCgpKTtcbiAgICogICAvLyBzZXQgdG8gdHJ1ZVxuICAgKiAgIG15UGxheWVyLmRlZmF1bHRNdXRlZCh0cnVlKTtcbiAgICogICAvLyBnZXQgc2hvdWxkIGJlIHRydWVcbiAgICogICBjb25zb2xlLmxvZyhteVBsYXllci5kZWZhdWx0TXV0ZWQoKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWZhdWx0TXV0ZWRdXG4gICAqICAgICAgICAtIHRydWUgdG8gbXV0ZVxuICAgKiAgICAgICAgLSBmYWxzZSB0byB1bm11dGVcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbnxQbGF5ZXJ9XG4gICAqICAgICAgICAgLSB0cnVlIGlmIGRlZmF1bHRNdXRlZCBpcyBvbiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgZGVmYXVsdE11dGVkIGlzIG9mZiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGVmYXVsdE11dGVkID0gZnVuY3Rpb24gZGVmYXVsdE11dGVkKF9kZWZhdWx0TXV0ZWQpIHtcbiAgICBpZiAoX2RlZmF1bHRNdXRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoQ2FsbF8oJ3NldERlZmF1bHRNdXRlZCcsIF9kZWZhdWx0TXV0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnZGVmYXVsdE11dGVkJykgfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCB2b2x1bWUsIG9yIHNldCBpdFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtwZXJjZW50QXNEZWNpbWFsXVxuICAgKiAgICAgICAgIFRoZSBuZXcgbGFzdCB2b2x1bWUgYXMgYSBkZWNpbWFsIHBlcmNlbnQ6XG4gICAqICAgICAgICAgLSAwIGlzIG11dGVkLzAlL29mZlxuICAgKiAgICAgICAgIC0gMS4wIGlzIDEwMCUvZnVsbFxuICAgKiAgICAgICAgIC0gMC41IGlzIGhhbGYgdm9sdW1lIG9yIDUwJVxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgbGFzdFZvbHVtZSBhcyBhIHBlcmNlbnQgd2hlbiBnZXR0aW5nXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sYXN0Vm9sdW1lXyA9IGZ1bmN0aW9uIGxhc3RWb2x1bWVfKHBlcmNlbnRBc0RlY2ltYWwpIHtcbiAgICBpZiAocGVyY2VudEFzRGVjaW1hbCAhPT0gdW5kZWZpbmVkICYmIHBlcmNlbnRBc0RlY2ltYWwgIT09IDApIHtcbiAgICAgIHRoaXMuY2FjaGVfLmxhc3RWb2x1bWUgPSBwZXJjZW50QXNEZWNpbWFsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZV8ubGFzdFZvbHVtZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgY3VycmVudCB0ZWNoIGNhbiBzdXBwb3J0IG5hdGl2ZSBmdWxsc2NyZWVuXG4gICAqIChlLmcuIHdpdGggYnVpbHQgaW4gY29udHJvbHMgbGlrZSBpT1MsIHNvIG5vdCBvdXIgZmxhc2ggc3dmKVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIGlmIG5hdGl2ZSBmdWxsc2NyZWVuIGlzIHN1cHBvcnRlZFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc3VwcG9ydHNGdWxsU2NyZWVuID0gZnVuY3Rpb24gc3VwcG9ydHNGdWxsU2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdzdXBwb3J0c0Z1bGxTY3JlZW4nKSB8fCBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHBsYXllciBpcyBpbiBmdWxsc2NyZWVuIG1vZGUgb3IgdGVsbCB0aGUgcGxheWVyIHRoYXQgaXRcbiAgICogaXMgb3IgaXMgbm90IGluIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICpcbiAgICogPiBOT1RFOiBBcyBvZiB0aGUgbGF0ZXN0IEhUTUw1IHNwZWMsIGlzRnVsbHNjcmVlbiBpcyBubyBsb25nZXIgYW4gb2ZmaWNpYWxcbiAgICogcHJvcGVydHkgYW5kIGluc3RlYWQgZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgaXMgdXNlZC4gQnV0IGlzRnVsbHNjcmVlbiBpc1xuICAgKiBzdGlsbCBhIHZhbHVhYmxlIHByb3BlcnR5IGZvciBpbnRlcm5hbCBwbGF5ZXIgd29ya2luZ3MuXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFtpc0ZTXVxuICAgKiAgICAgICAgIFNldCB0aGUgcGxheWVycyBjdXJyZW50IGZ1bGxzY3JlZW4gc3RhdGVcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIHRydWUgaWYgZnVsbHNjcmVlbiBpcyBvbiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgZnVsbHNjcmVlbiBpcyBvZmYgYW5kIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmlzRnVsbHNjcmVlbiA9IGZ1bmN0aW9uIGlzRnVsbHNjcmVlbihpc0ZTKSB7XG4gICAgaWYgKGlzRlMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pc0Z1bGxzY3JlZW5fID0gISFpc0ZTO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLmlzRnVsbHNjcmVlbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlIHRoZSBzaXplIG9mIHRoZSB2aWRlbyB0byBmdWxsIHNjcmVlblxuICAgKiBJbiBzb21lIGJyb3dzZXJzLCBmdWxsIHNjcmVlbiBpcyBub3Qgc3VwcG9ydGVkIG5hdGl2ZWx5LCBzbyBpdCBlbnRlcnNcbiAgICogXCJmdWxsIHdpbmRvdyBtb2RlXCIsIHdoZXJlIHRoZSB2aWRlbyBmaWxscyB0aGUgYnJvd3NlciB3aW5kb3cuXG4gICAqIEluIGJyb3dzZXJzIGFuZCBkZXZpY2VzIHRoYXQgc3VwcG9ydCBuYXRpdmUgZnVsbCBzY3JlZW4sIHNvbWV0aW1lcyB0aGVcbiAgICogYnJvd3NlcidzIGRlZmF1bHQgY29udHJvbHMgd2lsbCBiZSBzaG93biwgYW5kIG5vdCB0aGUgVmlkZW8uanMgY3VzdG9tIHNraW4uXG4gICAqIFRoaXMgaW5jbHVkZXMgbW9zdCBtb2JpbGUgZGV2aWNlcyAoaU9TLCBBbmRyb2lkKSBhbmQgb2xkZXIgdmVyc2lvbnMgb2ZcbiAgICogU2FmYXJpLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlcXVlc3RGdWxsc2NyZWVuID0gZnVuY3Rpb24gcmVxdWVzdEZ1bGxzY3JlZW4oKSB7XG4gICAgdmFyIGZzQXBpID0gRnVsbHNjcmVlbkFwaTtcblxuICAgIHRoaXMuaXNGdWxsc2NyZWVuKHRydWUpO1xuXG4gICAgaWYgKGZzQXBpLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAvLyB0aGUgYnJvd3NlciBzdXBwb3J0cyBnb2luZyBmdWxsc2NyZWVuIGF0IHRoZSBlbGVtZW50IGxldmVsIHNvIHdlIGNhblxuICAgICAgLy8gdGFrZSB0aGUgY29udHJvbHMgZnVsbHNjcmVlbiBhcyB3ZWxsIGFzIHRoZSB2aWRlb1xuXG4gICAgICAvLyBUcmlnZ2VyIGZ1bGxzY3JlZW5jaGFuZ2UgZXZlbnQgYWZ0ZXIgY2hhbmdlXG4gICAgICAvLyBXZSBoYXZlIHRvIHNwZWNpZmljYWxseSBhZGQgdGhpcyBlYWNoIHRpbWUsIGFuZCByZW1vdmVcbiAgICAgIC8vIHdoZW4gY2FuY2VsaW5nIGZ1bGxzY3JlZW4uIE90aGVyd2lzZSBpZiB0aGVyZSdzIG11bHRpcGxlXG4gICAgICAvLyBwbGF5ZXJzIG9uIGEgcGFnZSwgdGhleSB3b3VsZCBhbGwgYmUgcmVhY3RpbmcgdG8gdGhlIHNhbWUgZnVsbHNjcmVlblxuICAgICAgLy8gZXZlbnRzXG4gICAgICBvbihkb2N1bWVudCwgZnNBcGkuZnVsbHNjcmVlbmNoYW5nZSwgYmluZCh0aGlzLCBmdW5jdGlvbiBkb2N1bWVudEZ1bGxzY3JlZW5DaGFuZ2UoZSkge1xuICAgICAgICB0aGlzLmlzRnVsbHNjcmVlbihkb2N1bWVudFtmc0FwaS5mdWxsc2NyZWVuRWxlbWVudF0pO1xuXG4gICAgICAgIC8vIElmIGNhbmNlbGxpbmcgZnVsbHNjcmVlbiwgcmVtb3ZlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4oKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIGZzQXBpLmZ1bGxzY3JlZW5jaGFuZ2UsIGRvY3VtZW50RnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICAgIH0pKTtcblxuICAgICAgdGhpcy5lbF9bZnNBcGkucmVxdWVzdEZ1bGxzY3JlZW5dKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRlY2hfLnN1cHBvcnRzRnVsbFNjcmVlbigpKSB7XG4gICAgICAvLyB3ZSBjYW4ndCB0YWtlIHRoZSB2aWRlby5qcyBjb250cm9scyBmdWxsc2NyZWVuIGJ1dCB3ZSBjYW4gZ28gZnVsbHNjcmVlblxuICAgICAgLy8gd2l0aCBuYXRpdmUgY29udHJvbHNcbiAgICAgIHRoaXMudGVjaENhbGxfKCdlbnRlckZ1bGxTY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZnVsbHNjcmVlbiBpc24ndCBzdXBwb3J0ZWQgc28gd2UnbGwganVzdCBzdHJldGNoIHRoZSB2aWRlbyBlbGVtZW50IHRvXG4gICAgICAvLyBmaWxsIHRoZSB2aWV3cG9ydFxuICAgICAgdGhpcy5lbnRlckZ1bGxXaW5kb3coKTtcbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2aWRlbyB0byBpdHMgbm9ybWFsIHNpemUgYWZ0ZXIgaGF2aW5nIGJlZW4gaW4gZnVsbCBzY3JlZW4gbW9kZVxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmV4aXRGdWxsc2NyZWVuID0gZnVuY3Rpb24gZXhpdEZ1bGxzY3JlZW4oKSB7XG4gICAgdmFyIGZzQXBpID0gRnVsbHNjcmVlbkFwaTtcblxuICAgIHRoaXMuaXNGdWxsc2NyZWVuKGZhbHNlKTtcblxuICAgIC8vIENoZWNrIGZvciBicm93c2VyIGVsZW1lbnQgZnVsbHNjcmVlbiBzdXBwb3J0XG4gICAgaWYgKGZzQXBpLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICBkb2N1bWVudFtmc0FwaS5leGl0RnVsbHNjcmVlbl0oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudGVjaF8uc3VwcG9ydHNGdWxsU2NyZWVuKCkpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdleGl0RnVsbFNjcmVlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4aXRGdWxsV2luZG93KCk7XG4gICAgICAvKipcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gZnVsbHNjcmVlbiBpc24ndCBzdXBwb3J0ZWQgd2UgY2FuIHN0cmV0Y2ggdGhlXG4gICAqIHZpZGVvIGNvbnRhaW5lciB0byBhcyB3aWRlIGFzIHRoZSBicm93c2VyIHdpbGwgbGV0IHVzLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2VudGVyRnVsbFdpbmRvd1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZW50ZXJGdWxsV2luZG93ID0gZnVuY3Rpb24gZW50ZXJGdWxsV2luZG93KCkge1xuICAgIHRoaXMuaXNGdWxsV2luZG93ID0gdHJ1ZTtcblxuICAgIC8vIFN0b3Jpbmcgb3JpZ2luYWwgZG9jIG92ZXJmbG93IHZhbHVlIHRvIHJldHVybiB0byB3aGVuIGZ1bGxzY3JlZW4gaXMgb2ZmXG4gICAgdGhpcy5kb2NPcmlnT3ZlcmZsb3cgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3c7XG5cbiAgICAvLyBBZGQgbGlzdGVuZXIgZm9yIGVzYyBrZXkgdG8gZXhpdCBmdWxsc2NyZWVuXG4gICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmZ1bGxXaW5kb3dPbkVzY0tleSkpO1xuXG4gICAgLy8gSGlkZSBhbnkgc2Nyb2xsIGJhcnNcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgIC8vIEFwcGx5IGZ1bGxzY3JlZW4gc3R5bGVzXG4gICAgYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3Zqcy1mdWxsLXdpbmRvdycpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFBsYXllciNlbnRlckZ1bGxXaW5kb3dcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdlbnRlckZ1bGxXaW5kb3cnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgZm9yIGNhbGwgdG8gZWl0aGVyIGV4aXQgZnVsbCB3aW5kb3cgb3JcbiAgICogZnVsbCBzY3JlZW4gb24gRVNDIGtleVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogICAgICAgIEV2ZW50IHRvIGNoZWNrIGZvciBrZXkgcHJlc3NcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmZ1bGxXaW5kb3dPbkVzY0tleSA9IGZ1bmN0aW9uIGZ1bGxXaW5kb3dPbkVzY0tleShldmVudCkge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuICAgICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbFdpbmRvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXhpdCBmdWxsIHdpbmRvd1xuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2V4aXRGdWxsV2luZG93XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5leGl0RnVsbFdpbmRvdyA9IGZ1bmN0aW9uIGV4aXRGdWxsV2luZG93KCkge1xuICAgIHRoaXMuaXNGdWxsV2luZG93ID0gZmFsc2U7XG4gICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuZnVsbFdpbmRvd09uRXNjS2V5KTtcblxuICAgIC8vIFVuaGlkZSBzY3JvbGwgYmFycy5cbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSB0aGlzLmRvY09yaWdPdmVyZmxvdztcblxuICAgIC8vIFJlbW92ZSBmdWxsc2NyZWVuIHN0eWxlc1xuICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICd2anMtZnVsbC13aW5kb3cnKTtcblxuICAgIC8vIFJlc2l6ZSB0aGUgYm94LCBjb250cm9sbGVyLCBhbmQgcG9zdGVyIHRvIG9yaWdpbmFsIHNpemVzXG4gICAgLy8gdGhpcy5wb3NpdGlvbkFsbCgpO1xuICAgIC8qKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZXhpdEZ1bGxXaW5kb3dcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdleGl0RnVsbFdpbmRvdycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBwbGF5ZXIgY2FuIHBsYXkgYSBnaXZlbiBtaW1ldHlwZVxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwMTEzL3ZpZGVvLmh0bWwjZG9tLW5hdmlnYXRvci1jYW5wbGF5dHlwZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiBjYW5QbGF5VHlwZSh0eXBlKSB7XG4gICAgdmFyIGNhbiA9IHZvaWQgMDtcblxuICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIHBsYXliYWNrIHRlY2hub2xvZ3kgaW4gdGhlIG9wdGlvbnMgb3JkZXJcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMub3B0aW9uc18udGVjaE9yZGVyOyBpIDwgai5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRlY2hOYW1lID0galtpXTtcbiAgICAgIHZhciB0ZWNoID0gVGVjaC5nZXRUZWNoKHRlY2hOYW1lKTtcblxuICAgICAgLy8gU3VwcG9ydCBvbGQgYmVoYXZpb3Igb2YgdGVjaHMgYmVpbmcgcmVnaXN0ZXJlZCBhcyBjb21wb25lbnRzLlxuICAgICAgLy8gUmVtb3ZlIG9uY2UgdGhhdCBkZXByZWNhdGVkIGJlaGF2aW9yIGlzIHJlbW92ZWQuXG4gICAgICBpZiAoIXRlY2gpIHtcbiAgICAgICAgdGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQodGVjaE5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCB0ZWNoIGlzIGRlZmluZWQgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgIGlmICghdGVjaCkge1xuICAgICAgICBsb2ckMS5lcnJvcignVGhlIFwiJyArIHRlY2hOYW1lICsgJ1wiIHRlY2ggaXMgdW5kZWZpbmVkLiBTa2lwcGVkIGJyb3dzZXIgc3VwcG9ydCBjaGVjayBmb3IgdGhhdCB0ZWNoLicpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyB0ZWNobm9sb2d5XG4gICAgICBpZiAodGVjaC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIGNhbiA9IHRlY2guY2FuUGxheVR5cGUodHlwZSk7XG5cbiAgICAgICAgaWYgKGNhbikge1xuICAgICAgICAgIHJldHVybiBjYW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBzb3VyY2UgYmFzZWQgb24gdGVjaC1vcmRlciBvciBzb3VyY2Utb3JkZXJcbiAgICogVXNlcyBzb3VyY2Utb3JkZXIgc2VsZWN0aW9uIGlmIGBvcHRpb25zLnNvdXJjZU9yZGVyYCBpcyB0cnV0aHkuIE90aGVyd2lzZSxcbiAgICogZGVmYXVsdHMgdG8gdGVjaC1vcmRlciBzZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gc291cmNlc1xuICAgKiAgICAgICAgVGhlIHNvdXJjZXMgZm9yIGEgbWVkaWEgYXNzZXRcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fGJvb2xlYW59XG4gICAqICAgICAgICAgT2JqZWN0IG9mIHNvdXJjZSBhbmQgdGVjaCBvcmRlciBvciBmYWxzZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc2VsZWN0U291cmNlID0gZnVuY3Rpb24gc2VsZWN0U291cmNlKHNvdXJjZXMpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIC8vIEdldCBvbmx5IHRoZSB0ZWNocyBzcGVjaWZpZWQgaW4gYHRlY2hPcmRlcmAgdGhhdCBleGlzdCBhbmQgYXJlIHN1cHBvcnRlZCBieSB0aGVcbiAgICAvLyBjdXJyZW50IHBsYXRmb3JtXG4gICAgdmFyIHRlY2hzID0gdGhpcy5vcHRpb25zXy50ZWNoT3JkZXIubWFwKGZ1bmN0aW9uICh0ZWNoTmFtZSkge1xuICAgICAgcmV0dXJuIFt0ZWNoTmFtZSwgVGVjaC5nZXRUZWNoKHRlY2hOYW1lKV07XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgdGVjaE5hbWUgPSBfcmVmWzBdLFxuICAgICAgICAgIHRlY2ggPSBfcmVmWzFdO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCB0ZWNoIGlzIGRlZmluZWQgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgIGlmICh0ZWNoKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoaXMgdGVjaG5vbG9neVxuICAgICAgICByZXR1cm4gdGVjaC5pc1N1cHBvcnRlZCgpO1xuICAgICAgfVxuXG4gICAgICBsb2ckMS5lcnJvcignVGhlIFwiJyArIHRlY2hOYW1lICsgJ1wiIHRlY2ggaXMgdW5kZWZpbmVkLiBTa2lwcGVkIGJyb3dzZXIgc3VwcG9ydCBjaGVjayBmb3IgdGhhdCB0ZWNoLicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGVhY2ggYGlubmVyQXJyYXlgIGVsZW1lbnQgb25jZSBwZXIgYG91dGVyQXJyYXlgIGVsZW1lbnQgYW5kIGV4ZWN1dGVcbiAgICAvLyBgdGVzdGVyYCB3aXRoIGJvdGguIElmIGB0ZXN0ZXJgIHJldHVybnMgYSBub24tZmFsc3kgdmFsdWUsIGV4aXQgZWFybHkgYW5kIHJldHVyblxuICAgIC8vIHRoYXQgdmFsdWUuXG4gICAgdmFyIGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpciA9IGZ1bmN0aW9uIGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpcihvdXRlckFycmF5LCBpbm5lckFycmF5LCB0ZXN0ZXIpIHtcbiAgICAgIHZhciBmb3VuZCA9IHZvaWQgMDtcblxuICAgICAgb3V0ZXJBcnJheS5zb21lKGZ1bmN0aW9uIChvdXRlckNob2ljZSkge1xuICAgICAgICByZXR1cm4gaW5uZXJBcnJheS5zb21lKGZ1bmN0aW9uIChpbm5lckNob2ljZSkge1xuICAgICAgICAgIGZvdW5kID0gdGVzdGVyKG91dGVyQ2hvaWNlLCBpbm5lckNob2ljZSk7XG5cbiAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH07XG5cbiAgICB2YXIgZm91bmRTb3VyY2VBbmRUZWNoID0gdm9pZCAwO1xuICAgIHZhciBmbGlwID0gZnVuY3Rpb24gZmxpcChmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBmbihiLCBhKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZmluZGVyID0gZnVuY3Rpb24gZmluZGVyKF9yZWYyLCBzb3VyY2UpIHtcbiAgICAgIHZhciB0ZWNoTmFtZSA9IF9yZWYyWzBdLFxuICAgICAgICAgIHRlY2ggPSBfcmVmMlsxXTtcblxuICAgICAgaWYgKHRlY2guY2FuUGxheVNvdXJjZShzb3VyY2UsIF90aGlzNS5vcHRpb25zX1t0ZWNoTmFtZS50b0xvd2VyQ2FzZSgpXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgc291cmNlOiBzb3VyY2UsIHRlY2g6IHRlY2hOYW1lIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIERlcGVuZGluZyBvbiB0aGUgdHJ1dGhpbmVzcyBvZiBgb3B0aW9ucy5zb3VyY2VPcmRlcmAsIHdlIHN3YXAgdGhlIG9yZGVyIG9mIHRlY2hzIGFuZCBzb3VyY2VzXG4gICAgLy8gdG8gc2VsZWN0IGZyb20gdGhlbSBiYXNlZCBvbiB0aGVpciBwcmlvcml0eS5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5zb3VyY2VPcmRlcikge1xuICAgICAgLy8gU291cmNlLWZpcnN0IG9yZGVyaW5nXG4gICAgICBmb3VuZFNvdXJjZUFuZFRlY2ggPSBmaW5kRmlyc3RQYXNzaW5nVGVjaFNvdXJjZVBhaXIoc291cmNlcywgdGVjaHMsIGZsaXAoZmluZGVyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRlY2gtZmlyc3Qgb3JkZXJpbmdcbiAgICAgIGZvdW5kU291cmNlQW5kVGVjaCA9IGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpcih0ZWNocywgc291cmNlcywgZmluZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm91bmRTb3VyY2VBbmRUZWNoIHx8IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSB2aWRlbyBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R8VGVjaH5Tb3VyY2VPYmplY3RbXXxzdHJpbmd9IFtzb3VyY2VdXG4gICAqICAgICAgICBBIFNvdXJjZU9iamVjdCwgYW4gYXJyYXkgb2YgU291cmNlT2JqZWN0cywgb3IgYSBzdHJpbmcgcmVmZXJlbmNpbmdcbiAgICogICAgICAgIGEgVVJMIHRvIGEgbWVkaWEgc291cmNlLiBJdCBpcyBfaGlnaGx5IHJlY29tbWVuZGVkXyB0aGF0IGFuIG9iamVjdFxuICAgKiAgICAgICAgb3IgYXJyYXkgb2Ygb2JqZWN0cyBpcyB1c2VkIGhlcmUsIHNvIHRoYXQgc291cmNlIHNlbGVjdGlvblxuICAgKiAgICAgICAgYWxnb3JpdGhtcyBjYW4gdGFrZSB0aGUgYHR5cGVgIGludG8gYWNjb3VudC5cbiAgICpcbiAgICogICAgICAgIElmIG5vdCBwcm92aWRlZCwgdGhpcyBtZXRob2QgYWN0cyBhcyBhIGdldHRlci5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICogICAgICAgICBJZiB0aGUgYHNvdXJjZWAgYXJndW1lbnQgaXMgbWlzc2luZywgcmV0dXJucyB0aGUgY3VycmVudCBzb3VyY2VcbiAgICogICAgICAgICBVUkwuIE90aGVyd2lzZSwgcmV0dXJucyBub3RoaW5nL3VuZGVmaW5lZC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uIHNyYyhzb3VyY2UpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIC8vIGdldHRlciB1c2FnZVxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVfLnNyYztcbiAgICB9XG4gICAgLy8gZmlsdGVyIG91dCBpbnZhbGlkIHNvdXJjZXMgYW5kIHR1cm4gb3VyIHNvdXJjZSBpbnRvXG4gICAgLy8gYW4gYXJyYXkgb2Ygc291cmNlIG9iamVjdHNcbiAgICB2YXIgc291cmNlcyA9IGZpbHRlclNvdXJjZShzb3VyY2UpO1xuXG4gICAgLy8gaWYgYSBzb3VyY2Ugd2FzIHBhc3NlZCBpbiB0aGVuIGl0IGlzIGludmFsaWQgYmVjYXVzZVxuICAgIC8vIGl0IHdhcyBmaWx0ZXJlZCB0byBhIHplcm8gbGVuZ3RoIEFycmF5LiBTbyB3ZSBoYXZlIHRvXG4gICAgLy8gc2hvdyBhbiBlcnJvclxuICAgIGlmICghc291cmNlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXJyb3IoeyBjb2RlOiA0LCBtZXNzYWdlOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubm90U3VwcG9ydGVkTWVzc2FnZSkgfSk7XG4gICAgICB9LCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpbnRpYWwgc291cmNlc1xuICAgIHRoaXMuY2FjaGVfLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgIHRoaXMuY2hhbmdpbmdTcmNfID0gdHJ1ZTtcblxuICAgIC8vIGludGlhbCBzb3VyY2VcbiAgICB0aGlzLmNhY2hlXy5zb3VyY2UgPSBzb3VyY2VzWzBdO1xuXG4gICAgLy8gbWlkZGxld2FyZVNvdXJjZSBpcyB0aGUgc291cmNlIGFmdGVyIGl0IGhhcyBiZWVuIGNoYW5nZWQgYnkgbWlkZGxld2FyZVxuICAgIHNldFNvdXJjZSh0aGlzLCBzb3VyY2VzWzBdLCBmdW5jdGlvbiAobWlkZGxld2FyZVNvdXJjZSwgbXdzKSB7XG4gICAgICBfdGhpczYubWlkZGxld2FyZV8gPSBtd3M7XG5cbiAgICAgIHZhciBlcnIgPSBfdGhpczYuc3JjXyhtaWRkbGV3YXJlU291cmNlKTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoc291cmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNi5zcmMoc291cmNlcy5zbGljZSgxKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiBhIHRpbWVvdXQgdG8gZ2l2ZSBmb2xrcyBhIGNoYW5jZSB0byBhZGQgZXJyb3IgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgX3RoaXM2LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuZXJyb3IoeyBjb2RlOiA0LCBtZXNzYWdlOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubm90U3VwcG9ydGVkTWVzc2FnZSkgfSk7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIC8vIHdlIGNvdWxkIG5vdCBmaW5kIGFuIGFwcHJvcHJpYXRlIHRlY2gsIGJ1dCBsZXQncyBzdGlsbCBub3RpZnkgdGhlIGRlbGVnYXRlIHRoYXQgdGhpcyBpcyBpdFxuICAgICAgICAvLyB0aGlzIG5lZWRzIGEgYmV0dGVyIGNvbW1lbnQgYWJvdXQgd2h5IHRoaXMgaXMgbmVlZGVkXG4gICAgICAgIF90aGlzNi50cmlnZ2VyUmVhZHkoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzNi5jaGFuZ2luZ1NyY18gPSBmYWxzZTtcbiAgICAgIC8vIHZpZGVvIGVsZW1lbnQgbGlzdGVkIHNvdXJjZVxuICAgICAgX3RoaXM2LmNhY2hlXy5zcmMgPSBtaWRkbGV3YXJlU291cmNlLnNyYztcblxuICAgICAgc2V0VGVjaChtd3MsIF90aGlzNi50ZWNoXyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIG9iamVjdCBvbiB0aGUgdGVjaCwgcmV0dXJucyBhIGJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgd2V0aGVyXG4gICAqIHRoZXJlIGlzIGEgdGVjaCB0aGF0IGNhbiBwbGF5IHRoZSBzb3VyY2Ugb3Igbm90XG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNvdXJjZVxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3QgdG8gc2V0IG9uIHRoZSBUZWNoXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqICAgICAgICAgLSBUcnVlIGlmIHRoZXJlIGlzIG5vIFRlY2ggdG8gcGxheWJhY2sgdGhpcyBzb3VyY2VcbiAgICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc3JjXyA9IGZ1bmN0aW9uIHNyY18oc291cmNlKSB7XG4gICAgdmFyIHNvdXJjZVRlY2ggPSB0aGlzLnNlbGVjdFNvdXJjZShbc291cmNlXSk7XG5cbiAgICBpZiAoIXNvdXJjZVRlY2gpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGl0bGVDYXNlRXF1YWxzKHNvdXJjZVRlY2gudGVjaCwgdGhpcy50ZWNoTmFtZV8pKSB7XG4gICAgICB0aGlzLmNoYW5naW5nU3JjXyA9IHRydWU7XG5cbiAgICAgIC8vIGxvYWQgdGhpcyB0ZWNobm9sb2d5IHdpdGggdGhlIGNob3NlbiBzb3VyY2VcbiAgICAgIHRoaXMubG9hZFRlY2hfKHNvdXJjZVRlY2gudGVjaCwgc291cmNlVGVjaC5zb3VyY2UpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHdhaXQgdW50aWwgdGhlIHRlY2ggaXMgcmVhZHkgdG8gc2V0IHRoZSBzb3VyY2VcbiAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gVGhlIHNldFNvdXJjZSB0ZWNoIG1ldGhvZCB3YXMgYWRkZWQgd2l0aCBzb3VyY2UgaGFuZGxlcnNcbiAgICAgIC8vIHNvIG9sZGVyIHRlY2hzIHdvbid0IHN1cHBvcnQgaXRcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgdGhlIGRpcmVjdCBwcm90b3R5cGUgZm9yIHRoZSBjYXNlIHdoZXJlIHN1YmNsYXNzZXNcbiAgICAgIC8vIG9mIHRoZSB0ZWNoIGRvIG5vdCBzdXBwb3J0IHNvdXJjZSBoYW5kbGVyc1xuICAgICAgaWYgKHRoaXMudGVjaF8uY29uc3RydWN0b3IucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzZXRTb3VyY2UnKSkge1xuICAgICAgICB0aGlzLnRlY2hDYWxsXygnc2V0U291cmNlJywgc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGVjaENhbGxfKCdzcmMnLCBzb3VyY2Uuc3JjKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9uc18ucHJlbG9hZCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy5hdXRvcGxheSkge1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRoZSBzb3VyY2Ugc3luY2hyb25vdXNseSBpZiBwb3NzaWJsZSAoIzIzMjYpXG4gICAgfSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJlZ2luIGxvYWRpbmcgdGhlIHNyYyBkYXRhLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgdGhpcy50ZWNoQ2FsbF8oJ2xvYWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVzZXQgdGhlIHBsYXllci4gTG9hZHMgdGhlIGZpcnN0IHRlY2ggaW4gdGhlIHRlY2hPcmRlcixcbiAgICogYW5kIGNhbGxzIGByZXNldGAgb24gdGhlIHRlY2hgLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLmxvYWRUZWNoXyh0aGlzLm9wdGlvbnNfLnRlY2hPcmRlclswXSwgbnVsbCk7XG4gICAgdGhpcy50ZWNoQ2FsbF8oJ3Jlc2V0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIG9mIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3RzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdFtdfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3RzXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50U291cmNlcyA9IGZ1bmN0aW9uIGN1cnJlbnRTb3VyY2VzKCkge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLmN1cnJlbnRTb3VyY2UoKTtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuXG4gICAgLy8gYXNzdW1lIGB7fWAgb3IgYHsgc3JjIH1gXG4gICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jYWNoZV8uc291cmNlcyB8fCBzb3VyY2VzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge1RlY2h+U291cmNlT2JqZWN0fVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3RcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRTb3VyY2UgPSBmdW5jdGlvbiBjdXJyZW50U291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlXy5zb3VyY2UgfHwge307XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZ1bGx5IHF1YWxpZmllZCBVUkwgb2YgdGhlIGN1cnJlbnQgc291cmNlIHZhbHVlIGUuZy4gaHR0cDovL215c2l0ZS5jb20vdmlkZW8ubXA0XG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBgY3VycmVudFR5cGVgIHRvIGFzc2lzdCBpbiByZWJ1aWxkaW5nIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY3VycmVudCBzb3VyY2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRTcmMgPSBmdW5jdGlvbiBjdXJyZW50U3JjKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTb3VyY2UoKSAmJiB0aGlzLmN1cnJlbnRTb3VyY2UoKS5zcmMgfHwgJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzb3VyY2UgdHlwZSBlLmcuIHZpZGVvL21wNFxuICAgKiBUaGlzIGNhbiBhbGxvdyB5b3UgcmVidWlsZCB0aGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0IHNvIHRoYXQgeW91IGNvdWxkIGxvYWQgdGhlIHNhbWVcbiAgICogc291cmNlIGFuZCB0ZWNoIGxhdGVyXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgc291cmNlIE1JTUUgdHlwZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudFR5cGUgPSBmdW5jdGlvbiBjdXJyZW50VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U291cmNlKCkgJiYgdGhpcy5jdXJyZW50U291cmNlKCkudHlwZSB8fCAnJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgcHJlbG9hZCBhdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAtIHRydWUgbWVhbnMgdGhhdCB3ZSBzaG91bGQgcHJlbG9hZFxuICAgKiAgICAgICAgLSBmYWxzZSBtYWVucyB0aGF0IHdlIHNob3VsZCBub3QgcHJlbG9hZFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIHByZWxvYWQgYXR0cmlidXRlIHZhbHVlIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucHJlbG9hZCA9IGZ1bmN0aW9uIHByZWxvYWQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFByZWxvYWQnLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfLnByZWxvYWQgPSB2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3ByZWxvYWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgYXV0b3BsYXkgYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgIC0gdHJ1ZSBtZWFucyB0aGF0IHdlIHNob3VsZCBhdXRvcGxheVxuICAgKiAgICAgICAgLSBmYWxzZSBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgYXV0b3BsYXlcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGF1dG9wbGF5IHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYXV0b3BsYXkgPSBmdW5jdGlvbiBhdXRvcGxheSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0QXV0b3BsYXknLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfLmF1dG9wbGF5ID0gdmFsdWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdhdXRvcGxheScsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IG9yIHVuc2V0IHRoZSBwbGF5c2lubGluZSBhdHRyaWJ1dGUuXG4gICAqIFBsYXlzaW5saW5lIHRlbGxzIHRoZSBicm93c2VyIHRoYXQgbm9uLWZ1bGxzY3JlZW4gcGxheWJhY2sgaXMgcHJlZmVycmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgIC0gdHJ1ZSBtZWFucyB0aGF0IHdlIHNob3VsZCB0cnkgdG8gcGxheSBpbmxpbmUgYnkgZGVmYXVsdFxuICAgKiAgICAgICAgLSBmYWxzZSBtZWFucyB0aGF0IHdlIHNob3VsZCB1c2UgdGhlIGJyb3dzZXIncyBkZWZhdWx0IHBsYXliYWNrIG1vZGUsXG4gICAqICAgICAgICAgIHdoaWNoIGluIG1vc3QgY2FzZXMgaXMgaW5saW5lLiBpT1MgU2FmYXJpIGlzIGEgbm90YWJsZSBleGNlcHRpb25cbiAgICogICAgICAgICAgYW5kIHBsYXlzIGZ1bGxzY3JlZW4gYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfFBsYXllcn1cbiAgICogICAgICAgICAtIHRoZSBjdXJyZW50IHZhbHVlIG9mIHBsYXlzaW5saW5lXG4gICAqICAgICAgICAgLSB0aGUgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKlxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNhdHRyLXZpZGVvLXBsYXlzaW5saW5lfVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGxheXNpbmxpbmUgPSBmdW5jdGlvbiBwbGF5c2lubGluZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0UGxheXNpbmxpbmUnLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfLnBsYXlzaW5saW5lID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BsYXlzaW5saW5lJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGxvb3AgYXR0cmlidXRlIG9uIHRoZSB2aWRlbyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgIC0gdHJ1ZSBtZWFucyB0aGF0IHdlIHNob3VsZCBsb29wIHRoZSB2aWRlb1xuICAgKiAgICAgICAgLSBmYWxzZSBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbG9vcCB0aGUgdmlkZW9cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGxvb3Agd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sb29wID0gZnVuY3Rpb24gbG9vcCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0TG9vcCcsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc18ubG9vcCA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnbG9vcCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBwb3N0ZXIgaW1hZ2Ugc291cmNlIHVybFxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3Bvc3RlcmNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NyY11cbiAgICogICAgICAgIFBvc3RlciBpbWFnZSBzb3VyY2UgVVJMXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBwb3N0ZXIgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wb3N0ZXIgPSBmdW5jdGlvbiBwb3N0ZXIoc3JjKSB7XG4gICAgaWYgKHNyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3N0ZXJfO1xuICAgIH1cblxuICAgIC8vIFRoZSBjb3JyZWN0IHdheSB0byByZW1vdmUgYSBwb3N0ZXIgaXMgdG8gc2V0IGFzIGFuIGVtcHR5IHN0cmluZ1xuICAgIC8vIG90aGVyIGZhbHNleSB2YWx1ZXMgd2lsbCB0aHJvdyBlcnJvcnNcbiAgICBpZiAoIXNyYykge1xuICAgICAgc3JjID0gJyc7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRoZSBpbnRlcm5hbCBwb3N0ZXIgdmFyaWFibGVcbiAgICB0aGlzLnBvc3Rlcl8gPSBzcmM7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHRlY2gncyBwb3N0ZXJcbiAgICB0aGlzLnRlY2hDYWxsXygnc2V0UG9zdGVyJywgc3JjKTtcblxuICAgIC8vIGFsZXJ0IGNvbXBvbmVudHMgdGhhdCB0aGUgcG9zdGVyIGhhcyBiZWVuIHNldFxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgZmlyZXMgd2hlbiB0aGUgcG9zdGVyIGltYWdlIGlzIGNoYW5nZWQgb24gdGhlIHBsYXllci5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcG9zdGVyY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcigncG9zdGVyY2hhbmdlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNvbWUgdGVjaHMgKGUuZy4gWW91VHViZSkgY2FuIHByb3ZpZGUgYSBwb3N0ZXIgc291cmNlIGluIGFuXG4gICAqIGFzeW5jaHJvbm91cyB3YXkuIFdlIHdhbnQgdGhlIHBvc3RlciBjb21wb25lbnQgdG8gdXNlIHRoaXNcbiAgICogcG9zdGVyIHNvdXJjZSBzbyB0aGF0IGl0IGNvdmVycyB1cCB0aGUgdGVjaCdzIGNvbnRyb2xzLlxuICAgKiAoWW91VHViZSdzIHBsYXkgYnV0dG9uKS4gSG93ZXZlciB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXNcbiAgICogc291cmNlIGlmIHRoZSBwbGF5ZXIgdXNlciBoYXNuJ3Qgc2V0IGEgcG9zdGVyIHRocm91Z2hcbiAgICogdGhlIG5vcm1hbCBBUElzLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3Bvc3RlcmNoYW5nZVxuICAgKiBAbGlzdGVucyBUZWNoI3Bvc3RlcmNoYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUG9zdGVyQ2hhbmdlXygpIHtcbiAgICBpZiAoIXRoaXMucG9zdGVyXyAmJiB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8ucG9zdGVyKSB7XG4gICAgICB0aGlzLnBvc3Rlcl8gPSB0aGlzLnRlY2hfLnBvc3RlcigpIHx8ICcnO1xuXG4gICAgICAvLyBMZXQgY29tcG9uZW50cyBrbm93IHRoZSBwb3N0ZXIgaGFzIGNoYW5nZWRcbiAgICAgIHRoaXMudHJpZ2dlcigncG9zdGVyY2hhbmdlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHdoZXRoZXIgb3Igbm90IHRoZSBjb250cm9scyBhcmUgc2hvd2luZy5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNjb250cm9sc2VuYWJsZWRcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cbiAgICogICAgICAgIC0gdHJ1ZSB0byB0dXJuIGNvbnRyb2xzIG9uXG4gICAqICAgICAgICAtIGZhbHNlIHRvIHR1cm4gY29udHJvbHMgb2ZmXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgY29udHJvbHMgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jb250cm9scyA9IGZ1bmN0aW9uIGNvbnRyb2xzKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBib29sID0gISFib29sO1xuXG4gICAgICAvLyBEb24ndCB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IHVubGVzcyBpdCBhY3R1YWxseSBjaGFuZ2VkXG4gICAgICBpZiAodGhpcy5jb250cm9sc18gIT09IGJvb2wpIHtcbiAgICAgICAgdGhpcy5jb250cm9sc18gPSBib29sO1xuXG4gICAgICAgIGlmICh0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHMoKSkge1xuICAgICAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRDb250cm9scycsIGJvb2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtY29udHJvbHMtZGlzYWJsZWQnKTtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZW5hYmxlZCcpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBldmVudCBQbGF5ZXIjY29udHJvbHNlbmFibGVkXG4gICAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY29udHJvbHNlbmFibGVkJyk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWNvbnRyb2xzLWVuYWJsZWQnKTtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZGlzYWJsZWQnKTtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAZXZlbnQgUGxheWVyI2NvbnRyb2xzZGlzYWJsZWRcbiAgICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjb250cm9sc2Rpc2FibGVkJyk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuICEhdGhpcy5jb250cm9sc187XG4gIH07XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSBuYXRpdmUgY29udHJvbHMgb24vb2ZmLiBOYXRpdmUgY29udHJvbHMgYXJlIHRoZSBjb250cm9scyBidWlsdCBpbnRvXG4gICAqIGRldmljZXMgKGUuZy4gZGVmYXVsdCBpUGhvbmUgY29udHJvbHMpLCBGbGFzaCwgb3Igb3RoZXIgdGVjaHNcbiAgICogKGUuZy4gVmltZW8gQ29udHJvbHMpXG4gICAqICoqVGhpcyBzaG91bGQgb25seSBiZSBzZXQgYnkgdGhlIGN1cnJlbnQgdGVjaCwgYmVjYXVzZSBvbmx5IHRoZSB0ZWNoIGtub3dzXG4gICAqIGlmIGl0IGNhbiBzdXBwb3J0IG5hdGl2ZSBjb250cm9scyoqXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjdXNpbmduYXRpdmVjb250cm9sc1xuICAgKiBAZmlyZXMgUGxheWVyI3VzaW5nY3VzdG9tY29udHJvbHNcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cbiAgICogICAgICAgIC0gdHJ1ZSB0byB0dXJuIG5hdGl2ZSBjb250cm9scyBvblxuICAgKiAgICAgICAgLSBmYWxzZSB0byB0dXJuIG5hdGl2ZSBjb250cm9scyBvZmZcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBuYXRpdmUgY29udHJvbHMgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS51c2luZ05hdGl2ZUNvbnRyb2xzID0gZnVuY3Rpb24gdXNpbmdOYXRpdmVDb250cm9scyhib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYm9vbCA9ICEhYm9vbDtcblxuICAgICAgLy8gRG9uJ3QgdHJpZ2dlciBhIGNoYW5nZSBldmVudCB1bmxlc3MgaXQgYWN0dWFsbHkgY2hhbmdlZFxuICAgICAgaWYgKHRoaXMudXNpbmdOYXRpdmVDb250cm9sc18gIT09IGJvb2wpIHtcbiAgICAgICAgdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzXyA9IGJvb2w7XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXVzaW5nLW5hdGl2ZS1jb250cm9scycpO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogcGxheWVyIGlzIHVzaW5nIHRoZSBuYXRpdmUgZGV2aWNlIGNvbnRyb2xzXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAZXZlbnQgUGxheWVyI3VzaW5nbmF0aXZlY29udHJvbHNcbiAgICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd1c2luZ25hdGl2ZWNvbnRyb2xzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXVzaW5nLW5hdGl2ZS1jb250cm9scycpO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogcGxheWVyIGlzIHVzaW5nIHRoZSBjdXN0b20gSFRNTCBjb250cm9sc1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGV2ZW50IFBsYXllciN1c2luZ2N1c3RvbWNvbnRyb2xzXG4gICAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMudHJpZ2dlcigndXNpbmdjdXN0b21jb250cm9scycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMudXNpbmdOYXRpdmVDb250cm9sc187XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBvciBnZXQgdGhlIGN1cnJlbnQgTWVkaWFFcnJvclxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2Vycm9yXG4gICAqXG4gICAqIEBwYXJhbSAge01lZGlhRXJyb3J8c3RyaW5nfG51bWJlcn0gW2Vycl1cbiAgICogICAgICAgICBBIE1lZGlhRXJyb3Igb3IgYSBzdHJpbmcvbnVtYmVyIHRvIGJlIHR1cm5lZFxuICAgKiAgICAgICAgIGludG8gYSBNZWRpYUVycm9yXG4gICAqXG4gICAqIEByZXR1cm4ge01lZGlhRXJyb3J8bnVsbH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBNZWRpYUVycm9yIHdoZW4gZ2V0dGluZyAob3IgbnVsbClcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGVyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvcl8gfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZXN0b3JpbmcgdG8gZGVmYXVsdFxuICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZXJyb3JfID0gZXJyO1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVycm9yJyk7XG4gICAgICBpZiAodGhpcy5lcnJvckRpc3BsYXkpIHtcbiAgICAgICAgdGhpcy5lcnJvckRpc3BsYXkuY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVycm9yXyA9IG5ldyBNZWRpYUVycm9yKGVycik7XG5cbiAgICAvLyBhZGQgdGhlIHZqcy1lcnJvciBjbGFzc25hbWUgdG8gdGhlIHBsYXllclxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1lcnJvcicpO1xuXG4gICAgLy8gbG9nIHRoZSBuYW1lIG9mIHRoZSBlcnJvciB0eXBlIGFuZCBhbnkgbWVzc2FnZVxuICAgIC8vIGllOCBqdXN0IGxvZ3MgXCJbb2JqZWN0IG9iamVjdF1cIiBpZiB5b3UganVzdCBsb2cgdGhlIGVycm9yIG9iamVjdFxuICAgIGxvZyQxLmVycm9yKCcoQ09ERTonICsgdGhpcy5lcnJvcl8uY29kZSArICcgJyArIE1lZGlhRXJyb3IuZXJyb3JUeXBlc1t0aGlzLmVycm9yXy5jb2RlXSArICcpJywgdGhpcy5lcnJvcl8ubWVzc2FnZSwgdGhpcy5lcnJvcl8pO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFBsYXllciNlcnJvclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJyk7XG5cbiAgICByZXR1cm47XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcG9ydCB1c2VyIGFjdGl2aXR5XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgICAgICAgRXZlbnQgb2JqZWN0XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZXBvcnRVc2VyQWN0aXZpdHkgPSBmdW5jdGlvbiByZXBvcnRVc2VyQWN0aXZpdHkoZXZlbnQpIHtcbiAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IGlmIHVzZXIgaXMgYWN0aXZlXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjdXNlcmFjdGl2ZVxuICAgKiBAZmlyZXMgUGxheWVyI3VzZXJpbmFjdGl2ZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib29sXVxuICAgKiAgICAgICAgLSB0cnVlIGlmIHRoZSB1c2VyIGlzIGFjdGl2ZVxuICAgKiAgICAgICAgLSBmYWxzZSBpZiB0aGUgdXNlciBpcyBpbmFjdGl2ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIHVzZXJBY3RpdmUgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS51c2VyQWN0aXZlID0gZnVuY3Rpb24gdXNlckFjdGl2ZShib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYm9vbCA9ICEhYm9vbDtcbiAgICAgIGlmIChib29sICE9PSB0aGlzLnVzZXJBY3RpdmVfKSB7XG4gICAgICAgIHRoaXMudXNlckFjdGl2ZV8gPSBib29sO1xuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHdhcyBpbmFjdGl2ZSBhbmQgaXMgbm93IGFjdGl2ZSB3ZSB3YW50IHRvIHJlc2V0IHRoZVxuICAgICAgICAgIC8vIGluYWN0aXZpdHkgdGltZXJcbiAgICAgICAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2VyLWluYWN0aXZlJyk7XG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXVzZXItYWN0aXZlJyk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQGV2ZW50IFBsYXllciN1c2VyYWN0aXZlXG4gICAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMudHJpZ2dlcigndXNlcmFjdGl2ZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdlJ3JlIHN3aXRjaGluZyB0aGUgc3RhdGUgdG8gaW5hY3RpdmUgbWFudWFsbHksIHNvIGVyYXNlIGFueSBvdGhlclxuICAgICAgICAgIC8vIGFjdGl2aXR5XG4gICAgICAgICAgdGhpcy51c2VyQWN0aXZpdHlfID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBDaHJvbWUvU2FmYXJpL0lFIGhhdmUgYnVncyB3aGVyZSB3aGVuIHlvdSBjaGFuZ2UgdGhlIGN1cnNvciBpdCBjYW5cbiAgICAgICAgICAvLyB0cmlnZ2VyIGEgbW91c2Vtb3ZlIGV2ZW50LiBUaGlzIGNhdXNlcyBhbiBpc3N1ZSB3aGVuIHlvdSdyZSBoaWRpbmdcbiAgICAgICAgICAvLyB0aGUgY3Vyc29yIHdoZW4gdGhlIHVzZXIgaXMgaW5hY3RpdmUsIGFuZCBhIG1vdXNlbW92ZSBzaWduYWxzIHVzZXJcbiAgICAgICAgICAvLyBhY3Rpdml0eS4gTWFraW5nIGl0IGltcG9zc2libGUgdG8gZ28gaW50byBpbmFjdGl2ZSBtb2RlLiBTcGVjaWZpY2FsbHlcbiAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaW4gZnVsbHNjcmVlbiB3aGVuIHdlIHJlYWxseSBuZWVkIHRvIGhpZGUgdGhlIGN1cnNvci5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFdoZW4gdGhpcyBnZXRzIHJlc29sdmVkIGluIEFMTCBicm93c2VycyBpdCBjYW4gYmUgcmVtb3ZlZFxuICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDMwNDFcbiAgICAgICAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgICAgICAgdGhpcy50ZWNoXy5vbmUoJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2VyLWFjdGl2ZScpO1xuICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy11c2VyLWluYWN0aXZlJyk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQGV2ZW50IFBsYXllciN1c2VyaW5hY3RpdmVcbiAgICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd1c2VyaW5hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51c2VyQWN0aXZlXztcbiAgfTtcblxuICAvKipcbiAgICogTGlzdGVuIGZvciB1c2VyIGFjdGl2aXR5IGJhc2VkIG9uIHRpbWVvdXQgdmFsdWVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxpc3RlbkZvclVzZXJBY3Rpdml0eV8gPSBmdW5jdGlvbiBsaXN0ZW5Gb3JVc2VyQWN0aXZpdHlfKCkge1xuICAgIHZhciBtb3VzZUluUHJvZ3Jlc3MgPSB2b2lkIDA7XG4gICAgdmFyIGxhc3RNb3ZlWCA9IHZvaWQgMDtcbiAgICB2YXIgbGFzdE1vdmVZID0gdm9pZCAwO1xuICAgIHZhciBoYW5kbGVBY3Rpdml0eSA9IGJpbmQodGhpcywgdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHkpO1xuXG4gICAgdmFyIGhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShlKSB7XG4gICAgICAvLyAjMTA2OCAtIFByZXZlbnQgbW91c2Vtb3ZlIHNwYW1taW5nXG4gICAgICAvLyBDaHJvbWUgQnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzY2OTcwXG4gICAgICBpZiAoZS5zY3JlZW5YICE9PSBsYXN0TW92ZVggfHwgZS5zY3JlZW5ZICE9PSBsYXN0TW92ZVkpIHtcbiAgICAgICAgbGFzdE1vdmVYID0gZS5zY3JlZW5YO1xuICAgICAgICBsYXN0TW92ZVkgPSBlLnNjcmVlblk7XG4gICAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBoYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oKSB7XG4gICAgICBoYW5kbGVBY3Rpdml0eSgpO1xuICAgICAgLy8gRm9yIGFzIGxvbmcgYXMgdGhlIHRoZXkgYXJlIHRvdWNoaW5nIHRoZSBkZXZpY2Ugb3IgaGF2ZSB0aGVpciBtb3VzZSBkb3duLFxuICAgICAgLy8gd2UgY29uc2lkZXIgdGhlbSBhY3RpdmUgZXZlbiBpZiB0aGV5J3JlIG5vdCBtb3ZpbmcgdGhlaXIgZmluZ2VyIG9yIG1vdXNlLlxuICAgICAgLy8gU28gd2Ugd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgdGhhdCB0aGV5IGFyZSBhY3RpdmVcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbChtb3VzZUluUHJvZ3Jlc3MpO1xuICAgICAgLy8gU2V0dGluZyB1c2VyQWN0aXZpdHk9dHJ1ZSBub3cgYW5kIHNldHRpbmcgdGhlIGludGVydmFsIHRvIHRoZSBzYW1lIHRpbWVcbiAgICAgIC8vIGFzIHRoZSBhY3Rpdml0eUNoZWNrIGludGVydmFsICgyNTApIHNob3VsZCBlbnN1cmUgd2UgbmV2ZXIgbWlzcyB0aGVcbiAgICAgIC8vIG5leHQgYWN0aXZpdHlDaGVja1xuICAgICAgbW91c2VJblByb2dyZXNzID0gdGhpcy5zZXRJbnRlcnZhbChoYW5kbGVBY3Rpdml0eSwgMjUwKTtcbiAgICB9O1xuXG4gICAgdmFyIGhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgICBoYW5kbGVBY3Rpdml0eSgpO1xuICAgICAgLy8gU3RvcCB0aGUgaW50ZXJ2YWwgdGhhdCBtYWludGFpbnMgYWN0aXZpdHkgaWYgdGhlIG1vdXNlL3RvdWNoIGlzIGRvd25cbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbChtb3VzZUluUHJvZ3Jlc3MpO1xuICAgIH07XG5cbiAgICAvLyBBbnkgbW91c2UgbW92ZW1lbnQgd2lsbCBiZSBjb25zaWRlcmVkIHVzZXIgYWN0aXZpdHlcbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCBoYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub24oJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vbignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXApO1xuXG4gICAgLy8gTGlzdGVuIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uXG4gICAgLy8gU2hvdWxkbid0IG5lZWQgdG8gdXNlIGluUHJvZ3Jlc3MgaW50ZXJ2YWwgYmVjYXVzZSBvZiBrZXkgcmVwZWF0XG4gICAgdGhpcy5vbigna2V5ZG93bicsIGhhbmRsZUFjdGl2aXR5KTtcbiAgICB0aGlzLm9uKCdrZXl1cCcsIGhhbmRsZUFjdGl2aXR5KTtcblxuICAgIC8vIFJ1biBhbiBpbnRlcnZhbCBldmVyeSAyNTAgbWlsbGlzZWNvbmRzIGluc3RlYWQgb2Ygc3R1ZmZpbmcgZXZlcnl0aGluZyBpbnRvXG4gICAgLy8gdGhlIG1vdXNlbW92ZS90b3VjaG1vdmUgZnVuY3Rpb24gaXRzZWxmLCB0byBwcmV2ZW50IHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uLlxuICAgIC8vIGB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eWAgc2ltcGx5IHNldHMgdGhpcy51c2VyQWN0aXZpdHlfIHRvIHRydWUsIHdoaWNoXG4gICAgLy8gdGhlbiBnZXRzIHBpY2tlZCB1cCBieSB0aGlzIGxvb3BcbiAgICAvLyBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvbGVhcm5pbmctZnJvbS10d2l0dGVyL1xuICAgIHZhciBpbmFjdGl2aXR5VGltZW91dCA9IHZvaWQgMDtcblxuICAgIHRoaXMuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIG1vdXNlL3RvdWNoIGFjdGl2aXR5IGhhcyBoYXBwZW5lZFxuICAgICAgaWYgKHRoaXMudXNlckFjdGl2aXR5Xykge1xuICAgICAgICAvLyBSZXNldCB0aGUgYWN0aXZpdHkgdHJhY2tlclxuICAgICAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSBmYWxzZTtcblxuICAgICAgICAvLyBJZiB0aGUgdXNlciBzdGF0ZSB3YXMgaW5hY3RpdmUsIHNldCB0aGUgc3RhdGUgdG8gYWN0aXZlXG4gICAgICAgIHRoaXMudXNlckFjdGl2ZSh0cnVlKTtcblxuICAgICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgaW5hY3Rpdml0eSB0aW1lb3V0IHRvIHN0YXJ0IHRoZSB0aW1lciBvdmVyXG4gICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KGluYWN0aXZpdHlUaW1lb3V0KTtcblxuICAgICAgICB2YXIgdGltZW91dCA9IHRoaXMub3B0aW9uc18uaW5hY3Rpdml0eVRpbWVvdXQ7XG5cbiAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgLy8gSW4gPHRpbWVvdXQ+IG1pbGxpc2Vjb25kcywgaWYgbm8gbW9yZSBhY3Rpdml0eSBoYXMgb2NjdXJyZWQgdGhlXG4gICAgICAgICAgLy8gdXNlciB3aWxsIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmVcbiAgICAgICAgICBpbmFjdGl2aXR5VGltZW91dCA9IHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3QgdGhlIGNhc2Ugd2hlcmUgdGhlIGluYWN0aXZpdHlUaW1lb3V0IGNhbiB0cmlnZ2VyIGp1c3RcbiAgICAgICAgICAgIC8vIGJlZm9yZSB0aGUgbmV4dCB1c2VyIGFjdGl2aXR5IGlzIHBpY2tlZCB1cCBieSB0aGUgYWN0aXZpdHkgY2hlY2sgbG9vcFxuICAgICAgICAgICAgLy8gY2F1c2luZyBhIGZsaWNrZXJcbiAgICAgICAgICAgIGlmICghdGhpcy51c2VyQWN0aXZpdHlfKSB7XG4gICAgICAgICAgICAgIHRoaXMudXNlckFjdGl2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAyNTApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZS4gQSBwbGF5YmFjayByYXRlIG9mXG4gICAqIDEuMCByZXByZXNlbnRzIG5vcm1hbCBzcGVlZCBhbmQgMC41IHdvdWxkIGluZGljYXRlIGhhbGYtc3BlZWRcbiAgICogcGxheWJhY2ssIGZvciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXBsYXliYWNrcmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JhdGVdXG4gICAqICAgICAgIE5ldyBwbGF5YmFjayByYXRlIHRvIHNldC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUgd2hlbiBnZXR0aW5nIG9yIDEuMFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGxheWJhY2tSYXRlID0gZnVuY3Rpb24gcGxheWJhY2tSYXRlKHJhdGUpIHtcbiAgICBpZiAocmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0UGxheWJhY2tSYXRlJywgcmF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy5mZWF0dXJlc1BsYXliYWNrUmF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BsYXliYWNrUmF0ZScpO1xuICAgIH1cbiAgICByZXR1cm4gMS4wO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgZGVmYXVsdCBwbGF5YmFjayByYXRlLiBBIGRlZmF1bHQgcGxheWJhY2sgcmF0ZSBvZlxuICAgKiAxLjAgcmVwcmVzZW50cyBub3JtYWwgc3BlZWQgYW5kIDAuNSB3b3VsZCBpbmRpY2F0ZSBoYWxmLXNwZWVkIHBsYXliYWNrLCBmb3IgaW5zdGFuY2UuXG4gICAqIGRlZmF1bHRQbGF5YmFja1JhdGUgd2lsbCBvbmx5IHJlcHJlc2VudCB3aGF0IHRoZSBpbnRpYWwgcGxheWJhY2tSYXRlIG9mIGEgdmlkZW8gd2FzLCBub3RcbiAgICogbm90IHRoZSBjdXJyZW50IHBsYXliYWNrUmF0ZS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLWRlZmF1bHRwbGF5YmFja3JhdGVcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtyYXRlXVxuICAgKiAgICAgICBOZXcgZGVmYXVsdCBwbGF5YmFjayByYXRlIHRvIHNldC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfFBsYXllcn1cbiAgICogICAgICAgICAtIFRoZSBkZWZhdWx0IHBsYXliYWNrIHJhdGUgd2hlbiBnZXR0aW5nIG9yIDEuMFxuICAgKiAgICAgICAgIC0gdGhlIHBsYXllciB3aGVuIHNldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmRlZmF1bHRQbGF5YmFja1JhdGUgPSBmdW5jdGlvbiBkZWZhdWx0UGxheWJhY2tSYXRlKHJhdGUpIHtcbiAgICBpZiAocmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoQ2FsbF8oJ3NldERlZmF1bHRQbGF5YmFja1JhdGUnLCByYXRlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLmZlYXR1cmVzUGxheWJhY2tSYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnZGVmYXVsdFBsYXliYWNrUmF0ZScpO1xuICAgIH1cbiAgICByZXR1cm4gMS4wO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGF1ZGlvIGZsYWdcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBib29sXG4gICAqICAgICAgICAtIHRydWUgc2lnbmFscyB0aGF0IHRoaXMgaXMgYW4gYXVkaW8gcGxheWVyXG4gICAqICAgICAgICAtIGZhbHNlIHNpZ25hbHMgdGhhdCB0aGlzIGlzIG5vdCBhbiBhdWRpbyBwbGF5ZXJcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBpc0F1ZGlvIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaXNBdWRpbyA9IGZ1bmN0aW9uIGlzQXVkaW8oYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaXNBdWRpb18gPSAhIWJvb2w7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuICEhdGhpcy5pc0F1ZGlvXztcbiAgfTtcblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIGZvciBhZGRpbmcgYSB7QGxpbmsgVGV4dFRyYWNrfSB0byBvdXJcbiAgICoge0BsaW5rIFRleHRUcmFja0xpc3R9LlxuICAgKlxuICAgKiBJbiBhZGRpdGlvbiB0byB0aGUgVzNDIHNldHRpbmdzIHdlIGFsbG93IGFkZGluZyBhZGRpdGlvbmFsIGluZm8gdGhyb3VnaCBvcHRpb25zLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1hZGR0ZXh0dHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtraW5kXVxuICAgKiAgICAgICAgdGhlIGtpbmQgb2YgVGV4dFRyYWNrIHlvdSBhcmUgYWRkaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdXG4gICAqICAgICAgICB0aGUgbGFiZWwgdG8gZ2l2ZSB0aGUgVGV4dFRyYWNrIGxhYmVsXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2VdXG4gICAqICAgICAgICB0aGUgbGFuZ3VhZ2UgdG8gc2V0IG9uIHRoZSBUZXh0VHJhY2tcbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrfHVuZGVmaW5lZH1cbiAgICogICAgICAgICB0aGUgVGV4dFRyYWNrIHRoYXQgd2FzIGFkZGVkIG9yIHVuZGVmaW5lZFxuICAgKiAgICAgICAgIGlmIHRoZXJlIGlzIG5vIHRlY2hcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmFkZFRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaF8uYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByZW1vdGUge0BsaW5rIFRleHRUcmFja30gYW5kIGFuIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fS4gSXQgd2lsbFxuICAgKiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgZnJvbSB0aGUgdmlkZW8gZWxlbWVudCB3aGVuZXZlciB0aGUgc291cmNlIGNoYW5nZXMsIHVubGVzc1xuICAgKiBtYW51YWxDbGVhbnVwIGlzIHNldCB0byBmYWxzZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIE9wdGlvbnMgdG8gcGFzcyB0byB7QGxpbmsgSFRNTFRyYWNrRWxlbWVudH0gZHVyaW5nIGNyZWF0aW9uLiBTZWVcbiAgICogICAgICAgIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fSBmb3Igb2JqZWN0IHByb3BlcnRpZXMgdGhhdCB5b3Ugc2hvdWxkIHVzZS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbbWFudWFsQ2xlYW51cD10cnVlXSBpZiBzZXQgdG8gZmFsc2UsIHRoZSBUZXh0VHJhY2sgd2lsbCBiZVxuICAgKlxuICAgKiBAcmV0dXJuIHtIdG1sVHJhY2tFbGVtZW50fVxuICAgKiAgICAgICAgIHRoZSBIVE1MVHJhY2tFbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQgYW5kIGFkZGVkXG4gICAqICAgICAgICAgdG8gdGhlIEh0bWxUcmFja0VsZW1lbnRMaXN0IGFuZCB0aGUgcmVtb3RlXG4gICAqICAgICAgICAgVGV4dFRyYWNrTGlzdFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBUaGUgZGVmYXVsdCB2YWx1ZSBvZiB0aGUgXCJtYW51YWxDbGVhbnVwXCIgcGFyYW1ldGVyIHdpbGwgZGVmYXVsdFxuICAgKiAgICAgICAgICAgICB0byBcImZhbHNlXCIgaW4gdXBjb21pbmcgdmVyc2lvbnMgb2YgVmlkZW8uanNcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFJlbW90ZVRleHRUcmFjayhvcHRpb25zLCBtYW51YWxDbGVhbnVwKSB7XG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hfLmFkZFJlbW90ZVRleHRUcmFjayhvcHRpb25zLCBtYW51YWxDbGVhbnVwKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfSBmcm9tIHRoZSByZXNwZWN0aXZlXG4gICAqIHtAbGluayBUZXh0VHJhY2tMaXN0fSBhbmQge0BsaW5rIEh0bWxUcmFja0VsZW1lbnRMaXN0fS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYWNrXG4gICAqICAgICAgICBSZW1vdGUge0BsaW5rIFRleHRUcmFja30gdG8gcmVtb3ZlXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICogICAgICAgICBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlbW92ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRleHRUcmFjaygpIHtcbiAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBfcmVmMyR0cmFjayA9IF9yZWYzLnRyYWNrLFxuICAgICAgICB0cmFjayA9IF9yZWYzJHRyYWNrID09PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfcmVmMyR0cmFjaztcblxuICAgIC8vIGRlc3RydWN0dXJlIHRoZSBpbnB1dCBpbnRvIGFuIG9iamVjdCB3aXRoIGEgdHJhY2sgYXJndW1lbnQsIGRlZmF1bHRpbmcgdG8gYXJndW1lbnRzWzBdXG4gICAgLy8gZGVmYXVsdCB0aGUgd2hvbGUgYXJndW1lbnQgdG8gYW4gZW1wdHkgb2JqZWN0IGlmIG5vdGhpbmcgd2FzIHBhc3NlZCBpblxuXG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hfLnJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjayk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGF2YWlsYWJsZSBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBXM0MncyBNZWRpYVxuICAgKiBQbGF5YmFjayBRdWFsaXR5IEFQSS5cbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9tZWRpYS1wbGF5YmFjay1xdWFsaXR5fVxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIEFuIG9iamVjdCB3aXRoIHN1cHBvcnRlZCBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3Mgb3IgdW5kZWZpbmVkIGlmIHRoZXJlXG4gICAqICAgICAgICAgaXMgbm8gdGVjaCBvciB0aGUgdGVjaCBkb2VzIG5vdCBzdXBwb3J0IGl0LlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPSBmdW5jdGlvbiBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHknKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHZpZGVvIHdpZHRoXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBjdXJyZW50IHZpZGVvIHdpZHRoXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS52aWRlb1dpZHRoID0gZnVuY3Rpb24gdmlkZW9XaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLnZpZGVvV2lkdGggJiYgdGhpcy50ZWNoXy52aWRlb1dpZHRoKCkgfHwgMDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHZpZGVvIGhlaWdodFxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgY3VycmVudCB2aWRlbyBoZWlnaHRcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnZpZGVvSGVpZ2h0ID0gZnVuY3Rpb24gdmlkZW9IZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy52aWRlb0hlaWdodCAmJiB0aGlzLnRlY2hfLnZpZGVvSGVpZ2h0KCkgfHwgMDtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHBsYXllcidzIGxhbmd1YWdlIGNvZGVcbiAgICogTk9URTogVGhlIGxhbmd1YWdlIHNob3VsZCBiZSBzZXQgaW4gdGhlIHBsYXllciBvcHRpb25zIGlmIHlvdSB3YW50IHRoZVxuICAgKiB0aGUgY29udHJvbHMgdG8gYmUgYnVpbHQgd2l0aCBhIHNwZWNpZmljIGxhbmd1YWdlLiBDaGFuZ2luZyB0aGUgbGFudWdhZ2VcbiAgICogbGF0ZXIgd2lsbCBub3QgdXBkYXRlIGNvbnRyb2xzIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV1cbiAgICogICAgICAgIHRoZSBsYW5ndWFnZSBjb2RlIHRvIHNldCB0aGUgcGxheWVyIHRvXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY3VycmVudCBsYW5ndWFnZSBjb2RlIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubGFuZ3VhZ2UgPSBmdW5jdGlvbiBsYW5ndWFnZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFuZ3VhZ2VfO1xuICAgIH1cblxuICAgIHRoaXMubGFuZ3VhZ2VfID0gU3RyaW5nKGNvZGUpLnRvTG93ZXJDYXNlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGxheWVyJ3MgbGFuZ3VhZ2UgZGljdGlvbmFyeVxuICAgKiBNZXJnZSBldmVyeSB0aW1lLCBiZWNhdXNlIGEgbmV3bHkgYWRkZWQgcGx1Z2luIG1pZ2h0IGNhbGwgdmlkZW9qcy5hZGRMYW5ndWFnZSgpIGF0IGFueSB0aW1lXG4gICAqIExhbmd1YWdlcyBzcGVjaWZpZWQgZGlyZWN0bHkgaW4gdGhlIHBsYXllciBvcHRpb25zIGhhdmUgcHJlY2VkZW5jZVxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogICAgICAgICBBbiBhcnJheSBvZiBvZiBzdXBwb3J0ZWQgbGFuZ3VhZ2VzXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sYW5ndWFnZXMgPSBmdW5jdGlvbiBsYW5ndWFnZXMoKSB7XG4gICAgcmV0dXJuIG1lcmdlT3B0aW9ucyhQbGF5ZXIucHJvdG90eXBlLm9wdGlvbnNfLmxhbmd1YWdlcywgdGhpcy5sYW5ndWFnZXNfKTtcbiAgfTtcblxuICAvKipcbiAgICogcmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHJlcGVyZXNlbnRpbmcgdGhlIGN1cnJlbnQgdHJhY2tcbiAgICogaW5mb3JtYXRpb24uICoqRE9FUyBub3QgcmV0dXJuIGl0IGFzIEpTT04qKlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgT2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBvZiB0cmFjayBpbmZvXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zXyk7XG4gICAgdmFyIHRyYWNrcyA9IG9wdGlvbnMudHJhY2tzO1xuXG4gICAgb3B0aW9ucy50cmFja3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIC8vIGRlZXAgbWVyZ2UgdHJhY2tzIGFuZCBudWxsIG91dCBwbGF5ZXIgc28gbm8gY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAgdHJhY2sgPSBtZXJnZU9wdGlvbnModHJhY2spO1xuICAgICAgdHJhY2sucGxheWVyID0gdW5kZWZpbmVkO1xuICAgICAgb3B0aW9ucy50cmFja3NbaV0gPSB0cmFjaztcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNpbXBsZSBtb2RhbCBkaWFsb2cgKGFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgTW9kYWxEaWFsb2d9XG4gICAqIGNvbXBvbmVudCkgdGhhdCBpbW1lZGlhdGVseSBvdmVybGF5cyB0aGUgcGxheWVyIHdpdGggYXJiaXRyYXJ5XG4gICAqIGNvbnRlbnQgYW5kIHJlbW92ZXMgaXRzZWxmIHdoZW4gY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbnxFbGVtZW50fEFycmF5fG51bGx9IGNvbnRlbnRcbiAgICogICAgICAgIFNhbWUgYXMge0BsaW5rIE1vZGFsRGlhbG9nI2NvbnRlbnR9J3MgcGFyYW0gb2YgdGhlIHNhbWUgbmFtZS5cbiAgICogICAgICAgIFRoZSBtb3N0IHN0cmFpZ2h0LWZvcndhcmQgdXNhZ2UgaXMgdG8gcHJvdmlkZSBhIHN0cmluZyBvciBET01cbiAgICogICAgICAgIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIEV4dHJhIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHtAbGluayBNb2RhbERpYWxvZ30uXG4gICAqXG4gICAqIEByZXR1cm4ge01vZGFsRGlhbG9nfVxuICAgKiAgICAgICAgIHRoZSB7QGxpbmsgTW9kYWxEaWFsb2d9IHRoYXQgd2FzIGNyZWF0ZWRcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmNyZWF0ZU1vZGFsID0gZnVuY3Rpb24gY3JlYXRlTW9kYWwoY29udGVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jb250ZW50ID0gY29udGVudCB8fCAnJztcblxuICAgIHZhciBtb2RhbCA9IG5ldyBNb2RhbERpYWxvZyh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuYWRkQ2hpbGQobW9kYWwpO1xuICAgIG1vZGFsLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXM3LnJlbW92ZUNoaWxkKG1vZGFsKTtcbiAgICB9KTtcblxuICAgIG1vZGFsLm9wZW4oKTtcbiAgICByZXR1cm4gbW9kYWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgdGFnIHNldHRpbmdzXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFnXG4gICAqICAgICAgICBUaGUgcGxheWVyIHRhZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBzZXR0aW5nc1xuICAgKiAgICAgICAgIGZvciBhIHBsYXllciB0YWdcbiAgICovXG5cblxuICBQbGF5ZXIuZ2V0VGFnU2V0dGluZ3MgPSBmdW5jdGlvbiBnZXRUYWdTZXR0aW5ncyh0YWcpIHtcbiAgICB2YXIgYmFzZU9wdGlvbnMgPSB7XG4gICAgICBzb3VyY2VzOiBbXSxcbiAgICAgIHRyYWNrczogW11cbiAgICB9O1xuXG4gICAgdmFyIHRhZ09wdGlvbnMgPSBnZXRBdHRyaWJ1dGVzKHRhZyk7XG4gICAgdmFyIGRhdGFTZXR1cCA9IHRhZ09wdGlvbnNbJ2RhdGEtc2V0dXAnXTtcblxuICAgIGlmIChoYXNDbGFzcyh0YWcsICd2anMtZmx1aWQnKSkge1xuICAgICAgdGFnT3B0aW9ucy5mbHVpZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgZGF0YS1zZXR1cCBhdHRyIGV4aXN0cy5cbiAgICBpZiAoZGF0YVNldHVwICE9PSBudWxsKSB7XG4gICAgICAvLyBQYXJzZSBvcHRpb25zIEpTT05cbiAgICAgIC8vIElmIGVtcHR5IHN0cmluZywgbWFrZSBpdCBhIHBhcnNhYmxlIGpzb24gb2JqZWN0LlxuICAgICAgdmFyIF9zYWZlUGFyc2VUdXBsZSA9IHNhZmVQYXJzZVR1cGxlKGRhdGFTZXR1cCB8fCAne30nKSxcbiAgICAgICAgICBlcnIgPSBfc2FmZVBhcnNlVHVwbGVbMF0sXG4gICAgICAgICAgZGF0YSA9IF9zYWZlUGFyc2VUdXBsZVsxXTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2ckMS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgYXNzaWduKHRhZ09wdGlvbnMsIGRhdGEpO1xuICAgIH1cblxuICAgIGFzc2lnbihiYXNlT3B0aW9ucywgdGFnT3B0aW9ucyk7XG5cbiAgICAvLyBHZXQgdGFnIGNoaWxkcmVuIHNldHRpbmdzXG4gICAgaWYgKHRhZy5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRhZy5jaGlsZE5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgLy8gQ2hhbmdlIGNhc2UgbmVlZGVkOiBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvbm9kZW5hbWUtY2FzZS1zZW5zaXRpdml0eS9cbiAgICAgICAgdmFyIGNoaWxkTmFtZSA9IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJ3NvdXJjZScpIHtcbiAgICAgICAgICBiYXNlT3B0aW9ucy5zb3VyY2VzLnB1c2goZ2V0QXR0cmlidXRlcyhjaGlsZCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkTmFtZSA9PT0gJ3RyYWNrJykge1xuICAgICAgICAgIGJhc2VPcHRpb25zLnRyYWNrcy5wdXNoKGdldEF0dHJpYnV0ZXMoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiYXNlT3B0aW9ucztcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdldGhlciBvciBub3QgZmxleGJveCBpcyBzdXBwb3J0ZWRcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIHRydWUgaWYgZmxleGJveCBpcyBzdXBwb3J0ZWRcbiAgICogICAgICAgICAtIGZhbHNlIGlmIGZsZXhib3ggaXMgbm90IHN1cHBvcnRlZFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZmxleE5vdFN1cHBvcnRlZF8gPSBmdW5jdGlvbiBmbGV4Tm90U3VwcG9ydGVkXygpIHtcbiAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKTtcblxuICAgIC8vIE5vdGU6IFdlIGRvbid0IGFjdHVhbGx5IHVzZSBmbGV4QmFzaXMgKG9yIGZsZXhPcmRlciksIGJ1dCBpdCdzIG9uZSBvZiB0aGUgbW9yZVxuICAgIC8vIGNvbW1vbiBmbGV4IGZlYXR1cmVzIHRoYXQgd2UgY2FuIHJlbHkgb24gd2hlbiBjaGVja2luZyBmb3IgZmxleCBzdXBwb3J0LlxuICAgIHJldHVybiAhKCdmbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUgfHwgJ3dlYmtpdEZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fCAnbW96RmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8ICdtc0ZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fFxuICAgIC8vIElFMTAtc3BlY2lmaWMgKDIwMTIgZmxleCBzcGVjKVxuICAgICdtc0ZsZXhPcmRlcicgaW4gZWxlbS5zdHlsZSk7XG4gIH07XG5cbiAgcmV0dXJuIFBsYXllcjtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBWaWRlb1RyYWNrTGlzdH1cbiAqIEBsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN2aWRlb3RyYWNrbGlzdFxuICpcbiAqIEByZXR1cm4ge1ZpZGVvVHJhY2tMaXN0fVxuICogICAgICAgICB0aGUgY3VycmVudCB2aWRlbyB0cmFjayBsaXN0XG4gKlxuICogQG1ldGhvZCBQbGF5ZXIucHJvdG90eXBlLnZpZGVvVHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBBdWRpb1RyYWNrTGlzdH1cbiAqIEBsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdWRpb3RyYWNrbGlzdFxuICpcbiAqIEByZXR1cm4ge0F1ZGlvVHJhY2tMaXN0fVxuICogICAgICAgICB0aGUgY3VycmVudCBhdWRpbyB0cmFjayBsaXN0XG4gKlxuICogQG1ldGhvZCBQbGF5ZXIucHJvdG90eXBlLmF1ZGlvVHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICpcbiAqIEBsaW5rIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS10ZXh0dHJhY2tzXG4gKlxuICogQHJldHVybiB7VGV4dFRyYWNrTGlzdH1cbiAqICAgICAgICAgdGhlIGN1cnJlbnQgdGV4dCB0cmFjayBsaXN0XG4gKlxuICogQG1ldGhvZCBQbGF5ZXIucHJvdG90eXBlLnRleHRUcmFja3NcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgcmVtb3RlIHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICpcbiAqIEByZXR1cm4ge1RleHRUcmFja0xpc3R9XG4gKiAgICAgICAgIFRoZSBjdXJyZW50IHJlbW90ZSB0ZXh0IHRyYWNrIGxpc3RcbiAqXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUucmVtb3RlVGV4dFRyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSByZW1vdGUge0BsaW5rIEh0bWxUcmFja0VsZW1lbnRMaXN0fSB0cmFja3MuXG4gKlxuICogQHJldHVybiB7SHRtbFRyYWNrRWxlbWVudExpc3R9XG4gKiAgICAgICAgIFRoZSBjdXJyZW50IHJlbW90ZSB0ZXh0IHRyYWNrIGVsZW1lbnQgbGlzdFxuICpcbiAqIEBtZXRob2QgUGxheWVyLnByb3RvdHlwZS5yZW1vdGVUZXh0VHJhY2tFbHNcbiAqL1xuXG5BTEwubmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSQkMSkge1xuICB2YXIgcHJvcHMgPSBBTExbbmFtZSQkMV07XG5cbiAgUGxheWVyLnByb3RvdHlwZVtwcm9wcy5nZXR0ZXJOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaF9bcHJvcHMuZ2V0dGVyTmFtZV0oKTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIG5vdCB5ZXQgbG9hZFRlY2hfLCB3ZSBjcmVhdGUge3ZpZGVvLGF1ZGlvLHRleHR9VHJhY2tzX1xuICAgIC8vIHRoZXNlIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB0ZWNoIGR1cmluZyBsb2FkaW5nXG4gICAgdGhpc1twcm9wcy5wcml2YXRlTmFtZV0gPSB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXSB8fCBuZXcgcHJvcHMuTGlzdENsYXNzKCk7XG4gICAgcmV0dXJuIHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdO1xuICB9O1xufSk7XG5cbi8qKlxuICogR2xvYmFsIHBsYXllciBsaXN0XG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuUGxheWVyLnBsYXllcnMgPSB7fTtcblxudmFyIG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG5cbi8qXG4gKiBQbGF5ZXIgaW5zdGFuY2Ugb3B0aW9ucywgc3VyZmFjZWQgdXNpbmcgb3B0aW9uc1xuICogb3B0aW9ucyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc19cbiAqIE1ha2UgY2hhbmdlcyBpbiBvcHRpb25zLCBub3QgaGVyZS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgLy8gRGVmYXVsdCBvcmRlciBvZiBmYWxsYmFjayB0ZWNobm9sb2d5XG4gIHRlY2hPcmRlcjogVGVjaC5kZWZhdWx0VGVjaE9yZGVyXyxcblxuICBodG1sNToge30sXG4gIGZsYXNoOiB7fSxcblxuICAvLyBkZWZhdWx0IGluYWN0aXZpdHkgdGltZW91dFxuICBpbmFjdGl2aXR5VGltZW91dDogMjAwMCxcblxuICAvLyBkZWZhdWx0IHBsYXliYWNrIHJhdGVzXG4gIHBsYXliYWNrUmF0ZXM6IFtdLFxuICAvLyBBZGQgcGxheWJhY2sgcmF0ZSBzZWxlY3Rpb24gYnkgYWRkaW5nIHJhdGVzXG4gIC8vICdwbGF5YmFja1JhdGVzJzogWzAuNSwgMSwgMS41LCAyXSxcblxuICAvLyBJbmNsdWRlZCBjb250cm9sIHNldHNcbiAgY2hpbGRyZW46IFsnbWVkaWFMb2FkZXInLCAncG9zdGVySW1hZ2UnLCAndGV4dFRyYWNrRGlzcGxheScsICdsb2FkaW5nU3Bpbm5lcicsICdiaWdQbGF5QnV0dG9uJywgJ2NvbnRyb2xCYXInLCAnZXJyb3JEaXNwbGF5JywgJ3RleHRUcmFja1NldHRpbmdzJ10sXG5cbiAgbGFuZ3VhZ2U6IG5hdmlnYXRvciAmJiAobmF2aWdhdG9yLmxhbmd1YWdlcyAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdIHx8IG5hdmlnYXRvci51c2VyTGFuZ3VhZ2UgfHwgbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCAnZW4nLFxuXG4gIC8vIGxvY2FsZXMgYW5kIHRoZWlyIGxhbmd1YWdlIHRyYW5zbGF0aW9uc1xuICBsYW5ndWFnZXM6IHt9LFxuXG4gIC8vIERlZmF1bHQgbWVzc2FnZSB0byBzaG93IHdoZW4gYSB2aWRlbyBjYW5ub3QgYmUgcGxheWVkLlxuICBub3RTdXBwb3J0ZWRNZXNzYWdlOiAnTm8gY29tcGF0aWJsZSBzb3VyY2Ugd2FzIGZvdW5kIGZvciB0aGlzIG1lZGlhLidcbn07XG5cbltcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxheWVyIGlzIGluIHRoZSBcImVuZGVkXCIgc3RhdGUuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGxheWVyIGlzIGluIHRoZSBlbmRlZCBzdGF0ZSwgZmFsc2UgaWYgbm90LlxuICogQG1ldGhvZCBQbGF5ZXIjZW5kZWRcbiAqL1xuJ2VuZGVkJyxcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxheWVyIGlzIGluIHRoZSBcInNlZWtpbmdcIiBzdGF0ZS5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwbGF5ZXIgaXMgaW4gdGhlIHNlZWtpbmcgc3RhdGUsIGZhbHNlIGlmIG5vdC5cbiAqIEBtZXRob2QgUGxheWVyI3NlZWtpbmdcbiAqL1xuJ3NlZWtpbmcnLFxuLyoqXG4gKiBSZXR1cm5zIHRoZSBUaW1lUmFuZ2VzIG9mIHRoZSBtZWRpYSB0aGF0IGFyZSBjdXJyZW50bHkgYXZhaWxhYmxlXG4gKiBmb3Igc2Vla2luZyB0by5cbiAqXG4gKiBAcmV0dXJuIHtUaW1lUmFuZ2VzfSB0aGUgc2Vla2FibGUgaW50ZXJ2YWxzIG9mIHRoZSBtZWRpYSB0aW1lbGluZVxuICogQG1ldGhvZCBQbGF5ZXIjc2Vla2FibGVcbiAqL1xuJ3NlZWthYmxlJyxcbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZSBvZiBuZXR3b3JrIGFjdGl2aXR5IGZvciB0aGUgZWxlbWVudCwgZnJvbVxuICogdGhlIGNvZGVzIGluIHRoZSBsaXN0IGJlbG93LlxuICogLSBORVRXT1JLX0VNUFRZIChudW1lcmljIHZhbHVlIDApXG4gKiAgIFRoZSBlbGVtZW50IGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGlzZWQuIEFsbCBhdHRyaWJ1dGVzIGFyZSBpblxuICogICB0aGVpciBpbml0aWFsIHN0YXRlcy5cbiAqIC0gTkVUV09SS19JRExFIChudW1lcmljIHZhbHVlIDEpXG4gKiAgIFRoZSBlbGVtZW50J3MgcmVzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobSBpcyBhY3RpdmUgYW5kIGhhc1xuICogICBzZWxlY3RlZCBhIHJlc291cmNlLCBidXQgaXQgaXMgbm90IGFjdHVhbGx5IHVzaW5nIHRoZSBuZXR3b3JrIGF0XG4gKiAgIHRoaXMgdGltZS5cbiAqIC0gTkVUV09SS19MT0FESU5HIChudW1lcmljIHZhbHVlIDIpXG4gKiAgIFRoZSB1c2VyIGFnZW50IGlzIGFjdGl2ZWx5IHRyeWluZyB0byBkb3dubG9hZCBkYXRhLlxuICogLSBORVRXT1JLX05PX1NPVVJDRSAobnVtZXJpYyB2YWx1ZSAzKVxuICogICBUaGUgZWxlbWVudCdzIHJlc291cmNlIHNlbGVjdGlvbiBhbGdvcml0aG0gaXMgYWN0aXZlLCBidXQgaXQgaGFzXG4gKiAgIG5vdCB5ZXQgZm91bmQgYSByZXNvdXJjZSB0byB1c2UuXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjbmV0d29yay1zdGF0ZXNcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGN1cnJlbnQgbmV0d29yayBhY3Rpdml0eSBzdGF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjbmV0d29ya1N0YXRlXG4gKi9cbiduZXR3b3JrU3RhdGUnLFxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBleHByZXNzZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnRcbiAqIHdpdGggcmVzcGVjdCB0byByZW5kZXJpbmcgdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24sIGZyb20gdGhlXG4gKiBjb2RlcyBpbiB0aGUgbGlzdCBiZWxvdy5cbiAqIC0gSEFWRV9OT1RISU5HIChudW1lcmljIHZhbHVlIDApXG4gKiAgIE5vIGluZm9ybWF0aW9uIHJlZ2FyZGluZyB0aGUgbWVkaWEgcmVzb3VyY2UgaXMgYXZhaWxhYmxlLlxuICogLSBIQVZFX01FVEFEQVRBIChudW1lcmljIHZhbHVlIDEpXG4gKiAgIEVub3VnaCBvZiB0aGUgcmVzb3VyY2UgaGFzIGJlZW4gb2J0YWluZWQgdGhhdCB0aGUgZHVyYXRpb24gb2YgdGhlXG4gKiAgIHJlc291cmNlIGlzIGF2YWlsYWJsZS5cbiAqIC0gSEFWRV9DVVJSRU5UX0RBVEEgKG51bWVyaWMgdmFsdWUgMilcbiAqICAgRGF0YSBmb3IgdGhlIGltbWVkaWF0ZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGlzIGF2YWlsYWJsZS5cbiAqIC0gSEFWRV9GVVRVUkVfREFUQSAobnVtZXJpYyB2YWx1ZSAzKVxuICogICBEYXRhIGZvciB0aGUgaW1tZWRpYXRlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgYXZhaWxhYmxlLCBhc1xuICogICB3ZWxsIGFzIGVub3VnaCBkYXRhIGZvciB0aGUgdXNlciBhZ2VudCB0byBhZHZhbmNlIHRoZSBjdXJyZW50XG4gKiAgIHBsYXliYWNrIHBvc2l0aW9uIGluIHRoZSBkaXJlY3Rpb24gb2YgcGxheWJhY2suXG4gKiAtIEhBVkVfRU5PVUdIX0RBVEEgKG51bWVyaWMgdmFsdWUgNClcbiAqICAgVGhlIHVzZXIgYWdlbnQgZXN0aW1hdGVzIHRoYXQgZW5vdWdoIGRhdGEgaXMgYXZhaWxhYmxlIGZvclxuICogICBwbGF5YmFjayB0byBwcm9jZWVkIHVuaW50ZXJydXB0ZWQuXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXJlYWR5c3RhdGVcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGN1cnJlbnQgcGxheWJhY2sgcmVuZGVyaW5nIHN0YXRlXG4gKiBAbWV0aG9kIFBsYXllciNyZWFkeVN0YXRlXG4gKi9cbidyZWFkeVN0YXRlJ10uZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgUGxheWVyLnByb3RvdHlwZVtmbl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oZm4pO1xuICB9O1xufSk7XG5cblRFQ0hfRVZFTlRTX1JFVFJJR0dFUi5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICBQbGF5ZXIucHJvdG90eXBlWydoYW5kbGVUZWNoJyArIHRvVGl0bGVDYXNlKGV2ZW50KSArICdfJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlcihldmVudCk7XG4gIH07XG59KTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBwbGF5ZXIgaGFzIGluaXRpYWwgZHVyYXRpb24gYW5kIGRpbWVuc2lvbiBpbmZvcm1hdGlvblxuICpcbiAqIEBldmVudCBQbGF5ZXIjbG9hZGVkbWV0YWRhdGFcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBoYXMgZG93bmxvYWRlZCBkYXRhIGF0IHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uXG4gKlxuICogQGV2ZW50IFBsYXllciNsb2FkZWRkYXRhXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGhhcyBjaGFuZ2VkICpcbiAqIER1cmluZyBwbGF5YmFjayB0aGlzIGlzIGZpcmVkIGV2ZXJ5IDE1LTI1MCBtaWxsaXNlY29uZHMsIGRlcGVuZGluZyBvbiB0aGVcbiAqIHBsYXliYWNrIHRlY2hub2xvZ3kgaW4gdXNlLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjdGltZXVwZGF0ZVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdm9sdW1lIGNoYW5nZXNcbiAqXG4gKiBAZXZlbnQgUGxheWVyI3ZvbHVtZWNoYW5nZVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogUmVwb3J0cyB3aGV0aGVyIG9yIG5vdCBhIHBsYXllciBoYXMgYSBwbHVnaW4gYXZhaWxhYmxlLlxuICpcbiAqIFRoaXMgZG9lcyBub3QgcmVwb3J0IHdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaGFzIGV2ZXIgYmVlbiBpbml0aWFsaXplZFxuICogb24gdGhpcyBwbGF5ZXIuIEZvciB0aGF0LCBbdXNpbmdQbHVnaW5de0BsaW5rIFBsYXllciN1c2luZ1BsdWdpbn0uXG4gKlxuICogQG1ldGhvZCBQbGF5ZXIjaGFzUGx1Z2luXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoaXMgcGxheWVyIGhhcyB0aGUgcmVxdWVzdGVkIHBsdWdpbiBhdmFpbGFibGUuXG4gKi9cblxuLyoqXG4gKiBSZXBvcnRzIHdoZXRoZXIgb3Igbm90IGEgcGxheWVyIGlzIHVzaW5nIGEgcGx1Z2luIGJ5IG5hbWUuXG4gKlxuICogRm9yIGJhc2ljIHBsdWdpbnMsIHRoaXMgb25seSByZXBvcnRzIHdoZXRoZXIgdGhlIHBsdWdpbiBoYXMgX2V2ZXJfIGJlZW5cbiAqIGluaXRpYWxpemVkIG9uIHRoaXMgcGxheWVyLlxuICpcbiAqIEBtZXRob2QgUGxheWVyI3VzaW5nUGx1Z2luXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdGhpcyBwbGF5ZXIgaXMgdXNpbmcgdGhlIHJlcXVlc3RlZCBwbHVnaW4uXG4gKi9cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5ZXInLCBQbGF5ZXIpO1xuXG4vKipcbiAqIEBmaWxlIHBsdWdpbi5qc1xuICovXG4vKipcbiAqIFRoZSBiYXNlIHBsdWdpbiBuYW1lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciBCQVNFX1BMVUdJTl9OQU1FID0gJ3BsdWdpbic7XG5cbi8qKlxuICogVGhlIGtleSBvbiB3aGljaCBhIHBsYXllcidzIGFjdGl2ZSBwbHVnaW5zIGNhY2hlIGlzIHN0b3JlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50XG4gKiBAdHlwZSAgICAge3N0cmluZ31cbiAqL1xudmFyIFBMVUdJTl9DQUNIRV9LRVkgPSAnYWN0aXZlUGx1Z2luc18nO1xuXG4vKipcbiAqIFN0b3JlcyByZWdpc3RlcmVkIHBsdWdpbnMgaW4gYSBwcml2YXRlIHNwYWNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSAgICB7T2JqZWN0fVxuICovXG52YXIgcGx1Z2luU3RvcmFnZSA9IHt9O1xuXG4vKipcbiAqIFJlcG9ydHMgd2hldGhlciBvciBub3QgYSBwbHVnaW4gaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgcGx1Z2luIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXG4gKi9cbnZhciBwbHVnaW5FeGlzdHMgPSBmdW5jdGlvbiBwbHVnaW5FeGlzdHMobmFtZSkge1xuICByZXR1cm4gcGx1Z2luU3RvcmFnZS5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbn07XG5cbi8qKlxuICogR2V0IGEgc2luZ2xlIHJlZ2lzdGVyZWQgcGx1Z2luIGJ5IG5hbWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKiAgICAgICAgICBUaGUgcGx1Z2luIChvciB1bmRlZmluZWQpLlxuICovXG52YXIgZ2V0UGx1Z2luID0gZnVuY3Rpb24gZ2V0UGx1Z2luKG5hbWUpIHtcbiAgcmV0dXJuIHBsdWdpbkV4aXN0cyhuYW1lKSA/IHBsdWdpblN0b3JhZ2VbbmFtZV0gOiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIE1hcmtzIGEgcGx1Z2luIGFzIFwiYWN0aXZlXCIgb24gYSBwbGF5ZXIuXG4gKlxuICogQWxzbywgZW5zdXJlcyB0aGF0IHRoZSBwbGF5ZXIgaGFzIGFuIG9iamVjdCBmb3IgdHJhY2tpbmcgYWN0aXZlIHBsdWdpbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtQbGF5ZXJ9IHBsYXllclxuICogICAgICAgICAgQSBWaWRlby5qcyBwbGF5ZXIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKi9cbnZhciBtYXJrUGx1Z2luQXNBY3RpdmUgPSBmdW5jdGlvbiBtYXJrUGx1Z2luQXNBY3RpdmUocGxheWVyLCBuYW1lKSB7XG4gIHBsYXllcltQTFVHSU5fQ0FDSEVfS0VZXSA9IHBsYXllcltQTFVHSU5fQ0FDSEVfS0VZXSB8fCB7fTtcbiAgcGxheWVyW1BMVUdJTl9DQUNIRV9LRVldW25hbWVdID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogVHJpZ2dlcnMgYSBwYWlyIG9mIHBsdWdpbiBzZXR1cCBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1BsYXllcn0gcGxheWVyXG4gKiAgICAgICAgIEEgVmlkZW8uanMgcGxheWVyIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSAge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9IGhhc2hcbiAqICAgICAgICAgQSBwbHVnaW4gZXZlbnQgaGFzaC5cbiAqXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbYmVmb3JlXVxuICogICAgICAgICBJZiB0cnVlLCBwcmVmaXhlcyB0aGUgZXZlbnQgbmFtZSB3aXRoIFwiYmVmb3JlXCIuIEluIG90aGVyIHdvcmRzLFxuICogICAgICAgICB1c2UgdGhpcyB0byB0cmlnZ2VyIFwiYmVmb3JlcGx1Z2luc2V0dXBcIiBpbnN0ZWFkIG9mIFwicGx1Z2luc2V0dXBcIi5cbiAqL1xudmFyIHRyaWdnZXJTZXR1cEV2ZW50ID0gZnVuY3Rpb24gdHJpZ2dlclNldHVwRXZlbnQocGxheWVyLCBoYXNoLCBiZWZvcmUpIHtcbiAgdmFyIGV2ZW50TmFtZSA9IChiZWZvcmUgPyAnYmVmb3JlJyA6ICcnKSArICdwbHVnaW5zZXR1cCc7XG5cbiAgcGxheWVyLnRyaWdnZXIoZXZlbnROYW1lLCBoYXNoKTtcbiAgcGxheWVyLnRyaWdnZXIoZXZlbnROYW1lICsgJzonICsgaGFzaC5uYW1lLCBoYXNoKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYSBiYXNpYyBwbHVnaW4gZnVuY3Rpb24gYW5kIHJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIG1hcmtzXG4gKiBvbiB0aGUgcGxheWVyIHRoYXQgdGhlIHBsdWdpbiBoYXMgYmVlbiBhY3RpdmF0ZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXG4gKlxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBwbHVnaW5cbiAqICAgICAgICAgIFRoZSBiYXNpYyBwbHVnaW4uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICogICAgICAgICAgQSB3cmFwcGVyIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gcGx1Z2luLlxuICovXG52YXIgY3JlYXRlQmFzaWNQbHVnaW4gPSBmdW5jdGlvbiBjcmVhdGVCYXNpY1BsdWdpbihuYW1lLCBwbHVnaW4pIHtcbiAgdmFyIGJhc2ljUGx1Z2luV3JhcHBlciA9IGZ1bmN0aW9uIGJhc2ljUGx1Z2luV3JhcHBlcigpIHtcblxuICAgIC8vIFdlIHRyaWdnZXIgdGhlIFwiYmVmb3JlcGx1Z2luc2V0dXBcIiBhbmQgXCJwbHVnaW5zZXR1cFwiIGV2ZW50cyBvbiB0aGUgcGxheWVyXG4gICAgLy8gcmVnYXJkbGVzcywgYnV0IHdlIHdhbnQgdGhlIGhhc2ggdG8gYmUgY29uc2lzdGVudCB3aXRoIHRoZSBoYXNoIHByb3ZpZGVkXG4gICAgLy8gZm9yIGFkdmFuY2VkIHBsdWdpbnMuXG4gICAgLy9cbiAgICAvLyBUaGUgb25seSBwb3RlbnRpYWxseSBjb3VudGVyLWludHVpdGl2ZSB0aGluZyBoZXJlIGlzIHRoZSBgaW5zdGFuY2VgIGluXG4gICAgLy8gdGhlIFwicGx1Z2luc2V0dXBcIiBldmVudCBpcyB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGBwbHVnaW5gIGZ1bmN0aW9uLlxuICAgIHRyaWdnZXJTZXR1cEV2ZW50KHRoaXMsIHsgbmFtZTogbmFtZSwgcGx1Z2luOiBwbHVnaW4sIGluc3RhbmNlOiBudWxsIH0sIHRydWUpO1xuXG4gICAgdmFyIGluc3RhbmNlID0gcGx1Z2luLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBtYXJrUGx1Z2luQXNBY3RpdmUodGhpcywgbmFtZSk7XG4gICAgdHJpZ2dlclNldHVwRXZlbnQodGhpcywgeyBuYW1lOiBuYW1lLCBwbHVnaW46IHBsdWdpbiwgaW5zdGFuY2U6IGluc3RhbmNlIH0pO1xuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIE9iamVjdC5rZXlzKHBsdWdpbikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIGJhc2ljUGx1Z2luV3JhcHBlcltwcm9wXSA9IHBsdWdpbltwcm9wXTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJhc2ljUGx1Z2luV3JhcHBlcjtcbn07XG5cbi8qKlxuICogVGFrZXMgYSBwbHVnaW4gc3ViLWNsYXNzIGFuZCByZXR1cm5zIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZ1xuICogaW5zdGFuY2VzIG9mIGl0LlxuICpcbiAqIFRoaXMgZmFjdG9yeSBmdW5jdGlvbiB3aWxsIHJlcGxhY2UgaXRzZWxmIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhlIHJlcXVlc3RlZFxuICogc3ViLWNsYXNzIG9mIFBsdWdpbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0gICB7UGx1Z2lufSBQbHVnaW5TdWJDbGFzc1xuICogICAgICAgICAgVGhlIGFkdmFuY2VkIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbnZhciBjcmVhdGVQbHVnaW5GYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlUGx1Z2luRmFjdG9yeShuYW1lLCBQbHVnaW5TdWJDbGFzcykge1xuXG4gIC8vIEFkZCBhIGBuYW1lYCBwcm9wZXJ0eSB0byB0aGUgcGx1Z2luIHByb3RvdHlwZSBzbyB0aGF0IGVhY2ggcGx1Z2luIGNhblxuICAvLyByZWZlciB0byBpdHNlbGYgYnkgbmFtZS5cbiAgUGx1Z2luU3ViQ2xhc3MucHJvdG90eXBlLm5hbWUgPSBuYW1lO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdHJpZ2dlclNldHVwRXZlbnQodGhpcywgeyBuYW1lOiBuYW1lLCBwbHVnaW46IFBsdWdpblN1YkNsYXNzLCBpbnN0YW5jZTogbnVsbCB9LCB0cnVlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoUGx1Z2luU3ViQ2xhc3MsIFtudWxsXS5jb25jYXQoW3RoaXNdLmNvbmNhdChhcmdzKSkpKSgpO1xuXG4gICAgLy8gVGhlIHBsdWdpbiBpcyByZXBsYWNlZCBieSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICB0aGlzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICB0cmlnZ2VyU2V0dXBFdmVudCh0aGlzLCBpbnN0YW5jZS5nZXRFdmVudEhhc2goKSk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59O1xuXG4vKipcbiAqIFBhcmVudCBjbGFzcyBmb3IgYWxsIGFkdmFuY2VkIHBsdWdpbnMuXG4gKlxuICogQG1peGVzICAgbW9kdWxlOmV2ZW50ZWR+RXZlbnRlZE1peGluXG4gKiBAbWl4ZXMgICBtb2R1bGU6c3RhdGVmdWx+U3RhdGVmdWxNaXhpblxuICogQGZpcmVzICAgUGxheWVyI2JlZm9yZXBsdWdpbnNldHVwXG4gKiBAZmlyZXMgICBQbGF5ZXIjYmVmb3JlcGx1Z2luc2V0dXA6JG5hbWVcbiAqIEBmaXJlcyAgIFBsYXllciNwbHVnaW5zZXR1cFxuICogQGZpcmVzICAgUGxheWVyI3BsdWdpbnNldHVwOiRuYW1lXG4gKiBAbGlzdGVucyBQbGF5ZXIjZGlzcG9zZVxuICogQHRocm93cyAge0Vycm9yfVxuICogICAgICAgICAgSWYgYXR0ZW1wdGluZyB0byBpbnN0YW50aWF0ZSB0aGUgYmFzZSB7QGxpbmsgUGx1Z2lufSBjbGFzc1xuICogICAgICAgICAgZGlyZWN0bHkgaW5zdGVhZCBvZiB2aWEgYSBzdWItY2xhc3MuXG4gKi9cblxudmFyIFBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBTdWItY2xhc3NlcyBzaG91bGQgY2FsbCBgc3VwZXJgIHRvIGVuc3VyZSBwbHVnaW5zIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgQSBWaWRlby5qcyBwbGF5ZXIgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBQbHVnaW4ocGxheWVyKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGx1Z2luKTtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBQbHVnaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGx1Z2luIG11c3QgYmUgc3ViLWNsYXNzZWQ7IG5vdCBkaXJlY3RseSBpbnN0YW50aWF0ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5wbGF5ZXIgPSBwbGF5ZXI7XG5cbiAgICAvLyBNYWtlIHRoaXMgb2JqZWN0IGV2ZW50ZWQsIGJ1dCByZW1vdmUgdGhlIGFkZGVkIGB0cmlnZ2VyYCBtZXRob2Qgc28gd2VcbiAgICAvLyB1c2UgdGhlIHByb3RvdHlwZSB2ZXJzaW9uIGluc3RlYWQuXG4gICAgZXZlbnRlZCh0aGlzKTtcbiAgICBkZWxldGUgdGhpcy50cmlnZ2VyO1xuXG4gICAgc3RhdGVmdWwodGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0U3RhdGUpO1xuICAgIG1hcmtQbHVnaW5Bc0FjdGl2ZShwbGF5ZXIsIHRoaXMubmFtZSk7XG5cbiAgICAvLyBBdXRvLWJpbmQgdGhlIGRpc3Bvc2UgbWV0aG9kIHNvIHdlIGNhbiB1c2UgaXQgYXMgYSBsaXN0ZW5lciBhbmQgdW5iaW5kXG4gICAgLy8gaXQgbGF0ZXIgZWFzaWx5LlxuICAgIHRoaXMuZGlzcG9zZSA9IGJpbmQodGhpcywgdGhpcy5kaXNwb3NlKTtcblxuICAgIC8vIElmIHRoZSBwbGF5ZXIgaXMgZGlzcG9zZWQsIGRpc3Bvc2UgdGhlIHBsdWdpbi5cbiAgICBwbGF5ZXIub24oJ2Rpc3Bvc2UnLCB0aGlzLmRpc3Bvc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVhY2ggZXZlbnQgdHJpZ2dlcmVkIGJ5IHBsdWdpbnMgaW5jbHVkZXMgYSBoYXNoIG9mIGFkZGl0aW9uYWwgZGF0YSB3aXRoXG4gICAqIGNvbnZlbnRpb25hbCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBUaGlzIHJldHVybnMgdGhhdCBvYmplY3Qgb3IgbXV0YXRlcyBhbiBleGlzdGluZyBoYXNoLlxuICAgKlxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSBbaGFzaD17fV1cbiAgICogICAgICAgICAgQW4gb2JqZWN0IHRvIGJlIHVzZWQgYXMgZXZlbnQgYW4gZXZlbnQgaGFzaC5cbiAgICpcbiAgICogQHJldHVybnMge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9XG4gICAqICAgICAgICAgIEFuIGV2ZW50IGhhc2ggb2JqZWN0IHdpdGggcHJvdmlkZWQgcHJvcGVydGllcyBtaXhlZC1pbi5cbiAgICovXG5cblxuICBQbHVnaW4ucHJvdG90eXBlLmdldEV2ZW50SGFzaCA9IGZ1bmN0aW9uIGdldEV2ZW50SGFzaCgpIHtcbiAgICB2YXIgaGFzaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBoYXNoLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgaGFzaC5wbHVnaW4gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIGhhc2guaW5zdGFuY2UgPSB0aGlzO1xuICAgIHJldHVybiBoYXNoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhbiBldmVudCBvbiB0aGUgcGx1Z2luIG9iamVjdCBhbmQgb3ZlcnJpZGVzXG4gICAqIHtAbGluayBtb2R1bGU6ZXZlbnRlZH5FdmVudGVkTWl4aW4udHJpZ2dlcnxFdmVudGVkTWl4aW4udHJpZ2dlcn0uXG4gICAqXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd8T2JqZWN0fSBldmVudFxuICAgKiAgICAgICAgICBBbiBldmVudCB0eXBlIG9yIGFuIG9iamVjdCB3aXRoIGEgdHlwZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtICAge09iamVjdH0gW2hhc2g9e31dXG4gICAqICAgICAgICAgIEFkZGl0aW9uYWwgZGF0YSBoYXNoIHRvIG1lcmdlIHdpdGggYVxuICAgKiAgICAgICAgICB7QGxpbmsgUGx1Z2luflBsdWdpbkV2ZW50SGFzaHxQbHVnaW5FdmVudEhhc2h9LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogICAgICAgICAgV2hldGhlciBvciBub3QgZGVmYXVsdCB3YXMgcHJldmVudGVkLlxuICAgKi9cblxuXG4gIFBsdWdpbi5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIkJDEoZXZlbnQpIHtcbiAgICB2YXIgaGFzaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICByZXR1cm4gdHJpZ2dlcih0aGlzLmV2ZW50QnVzRWxfLCBldmVudCwgdGhpcy5nZXRFdmVudEhhc2goaGFzaCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIFwic3RhdGVjaGFuZ2VkXCIgZXZlbnRzIG9uIHRoZSBwbHVnaW4uIE5vLW9wIGJ5IGRlZmF1bHQsIG92ZXJyaWRlIGJ5XG4gICAqIHN1YmNsYXNzaW5nLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtICAgIHtFdmVudH0gZVxuICAgKiAgICAgICAgICAgQW4gZXZlbnQgb2JqZWN0IHByb3ZpZGVkIGJ5IGEgXCJzdGF0ZWNoYW5nZWRcIiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICAgIHtPYmplY3R9IGUuY2hhbmdlc1xuICAgKiAgICAgICAgICAgQW4gb2JqZWN0IGRlc2NyaWJpbmcgY2hhbmdlcyB0aGF0IG9jY3VycmVkIHdpdGggdGhlIFwic3RhdGVjaGFuZ2VkXCJcbiAgICogICAgICAgICAgIGV2ZW50LlxuICAgKi9cblxuXG4gIFBsdWdpbi5wcm90b3R5cGUuaGFuZGxlU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24gaGFuZGxlU3RhdGVDaGFuZ2VkKGUpIHt9O1xuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyBhIHBsdWdpbi5cbiAgICpcbiAgICogU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyBpZiB0aGV5IHdhbnQsIGJ1dCBmb3IgdGhlIHNha2Ugb2Ygc2FmZXR5LFxuICAgKiBpdCdzIHByb2JhYmx5IGJlc3QgdG8gc3Vic2NyaWJlIHRoZSBcImRpc3Bvc2VcIiBldmVudC5cbiAgICpcbiAgICogQGZpcmVzIFBsdWdpbiNkaXNwb3NlXG4gICAqL1xuXG5cbiAgUGx1Z2luLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB2YXIgbmFtZSA9IHRoaXMubmFtZSxcbiAgICAgICAgcGxheWVyID0gdGhpcy5wbGF5ZXI7XG5cbiAgICAvKipcbiAgICAgKiBTaWduYWxzIHRoYXQgYSBhZHZhbmNlZCBwbHVnaW4gaXMgYWJvdXQgdG8gYmUgZGlzcG9zZWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGx1Z2luI2Rpc3Bvc2VcbiAgICAgKiBAdHlwZSAge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuXG4gICAgdGhpcy50cmlnZ2VyKCdkaXNwb3NlJyk7XG4gICAgdGhpcy5vZmYoKTtcbiAgICBwbGF5ZXIub2ZmKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlKTtcblxuICAgIC8vIEVsaW1pbmF0ZSBhbnkgcG9zc2libGUgc291cmNlcyBvZiBsZWFraW5nIG1lbW9yeSBieSBjbGVhcmluZyB1cFxuICAgIC8vIHJlZmVyZW5jZXMgYmV0d2VlbiB0aGUgcGxheWVyIGFuZCB0aGUgcGx1Z2luIGluc3RhbmNlIGFuZCBudWxsaW5nIG91dFxuICAgIC8vIHRoZSBwbHVnaW4ncyBzdGF0ZSBhbmQgcmVwbGFjaW5nIG1ldGhvZHMgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgdGhyb3dzLlxuICAgIHBsYXllcltQTFVHSU5fQ0FDSEVfS0VZXVtuYW1lXSA9IGZhbHNlO1xuICAgIHRoaXMucGxheWVyID0gdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAvLyBGaW5hbGx5LCByZXBsYWNlIHRoZSBwbHVnaW4gbmFtZSBvbiB0aGUgcGxheWVyIHdpdGggYSBuZXcgZmFjdG9yeVxuICAgIC8vIGZ1bmN0aW9uLCBzbyB0aGF0IHRoZSBwbHVnaW4gaXMgcmVhZHkgdG8gYmUgc2V0IHVwIGFnYWluLlxuICAgIHBsYXllcltuYW1lXSA9IGNyZWF0ZVBsdWdpbkZhY3RvcnkobmFtZSwgcGx1Z2luU3RvcmFnZVtuYW1lXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgYSBwbHVnaW4gaXMgYSBiYXNpYyBwbHVnaW4gKGkuZS4gbm90IGEgc3ViLWNsYXNzIG9mIGBQbHVnaW5gKS5cbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ3xGdW5jdGlvbn0gcGx1Z2luXG4gICAqICAgICAgICAgIElmIGEgc3RyaW5nLCBtYXRjaGVzIHRoZSBuYW1lIG9mIGEgcGx1Z2luLiBJZiBhIGZ1bmN0aW9uLCB3aWxsIGJlXG4gICAqICAgICAgICAgIHRlc3RlZCBkaXJlY3RseS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqICAgICAgICAgIFdoZXRoZXIgb3Igbm90IGEgcGx1Z2luIGlzIGEgYmFzaWMgcGx1Z2luLlxuICAgKi9cblxuXG4gIFBsdWdpbi5pc0Jhc2ljID0gZnVuY3Rpb24gaXNCYXNpYyhwbHVnaW4pIHtcbiAgICB2YXIgcCA9IHR5cGVvZiBwbHVnaW4gPT09ICdzdHJpbmcnID8gZ2V0UGx1Z2luKHBsdWdpbikgOiBwbHVnaW47XG5cbiAgICByZXR1cm4gdHlwZW9mIHAgPT09ICdmdW5jdGlvbicgJiYgIVBsdWdpbi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihwLnByb3RvdHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgVmlkZW8uanMgcGx1Z2luLlxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gYmUgcmVnaXN0ZXJlZC4gTXVzdCBiZSBhIHN0cmluZyBhbmRcbiAgICogICAgICAgICAgbXVzdCBub3QgbWF0Y2ggYW4gZXhpc3RpbmcgcGx1Z2luIG9yIGEgbWV0aG9kIG9uIHRoZSBgUGxheWVyYFxuICAgKiAgICAgICAgICBwcm90b3R5cGUuXG4gICAqXG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gcGx1Z2luXG4gICAqICAgICAgICAgIEEgc3ViLWNsYXNzIG9mIGBQbHVnaW5gIG9yIGEgZnVuY3Rpb24gZm9yIGJhc2ljIHBsdWdpbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICogICAgICAgICAgRm9yIGFkdmFuY2VkIHBsdWdpbnMsIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgdGhhdCBwbHVnaW4uIEZvclxuICAgKiAgICAgICAgICBiYXNpYyBwbHVnaW5zLCBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyB0aGUgcGx1Z2luLlxuICAgKi9cblxuXG4gIFBsdWdpbi5yZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKG5hbWUsIHBsdWdpbikge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBwbHVnaW4gbmFtZSwgXCInICsgbmFtZSArICdcIiwgbXVzdCBiZSBhIHN0cmluZywgd2FzICcgKyAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSArICcuJyk7XG4gICAgfVxuXG4gICAgaWYgKHBsdWdpbkV4aXN0cyhuYW1lKSkge1xuICAgICAgbG9nJDEud2FybignQSBwbHVnaW4gbmFtZWQgXCInICsgbmFtZSArICdcIiBhbHJlYWR5IGV4aXN0cy4gWW91IG1heSB3YW50IHRvIGF2b2lkIHJlLXJlZ2lzdGVyaW5nIHBsdWdpbnMhJyk7XG4gICAgfSBlbHNlIGlmIChQbGF5ZXIucHJvdG90eXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGx1Z2luIG5hbWUsIFwiJyArIG5hbWUgKyAnXCIsIGNhbm5vdCBzaGFyZSBhIG5hbWUgd2l0aCBhbiBleGlzdGluZyBwbGF5ZXIgbWV0aG9kIScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGx1Z2luICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGx1Z2luIGZvciBcIicgKyBuYW1lICsgJ1wiLCBtdXN0IGJlIGEgZnVuY3Rpb24sIHdhcyAnICsgKHR5cGVvZiBwbHVnaW4gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBsdWdpbikpICsgJy4nKTtcbiAgICB9XG5cbiAgICBwbHVnaW5TdG9yYWdlW25hbWVdID0gcGx1Z2luO1xuXG4gICAgLy8gQWRkIGEgcGxheWVyIHByb3RvdHlwZSBtZXRob2QgZm9yIGFsbCBzdWItY2xhc3NlZCBwbHVnaW5zIChidXQgbm90IGZvclxuICAgIC8vIHRoZSBiYXNlIFBsdWdpbiBjbGFzcykuXG4gICAgaWYgKG5hbWUgIT09IEJBU0VfUExVR0lOX05BTUUpIHtcbiAgICAgIGlmIChQbHVnaW4uaXNCYXNpYyhwbHVnaW4pKSB7XG4gICAgICAgIFBsYXllci5wcm90b3R5cGVbbmFtZV0gPSBjcmVhdGVCYXNpY1BsdWdpbihuYW1lLCBwbHVnaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUGxheWVyLnByb3RvdHlwZVtuYW1lXSA9IGNyZWF0ZVBsdWdpbkZhY3RvcnkobmFtZSwgcGx1Z2luKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGx1Z2luO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZS1yZWdpc3RlciBhIFZpZGVvLmpzIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gYmUgZGVyZWdpc3RlcmVkLlxuICAgKi9cblxuXG4gIFBsdWdpbi5kZXJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gZGVyZWdpc3RlclBsdWdpbihuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09IEJBU0VfUExVR0lOX05BTUUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlLXJlZ2lzdGVyIGJhc2UgcGx1Z2luLicpO1xuICAgIH1cbiAgICBpZiAocGx1Z2luRXhpc3RzKG5hbWUpKSB7XG4gICAgICBkZWxldGUgcGx1Z2luU3RvcmFnZVtuYW1lXTtcbiAgICAgIGRlbGV0ZSBQbGF5ZXIucHJvdG90eXBlW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3QgY29udGFpbmluZyBtdWx0aXBsZSBWaWRlby5qcyBwbHVnaW5zLlxuICAgKlxuICAgKiBAcGFyYW0gICB7QXJyYXl9IFtuYW1lc11cbiAgICogICAgICAgICAgSWYgcHJvdmlkZWQsIHNob3VsZCBiZSBhbiBhcnJheSBvZiBwbHVnaW4gbmFtZXMuIERlZmF1bHRzIHRvIF9hbGxfXG4gICAqICAgICAgICAgIHBsdWdpbiBuYW1lcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHBsdWdpbihzKSBhc3NvY2lhdGVkIHdpdGggdGhlaXIgbmFtZShzKSBvclxuICAgKiAgICAgICAgICBgdW5kZWZpbmVkYCBpZiBubyBtYXRjaGluZyBwbHVnaW5zIGV4aXN0KS5cbiAgICovXG5cblxuICBQbHVnaW4uZ2V0UGx1Z2lucyA9IGZ1bmN0aW9uIGdldFBsdWdpbnMoKSB7XG4gICAgdmFyIG5hbWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBPYmplY3Qua2V5cyhwbHVnaW5TdG9yYWdlKTtcblxuICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG5cbiAgICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcGx1Z2luID0gZ2V0UGx1Z2luKG5hbWUpO1xuXG4gICAgICBpZiAocGx1Z2luKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB7fTtcbiAgICAgICAgcmVzdWx0W25hbWVdID0gcGx1Z2luO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhIHBsdWdpbidzIHZlcnNpb24sIGlmIGF2YWlsYWJsZVxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiAgICAgICAgICBUaGUgcGx1Z2luJ3MgdmVyc2lvbiBvciBhbiBlbXB0eSBzdHJpbmcuXG4gICAqL1xuXG5cbiAgUGx1Z2luLmdldFBsdWdpblZlcnNpb24gPSBmdW5jdGlvbiBnZXRQbHVnaW5WZXJzaW9uKG5hbWUpIHtcbiAgICB2YXIgcGx1Z2luID0gZ2V0UGx1Z2luKG5hbWUpO1xuXG4gICAgcmV0dXJuIHBsdWdpbiAmJiBwbHVnaW4uVkVSU0lPTiB8fCAnJztcbiAgfTtcblxuICByZXR1cm4gUGx1Z2luO1xufSgpO1xuXG4vKipcbiAqIEdldHMgYSBwbHVnaW4gYnkgbmFtZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCAgIGdldFBsdWdpblxuICogQG1lbWJlck9mIFBsdWdpblxuICogQHBhcmFtICAgIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJucyAge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqICAgICAgICAgICBUaGUgcGx1Z2luIChvciBgdW5kZWZpbmVkYCkuXG4gKi9cblxuXG5QbHVnaW4uZ2V0UGx1Z2luID0gZ2V0UGx1Z2luO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBiYXNlIHBsdWdpbiBjbGFzcyBhcyBpdCBpcyByZWdpc3RlcmVkLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblBsdWdpbi5CQVNFX1BMVUdJTl9OQU1FID0gQkFTRV9QTFVHSU5fTkFNRTtcblxuUGx1Z2luLnJlZ2lzdGVyUGx1Z2luKEJBU0VfUExVR0lOX05BTUUsIFBsdWdpbik7XG5cbi8qKlxuICogRG9jdW1lbnRlZCBpbiBwbGF5ZXIuanNcbiAqXG4gKiBAaWdub3JlXG4gKi9cblBsYXllci5wcm90b3R5cGUudXNpbmdQbHVnaW4gPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gISF0aGlzW1BMVUdJTl9DQUNIRV9LRVldICYmIHRoaXNbUExVR0lOX0NBQ0hFX0tFWV1bbmFtZV0gPT09IHRydWU7XG59O1xuXG4vKipcbiAqIERvY3VtZW50ZWQgaW4gcGxheWVyLmpzXG4gKlxuICogQGlnbm9yZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhc1BsdWdpbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAhIXBsdWdpbkV4aXN0cyhuYW1lKTtcbn07XG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgcGx1Z2luIGlzIGFib3V0IHRvIGJlIHNldCB1cCBvbiBhIHBsYXllci5cbiAqXG4gKiBAZXZlbnQgICAgUGxheWVyI2JlZm9yZXBsdWdpbnNldHVwXG4gKiBAdHlwZSAgICAge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9XG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgYSBwbHVnaW4gaXMgYWJvdXQgdG8gYmUgc2V0IHVwIG9uIGEgcGxheWVyIC0gYnkgbmFtZS4gVGhlIG5hbWVcbiAqIGlzIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXG4gKlxuICogQGV2ZW50ICAgIFBsYXllciNiZWZvcmVwbHVnaW5zZXR1cDokbmFtZVxuICogQHR5cGUgICAgIHtQbHVnaW5+UGx1Z2luRXZlbnRIYXNofVxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgcGx1Z2luIGhhcyBqdXN0IGJlZW4gc2V0IHVwIG9uIGEgcGxheWVyLlxuICpcbiAqIEBldmVudCAgICBQbGF5ZXIjcGx1Z2luc2V0dXBcbiAqIEB0eXBlICAgICB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH1cbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHBsdWdpbiBoYXMganVzdCBiZWVuIHNldCB1cCBvbiBhIHBsYXllciAtIGJ5IG5hbWUuIFRoZSBuYW1lXG4gKiBpcyB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIEBldmVudCAgICBQbGF5ZXIjcGx1Z2luc2V0dXA6JG5hbWVcbiAqIEB0eXBlICAgICB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmICB7T2JqZWN0fSBQbHVnaW5+UGx1Z2luRXZlbnRIYXNoXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGluc3RhbmNlXG4gKiAgICAgICAgICAgRm9yIGJhc2ljIHBsdWdpbnMsIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHBsdWdpbiBmdW5jdGlvbi4gRm9yXG4gKiAgICAgICAgICAgYWR2YW5jZWQgcGx1Z2lucywgdGhlIHBsdWdpbiBpbnN0YW5jZSBvbiB3aGljaCB0aGUgZXZlbnQgaXMgZmlyZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwbHVnaW5cbiAqICAgICAgICAgICBGb3IgYmFzaWMgcGx1Z2lucywgdGhlIHBsdWdpbiBmdW5jdGlvbi4gRm9yIGFkdmFuY2VkIHBsdWdpbnMsIHRoZVxuICogICAgICAgICAgIHBsdWdpbiBjbGFzcy9jb25zdHJ1Y3Rvci5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIGV4dGVuZC5qc1xuICogQG1vZHVsZSBleHRlbmRcbiAqL1xuXG4vKipcbiAqIEEgY29tYmluYXRpb24gb2Ygbm9kZSBpbmhlcml0cyBhbmQgYmFiZWwncyBpbmhlcml0cyAoYWZ0ZXIgdHJhbnNwaWxlKS5cbiAqIEJvdGggd29yayB0aGUgc2FtZSBidXQgbm9kZSBhZGRzIGBzdXBlcl9gIHRvIHRoZSBzdWJDbGFzc1xuICogYW5kIEJhYmxlIGFkZHMgdGhlIHN1cGVyQ2xhc3MgYXMgX19wcm90b19fLiBCb3RoIHNlZW0gdXNlZnVsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJDbGFzc1xuICogICAgICAgIFRoZSBjbGFzcyB0byBpbmhlcml0IHRvXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN1cGVyQ2xhc3NcbiAqICAgICAgICBUaGUgY2xhc3MgdG8gaW5oZXJpdCBmcm9tXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIF9pbmhlcml0cyA9IGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3VwZXJDbGFzcykpKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBpZiAoc3VwZXJDbGFzcykge1xuICAgIC8vIG5vZGVcbiAgICBzdWJDbGFzcy5zdXBlcl8gPSBzdXBlckNsYXNzO1xuICB9XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIGZvciBzdWJjbGFzc2luZyB1c2luZyB0aGUgc2FtZSBpbmhlcml0YW5jZSB0aGF0XG4gKiB2aWRlb2pzIHVzZXMgaW50ZXJuYWxseVxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdXBlckNsYXNzXG4gKiAgICAgICAgVGhlIGNsYXNzIHRvIGluaGVyaXQgZnJvbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3ViQ2xhc3NNZXRob2RzPXt9XVxuICogICAgICAgIFRoZSBjbGFzcyB0byBpbmhlcml0IHRvXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBUaGUgbmV3IG9iamVjdCB3aXRoIHN1YkNsYXNzTWV0aG9kcyB0aGF0IGluaGVyaXRlZCBzdXBlckNsYXNzLlxuICovXG52YXIgZXh0ZW5kRm4gPSBmdW5jdGlvbiBleHRlbmRGbihzdXBlckNsYXNzKSB7XG4gIHZhciBzdWJDbGFzc01ldGhvZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIHZhciBzdWJDbGFzcyA9IGZ1bmN0aW9uIHN1YkNsYXNzKCkge1xuICAgIHN1cGVyQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgbWV0aG9kcyA9IHt9O1xuXG4gIGlmICgodHlwZW9mIHN1YkNsYXNzTWV0aG9kcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3ViQ2xhc3NNZXRob2RzKSkgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHN1YkNsYXNzTWV0aG9kcy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgc3ViQ2xhc3MgPSBzdWJDbGFzc01ldGhvZHMuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIG1ldGhvZHMgPSBzdWJDbGFzc01ldGhvZHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN1YkNsYXNzTWV0aG9kcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN1YkNsYXNzID0gc3ViQ2xhc3NNZXRob2RzO1xuICB9XG5cbiAgX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcblxuICAvLyBFeHRlbmQgc3ViT2JqJ3MgcHJvdG90eXBlIHdpdGggZnVuY3Rpb25zIGFuZCBvdGhlciBwcm9wZXJ0aWVzIGZyb20gcHJvcHNcbiAgZm9yICh2YXIgbmFtZSBpbiBtZXRob2RzKSB7XG4gICAgaWYgKG1ldGhvZHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHN1YkNsYXNzLnByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZHNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YkNsYXNzO1xufTtcblxuLyoqXG4gKiBAZmlsZSB2aWRlby5qc1xuICogQG1vZHVsZSB2aWRlb2pzXG4gKi9cbi8vIEluY2x1ZGUgdGhlIGJ1aWx0LWluIHRlY2hzXG4vLyBIVE1MNSBFbGVtZW50IFNoaW0gZm9yIElFOFxuaWYgKHR5cGVvZiBIVE1MVmlkZW9FbGVtZW50ID09PSAndW5kZWZpbmVkJyAmJiBpc1JlYWwoKSkge1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFjaycpO1xufVxuXG4vKipcbiAqIERvdWJsZXMgYXMgdGhlIG1haW4gZnVuY3Rpb24gZm9yIHVzZXJzIHRvIGNyZWF0ZSBhIHBsYXllciBpbnN0YW5jZSBhbmQgYWxzb1xuICogdGhlIG1haW4gbGlicmFyeSBvYmplY3QuXG4gKiBUaGUgYHZpZGVvanNgIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGluaXRpYWxpemUgb3IgcmV0cmlldmUgYSBwbGF5ZXIuXG4gICpcbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IGlkXG4gKiAgICAgICAgVmlkZW8gZWxlbWVudCBvciB2aWRlbyBlbGVtZW50IElEXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IGZvciBjb25maWcvc2V0dGluZ3NcbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gKiAgICAgICAgT3B0aW9uYWwgcmVhZHkgY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gKiAgICAgICAgIEEgcGxheWVyIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHZpZGVvanMoaWQsIG9wdGlvbnMsIHJlYWR5KSB7XG4gIHZhciB0YWcgPSB2b2lkIDA7XG5cbiAgLy8gQWxsb3cgZm9yIGVsZW1lbnQgb3IgSUQgdG8gYmUgcGFzc2VkIGluXG4gIC8vIFN0cmluZyBJRFxuICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgIHZhciBwbGF5ZXJzID0gdmlkZW9qcy5nZXRQbGF5ZXJzKCk7XG5cbiAgICAvLyBBZGp1c3QgZm9yIGpRdWVyeSBJRCBzeW50YXhcbiAgICBpZiAoaWQuaW5kZXhPZignIycpID09PSAwKSB7XG4gICAgICBpZCA9IGlkLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIC8vIElmIGEgcGxheWVyIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZCBmb3IgdGhpcyBJRCByZXR1cm4gaXQuXG4gICAgaWYgKHBsYXllcnNbaWRdKSB7XG5cbiAgICAgIC8vIElmIG9wdGlvbnMgb3IgcmVhZHkgZnVuY3Rpb24gYXJlIHBhc3NlZCwgd2FyblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgbG9nJDEud2FybignUGxheWVyIFwiJyArIGlkICsgJ1wiIGlzIGFscmVhZHkgaW5pdGlhbGlzZWQuIE9wdGlvbnMgd2lsbCBub3QgYmUgYXBwbGllZC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlYWR5KSB7XG4gICAgICAgIHBsYXllcnNbaWRdLnJlYWR5KHJlYWR5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBsYXllcnNbaWRdO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSBnZXQgZWxlbWVudCBmb3IgSURcbiAgICB0YWcgPSAkKCcjJyArIGlkKTtcblxuICAgIC8vIElEIGlzIGEgbWVkaWEgZWxlbWVudFxuICB9IGVsc2Uge1xuICAgIHRhZyA9IGlkO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGEgdXNlYWJsZSBlbGVtZW50XG4gIC8vIHJlOiBub2RlTmFtZSwgY291bGQgYmUgYSBib3ggZGl2IGFsc29cbiAgaWYgKCF0YWcgfHwgIXRhZy5ub2RlTmFtZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBlbGVtZW50IG9yIElEIHN1cHBsaWVkIGlzIG5vdCB2YWxpZC4gKHZpZGVvanMpJyk7XG4gIH1cblxuICAvLyBFbGVtZW50IG1heSBoYXZlIGEgcGxheWVyIGF0dHIgcmVmZXJyaW5nIHRvIGFuIGFscmVhZHkgY3JlYXRlZCBwbGF5ZXIgaW5zdGFuY2UuXG4gIC8vIElmIHNvIHJldHVybiB0aGF0IG90aGVyd2lzZSBzZXQgdXAgYSBuZXcgcGxheWVyIGJlbG93XG4gIGlmICh0YWcucGxheWVyIHx8IFBsYXllci5wbGF5ZXJzW3RhZy5wbGF5ZXJJZF0pIHtcbiAgICByZXR1cm4gdGFnLnBsYXllciB8fCBQbGF5ZXIucGxheWVyc1t0YWcucGxheWVySWRdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmlkZW9qcy5ob29rcygnYmVmb3Jlc2V0dXAnKS5mb3JFYWNoKGZ1bmN0aW9uIChob29rRnVuY3Rpb24pIHtcbiAgICB2YXIgb3B0cyA9IGhvb2tGdW5jdGlvbih0YWcsIG1lcmdlT3B0aW9ucyhvcHRpb25zKSk7XG5cbiAgICBpZiAoIWlzT2JqZWN0KG9wdHMpIHx8IEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgIGxvZyQxLmVycm9yKCdwbGVhc2UgcmV0dXJuIGFuIG9iamVjdCBpbiBiZWZvcmVzZXR1cCBob29rcycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywgb3B0cyk7XG4gIH0pO1xuXG4gIHZhciBQbGF5ZXJDb21wb25lbnQgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdQbGF5ZXInKTtcbiAgLy8gSWYgbm90LCBzZXQgdXAgYSBuZXcgcGxheWVyXG4gIHZhciBwbGF5ZXIgPSBuZXcgUGxheWVyQ29tcG9uZW50KHRhZywgb3B0aW9ucywgcmVhZHkpO1xuXG4gIHZpZGVvanMuaG9va3MoJ3NldHVwJykuZm9yRWFjaChmdW5jdGlvbiAoaG9va0Z1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGhvb2tGdW5jdGlvbihwbGF5ZXIpO1xuICB9KTtcblxuICByZXR1cm4gcGxheWVyO1xufVxuXG4vKipcbiAqIEFuIE9iamVjdCB0aGF0IGNvbnRhaW5zIGxpZmVjeWNsZSBob29rcyBhcyBrZXlzIHdoaWNoIHBvaW50IHRvIGFuIGFycmF5XG4gKiBvZiBmdW5jdGlvbnMgdGhhdCBhcmUgcnVuIHdoZW4gYSBsaWZlY3ljbGUgaXMgdHJpZ2dlcmVkXG4gKi9cbnZpZGVvanMuaG9va3NfID0ge307XG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiBob29rcyBmb3IgYSBzcGVjaWZpYyBsaWZlY3ljbGVcbiAqIEBmdW5jdGlvbiB2aWRlb2pzLmhvb2tzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICB0aGUgbGlmZWN5bGUgdG8gZ2V0IGhvb2tzIGZyb21cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiAgICAgICAgT3B0aW9uYWxseSBhZGQgYSBob29rIHRvIHRoZSBsaWZlY3ljbGUgdGhhdCB5b3VyIGFyZSBnZXR0aW5nLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBhbiBhcnJheSBvZiBob29rcywgb3IgYW4gZW1wdHkgYXJyYXkgaWYgdGhlcmUgYXJlIG5vbmUuXG4gKi9cbnZpZGVvanMuaG9va3MgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgdmlkZW9qcy5ob29rc19bdHlwZV0gPSB2aWRlb2pzLmhvb2tzX1t0eXBlXSB8fCBbXTtcbiAgaWYgKGZuKSB7XG4gICAgdmlkZW9qcy5ob29rc19bdHlwZV0gPSB2aWRlb2pzLmhvb2tzX1t0eXBlXS5jb25jYXQoZm4pO1xuICB9XG4gIHJldHVybiB2aWRlb2pzLmhvb2tzX1t0eXBlXTtcbn07XG5cbi8qKlxuICogQWRkIGEgZnVuY3Rpb24gaG9vayB0byBhIHNwZWNpZmljIHZpZGVvanMgbGlmZWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgdGhlIGxpZmVjeWNsZSB0byBob29rIHRoZSBmdW5jdGlvbiB0by5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEZ1bmN0aW9uW119XG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIG9yIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBhdHRhY2guXG4gKi9cbnZpZGVvanMuaG9vayA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICB2aWRlb2pzLmhvb2tzKHR5cGUsIGZuKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgaG9vayBmcm9tIGEgc3BlY2lmaWMgdmlkZW9qcyBsaWZlY3ljbGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICB0aGUgbGlmZWN5Y2xlIHRoYXQgdGhlIGZ1bmN0aW9uIGhvb2tlZCB0b1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiAgICAgICAgVGhlIGhvb2tlZCBmdW5jdGlvbiB0byByZW1vdmVcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3YXMgcmVtb3ZlZCBvciB1bmRlZlxuICovXG52aWRlb2pzLnJlbW92ZUhvb2sgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgdmFyIGluZGV4ID0gdmlkZW9qcy5ob29rcyh0eXBlKS5pbmRleE9mKGZuKTtcblxuICBpZiAoaW5kZXggPD0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2aWRlb2pzLmhvb2tzX1t0eXBlXSA9IHZpZGVvanMuaG9va3NfW3R5cGVdLnNsaWNlKCk7XG4gIHZpZGVvanMuaG9va3NfW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBBZGQgZGVmYXVsdCBzdHlsZXNcbmlmICh3aW5kb3cuVklERU9KU19OT19EWU5BTUlDX1NUWUxFICE9PSB0cnVlICYmIGlzUmVhbCgpKSB7XG4gIHZhciBzdHlsZSA9ICQoJy52anMtc3R5bGVzLWRlZmF1bHRzJyk7XG5cbiAgaWYgKCFzdHlsZSkge1xuICAgIHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KCd2anMtc3R5bGVzLWRlZmF1bHRzJyk7XG4gICAgdmFyIGhlYWQgPSAkKCdoZWFkJyk7XG5cbiAgICBpZiAoaGVhZCkge1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHNldFRleHRDb250ZW50KHN0eWxlLCAnXFxuICAgICAgLnZpZGVvLWpzIHtcXG4gICAgICAgIHdpZHRoOiAzMDBweDtcXG4gICAgICAgIGhlaWdodDogMTUwcHg7XFxuICAgICAgfVxcblxcbiAgICAgIC52anMtZmx1aWQge1xcbiAgICAgICAgcGFkZGluZy10b3A6IDU2LjI1JVxcbiAgICAgIH1cXG4gICAgJyk7XG4gIH1cbn1cblxuLy8gUnVuIEF1dG8tbG9hZCBwbGF5ZXJzXG4vLyBZb3UgaGF2ZSB0byB3YWl0IGF0IGxlYXN0IG9uY2UgaW4gY2FzZSB0aGlzIHNjcmlwdCBpcyBsb2FkZWQgYWZ0ZXIgeW91clxuLy8gdmlkZW8gaW4gdGhlIERPTSAod2VpcmQgYmVoYXZpb3Igb25seSB3aXRoIG1pbmlmaWVkIHZlcnNpb24pXG5hdXRvU2V0dXBUaW1lb3V0KDEsIHZpZGVvanMpO1xuXG4vKipcbiAqIEN1cnJlbnQgc29mdHdhcmUgdmVyc2lvbi4gRm9sbG93cyBzZW12ZXIuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmlkZW9qcy5WRVJTSU9OID0gdmVyc2lvbjtcblxuLyoqXG4gKiBUaGUgZ2xvYmFsIG9wdGlvbnMgb2JqZWN0LiBUaGVzZSBhcmUgdGhlIHNldHRpbmdzIHRoYXQgdGFrZSBlZmZlY3RcbiAqIGlmIG5vIG92ZXJyaWRlcyBhcmUgc3BlY2lmaWVkIHdoZW4gdGhlIHBsYXllciBpcyBjcmVhdGVkLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZpZGVvanMub3B0aW9ucyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc187XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50bHkgY3JlYXRlZCBwbGF5ZXJzLCBrZXllZCBieSBwbGF5ZXIgSURcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIFRoZSBjcmVhdGVkIHBsYXllcnNcbiAqL1xudmlkZW9qcy5nZXRQbGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gUGxheWVyLnBsYXllcnM7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBwbGF5ZXJzIG9iamVjdC5cbiAqXG4gKiBAbWVtYmVyT2YgdmlkZW9qc1xuICogQHByb3BlcnR5IHtPYmplY3R9IHBsYXllcnNcbiAqL1xudmlkZW9qcy5wbGF5ZXJzID0gUGxheWVyLnBsYXllcnM7XG5cbi8qKlxuICogR2V0IGEgY29tcG9uZW50IGNsYXNzIG9iamVjdCBieSBuYW1lXG4gKlxuICogQGJvcnJvd3MgQ29tcG9uZW50LmdldENvbXBvbmVudCBhcyB2aWRlb2pzLmdldENvbXBvbmVudFxuICovXG52aWRlb2pzLmdldENvbXBvbmVudCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQ7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBjb21wb25lbnQgc28gaXQgY2FuIHJlZmVycmVkIHRvIGJ5IG5hbWUuIFVzZWQgd2hlbiBhZGRpbmcgdG8gb3RoZXJcbiAqIGNvbXBvbmVudHMsIGVpdGhlciB0aHJvdWdoIGFkZENoaWxkIGBjb21wb25lbnQuYWRkQ2hpbGQoJ215Q29tcG9uZW50JylgIG9yIHRocm91Z2hcbiAqIGRlZmF1bHQgY2hpbGRyZW4gb3B0aW9ucyAgYHsgY2hpbGRyZW46IFsnbXlDb21wb25lbnQnXSB9YC5cbiAqXG4gKiA+IE5PVEU6IFlvdSBjb3VsZCBhbHNvIGp1c3QgaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50IGJlZm9yZSBhZGRpbmcuXG4gKiBgY29tcG9uZW50LmFkZENoaWxkKG5ldyBNeUNvbXBvbmVudCgpKTtgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICBUaGUgY2xhc3MgbmFtZSBvZiB0aGUgY29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtDb21wb25lbnR9IGNvbXBcbiAqICAgICAgICBUaGUgY29tcG9uZW50IGNsYXNzXG4gKlxuICogQHJldHVybiB7Q29tcG9uZW50fVxuICogICAgICAgICBUaGUgbmV3bHkgcmVnaXN0ZXJlZCBjb21wb25lbnRcbiAqL1xudmlkZW9qcy5yZWdpc3RlckNvbXBvbmVudCA9IGZ1bmN0aW9uIChuYW1lJCQxLCBjb21wKSB7XG4gIGlmIChUZWNoLmlzVGVjaChjb21wKSkge1xuICAgIGxvZyQxLndhcm4oJ1RoZSAnICsgbmFtZSQkMSArICcgdGVjaCB3YXMgcmVnaXN0ZXJlZCBhcyBhIGNvbXBvbmVudC4gSXQgc2hvdWxkIGluc3RlYWQgYmUgcmVnaXN0ZXJlZCB1c2luZyB2aWRlb2pzLnJlZ2lzdGVyVGVjaChuYW1lLCB0ZWNoKScpO1xuICB9XG5cbiAgQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50LmNhbGwoQ29tcG9uZW50LCBuYW1lJCQxLCBjb21wKTtcbn07XG5cbi8qKlxuICogR2V0IGEgVGVjaCBjbGFzcyBvYmplY3QgYnkgbmFtZVxuICpcbiAqIEBib3Jyb3dzIFRlY2guZ2V0VGVjaCBhcyB2aWRlb2pzLmdldFRlY2hcbiAqL1xudmlkZW9qcy5nZXRUZWNoID0gVGVjaC5nZXRUZWNoO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgVGVjaCBzbyBpdCBjYW4gcmVmZXJyZWQgdG8gYnkgbmFtZS5cbiAqIFRoaXMgaXMgdXNlZCBpbiB0aGUgdGVjaCBvcmRlciBmb3IgdGhlIHBsYXllci5cbiAqXG4gKiBAYm9ycm93cyBUZWNoLnJlZ2lzdGVyVGVjaCBhcyB2aWRlb2pzLnJlZ2lzdGVyVGVjaFxuICovXG52aWRlb2pzLnJlZ2lzdGVyVGVjaCA9IFRlY2gucmVnaXN0ZXJUZWNoO1xuXG52aWRlb2pzLnVzZSA9IHVzZTtcblxuLyoqXG4gKiBBIHN1aXRlIG9mIGJyb3dzZXIgYW5kIGRldmljZSB0ZXN0cyBmcm9tIHtAbGluayBicm93c2VyfS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmlkZW9qcy5icm93c2VyID0gYnJvd3NlcjtcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0b3VjaCBldmVudHMuIEluY2x1ZGVkIGZvciBiYWNrd2FyZFxuICogY29tcGF0aWJpbGl0eSB3aXRoIDQueCwgYnV0IGRlcHJlY2F0ZWQuIFVzZSBgdmlkZW9qcy5icm93c2VyLlRPVUNIX0VOQUJMRURgXG4gKiBpbnN0ZWFkIGdvaW5nIGZvcndhcmQuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1LjBcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG52aWRlb2pzLlRPVUNIX0VOQUJMRUQgPSBUT1VDSF9FTkFCTEVEO1xuXG4vKipcbiAqIFN1YmNsYXNzIGFuIGV4aXN0aW5nIGNsYXNzXG4gKiBNaW1pY3MgRVM2IHN1YmNsYXNzaW5nIHdpdGggdGhlIGBleHRlbmRgIGtleXdvcmRcbiAqXG4gKiBAYm9ycm93cyBleHRlbmQ6ZXh0ZW5kRm4gYXMgdmlkZW9qcy5leHRlbmRcbiAqL1xudmlkZW9qcy5leHRlbmQgPSBleHRlbmRGbjtcblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9ucyBvYmplY3RzIHJlY3Vyc2l2ZWx5XG4gKiBQZXJmb3JtcyBhIGRlZXAgbWVyZ2UgbGlrZSBsb2Rhc2gubWVyZ2UgYnV0ICoqb25seSBtZXJnZXMgcGxhaW4gb2JqZWN0cyoqXG4gKiAobm90IGFycmF5cywgZWxlbWVudHMsIGFueXRoaW5nIGVsc2UpXG4gKiBPdGhlciB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQgZGlyZWN0bHkgZnJvbSB0aGUgc2Vjb25kIG9iamVjdC5cbiAqXG4gKiBAYm9ycm93cyBtZXJnZS1vcHRpb25zOm1lcmdlT3B0aW9ucyBhcyB2aWRlb2pzLm1lcmdlT3B0aW9uc1xuICovXG52aWRlb2pzLm1lcmdlT3B0aW9ucyA9IG1lcmdlT3B0aW9ucztcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIGNvbnRleHQgKHRoaXMpIG9mIGEgZnVuY3Rpb25cbiAqXG4gKiA+IE5PVEU6IGFzIG9mIHY1LjAgd2UgcmVxdWlyZSBhbiBFUzUgc2hpbSwgc28geW91IHNob3VsZCB1c2UgdGhlIG5hdGl2ZVxuICogYGZ1bmN0aW9uKCkge30uYmluZChuZXdDb250ZXh0KTtgIGluc3RlYWQgb2YgdGhpcy5cbiAqXG4gKiBAYm9ycm93cyBmbjpiaW5kIGFzIHZpZGVvanMuYmluZFxuICovXG52aWRlb2pzLmJpbmQgPSBiaW5kO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgVmlkZW8uanMgcGx1Z2luLlxuICpcbiAqIEBib3Jyb3dzIHBsdWdpbjpyZWdpc3RlclBsdWdpbiBhcyB2aWRlb2pzLnJlZ2lzdGVyUGx1Z2luXG4gKiBAbWV0aG9kIHJlZ2lzdGVyUGx1Z2luXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gYmUgcmVnaXN0ZXJlZC4gTXVzdCBiZSBhIHN0cmluZyBhbmRcbiAqICAgICAgICAgbXVzdCBub3QgbWF0Y2ggYW4gZXhpc3RpbmcgcGx1Z2luIG9yIGEgbWV0aG9kIG9uIHRoZSBgUGxheWVyYFxuICogICAgICAgICBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IHBsdWdpblxuICogICAgICAgICBBIHN1Yi1jbGFzcyBvZiBgUGx1Z2luYCBvciBhIGZ1bmN0aW9uIGZvciBiYXNpYyBwbHVnaW5zLlxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogICAgICAgICBGb3IgYWR2YW5jZWQgcGx1Z2lucywgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciB0aGF0IHBsdWdpbi4gRm9yXG4gKiAgICAgICAgIGJhc2ljIHBsdWdpbnMsIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IGluaXRpYWxpemVzIHRoZSBwbHVnaW4uXG4gKi9cbnZpZGVvanMucmVnaXN0ZXJQbHVnaW4gPSBQbHVnaW4ucmVnaXN0ZXJQbHVnaW47XG5cbi8qKlxuICogRGVwcmVjYXRlZCBtZXRob2QgdG8gcmVnaXN0ZXIgYSBwbHVnaW4gd2l0aCBWaWRlby5qc1xuICpcbiAqIEBkZXByZWNhdGVkXG4gKiAgICAgICAgdmlkZW9qcy5wbHVnaW4oKSBpcyBkZXByZWNhdGVkOyB1c2UgdmlkZW9qcy5yZWdpc3RlclBsdWdpbigpIGluc3RlYWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogICAgICAgIFRoZSBwbHVnaW4gbmFtZVxuICpcbiAqIEBwYXJhbSB7UGx1Z2lufEZ1bmN0aW9ufSBwbHVnaW5cbiAqICAgICAgICAgVGhlIHBsdWdpbiBzdWItY2xhc3Mgb3IgZnVuY3Rpb25cbiAqL1xudmlkZW9qcy5wbHVnaW4gPSBmdW5jdGlvbiAobmFtZSQkMSwgcGx1Z2luKSB7XG4gIGxvZyQxLndhcm4oJ3ZpZGVvanMucGx1Z2luKCkgaXMgZGVwcmVjYXRlZDsgdXNlIHZpZGVvanMucmVnaXN0ZXJQbHVnaW4oKSBpbnN0ZWFkJyk7XG4gIHJldHVybiBQbHVnaW4ucmVnaXN0ZXJQbHVnaW4obmFtZSQkMSwgcGx1Z2luKTtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBvYmplY3QgY29udGFpbmluZyBtdWx0aXBsZSBWaWRlby5qcyBwbHVnaW5zLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBbbmFtZXNdXG4gKiAgICAgICAgIElmIHByb3ZpZGVkLCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgcGx1Z2luIG5hbWVzLiBEZWZhdWx0cyB0byBfYWxsX1xuICogICAgICAgICBwbHVnaW4gbmFtZXMuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAqICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgcGx1Z2luKHMpIGFzc29jaWF0ZWQgd2l0aCB0aGVpciBuYW1lKHMpIG9yXG4gKiAgICAgICAgIGB1bmRlZmluZWRgIGlmIG5vIG1hdGNoaW5nIHBsdWdpbnMgZXhpc3QpLlxuICovXG52aWRlb2pzLmdldFBsdWdpbnMgPSBQbHVnaW4uZ2V0UGx1Z2lucztcblxuLyoqXG4gKiBHZXRzIGEgcGx1Z2luIGJ5IG5hbWUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICogICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKiAgICAgICAgIFRoZSBwbHVnaW4gKG9yIGB1bmRlZmluZWRgKS5cbiAqL1xudmlkZW9qcy5nZXRQbHVnaW4gPSBQbHVnaW4uZ2V0UGx1Z2luO1xuXG4vKipcbiAqIEdldHMgYSBwbHVnaW4ncyB2ZXJzaW9uLCBpZiBhdmFpbGFibGVcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgcGx1Z2luJ3MgdmVyc2lvbiBvciBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbnZpZGVvanMuZ2V0UGx1Z2luVmVyc2lvbiA9IFBsdWdpbi5nZXRQbHVnaW5WZXJzaW9uO1xuXG4vKipcbiAqIEFkZGluZyBsYW5ndWFnZXMgc28gdGhhdCB0aGV5J3JlIGF2YWlsYWJsZSB0byBhbGwgcGxheWVycy5cbiAqIEV4YW1wbGU6IGB2aWRlb2pzLmFkZExhbmd1YWdlKCdlcycsIHsgJ0hlbGxvJzogJ0hvbGEnIH0pO2BcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICogICAgICAgIFRoZSBsYW5ndWFnZSBjb2RlIG9yIGRpY3Rpb25hcnkgcHJvcGVydHlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogICAgICAgIFRoZSBkYXRhIHZhbHVlcyB0byBiZSB0cmFuc2xhdGVkXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBUaGUgcmVzdWx0aW5nIGxhbmd1YWdlIGRpY3Rpb25hcnkgb2JqZWN0XG4gKi9cbnZpZGVvanMuYWRkTGFuZ3VhZ2UgPSBmdW5jdGlvbiAoY29kZSwgZGF0YSkge1xuICB2YXIgX21lcmdlT3B0aW9ucztcblxuICBjb2RlID0gKCcnICsgY29kZSkudG9Mb3dlckNhc2UoKTtcblxuICB2aWRlb2pzLm9wdGlvbnMubGFuZ3VhZ2VzID0gbWVyZ2VPcHRpb25zKHZpZGVvanMub3B0aW9ucy5sYW5ndWFnZXMsIChfbWVyZ2VPcHRpb25zID0ge30sIF9tZXJnZU9wdGlvbnNbY29kZV0gPSBkYXRhLCBfbWVyZ2VPcHRpb25zKSk7XG5cbiAgcmV0dXJuIHZpZGVvanMub3B0aW9ucy5sYW5ndWFnZXNbY29kZV07XG59O1xuXG4vKipcbiAqIExvZyBtZXNzYWdlc1xuICpcbiAqIEBib3Jyb3dzIGxvZzpsb2cgYXMgdmlkZW9qcy5sb2dcbiAqL1xudmlkZW9qcy5sb2cgPSBsb2ckMTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtdWxhdGVkIFRpbWVSYW5nZSBvYmplY3QuXG4gKlxuICogQGJvcnJvd3MgdGltZS1yYW5nZXM6Y3JlYXRlVGltZVJhbmdlcyBhcyB2aWRlb2pzLmNyZWF0ZVRpbWVSYW5nZVxuICovXG4vKipcbiAqIEBib3Jyb3dzIHRpbWUtcmFuZ2VzOmNyZWF0ZVRpbWVSYW5nZXMgYXMgdmlkZW9qcy5jcmVhdGVUaW1lUmFuZ2VzXG4gKi9cbnZpZGVvanMuY3JlYXRlVGltZVJhbmdlID0gdmlkZW9qcy5jcmVhdGVUaW1lUmFuZ2VzID0gY3JlYXRlVGltZVJhbmdlcztcblxuLyoqXG4gKiBGb3JtYXQgc2Vjb25kcyBhcyBhIHRpbWUgc3RyaW5nLCBIOk1NOlNTIG9yIE06U1NcbiAqIFN1cHBseWluZyBhIGd1aWRlIChpbiBzZWNvbmRzKSB3aWxsIGZvcmNlIGEgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3NcbiAqIHRvIGNvdmVyIHRoZSBsZW5ndGggb2YgdGhlIGd1aWRlXG4gKlxuICogQGJvcnJvd3MgZm9ybWF0LXRpbWU6Zm9ybWF0VGltZSBhcyB2aWRlb2pzLmZvcm1hdFRpbWVcbiAqL1xudmlkZW9qcy5mb3JtYXRUaW1lID0gZm9ybWF0VGltZTtcblxuLyoqXG4gKiBSZXNvbHZlIGFuZCBwYXJzZSB0aGUgZWxlbWVudHMgb2YgYSBVUkxcbiAqXG4gKiBAYm9ycm93cyB1cmw6cGFyc2VVcmwgYXMgdmlkZW9qcy5wYXJzZVVybFxuICovXG52aWRlb2pzLnBhcnNlVXJsID0gcGFyc2VVcmw7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSB1cmwgcGFzc2VkIGlzIGEgY3Jvc3MgZG9tYWluIHJlcXVlc3Qgb3Igbm90LlxuICpcbiAqIEBib3Jyb3dzIHVybDppc0Nyb3NzT3JpZ2luIGFzIHZpZGVvanMuaXNDcm9zc09yaWdpblxuICovXG52aWRlb2pzLmlzQ3Jvc3NPcmlnaW4gPSBpc0Nyb3NzT3JpZ2luO1xuXG4vKipcbiAqIEV2ZW50IHRhcmdldCBjbGFzcy5cbiAqXG4gKiBAYm9ycm93cyBFdmVudFRhcmdldCBhcyB2aWRlb2pzLkV2ZW50VGFyZ2V0XG4gKi9cbnZpZGVvanMuRXZlbnRUYXJnZXQgPSBFdmVudFRhcmdldDtcblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gZWxlbWVudFxuICogSXQgc3RvcmVzIHRoZSBoYW5kbGVyIGZ1bmN0aW9uIGluIGEgc2VwYXJhdGUgY2FjaGUgb2JqZWN0XG4gKiBhbmQgYWRkcyBhIGdlbmVyaWMgaGFuZGxlciB0byB0aGUgZWxlbWVudCdzIGV2ZW50LFxuICogYWxvbmcgd2l0aCBhIHVuaXF1ZSBpZCAoZ3VpZCkgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogQGJvcnJvd3MgZXZlbnRzOm9uIGFzIHZpZGVvanMub25cbiAqL1xudmlkZW9qcy5vbiA9IG9uO1xuXG4vKipcbiAqIFRyaWdnZXIgYSBsaXN0ZW5lciBvbmx5IG9uY2UgZm9yIGFuIGV2ZW50XG4gKlxuICogQGJvcnJvd3MgZXZlbnRzOm9uZSBhcyB2aWRlb2pzLm9uZVxuICovXG52aWRlb2pzLm9uZSA9IG9uZTtcblxuLyoqXG4gKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBmcm9tIGFuIGVsZW1lbnRcbiAqXG4gKiBAYm9ycm93cyBldmVudHM6b2ZmIGFzIHZpZGVvanMub2ZmXG4gKi9cbnZpZGVvanMub2ZmID0gb2ZmO1xuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnQgZm9yIGFuIGVsZW1lbnRcbiAqXG4gKiBAYm9ycm93cyBldmVudHM6dHJpZ2dlciBhcyB2aWRlb2pzLnRyaWdnZXJcbiAqL1xudmlkZW9qcy50cmlnZ2VyID0gdHJpZ2dlcjtcblxuLyoqXG4gKiBBIGNyb3NzLWJyb3dzZXIgWE1MSHR0cFJlcXVlc3Qgd3JhcHBlci4gSGVyZSdzIGEgc2ltcGxlIGV4YW1wbGU6XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICBzZXR0aW5ncyBmb3IgdGhlIHJlcXVlc3QuXG4gKlxuICogQHJldHVybiB7WE1MSHR0cFJlcXVlc3R8WERvbWFpblJlcXVlc3R9XG4gKiAgICAgICAgIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SYXlub3MveGhyXG4gKi9cbnZpZGVvanMueGhyID0geGhyO1xuXG4vKipcbiAqIFRleHRUcmFjayBjbGFzc1xuICpcbiAqIEBib3Jyb3dzIFRleHRUcmFjayBhcyB2aWRlb2pzLlRleHRUcmFja1xuICovXG52aWRlb2pzLlRleHRUcmFjayA9IFRleHRUcmFjaztcblxuLyoqXG4gKiBleHBvcnQgdGhlIEF1ZGlvVHJhY2sgY2xhc3Mgc28gdGhhdCBzb3VyY2UgaGFuZGxlcnMgY2FuIGNyZWF0ZVxuICogQXVkaW9UcmFja3MgYW5kIHRoZW4gYWRkIHRoZW0gdG8gdGhlIHBsYXllcnMgQXVkaW9UcmFja0xpc3RcbiAqXG4gKiBAYm9ycm93cyBBdWRpb1RyYWNrIGFzIHZpZGVvanMuQXVkaW9UcmFja1xuICovXG52aWRlb2pzLkF1ZGlvVHJhY2sgPSBBdWRpb1RyYWNrO1xuXG4vKipcbiAqIGV4cG9ydCB0aGUgVmlkZW9UcmFjayBjbGFzcyBzbyB0aGF0IHNvdXJjZSBoYW5kbGVycyBjYW4gY3JlYXRlXG4gKiBWaWRlb1RyYWNrcyBhbmQgdGhlbiBhZGQgdGhlbSB0byB0aGUgcGxheWVycyBWaWRlb1RyYWNrTGlzdFxuICpcbiAqIEBib3Jyb3dzIFZpZGVvVHJhY2sgYXMgdmlkZW9qcy5WaWRlb1RyYWNrXG4gKi9cbnZpZGVvanMuVmlkZW9UcmFjayA9IFZpZGVvVHJhY2s7XG5cbi8qKlxuICogRGV0ZXJtaW5lcywgdmlhIGR1Y2sgdHlwaW5nLCB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogQGJvcnJvd3MgZG9tOmlzRWwgYXMgdmlkZW9qcy5pc0VsXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uaXNFbCgpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIHRleHQgbm9kZS5cbiAqXG4gKiBAYm9ycm93cyBkb206aXNUZXh0Tm9kZSBhcyB2aWRlb2pzLmlzVGV4dE5vZGVcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5pc1RleHROb2RlKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbGVtZW50IGFuZCBhcHBsaWVzIHByb3BlcnRpZXMuXG4gKlxuICogQGJvcnJvd3MgZG9tOmNyZWF0ZUVsIGFzIHZpZGVvanMuY3JlYXRlRWxcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5jcmVhdGVFbCgpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaGFzIGEgQ1NTIGNsYXNzXG4gKlxuICogQGJvcnJvd3MgZG9tOmhhc0VsQ2xhc3MgYXMgdmlkZW9qcy5oYXNDbGFzc1xuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmhhc0NsYXNzKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogQWRkIGEgQ1NTIGNsYXNzIG5hbWUgdG8gYW4gZWxlbWVudFxuICpcbiAqIEBib3Jyb3dzIGRvbTphZGRFbENsYXNzIGFzIHZpZGVvanMuYWRkQ2xhc3NcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5hZGRDbGFzcygpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIFJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gYW4gZWxlbWVudFxuICpcbiAqIEBib3Jyb3dzIGRvbTpyZW1vdmVFbENsYXNzIGFzIHZpZGVvanMucmVtb3ZlQ2xhc3NcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5yZW1vdmVDbGFzcygpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIEFkZHMgb3IgcmVtb3ZlcyBhIENTUyBjbGFzcyBuYW1lIG9uIGFuIGVsZW1lbnQgZGVwZW5kaW5nIG9uIGFuIG9wdGlvbmFsXG4gKiBjb25kaXRpb24gb3IgdGhlIHByZXNlbmNlL2Fic2VuY2Ugb2YgdGhlIGNsYXNzIG5hbWUuXG4gKlxuICogQGJvcnJvd3MgZG9tOnRvZ2dsZUVsQ2xhc3MgYXMgdmlkZW9qcy50b2dnbGVDbGFzc1xuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLnRvZ2dsZUNsYXNzKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogQXBwbHkgYXR0cmlidXRlcyB0byBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQGJvcnJvd3MgZG9tOnNldEVsQXR0cmlidXRlcyBhcyB2aWRlb2pzLnNldEF0dHJpYnV0ZVxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLnNldEF0dHJpYnV0ZXMoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZSB2YWx1ZXMsIGFzIGRlZmluZWQgb24gdGhlIEhUTUwgdGFnXG4gKiBBdHRyaWJ1dGVzIGFyZSBub3QgdGhlIHNhbWUgYXMgcHJvcGVydGllcy4gVGhleSdyZSBkZWZpbmVkIG9uIHRoZSB0YWdcbiAqIG9yIHdpdGggc2V0QXR0cmlidXRlICh3aGljaCBzaG91bGRuJ3QgYmUgdXNlZCB3aXRoIEhUTUwpXG4gKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgb3IgZmFsc2UgZm9yIGJvb2xlYW4gYXR0cmlidXRlcy5cbiAqXG4gKiBAYm9ycm93cyBkb206Z2V0RWxBdHRyaWJ1dGVzIGFzIHZpZGVvanMuZ2V0QXR0cmlidXRlc1xuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmdldEF0dHJpYnV0ZXMoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBFbXB0aWVzIHRoZSBjb250ZW50cyBvZiBhbiBlbGVtZW50LlxuICpcbiAqIEBib3Jyb3dzIGRvbTplbXB0eUVsIGFzIHZpZGVvanMuZW1wdHlFbFxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmVtcHR5RWwoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBOb3JtYWxpemVzIGFuZCBhcHBlbmRzIGNvbnRlbnQgdG8gYW4gZWxlbWVudC5cbiAqXG4gKiBUaGUgY29udGVudCBmb3IgYW4gZWxlbWVudCBjYW4gYmUgcGFzc2VkIGluIG11bHRpcGxlIHR5cGVzIGFuZFxuICogY29tYmluYXRpb25zLCB3aG9zZSBiZWhhdmlvciBpcyBhcyBmb2xsb3dzOlxuICpcbiAqIC0gU3RyaW5nXG4gKiAgIE5vcm1hbGl6ZWQgaW50byBhIHRleHQgbm9kZS5cbiAqXG4gKiAtIEVsZW1lbnQsIFRleHROb2RlXG4gKiAgIFBhc3NlZCB0aHJvdWdoLlxuICpcbiAqIC0gQXJyYXlcbiAqICAgQSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2Ygc3RyaW5ncywgZWxlbWVudHMsIG5vZGVzLCBvciBmdW5jdGlvbnMgKHdoaWNoXG4gKiAgIHJldHVybiBzaW5nbGUgc3RyaW5ncywgZWxlbWVudHMsIG9yIG5vZGVzKS5cbiAqXG4gKiAtIEZ1bmN0aW9uXG4gKiAgIElmIHRoZSBzb2xlIGFyZ3VtZW50LCBpcyBleHBlY3RlZCB0byBwcm9kdWNlIGEgc3RyaW5nLCBlbGVtZW50LFxuICogICBub2RlLCBvciBhcnJheS5cbiAqXG4gKiBAYm9ycm93cyBkb206YXBwZW5kQ29udGVudHMgYXMgdmlkZW9qcy5hcHBlbmRDb250ZXRcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5hcHBlbmRDb250ZW50KCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogTm9ybWFsaXplcyBhbmQgaW5zZXJ0cyBjb250ZW50IGludG8gYW4gZWxlbWVudDsgdGhpcyBpcyBpZGVudGljYWwgdG9cbiAqIGBhcHBlbmRDb250ZW50KClgLCBleGNlcHQgaXQgZW1wdGllcyB0aGUgZWxlbWVudCBmaXJzdC5cbiAqXG4gKiBUaGUgY29udGVudCBmb3IgYW4gZWxlbWVudCBjYW4gYmUgcGFzc2VkIGluIG11bHRpcGxlIHR5cGVzIGFuZFxuICogY29tYmluYXRpb25zLCB3aG9zZSBiZWhhdmlvciBpcyBhcyBmb2xsb3dzOlxuICpcbiAqIC0gU3RyaW5nXG4gKiAgIE5vcm1hbGl6ZWQgaW50byBhIHRleHQgbm9kZS5cbiAqXG4gKiAtIEVsZW1lbnQsIFRleHROb2RlXG4gKiAgIFBhc3NlZCB0aHJvdWdoLlxuICpcbiAqIC0gQXJyYXlcbiAqICAgQSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2Ygc3RyaW5ncywgZWxlbWVudHMsIG5vZGVzLCBvciBmdW5jdGlvbnMgKHdoaWNoXG4gKiAgIHJldHVybiBzaW5nbGUgc3RyaW5ncywgZWxlbWVudHMsIG9yIG5vZGVzKS5cbiAqXG4gKiAtIEZ1bmN0aW9uXG4gKiAgIElmIHRoZSBzb2xlIGFyZ3VtZW50LCBpcyBleHBlY3RlZCB0byBwcm9kdWNlIGEgc3RyaW5nLCBlbGVtZW50LFxuICogICBub2RlLCBvciBhcnJheS5cbiAqXG4gKiBAYm9ycm93cyBkb206aW5zZXJ0Q29udGVudCBhcyB2aWRlb2pzLmluc2VydENvbnRlbnRcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5pbnNlcnRDb250ZW50KCkgaW5zdGVhZFxuICovXG5bJ2lzRWwnLCAnaXNUZXh0Tm9kZScsICdjcmVhdGVFbCcsICdoYXNDbGFzcycsICdhZGRDbGFzcycsICdyZW1vdmVDbGFzcycsICd0b2dnbGVDbGFzcycsICdzZXRBdHRyaWJ1dGVzJywgJ2dldEF0dHJpYnV0ZXMnLCAnZW1wdHlFbCcsICdhcHBlbmRDb250ZW50JywgJ2luc2VydENvbnRlbnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gIHZpZGVvanNba10gPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9nJDEud2FybigndmlkZW9qcy4nICsgayArICcoKSBpcyBkZXByZWNhdGVkOyB1c2UgdmlkZW9qcy5kb20uJyArIGsgKyAnKCkgaW5zdGVhZCcpO1xuICAgIHJldHVybiBEb21ba10uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEEgc2FmZSBnZXRDb21wdXRlZFN0eWxlIHdpdGggYW4gSUU4IGZhbGxiYWNrLlxuICpcbiAqIFRoaXMgaXMgYmVjYXVzZSBpbiBGaXJlZm94LCBpZiB0aGUgcGxheWVyIGlzIGxvYWRlZCBpbiBhbiBpZnJhbWUgd2l0aCBgZGlzcGxheTpub25lYCxcbiAqIHRoZW4gYGdldENvbXB1dGVkU3R5bGVgIHJldHVybnMgYG51bGxgLCBzbywgd2UgZG8gYSBudWxsLWNoZWNrIHRvIG1ha2Ugc3VyZVxuICogdGhhdCB0aGUgcGxheWVyIGRvZXNuJ3QgYnJlYWsgaW4gdGhlc2UgY2FzZXMuXG4gKiBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQGJvcnJvd3MgY29tcHV0ZWQtc3R5bGU6Y29tcHV0ZWRTdHlsZSBhcyB2aWRlb2pzLmNvbXB1dGVkU3R5bGVcbiAqL1xudmlkZW9qcy5jb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIERvbSB1dGlsaXRpZXMgZm9yIHVzZSBpbiBleHRlcm5hbCBwbHVnaW5zXG4gKiBhbmQgVGVjaCdzXG4gKi9cbnZpZGVvanMuZG9tID0gRG9tO1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgVXJsIHV0aWxpdGllcyBmb3IgdXNlIGluIGV4dGVybmFsIHBsdWdpbnNcbiAqIGFuZCBUZWNoJ3NcbiAqL1xudmlkZW9qcy51cmwgPSBVcmw7XG5cbm1vZHVsZS5leHBvcnRzID0gdmlkZW9qcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gRGVmYXVsdCBleHBvcnRzIGZvciBOb2RlLiBFeHBvcnQgdGhlIGV4dGVuZGVkIHZlcnNpb25zIG9mIFZUVEN1ZSBhbmRcbi8vIFZUVFJlZ2lvbiBpbiBOb2RlIHNpbmNlIHdlIGxpa2VseSB3YW50IHRoZSBjYXBhYmlsaXR5IHRvIGNvbnZlcnQgYmFjayBhbmRcbi8vIGZvcnRoIGJldHdlZW4gSlNPTi4gSWYgd2UgZG9uJ3QgdGhlbiBpdCdzIG5vdCB0aGF0IGJpZyBvZiBhIGRlYWwgc2luY2Ugd2UncmVcbi8vIG9mZiBicm93c2VyLlxuXG52YXIgd2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgdnR0anMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViVlRUOiByZXF1aXJlKFwiLi92dHQuanNcIiksXG4gIFZUVEN1ZTogcmVxdWlyZShcIi4vdnR0Y3VlLmpzXCIpLFxuICBWVFRSZWdpb246IHJlcXVpcmUoXCIuL3Z0dHJlZ2lvbi5qc1wiKVxufTtcblxud2luZG93LnZ0dGpzID0gdnR0anM7XG53aW5kb3cuV2ViVlRUID0gdnR0anMuV2ViVlRUO1xuXG52YXIgY3VlU2hpbSA9IHZ0dGpzLlZUVEN1ZTtcbnZhciByZWdpb25TaGltID0gdnR0anMuVlRUUmVnaW9uO1xudmFyIG5hdGl2ZVZUVEN1ZSA9IHdpbmRvdy5WVFRDdWU7XG52YXIgbmF0aXZlVlRUUmVnaW9uID0gd2luZG93LlZUVFJlZ2lvbjtcblxudnR0anMuc2hpbSA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cuVlRUQ3VlID0gY3VlU2hpbTtcbiAgd2luZG93LlZUVFJlZ2lvbiA9IHJlZ2lvblNoaW07XG59O1xuXG52dHRqcy5yZXN0b3JlID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5WVFRDdWUgPSBuYXRpdmVWVFRDdWU7XG4gIHdpbmRvdy5WVFRSZWdpb24gPSBuYXRpdmVWVFRSZWdpb247XG59O1xuXG5pZiAoIXdpbmRvdy5WVFRDdWUpIHtcbiAgdnR0anMuc2hpbSgpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiAtKi0gTW9kZTogSmF2YTsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGMtYmFzaWMtb2Zmc2V0OiAyIC0qLSAqL1xuLyogdmltOiBzZXQgc2hpZnR3aWR0aD0yIHRhYnN0b3A9MiBhdXRvaW5kZW50IGNpbmRlbnQgZXhwYW5kdGFiOiAqL1xudmFyIF9vYmpDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRigpIHt9XG4gIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0LmNyZWF0ZSBzaGltIG9ubHkgYWNjZXB0cyBvbmUgcGFyYW1ldGVyLicpO1xuICAgIH1cbiAgICBGLnByb3RvdHlwZSA9IG87XG4gICAgcmV0dXJuIG5ldyBGKCk7XG4gIH07XG59KSgpO1xuXG4vLyBDcmVhdGVzIGEgbmV3IFBhcnNlckVycm9yIG9iamVjdCBmcm9tIGFuIGVycm9yRGF0YSBvYmplY3QuIFRoZSBlcnJvckRhdGFcbi8vIG9iamVjdCBzaG91bGQgaGF2ZSBkZWZhdWx0IGNvZGUgYW5kIG1lc3NhZ2UgcHJvcGVydGllcy4gVGhlIGRlZmF1bHQgbWVzc2FnZVxuLy8gcHJvcGVydHkgY2FuIGJlIG92ZXJyaWRlbiBieSBwYXNzaW5nIGluIGEgbWVzc2FnZSBwYXJhbWV0ZXIuXG4vLyBTZWUgUGFyc2luZ0Vycm9yLkVycm9ycyBiZWxvdyBmb3IgYWNjZXB0YWJsZSBlcnJvcnMuXG5mdW5jdGlvbiBQYXJzaW5nRXJyb3IoZXJyb3JEYXRhLCBtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiUGFyc2luZ0Vycm9yXCI7XG4gIHRoaXMuY29kZSA9IGVycm9yRGF0YS5jb2RlO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IGVycm9yRGF0YS5tZXNzYWdlO1xufVxuUGFyc2luZ0Vycm9yLnByb3RvdHlwZSA9IF9vYmpDcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblBhcnNpbmdFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJzaW5nRXJyb3I7XG5cbi8vIFBhcnNpbmdFcnJvciBtZXRhZGF0YSBmb3IgYWNjZXB0YWJsZSBQYXJzaW5nRXJyb3JzLlxuUGFyc2luZ0Vycm9yLkVycm9ycyA9IHtcbiAgQmFkU2lnbmF0dXJlOiB7XG4gICAgY29kZTogMCxcbiAgICBtZXNzYWdlOiBcIk1hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLlwiXG4gIH0sXG4gIEJhZFRpbWVTdGFtcDoge1xuICAgIGNvZGU6IDEsXG4gICAgbWVzc2FnZTogXCJNYWxmb3JtZWQgdGltZSBzdGFtcC5cIlxuICB9XG59O1xuXG4vLyBUcnkgdG8gcGFyc2UgaW5wdXQgYXMgYSB0aW1lIHN0YW1wLlxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAoaW5wdXQpIHtcblxuICBmdW5jdGlvbiBjb21wdXRlU2Vjb25kcyhoLCBtLCBzLCBmKSB7XG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIChmIHwgMCkgLyAxMDAwO1xuICB9XG5cbiAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihcXGQrKTooXFxkezJ9KSg6XFxkezJ9KT9cXC4oXFxkezN9KS8pO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChtWzNdKSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCBtWzNdLnJlcGxhY2UoXCI6XCIsIFwiXCIpLCBtWzRdKTtcbiAgfSBlbHNlIGlmIChtWzFdID4gNTkpIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc10uW21pbGxpc2Vjb25kc11cbiAgICAvLyBGaXJzdCBwb3NpdGlvbiBpcyBob3VycyBhcyBpdCdzIG92ZXIgNTkuXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIDAsICBtWzRdKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcygwLCBtWzFdLCBtWzJdLCBtWzRdKTtcbiAgfVxufVxuXG4vLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3Rcbi8vIGFzc2lnbm1lbnQgdG8gYSBzcGVjaWZpYyBrZXkuXG5mdW5jdGlvbiBTZXR0aW5ncygpIHtcbiAgdGhpcy52YWx1ZXMgPSBfb2JqQ3JlYXRlKG51bGwpO1xufVxuXG5TZXR0aW5ncy5wcm90b3R5cGUgPSB7XG4gIC8vIE9ubHkgYWNjZXB0IHRoZSBmaXJzdCBhc3NpZ25tZW50IHRvIGFueSBrZXkuXG4gIHNldDogZnVuY3Rpb24oaywgdikge1xuICAgIGlmICghdGhpcy5nZXQoaykgJiYgdiAhPT0gXCJcIikge1xuICAgICAgdGhpcy52YWx1ZXNba10gPSB2O1xuICAgIH1cbiAgfSxcbiAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgYSBrZXksIG9yIGEgZGVmYXVsdCB2YWx1ZS5cbiAgLy8gSWYgJ2RlZmF1bHRLZXknIGlzIHBhc3NlZCB0aGVuICdkZmx0JyBpcyBhc3N1bWVkIHRvIGJlIGFuIG9iamVjdCB3aXRoXG4gIC8vIGEgbnVtYmVyIG9mIHBvc3NpYmxlIGRlZmF1bHQgdmFsdWVzIGFzIHByb3BlcnRpZXMgd2hlcmUgJ2RlZmF1bHRLZXknIGlzXG4gIC8vIHRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBjaG9zZW47IG90aGVyd2lzZSBpdCdzIGFzc3VtZWQgdG8gYmVcbiAgLy8gYSBzaW5nbGUgdmFsdWUuXG4gIGdldDogZnVuY3Rpb24oaywgZGZsdCwgZGVmYXVsdEtleSkge1xuICAgIGlmIChkZWZhdWx0S2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHRbZGVmYXVsdEtleV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdDtcbiAgfSxcbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgdmFsdWUgZm9yIGEga2V5LlxuICBoYXM6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayBpbiB0aGlzLnZhbHVlcztcbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgb25lIG9mIHRoZSBnaXZlbiBhbHRlcm5hdGl2ZXMuXG4gIGFsdDogZnVuY3Rpb24oaywgdiwgYSkge1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYS5sZW5ndGg7ICsrbikge1xuICAgICAgaWYgKHYgPT09IGFbbl0pIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICBpbnRlZ2VyOiBmdW5jdGlvbihrLCB2KSB7XG4gICAgaWYgKC9eLT9cXGQrJC8udGVzdCh2KSkgeyAvLyBpbnRlZ2VyXG4gICAgICB0aGlzLnNldChrLCBwYXJzZUludCh2LCAxMCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCBwZXJjZW50YWdlLlxuICBwZXJjZW50OiBmdW5jdGlvbihrLCB2KSB7XG4gICAgdmFyIG07XG4gICAgaWYgKChtID0gdi5tYXRjaCgvXihbXFxkXXsxLDN9KShcXC5bXFxkXSopPyUkLykpKSB7XG4gICAgICB2ID0gcGFyc2VGbG9hdCh2KTtcbiAgICAgIGlmICh2ID49IDAgJiYgdiA8PSAxMDApIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBpbnB1dCBpbnRvIGdyb3VwcyBzZXBhcmF0ZWQgYnkgJ2dyb3VwRGVsaW0nLCBhbmRcbi8vIGludGVycHJldGUgZWFjaCBncm91cCBhcyBhIGtleS92YWx1ZSBwYWlyIHNlcGFyYXRlZCBieSAna2V5VmFsdWVEZWxpbScuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMoaW5wdXQsIGNhbGxiYWNrLCBrZXlWYWx1ZURlbGltLCBncm91cERlbGltKSB7XG4gIHZhciBncm91cHMgPSBncm91cERlbGltID8gaW5wdXQuc3BsaXQoZ3JvdXBEZWxpbSkgOiBbaW5wdXRdO1xuICBmb3IgKHZhciBpIGluIGdyb3Vwcykge1xuICAgIGlmICh0eXBlb2YgZ3JvdXBzW2ldICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGt2ID0gZ3JvdXBzW2ldLnNwbGl0KGtleVZhbHVlRGVsaW0pO1xuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgayA9IGt2WzBdO1xuICAgIHZhciB2ID0ga3ZbMV07XG4gICAgY2FsbGJhY2soaywgdik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VDdWUoaW5wdXQsIGN1ZSwgcmVnaW9uTGlzdCkge1xuICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgdmFyIG9JbnB1dCA9IGlucHV0O1xuICAvLyA0LjEgV2ViVlRUIHRpbWVzdGFtcFxuICBmdW5jdGlvbiBjb25zdW1lVGltZVN0YW1wKCkge1xuICAgIHZhciB0cyA9IHBhcnNlVGltZVN0YW1wKGlucHV0KTtcbiAgICBpZiAodHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yLkVycm9ycy5CYWRUaW1lU3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNYWxmb3JtZWQgdGltZXN0YW1wOiBcIiArIG9JbnB1dCk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aW1lIHN0YW1wIGZyb20gaW5wdXQuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCBcIlwiKTtcbiAgICByZXR1cm4gdHM7XG4gIH1cblxuICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXG4gIGZ1bmN0aW9uIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKSB7XG4gICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG5cbiAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICBzd2l0Y2ggKGspIHtcbiAgICAgIGNhc2UgXCJyZWdpb25cIjpcbiAgICAgICAgLy8gRmluZCB0aGUgbGFzdCByZWdpb24gd2UgcGFyc2VkIHdpdGggdGhlIHNhbWUgcmVnaW9uIGlkLlxuICAgICAgICBmb3IgKHZhciBpID0gcmVnaW9uTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zZXQoaywgcmVnaW9uTGlzdFtpXS5yZWdpb24pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbXCJybFwiLCBcImxyXCJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICB2YXIgdmFscyA9IHYuc3BsaXQoXCIsXCIpLFxuICAgICAgICAgICAgdmFsczAgPSB2YWxzWzBdO1xuICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHZhbHMwKTtcbiAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzMCkgPyBzZXR0aW5ncy5zZXQoXCJzbmFwVG9MaW5lc1wiLCBmYWxzZSkgOiBudWxsO1xuICAgICAgICBzZXR0aW5ncy5hbHQoaywgdmFsczAsIFtcImF1dG9cIl0pO1xuICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoXCJsaW5lQWxpZ25cIiwgdmFsc1sxXSwgW1wic3RhcnRcIiwgXCJtaWRkbGVcIiwgXCJlbmRcIl0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvc2l0aW9uXCI6XG4gICAgICAgIHZhbHMgPSB2LnNwbGl0KFwiLFwiKTtcbiAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzWzBdKTtcbiAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KFwicG9zaXRpb25BbGlnblwiLCB2YWxzWzFdLCBbXCJzdGFydFwiLCBcIm1pZGRsZVwiLCBcImVuZFwiXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2l6ZVwiOlxuICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhbGlnblwiOlxuICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgW1wic3RhcnRcIiwgXCJtaWRkbGVcIiwgXCJlbmRcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LCAvOi8sIC9cXHMvKTtcblxuICAgIC8vIEFwcGx5IGRlZmF1bHQgdmFsdWVzIGZvciBhbnkgbWlzc2luZyBmaWVsZHMuXG4gICAgY3VlLnJlZ2lvbiA9IHNldHRpbmdzLmdldChcInJlZ2lvblwiLCBudWxsKTtcbiAgICBjdWUudmVydGljYWwgPSBzZXR0aW5ncy5nZXQoXCJ2ZXJ0aWNhbFwiLCBcIlwiKTtcbiAgICBjdWUubGluZSA9IHNldHRpbmdzLmdldChcImxpbmVcIiwgXCJhdXRvXCIpO1xuICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoXCJsaW5lQWxpZ25cIiwgXCJzdGFydFwiKTtcbiAgICBjdWUuc25hcFRvTGluZXMgPSBzZXR0aW5ncy5nZXQoXCJzbmFwVG9MaW5lc1wiLCB0cnVlKTtcbiAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldChcInNpemVcIiwgMTAwKTtcbiAgICBjdWUuYWxpZ24gPSBzZXR0aW5ncy5nZXQoXCJhbGlnblwiLCBcIm1pZGRsZVwiKTtcbiAgICBjdWUucG9zaXRpb24gPSBzZXR0aW5ncy5nZXQoXCJwb3NpdGlvblwiLCB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBtaWRkbGU6IDUwLFxuICAgICAgZW5kOiAxMDAsXG4gICAgICByaWdodDogMTAwXG4gICAgfSwgY3VlLmFsaWduKTtcbiAgICBjdWUucG9zaXRpb25BbGlnbiA9IHNldHRpbmdzLmdldChcInBvc2l0aW9uQWxpZ25cIiwge1xuICAgICAgc3RhcnQ6IFwic3RhcnRcIixcbiAgICAgIGxlZnQ6IFwic3RhcnRcIixcbiAgICAgIG1pZGRsZTogXCJtaWRkbGVcIixcbiAgICAgIGVuZDogXCJlbmRcIixcbiAgICAgIHJpZ2h0OiBcImVuZFwiXG4gICAgfSwgY3VlLmFsaWduKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlxccysvLCBcIlwiKTtcbiAgfVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHRpbWluZ3MuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGN1ZS5zdGFydFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7ICAgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgaWYgKGlucHV0LnN1YnN0cigwLCAzKSAhPT0gXCItLT5cIikgeyAgICAgLy8gKDMpIG5leHQgY2hhcmFjdGVycyBtdXN0IG1hdGNoIFwiLS0+XCJcbiAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvci5FcnJvcnMuQmFkVGltZVN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgJy0tPicpOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvSW5wdXQpO1xuICB9XG4gIGlucHV0ID0gaW5wdXQuc3Vic3RyKDMpO1xuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgICAgIC8vICg1KSBjb2xsZWN0IGN1ZSBlbmQgdGltZVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHNldHRpbmdzIGxpc3QuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKTtcbn1cblxudmFyIEVTQ0FQRSA9IHtcbiAgXCImYW1wO1wiOiBcIiZcIixcbiAgXCImbHQ7XCI6IFwiPFwiLFxuICBcIiZndDtcIjogXCI+XCIsXG4gIFwiJmxybTtcIjogXCJcXHUyMDBlXCIsXG4gIFwiJnJsbTtcIjogXCJcXHUyMDBmXCIsXG4gIFwiJm5ic3A7XCI6IFwiXFx1MDBhMFwiXG59O1xuXG52YXIgVEFHX05BTUUgPSB7XG4gIGM6IFwic3BhblwiLFxuICBpOiBcImlcIixcbiAgYjogXCJiXCIsXG4gIHU6IFwidVwiLFxuICBydWJ5OiBcInJ1YnlcIixcbiAgcnQ6IFwicnRcIixcbiAgdjogXCJzcGFuXCIsXG4gIGxhbmc6IFwic3BhblwiXG59O1xuXG52YXIgVEFHX0FOTk9UQVRJT04gPSB7XG4gIHY6IFwidGl0bGVcIixcbiAgbGFuZzogXCJsYW5nXCJcbn07XG5cbnZhciBORUVEU19QQVJFTlQgPSB7XG4gIHJ0OiBcInJ1YnlcIlxufTtcblxuLy8gUGFyc2UgY29udGVudCBpbnRvIGEgZG9jdW1lbnQgZnJhZ21lbnQuXG5mdW5jdGlvbiBwYXJzZUNvbnRlbnQod2luZG93LCBpbnB1dCkge1xuICBmdW5jdGlvbiBuZXh0VG9rZW4oKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGVuZC1vZi1zdHJpbmcuXG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZSAnbicgY2hhcmFjdGVycyBmcm9tIHRoZSBpbnB1dC5cbiAgICBmdW5jdGlvbiBjb25zdW1lKHJlc3VsdCkge1xuICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHIocmVzdWx0Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBtID0gaW5wdXQubWF0Y2goL14oW148XSopKDxbXj5dKz4/KT8vKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBzb21lIHRleHQgYmVmb3JlIHRoZSBuZXh0IHRhZywgcmV0dXJuIGl0LCBvdGhlcndpc2UgcmV0dXJuXG4gICAgLy8gdGhlIHRhZy5cbiAgICByZXR1cm4gY29uc3VtZShtWzFdID8gbVsxXSA6IG1bMl0pO1xuICB9XG5cbiAgLy8gVW5lc2NhcGUgYSBzdHJpbmcgJ3MnLlxuICBmdW5jdGlvbiB1bmVzY2FwZTEoZSkge1xuICAgIHJldHVybiBFU0NBUEVbZV07XG4gIH1cbiAgZnVuY3Rpb24gdW5lc2NhcGUocykge1xuICAgIHdoaWxlICgobSA9IHMubWF0Y2goLyYoYW1wfGx0fGd0fGxybXxybG18bmJzcCk7LykpKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKG1bMF0sIHVuZXNjYXBlMSk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkQWRkKGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIU5FRURTX1BBUkVOVFtlbGVtZW50LmxvY2FsTmFtZV0gfHxcbiAgICAgICAgICAgTkVFRFNfUEFSRU5UW2VsZW1lbnQubG9jYWxOYW1lXSA9PT0gY3VycmVudC5sb2NhbE5hbWU7XG4gIH1cblxuICAvLyBDcmVhdGUgYW4gZWxlbWVudCBmb3IgdGhpcyB0YWcuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgYW5ub3RhdGlvbikge1xuICAgIHZhciB0YWdOYW1lID0gVEFHX05BTUVbdHlwZV07XG4gICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBlbGVtZW50LmxvY2FsTmFtZSA9IHRhZ05hbWU7XG4gICAgdmFyIG5hbWUgPSBUQUdfQU5OT1RBVElPTlt0eXBlXTtcbiAgICBpZiAobmFtZSAmJiBhbm5vdGF0aW9uKSB7XG4gICAgICBlbGVtZW50W25hbWVdID0gYW5ub3RhdGlvbi50cmltKCk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdmFyIHJvb3REaXYgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgIGN1cnJlbnQgPSByb290RGl2LFxuICAgICAgdCxcbiAgICAgIHRhZ1N0YWNrID0gW107XG5cbiAgd2hpbGUgKCh0ID0gbmV4dFRva2VuKCkpICE9PSBudWxsKSB7XG4gICAgaWYgKHRbMF0gPT09ICc8Jykge1xuICAgICAgaWYgKHRbMV0gPT09IFwiL1wiKSB7XG4gICAgICAgIC8vIElmIHRoZSBjbG9zaW5nIHRhZyBtYXRjaGVzLCBtb3ZlIGJhY2sgdXAgdG8gdGhlIHBhcmVudCBub2RlLlxuICAgICAgICBpZiAodGFnU3RhY2subGVuZ3RoICYmXG4gICAgICAgICAgICB0YWdTdGFja1t0YWdTdGFjay5sZW5ndGggLSAxXSA9PT0gdC5zdWJzdHIoMikucmVwbGFjZShcIj5cIiwgXCJcIikpIHtcbiAgICAgICAgICB0YWdTdGFjay5wb3AoKTtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGlnbm9yZSB0aGUgZW5kIHRhZy5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgdHMgPSBwYXJzZVRpbWVTdGFtcCh0LnN1YnN0cigxLCB0Lmxlbmd0aCAtIDIpKTtcbiAgICAgIHZhciBub2RlO1xuICAgICAgaWYgKHRzKSB7XG4gICAgICAgIC8vIFRpbWVzdGFtcHMgYXJlIGxlYWQgbm9kZXMgYXMgd2VsbC5cbiAgICAgICAgbm9kZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oXCJ0aW1lc3RhbXBcIiwgdHMpO1xuICAgICAgICBjdXJyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtID0gdC5tYXRjaCgvXjwoW14uXFxzLzAtOT5dKykoXFwuW15cXHNcXFxcPl0rKT8oW14+XFxcXF0rKT8oXFxcXD8pPj8kLyk7XG4gICAgICAvLyBJZiB3ZSBjYW4ndCBwYXJzZSB0aGUgdGFnLCBza2lwIHRvIHRoZSBuZXh0IHRhZy5cbiAgICAgIGlmICghbSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRyeSB0byBjb25zdHJ1Y3QgYW4gZWxlbWVudCwgYW5kIGlnbm9yZSB0aGUgdGFnIGlmIHdlIGNvdWxkbid0LlxuICAgICAgbm9kZSA9IGNyZWF0ZUVsZW1lbnQobVsxXSwgbVszXSk7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIHRhZyBzaG91bGQgYmUgYWRkZWQgYmFzZWQgb24gdGhlIGNvbnRleHQgb2Ygd2hlcmUgaXRcbiAgICAgIC8vIGlzIHBsYWNlZCBpbiB0aGUgY3VldGV4dC5cbiAgICAgIGlmICghc2hvdWxkQWRkKGN1cnJlbnQsIG5vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gU2V0IHRoZSBjbGFzcyBsaXN0IChhcyBhIGxpc3Qgb2YgY2xhc3Nlcywgc2VwYXJhdGVkIGJ5IHNwYWNlKS5cbiAgICAgIGlmIChtWzJdKSB7XG4gICAgICAgIG5vZGUuY2xhc3NOYW1lID0gbVsyXS5zdWJzdHIoMSkucmVwbGFjZSgnLicsICcgJyk7XG4gICAgICB9XG4gICAgICAvLyBBcHBlbmQgdGhlIG5vZGUgdG8gdGhlIGN1cnJlbnQgbm9kZSwgYW5kIGVudGVyIHRoZSBzY29wZSBvZiB0aGUgbmV3XG4gICAgICAvLyBub2RlLlxuICAgICAgdGFnU3RhY2sucHVzaChtWzFdKTtcbiAgICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBjdXJyZW50ID0gbm9kZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFRleHQgbm9kZXMgYXJlIGxlYWYgbm9kZXMuXG4gICAgY3VycmVudC5hcHBlbmRDaGlsZCh3aW5kb3cuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodW5lc2NhcGUodCkpKTtcbiAgfVxuXG4gIHJldHVybiByb290RGl2O1xufVxuXG4vLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgdGhlIFVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYSBzdHJvbmdcbi8vIHJpZ2h0LXRvLWxlZnQgY2F0ZWdvcnkuIFdoYXQgdGhpcyBtZWFucyBpcyB0aGF0IHRoZXNlIGNoYXJhY3RlcnMgYXJlXG4vLyB3cml0dGVuIHJpZ2h0LXRvLWxlZnQgZm9yIHN1cmUuIEl0IHdhcyBnZW5lcmF0ZWQgYnkgcHVsbGluZyBhbGwgdGhlIHN0cm9uZ1xuLy8gcmlnaHQtdG8tbGVmdCBjaGFyYWN0ZXJzIG91dCBvZiB0aGUgVW5pY29kZSBkYXRhIHRhYmxlLiBUaGF0IHRhYmxlIGNhblxuLy8gZm91bmQgYXQ6IGh0dHA6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VOSURBVEEvVW5pY29kZURhdGEudHh0XG52YXIgc3Ryb25nUlRMUmFuZ2VzID0gW1sweDViZSwgMHg1YmVdLCBbMHg1YzAsIDB4NWMwXSwgWzB4NWMzLCAweDVjM10sIFsweDVjNiwgMHg1YzZdLFxuIFsweDVkMCwgMHg1ZWFdLCBbMHg1ZjAsIDB4NWY0XSwgWzB4NjA4LCAweDYwOF0sIFsweDYwYiwgMHg2MGJdLCBbMHg2MGQsIDB4NjBkXSxcbiBbMHg2MWIsIDB4NjFiXSwgWzB4NjFlLCAweDY0YV0sIFsweDY2ZCwgMHg2NmZdLCBbMHg2NzEsIDB4NmQ1XSwgWzB4NmU1LCAweDZlNl0sXG4gWzB4NmVlLCAweDZlZl0sIFsweDZmYSwgMHg3MGRdLCBbMHg3MGYsIDB4NzEwXSwgWzB4NzEyLCAweDcyZl0sIFsweDc0ZCwgMHg3YTVdLFxuIFsweDdiMSwgMHg3YjFdLCBbMHg3YzAsIDB4N2VhXSwgWzB4N2Y0LCAweDdmNV0sIFsweDdmYSwgMHg3ZmFdLCBbMHg4MDAsIDB4ODE1XSxcbiBbMHg4MWEsIDB4ODFhXSwgWzB4ODI0LCAweDgyNF0sIFsweDgyOCwgMHg4MjhdLCBbMHg4MzAsIDB4ODNlXSwgWzB4ODQwLCAweDg1OF0sXG4gWzB4ODVlLCAweDg1ZV0sIFsweDhhMCwgMHg4YTBdLCBbMHg4YTIsIDB4OGFjXSwgWzB4MjAwZiwgMHgyMDBmXSxcbiBbMHhmYjFkLCAweGZiMWRdLCBbMHhmYjFmLCAweGZiMjhdLCBbMHhmYjJhLCAweGZiMzZdLCBbMHhmYjM4LCAweGZiM2NdLFxuIFsweGZiM2UsIDB4ZmIzZV0sIFsweGZiNDAsIDB4ZmI0MV0sIFsweGZiNDMsIDB4ZmI0NF0sIFsweGZiNDYsIDB4ZmJjMV0sXG4gWzB4ZmJkMywgMHhmZDNkXSwgWzB4ZmQ1MCwgMHhmZDhmXSwgWzB4ZmQ5MiwgMHhmZGM3XSwgWzB4ZmRmMCwgMHhmZGZjXSxcbiBbMHhmZTcwLCAweGZlNzRdLCBbMHhmZTc2LCAweGZlZmNdLCBbMHgxMDgwMCwgMHgxMDgwNV0sIFsweDEwODA4LCAweDEwODA4XSxcbiBbMHgxMDgwYSwgMHgxMDgzNV0sIFsweDEwODM3LCAweDEwODM4XSwgWzB4MTA4M2MsIDB4MTA4M2NdLCBbMHgxMDgzZiwgMHgxMDg1NV0sXG4gWzB4MTA4NTcsIDB4MTA4NWZdLCBbMHgxMDkwMCwgMHgxMDkxYl0sIFsweDEwOTIwLCAweDEwOTM5XSwgWzB4MTA5M2YsIDB4MTA5M2ZdLFxuIFsweDEwOTgwLCAweDEwOWI3XSwgWzB4MTA5YmUsIDB4MTA5YmZdLCBbMHgxMGEwMCwgMHgxMGEwMF0sIFsweDEwYTEwLCAweDEwYTEzXSxcbiBbMHgxMGExNSwgMHgxMGExN10sIFsweDEwYTE5LCAweDEwYTMzXSwgWzB4MTBhNDAsIDB4MTBhNDddLCBbMHgxMGE1MCwgMHgxMGE1OF0sXG4gWzB4MTBhNjAsIDB4MTBhN2ZdLCBbMHgxMGIwMCwgMHgxMGIzNV0sIFsweDEwYjQwLCAweDEwYjU1XSwgWzB4MTBiNTgsIDB4MTBiNzJdLFxuIFsweDEwYjc4LCAweDEwYjdmXSwgWzB4MTBjMDAsIDB4MTBjNDhdLCBbMHgxZWUwMCwgMHgxZWUwM10sIFsweDFlZTA1LCAweDFlZTFmXSxcbiBbMHgxZWUyMSwgMHgxZWUyMl0sIFsweDFlZTI0LCAweDFlZTI0XSwgWzB4MWVlMjcsIDB4MWVlMjddLCBbMHgxZWUyOSwgMHgxZWUzMl0sXG4gWzB4MWVlMzQsIDB4MWVlMzddLCBbMHgxZWUzOSwgMHgxZWUzOV0sIFsweDFlZTNiLCAweDFlZTNiXSwgWzB4MWVlNDIsIDB4MWVlNDJdLFxuIFsweDFlZTQ3LCAweDFlZTQ3XSwgWzB4MWVlNDksIDB4MWVlNDldLCBbMHgxZWU0YiwgMHgxZWU0Yl0sIFsweDFlZTRkLCAweDFlZTRmXSxcbiBbMHgxZWU1MSwgMHgxZWU1Ml0sIFsweDFlZTU0LCAweDFlZTU0XSwgWzB4MWVlNTcsIDB4MWVlNTddLCBbMHgxZWU1OSwgMHgxZWU1OV0sXG4gWzB4MWVlNWIsIDB4MWVlNWJdLCBbMHgxZWU1ZCwgMHgxZWU1ZF0sIFsweDFlZTVmLCAweDFlZTVmXSwgWzB4MWVlNjEsIDB4MWVlNjJdLFxuIFsweDFlZTY0LCAweDFlZTY0XSwgWzB4MWVlNjcsIDB4MWVlNmFdLCBbMHgxZWU2YywgMHgxZWU3Ml0sIFsweDFlZTc0LCAweDFlZTc3XSxcbiBbMHgxZWU3OSwgMHgxZWU3Y10sIFsweDFlZTdlLCAweDFlZTdlXSwgWzB4MWVlODAsIDB4MWVlODldLCBbMHgxZWU4YiwgMHgxZWU5Yl0sXG4gWzB4MWVlYTEsIDB4MWVlYTNdLCBbMHgxZWVhNSwgMHgxZWVhOV0sIFsweDFlZWFiLCAweDFlZWJiXSwgWzB4MTBmZmZkLCAweDEwZmZmZF1dO1xuXG5mdW5jdGlvbiBpc1N0cm9uZ1JUTENoYXIoY2hhckNvZGUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJvbmdSVExSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3VycmVudFJhbmdlID0gc3Ryb25nUlRMUmFuZ2VzW2ldO1xuICAgIGlmIChjaGFyQ29kZSA+PSBjdXJyZW50UmFuZ2VbMF0gJiYgY2hhckNvZGUgPD0gY3VycmVudFJhbmdlWzFdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUJpZGkoY3VlRGl2KSB7XG4gIHZhciBub2RlU3RhY2sgPSBbXSxcbiAgICAgIHRleHQgPSBcIlwiLFxuICAgICAgY2hhckNvZGU7XG5cbiAgaWYgKCFjdWVEaXYgfHwgIWN1ZURpdi5jaGlsZE5vZGVzKSB7XG4gICAgcmV0dXJuIFwibHRyXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoTm9kZXMobm9kZVN0YWNrLCBub2RlKSB7XG4gICAgZm9yICh2YXIgaSA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbm9kZVN0YWNrLnB1c2gobm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKSB7XG4gICAgaWYgKCFub2RlU3RhY2sgfHwgIW5vZGVTdGFjay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbm9kZVN0YWNrLnBvcCgpLFxuICAgICAgICB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudCB8fCBub2RlLmlubmVyVGV4dDtcbiAgICBpZiAodGV4dCkge1xuICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbWF0Y2ggYWxsIHVuaWNvZGUgdHlwZSBCIGNoYXJhY3RlcnMgKHBhcmFncmFwaFxuICAgICAgLy8gc2VwYXJhdG9yIGNoYXJhY3RlcnMpLiBTZWUgaXNzdWUgIzExNS5cbiAgICAgIHZhciBtID0gdGV4dC5tYXRjaCgvXi4qKFxcbnxcXHIpLyk7XG4gICAgICBpZiAobSkge1xuICAgICAgICBub2RlU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gXCJydWJ5XCIpIHtcbiAgICAgIHJldHVybiBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGROb2Rlcykge1xuICAgICAgcHVzaE5vZGVzKG5vZGVTdGFjaywgbm9kZSk7XG4gICAgICByZXR1cm4gbmV4dFRleHROb2RlKG5vZGVTdGFjayk7XG4gICAgfVxuICB9XG5cbiAgcHVzaE5vZGVzKG5vZGVTdGFjaywgY3VlRGl2KTtcbiAgd2hpbGUgKCh0ZXh0ID0gbmV4dFRleHROb2RlKG5vZGVTdGFjaykpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChpc1N0cm9uZ1JUTENoYXIoY2hhckNvZGUpKSB7XG4gICAgICAgIHJldHVybiBcInJ0bFwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gXCJsdHJcIjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUxpbmVQb3MoY3VlKSB7XG4gIGlmICh0eXBlb2YgY3VlLmxpbmUgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgIChjdWUuc25hcFRvTGluZXMgfHwgKGN1ZS5saW5lID49IDAgJiYgY3VlLmxpbmUgPD0gMTAwKSkpIHtcbiAgICByZXR1cm4gY3VlLmxpbmU7XG4gIH1cbiAgaWYgKCFjdWUudHJhY2sgfHwgIWN1ZS50cmFjay50ZXh0VHJhY2tMaXN0IHx8XG4gICAgICAhY3VlLnRyYWNrLnRleHRUcmFja0xpc3QubWVkaWFFbGVtZW50KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciB0cmFjayA9IGN1ZS50cmFjayxcbiAgICAgIHRyYWNrTGlzdCA9IHRyYWNrLnRleHRUcmFja0xpc3QsXG4gICAgICBjb3VudCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMaXN0Lmxlbmd0aCAmJiB0cmFja0xpc3RbaV0gIT09IHRyYWNrOyBpKyspIHtcbiAgICBpZiAodHJhY2tMaXN0W2ldLm1vZGUgPT09IFwic2hvd2luZ1wiKSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKytjb3VudCAqIC0xO1xufVxuXG5mdW5jdGlvbiBTdHlsZUJveCgpIHtcbn1cblxuLy8gQXBwbHkgc3R5bGVzIHRvIGEgZGl2LiBJZiB0aGVyZSBpcyBubyBkaXYgcGFzc2VkIHRoZW4gaXQgZGVmYXVsdHMgdG8gdGhlXG4vLyBkaXYgb24gJ3RoaXMnLlxuU3R5bGVCb3gucHJvdG90eXBlLmFwcGx5U3R5bGVzID0gZnVuY3Rpb24oc3R5bGVzLCBkaXYpIHtcbiAgZGl2ID0gZGl2IHx8IHRoaXMuZGl2O1xuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlcykge1xuICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGRpdi5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXTtcbiAgICB9XG4gIH1cbn07XG5cblN0eWxlQm94LnByb3RvdHlwZS5mb3JtYXRTdHlsZSA9IGZ1bmN0aW9uKHZhbCwgdW5pdCkge1xuICByZXR1cm4gdmFsID09PSAwID8gMCA6IHZhbCArIHVuaXQ7XG59O1xuXG4vLyBDb25zdHJ1Y3RzIHRoZSBjb21wdXRlZCBkaXNwbGF5IHN0YXRlIG9mIHRoZSBjdWUgKGEgZGl2KS4gUGxhY2VzIHRoZSBkaXZcbi8vIGludG8gdGhlIG92ZXJsYXkgd2hpY2ggc2hvdWxkIGJlIGEgYmxvY2sgbGV2ZWwgZWxlbWVudCAodXN1YWxseSBhIGRpdikuXG5mdW5jdGlvbiBDdWVTdHlsZUJveCh3aW5kb3csIGN1ZSwgc3R5bGVPcHRpb25zKSB7XG4gIHZhciBpc0lFOCA9ICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIGNvbG9yID0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpXCI7XG4gIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoMCwgMCwgMCwgMC44KVwiO1xuXG4gIGlmIChpc0lFOCkge1xuICAgIGNvbG9yID0gXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIjtcbiAgICBiYWNrZ3JvdW5kQ29sb3IgPSBcInJnYigwLCAwLCAwKVwiO1xuICB9XG5cbiAgU3R5bGVCb3guY2FsbCh0aGlzKTtcbiAgdGhpcy5jdWUgPSBjdWU7XG5cbiAgLy8gUGFyc2Ugb3VyIGN1ZSdzIHRleHQgaW50byBhIERPTSB0cmVlIHJvb3RlZCBhdCAnY3VlRGl2Jy4gVGhpcyBkaXYgd2lsbFxuICAvLyBoYXZlIGlubGluZSBwb3NpdGlvbmluZyBhbmQgd2lsbCBmdW5jdGlvbiBhcyB0aGUgY3VlIGJhY2tncm91bmQgYm94LlxuICB0aGlzLmN1ZURpdiA9IHBhcnNlQ29udGVudCh3aW5kb3csIGN1ZS50ZXh0KTtcbiAgdmFyIHN0eWxlcyA9IHtcbiAgICBjb2xvcjogY29sb3IsXG4gICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDAsXG4gICAgZGlzcGxheTogXCJpbmxpbmVcIlxuICB9O1xuXG4gIGlmICghaXNJRTgpIHtcbiAgICBzdHlsZXMud3JpdGluZ01vZGUgPSBjdWUudmVydGljYWwgPT09IFwiXCIgPyBcImhvcml6b250YWwtdGJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdWUudmVydGljYWwgPT09IFwibHJcIiA/IFwidmVydGljYWwtbHJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcInZlcnRpY2FsLXJsXCI7XG4gICAgc3R5bGVzLnVuaWNvZGVCaWRpID0gXCJwbGFpbnRleHRcIjtcbiAgfVxuICB0aGlzLmFwcGx5U3R5bGVzKHN0eWxlcywgdGhpcy5jdWVEaXYpO1xuXG4gIC8vIENyZWF0ZSBhbiBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZGl2IHRoYXQgd2lsbCBiZSB1c2VkIHRvIHBvc2l0aW9uIHRoZSBjdWVcbiAgLy8gZGl2LiBOb3RlLCBhbGwgV2ViVlRUIGN1ZS1zZXR0aW5nIGFsaWdubWVudHMgYXJlIGVxdWl2YWxlbnQgdG8gdGhlIENTU1xuICAvLyBtaXJyb3JzIG9mIHRoZW0gZXhjZXB0IFwibWlkZGxlXCIgd2hpY2ggaXMgXCJjZW50ZXJcIiBpbiBDU1MuXG4gIHRoaXMuZGl2ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHN0eWxlcyA9IHtcbiAgICB0ZXh0QWxpZ246IGN1ZS5hbGlnbiA9PT0gXCJtaWRkbGVcIiA/IFwiY2VudGVyXCIgOiBjdWUuYWxpZ24sXG4gICAgZm9udDogc3R5bGVPcHRpb25zLmZvbnQsXG4gICAgd2hpdGVTcGFjZTogXCJwcmUtbGluZVwiLFxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgfTtcblxuICBpZiAoIWlzSUU4KSB7XG4gICAgc3R5bGVzLmRpcmVjdGlvbiA9IGRldGVybWluZUJpZGkodGhpcy5jdWVEaXYpO1xuICAgIHN0eWxlcy53cml0aW5nTW9kZSA9IGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIiA/IFwiaG9yaXpvbnRhbC10YlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1ZS52ZXJ0aWNhbCA9PT0gXCJsclwiID8gXCJ2ZXJ0aWNhbC1sclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwidmVydGljYWwtcmxcIi5cbiAgICBzdHlsZXN1bmljb2RlQmlkaSA9ICBcInBsYWludGV4dFwiO1xuICB9XG5cbiAgdGhpcy5hcHBseVN0eWxlcyhzdHlsZXMpO1xuXG4gIHRoaXMuZGl2LmFwcGVuZENoaWxkKHRoaXMuY3VlRGl2KTtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHJlZmVyZW5jZSBlZGdlIG9mIHRoZSB2aWV3cG9ydCB0byB0aGUgdGV4dFxuICAvLyBwb3NpdGlvbiBvZiB0aGUgY3VlIGJveC4gVGhlIHJlZmVyZW5jZSBlZGdlIHdpbGwgYmUgcmVzb2x2ZWQgbGF0ZXIgd2hlblxuICAvLyB0aGUgYm94IG9yaWVudGF0aW9uIHN0eWxlcyBhcmUgYXBwbGllZC5cbiAgdmFyIHRleHRQb3MgPSAwO1xuICBzd2l0Y2ggKGN1ZS5wb3NpdGlvbkFsaWduKSB7XG4gIGNhc2UgXCJzdGFydFwiOlxuICAgIHRleHRQb3MgPSBjdWUucG9zaXRpb247XG4gICAgYnJlYWs7XG4gIGNhc2UgXCJtaWRkbGVcIjpcbiAgICB0ZXh0UG9zID0gY3VlLnBvc2l0aW9uIC0gKGN1ZS5zaXplIC8gMik7XG4gICAgYnJlYWs7XG4gIGNhc2UgXCJlbmRcIjpcbiAgICB0ZXh0UG9zID0gY3VlLnBvc2l0aW9uIC0gY3VlLnNpemU7XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBIb3Jpem9udGFsIGJveCBvcmllbnRhdGlvbjsgdGV4dFBvcyBpcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZVxuICAvLyBhcmVhIHRvIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGJveCBhbmQgY3VlLnNpemUgaXMgdGhlIGRpc3RhbmNlIGV4dGVuZGluZyB0b1xuICAvLyB0aGUgcmlnaHQgZnJvbSB0aGVyZS5cbiAgaWYgKGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIikge1xuICAgIHRoaXMuYXBwbHlTdHlsZXMoe1xuICAgICAgbGVmdDogIHRoaXMuZm9ybWF0U3R5bGUodGV4dFBvcywgXCIlXCIpLFxuICAgICAgd2lkdGg6IHRoaXMuZm9ybWF0U3R5bGUoY3VlLnNpemUsIFwiJVwiKVxuICAgIH0pO1xuICAvLyBWZXJ0aWNhbCBib3ggb3JpZW50YXRpb247IHRleHRQb3MgaXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHRvcCBlZGdlIG9mIHRoZVxuICAvLyBhcmVhIHRvIHRoZSB0b3AgZWRnZSBvZiB0aGUgYm94IGFuZCBjdWUuc2l6ZSBpcyB0aGUgaGVpZ2h0IGV4dGVuZGluZ1xuICAvLyBkb3dud2FyZHMgZnJvbSB0aGVyZS5cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFwcGx5U3R5bGVzKHtcbiAgICAgIHRvcDogdGhpcy5mb3JtYXRTdHlsZSh0ZXh0UG9zLCBcIiVcIiksXG4gICAgICBoZWlnaHQ6IHRoaXMuZm9ybWF0U3R5bGUoY3VlLnNpemUsIFwiJVwiKVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5tb3ZlID0gZnVuY3Rpb24oYm94KSB7XG4gICAgdGhpcy5hcHBseVN0eWxlcyh7XG4gICAgICB0b3A6IHRoaXMuZm9ybWF0U3R5bGUoYm94LnRvcCwgXCJweFwiKSxcbiAgICAgIGJvdHRvbTogdGhpcy5mb3JtYXRTdHlsZShib3guYm90dG9tLCBcInB4XCIpLFxuICAgICAgbGVmdDogdGhpcy5mb3JtYXRTdHlsZShib3gubGVmdCwgXCJweFwiKSxcbiAgICAgIHJpZ2h0OiB0aGlzLmZvcm1hdFN0eWxlKGJveC5yaWdodCwgXCJweFwiKSxcbiAgICAgIGhlaWdodDogdGhpcy5mb3JtYXRTdHlsZShib3guaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgd2lkdGg6IHRoaXMuZm9ybWF0U3R5bGUoYm94LndpZHRoLCBcInB4XCIpXG4gICAgfSk7XG4gIH07XG59XG5DdWVTdHlsZUJveC5wcm90b3R5cGUgPSBfb2JqQ3JlYXRlKFN0eWxlQm94LnByb3RvdHlwZSk7XG5DdWVTdHlsZUJveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWVTdHlsZUJveDtcblxuLy8gUmVwcmVzZW50cyB0aGUgY28tb3JkaW5hdGVzIG9mIGFuIEVsZW1lbnQgaW4gYSB3YXkgdGhhdCB3ZSBjYW4gZWFzaWx5XG4vLyBjb21wdXRlIHRoaW5ncyB3aXRoIHN1Y2ggYXMgaWYgaXQgb3ZlcmxhcHMgb3IgaW50ZXJzZWN0cyB3aXRoIGFub3RoZXIgRWxlbWVudC5cbi8vIENhbiBpbml0aWFsaXplIGl0IHdpdGggZWl0aGVyIGEgU3R5bGVCb3ggb3IgYW5vdGhlciBCb3hQb3NpdGlvbi5cbmZ1bmN0aW9uIEJveFBvc2l0aW9uKG9iaikge1xuICB2YXIgaXNJRTggPSAoL01TSUVcXHM4XFwuMC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgLy8gRWl0aGVyIGEgQm94UG9zaXRpb24gd2FzIHBhc3NlZCBpbiBhbmQgd2UgbmVlZCB0byBjb3B5IGl0LCBvciBhIFN0eWxlQm94XG4gIC8vIHdhcyBwYXNzZWQgaW4gYW5kIHdlIG5lZWQgdG8gY29weSB0aGUgcmVzdWx0cyBvZiAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0J1xuICAvLyBhcyB0aGUgb2JqZWN0IHJldHVybmVkIGlzIHJlYWRvbmx5LiBBbGwgY28tb3JkaW5hdGUgdmFsdWVzIGFyZSBpbiByZWZlcmVuY2VcbiAgLy8gdG8gdGhlIHZpZXdwb3J0IG9yaWdpbiAodG9wIGxlZnQpLlxuICB2YXIgbGgsIGhlaWdodCwgd2lkdGgsIHRvcDtcbiAgaWYgKG9iai5kaXYpIHtcbiAgICBoZWlnaHQgPSBvYmouZGl2Lm9mZnNldEhlaWdodDtcbiAgICB3aWR0aCA9IG9iai5kaXYub2Zmc2V0V2lkdGg7XG4gICAgdG9wID0gb2JqLmRpdi5vZmZzZXRUb3A7XG5cbiAgICB2YXIgcmVjdHMgPSAocmVjdHMgPSBvYmouZGl2LmNoaWxkTm9kZXMpICYmIChyZWN0cyA9IHJlY3RzWzBdKSAmJlxuICAgICAgICAgICAgICAgIHJlY3RzLmdldENsaWVudFJlY3RzICYmIHJlY3RzLmdldENsaWVudFJlY3RzKCk7XG4gICAgb2JqID0gb2JqLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyBJbiBjZXJ0YWluIGNhc2VzIHRoZSBvdXR0ZXIgZGl2IHdpbGwgYmUgc2xpZ2h0bHkgbGFyZ2VyIHRoZW4gdGhlIHN1bSBvZlxuICAgIC8vIHRoZSBpbm5lciBkaXYncyBsaW5lcy4gVGhpcyBjb3VsZCBiZSBkdWUgdG8gYm9sZCB0ZXh0LCBldGMsIG9uIHNvbWUgcGxhdGZvcm1zLlxuICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBzaG91bGQgZ2V0IHRoZSBhdmVyYWdlIGxpbmUgaGVpZ2h0IGFuZCB1c2UgdGhhdC4gVGhpcyB3aWxsXG4gICAgLy8gcmVzdWx0IGluIHRoZSBkZXNpcmVkIGJlaGF2aW91ci5cbiAgICBsaCA9IHJlY3RzID8gTWF0aC5tYXgoKHJlY3RzWzBdICYmIHJlY3RzWzBdLmhlaWdodCkgfHwgMCwgb2JqLmhlaWdodCAvIHJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgICAgIDogMDtcblxuICB9XG4gIHRoaXMubGVmdCA9IG9iai5sZWZ0O1xuICB0aGlzLnJpZ2h0ID0gb2JqLnJpZ2h0O1xuICB0aGlzLnRvcCA9IG9iai50b3AgfHwgdG9wO1xuICB0aGlzLmhlaWdodCA9IG9iai5oZWlnaHQgfHwgaGVpZ2h0O1xuICB0aGlzLmJvdHRvbSA9IG9iai5ib3R0b20gfHwgKHRvcCArIChvYmouaGVpZ2h0IHx8IGhlaWdodCkpO1xuICB0aGlzLndpZHRoID0gb2JqLndpZHRoIHx8IHdpZHRoO1xuICB0aGlzLmxpbmVIZWlnaHQgPSBsaCAhPT0gdW5kZWZpbmVkID8gbGggOiBvYmoubGluZUhlaWdodDtcblxuICBpZiAoaXNJRTggJiYgIXRoaXMubGluZUhlaWdodCkge1xuICAgIHRoaXMubGluZUhlaWdodCA9IDEzO1xuICB9XG59XG5cbi8vIE1vdmUgdGhlIGJveCBhbG9uZyBhIHBhcnRpY3VsYXIgYXhpcy4gT3B0aW9uYWxseSBwYXNzIGluIGFuIGFtb3VudCB0byBtb3ZlXG4vLyB0aGUgYm94LiBJZiBubyBhbW91bnQgaXMgcGFzc2VkIHRoZW4gdGhlIGRlZmF1bHQgaXMgdGhlIGxpbmUgaGVpZ2h0IG9mIHRoZVxuLy8gYm94LlxuQm94UG9zaXRpb24ucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihheGlzLCB0b01vdmUpIHtcbiAgdG9Nb3ZlID0gdG9Nb3ZlICE9PSB1bmRlZmluZWQgPyB0b01vdmUgOiB0aGlzLmxpbmVIZWlnaHQ7XG4gIHN3aXRjaCAoYXhpcykge1xuICBjYXNlIFwiK3hcIjpcbiAgICB0aGlzLmxlZnQgKz0gdG9Nb3ZlO1xuICAgIHRoaXMucmlnaHQgKz0gdG9Nb3ZlO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiLXhcIjpcbiAgICB0aGlzLmxlZnQgLT0gdG9Nb3ZlO1xuICAgIHRoaXMucmlnaHQgLT0gdG9Nb3ZlO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiK3lcIjpcbiAgICB0aGlzLnRvcCArPSB0b01vdmU7XG4gICAgdGhpcy5ib3R0b20gKz0gdG9Nb3ZlO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiLXlcIjpcbiAgICB0aGlzLnRvcCAtPSB0b01vdmU7XG4gICAgdGhpcy5ib3R0b20gLT0gdG9Nb3ZlO1xuICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyBDaGVjayBpZiB0aGlzIGJveCBvdmVybGFwcyBhbm90aGVyIGJveCwgYjIuXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUub3ZlcmxhcHMgPSBmdW5jdGlvbihiMikge1xuICByZXR1cm4gdGhpcy5sZWZ0IDwgYjIucmlnaHQgJiZcbiAgICAgICAgIHRoaXMucmlnaHQgPiBiMi5sZWZ0ICYmXG4gICAgICAgICB0aGlzLnRvcCA8IGIyLmJvdHRvbSAmJlxuICAgICAgICAgdGhpcy5ib3R0b20gPiBiMi50b3A7XG59O1xuXG4vLyBDaGVjayBpZiB0aGlzIGJveCBvdmVybGFwcyBhbnkgb3RoZXIgYm94ZXMgaW4gYm94ZXMuXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUub3ZlcmxhcHNBbnkgPSBmdW5jdGlvbihib3hlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMub3ZlcmxhcHMoYm94ZXNbaV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gQ2hlY2sgaWYgdGhpcyBib3ggaXMgd2l0aGluIGFub3RoZXIgYm94LlxuQm94UG9zaXRpb24ucHJvdG90eXBlLndpdGhpbiA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICByZXR1cm4gdGhpcy50b3AgPj0gY29udGFpbmVyLnRvcCAmJlxuICAgICAgICAgdGhpcy5ib3R0b20gPD0gY29udGFpbmVyLmJvdHRvbSAmJlxuICAgICAgICAgdGhpcy5sZWZ0ID49IGNvbnRhaW5lci5sZWZ0ICYmXG4gICAgICAgICB0aGlzLnJpZ2h0IDw9IGNvbnRhaW5lci5yaWdodDtcbn07XG5cbi8vIENoZWNrIGlmIHRoaXMgYm94IGlzIGVudGlyZWx5IHdpdGhpbiB0aGUgY29udGFpbmVyIG9yIGl0IGlzIG92ZXJsYXBwaW5nXG4vLyBvbiB0aGUgZWRnZSBvcHBvc2l0ZSBvZiB0aGUgYXhpcyBkaXJlY3Rpb24gcGFzc2VkLiBGb3IgZXhhbXBsZSwgaWYgXCIreFwiIGlzXG4vLyBwYXNzZWQgYW5kIHRoZSBib3ggaXMgb3ZlcmxhcHBpbmcgb24gdGhlIGxlZnQgZWRnZSBvZiB0aGUgY29udGFpbmVyLCB0aGVuXG4vLyByZXR1cm4gdHJ1ZS5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS5vdmVybGFwc09wcG9zaXRlQXhpcyA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgYXhpcykge1xuICBzd2l0Y2ggKGF4aXMpIHtcbiAgY2FzZSBcIit4XCI6XG4gICAgcmV0dXJuIHRoaXMubGVmdCA8IGNvbnRhaW5lci5sZWZ0O1xuICBjYXNlIFwiLXhcIjpcbiAgICByZXR1cm4gdGhpcy5yaWdodCA+IGNvbnRhaW5lci5yaWdodDtcbiAgY2FzZSBcIit5XCI6XG4gICAgcmV0dXJuIHRoaXMudG9wIDwgY29udGFpbmVyLnRvcDtcbiAgY2FzZSBcIi15XCI6XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tID4gY29udGFpbmVyLmJvdHRvbTtcbiAgfVxufTtcblxuLy8gRmluZCB0aGUgcGVyY2VudGFnZSBvZiB0aGUgYXJlYSB0aGF0IHRoaXMgYm94IGlzIG92ZXJsYXBwaW5nIHdpdGggYW5vdGhlclxuLy8gYm94LlxuQm94UG9zaXRpb24ucHJvdG90eXBlLmludGVyc2VjdFBlcmNlbnRhZ2UgPSBmdW5jdGlvbihiMikge1xuICB2YXIgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMucmlnaHQsIGIyLnJpZ2h0KSAtIE1hdGgubWF4KHRoaXMubGVmdCwgYjIubGVmdCkpLFxuICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuYm90dG9tLCBiMi5ib3R0b20pIC0gTWF0aC5tYXgodGhpcy50b3AsIGIyLnRvcCkpLFxuICAgICAgaW50ZXJzZWN0QXJlYSA9IHggKiB5O1xuICByZXR1cm4gaW50ZXJzZWN0QXJlYSAvICh0aGlzLmhlaWdodCAqIHRoaXMud2lkdGgpO1xufTtcblxuLy8gQ29udmVydCB0aGUgcG9zaXRpb25zIGZyb20gdGhpcyBib3ggdG8gQ1NTIGNvbXBhdGlibGUgcG9zaXRpb25zIHVzaW5nXG4vLyB0aGUgcmVmZXJlbmNlIGNvbnRhaW5lcidzIHBvc2l0aW9ucy4gVGhpcyBoYXMgdG8gYmUgZG9uZSBiZWNhdXNlIHRoaXNcbi8vIGJveCdzIHBvc2l0aW9ucyBhcmUgaW4gcmVmZXJlbmNlIHRvIHRoZSB2aWV3cG9ydCBvcmlnaW4sIHdoZXJlYXMsIENTU1xuLy8gdmFsdWVzIGFyZSBpbiByZWZlcmVjbmUgdG8gdGhlaXIgcmVzcGVjdGl2ZSBlZGdlcy5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS50b0NTU0NvbXBhdFZhbHVlcyA9IGZ1bmN0aW9uKHJlZmVyZW5jZSkge1xuICByZXR1cm4ge1xuICAgIHRvcDogdGhpcy50b3AgLSByZWZlcmVuY2UudG9wLFxuICAgIGJvdHRvbTogcmVmZXJlbmNlLmJvdHRvbSAtIHRoaXMuYm90dG9tLFxuICAgIGxlZnQ6IHRoaXMubGVmdCAtIHJlZmVyZW5jZS5sZWZ0LFxuICAgIHJpZ2h0OiByZWZlcmVuY2UucmlnaHQgLSB0aGlzLnJpZ2h0LFxuICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgd2lkdGg6IHRoaXMud2lkdGhcbiAgfTtcbn07XG5cbi8vIEdldCBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBib3gncyBwb3NpdGlvbiB3aXRob3V0IGFueXRoaW5nIGV4dHJhLlxuLy8gQ2FuIHBhc3MgYSBTdHlsZUJveCwgSFRNTEVsZW1lbnQsIG9yIGFub3RoZXIgQm94UG9zaXRvbi5cbkJveFBvc2l0aW9uLmdldFNpbXBsZUJveFBvc2l0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBoZWlnaHQgPSBvYmouZGl2ID8gb2JqLmRpdi5vZmZzZXRIZWlnaHQgOiBvYmoudGFnTmFtZSA/IG9iai5vZmZzZXRIZWlnaHQgOiAwO1xuICB2YXIgd2lkdGggPSBvYmouZGl2ID8gb2JqLmRpdi5vZmZzZXRXaWR0aCA6IG9iai50YWdOYW1lID8gb2JqLm9mZnNldFdpZHRoIDogMDtcbiAgdmFyIHRvcCA9IG9iai5kaXYgPyBvYmouZGl2Lm9mZnNldFRvcCA6IG9iai50YWdOYW1lID8gb2JqLm9mZnNldFRvcCA6IDA7XG5cbiAgb2JqID0gb2JqLmRpdiA/IG9iai5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOlxuICAgICAgICAgICAgICAgIG9iai50YWdOYW1lID8gb2JqLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogb2JqO1xuICB2YXIgcmV0ID0ge1xuICAgIGxlZnQ6IG9iai5sZWZ0LFxuICAgIHJpZ2h0OiBvYmoucmlnaHQsXG4gICAgdG9wOiBvYmoudG9wIHx8IHRvcCxcbiAgICBoZWlnaHQ6IG9iai5oZWlnaHQgfHwgaGVpZ2h0LFxuICAgIGJvdHRvbTogb2JqLmJvdHRvbSB8fCAodG9wICsgKG9iai5oZWlnaHQgfHwgaGVpZ2h0KSksXG4gICAgd2lkdGg6IG9iai53aWR0aCB8fCB3aWR0aFxuICB9O1xuICByZXR1cm4gcmV0O1xufTtcblxuLy8gTW92ZSBhIFN0eWxlQm94IHRvIGl0cyBzcGVjaWZpZWQsIG9yIG5leHQgYmVzdCwgcG9zaXRpb24uIFRoZSBjb250YWluZXJCb3hcbi8vIGlzIHRoZSBib3ggdGhhdCBjb250YWlucyB0aGUgU3R5bGVCb3gsIHN1Y2ggYXMgYSBkaXYuIGJveFBvc2l0aW9ucyBhcmVcbi8vIGEgbGlzdCBvZiBvdGhlciBib3hlcyB0aGF0IHRoZSBzdHlsZUJveCBjYW4ndCBvdmVybGFwIHdpdGguXG5mdW5jdGlvbiBtb3ZlQm94VG9MaW5lUG9zaXRpb24od2luZG93LCBzdHlsZUJveCwgY29udGFpbmVyQm94LCBib3hQb3NpdGlvbnMpIHtcblxuICAvLyBGaW5kIHRoZSBiZXN0IHBvc2l0aW9uIGZvciBhIGN1ZSBib3gsIGIsIG9uIHRoZSB2aWRlby4gVGhlIGF4aXMgcGFyYW1ldGVyXG4gIC8vIGlzIGEgbGlzdCBvZiBheGlzLCB0aGUgb3JkZXIgb2Ygd2hpY2gsIGl0IHdpbGwgbW92ZSB0aGUgYm94IGFsb25nLiBGb3IgZXhhbXBsZTpcbiAgLy8gUGFzc2luZyBbXCIreFwiLCBcIi14XCJdIHdpbGwgbW92ZSB0aGUgYm94IGZpcnN0IGFsb25nIHRoZSB4IGF4aXMgaW4gdGhlIHBvc2l0aXZlXG4gIC8vIGRpcmVjdGlvbi4gSWYgaXQgZG9lc24ndCBmaW5kIGEgZ29vZCBwb3NpdGlvbiBmb3IgaXQgdGhlcmUgaXQgd2lsbCB0aGVuIG1vdmVcbiAgLy8gaXQgYWxvbmcgdGhlIHggYXhpcyBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uLlxuICBmdW5jdGlvbiBmaW5kQmVzdFBvc2l0aW9uKGIsIGF4aXMpIHtcbiAgICB2YXIgYmVzdFBvc2l0aW9uLFxuICAgICAgICBzcGVjaWZpZWRQb3NpdGlvbiA9IG5ldyBCb3hQb3NpdGlvbihiKSxcbiAgICAgICAgcGVyY2VudGFnZSA9IDE7IC8vIEhpZ2hlc3QgcG9zc2libGUgc28gdGhlIGZpcnN0IHRoaW5nIHdlIGdldCBpcyBiZXR0ZXIuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4aXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdoaWxlIChiLm92ZXJsYXBzT3Bwb3NpdGVBeGlzKGNvbnRhaW5lckJveCwgYXhpc1tpXSkgfHxcbiAgICAgICAgICAgICAoYi53aXRoaW4oY29udGFpbmVyQm94KSAmJiBiLm92ZXJsYXBzQW55KGJveFBvc2l0aW9ucykpKSB7XG4gICAgICAgIGIubW92ZShheGlzW2ldKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGZvdW5kIGEgc3BvdCB3aGVyZSB3ZSBhcmVuJ3Qgb3ZlcmxhcHBpbmcgYW55dGhpbmcuIFRoaXMgaXMgb3VyXG4gICAgICAvLyBiZXN0IHBvc2l0aW9uLlxuICAgICAgaWYgKGIud2l0aGluKGNvbnRhaW5lckJveCkpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgICB2YXIgcCA9IGIuaW50ZXJzZWN0UGVyY2VudGFnZShjb250YWluZXJCb3gpO1xuICAgICAgLy8gSWYgd2UncmUgb3V0c2lkZSB0aGUgY29udGFpbmVyIGJveCBsZXNzIHRoZW4gd2Ugd2VyZSBvbiBvdXIgbGFzdCB0cnlcbiAgICAgIC8vIHRoZW4gcmVtZW1iZXIgdGhpcyBwb3NpdGlvbiBhcyB0aGUgYmVzdCBwb3NpdGlvbi5cbiAgICAgIGlmIChwZXJjZW50YWdlID4gcCkge1xuICAgICAgICBiZXN0UG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oYik7XG4gICAgICAgIHBlcmNlbnRhZ2UgPSBwO1xuICAgICAgfVxuICAgICAgLy8gUmVzZXQgdGhlIGJveCBwb3NpdGlvbiB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgICAgYiA9IG5ldyBCb3hQb3NpdGlvbihzcGVjaWZpZWRQb3NpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBiZXN0UG9zaXRpb24gfHwgc3BlY2lmaWVkUG9zaXRpb247XG4gIH1cblxuICB2YXIgYm94UG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oc3R5bGVCb3gpLFxuICAgICAgY3VlID0gc3R5bGVCb3guY3VlLFxuICAgICAgbGluZVBvcyA9IGNvbXB1dGVMaW5lUG9zKGN1ZSksXG4gICAgICBheGlzID0gW107XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIGxpbmUgbnVtYmVyIHRvIGFsaWduIHRoZSBjdWUgdG8uXG4gIGlmIChjdWUuc25hcFRvTGluZXMpIHtcbiAgICB2YXIgc2l6ZTtcbiAgICBzd2l0Y2ggKGN1ZS52ZXJ0aWNhbCkge1xuICAgIGNhc2UgXCJcIjpcbiAgICAgIGF4aXMgPSBbIFwiK3lcIiwgXCIteVwiIF07XG4gICAgICBzaXplID0gXCJoZWlnaHRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJybFwiOlxuICAgICAgYXhpcyA9IFsgXCIreFwiLCBcIi14XCIgXTtcbiAgICAgIHNpemUgPSBcIndpZHRoXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibHJcIjpcbiAgICAgIGF4aXMgPSBbIFwiLXhcIiwgXCIreFwiIF07XG4gICAgICBzaXplID0gXCJ3aWR0aFwiO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHN0ZXAgPSBib3hQb3NpdGlvbi5saW5lSGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbiA9IHN0ZXAgKiBNYXRoLnJvdW5kKGxpbmVQb3MpLFxuICAgICAgICBtYXhQb3NpdGlvbiA9IGNvbnRhaW5lckJveFtzaXplXSArIHN0ZXAsXG4gICAgICAgIGluaXRpYWxBeGlzID0gYXhpc1swXTtcblxuICAgIC8vIElmIHRoZSBzcGVjaWZpZWQgaW50aWFsIHBvc2l0aW9uIGlzIGdyZWF0ZXIgdGhlbiB0aGUgbWF4IHBvc2l0aW9uIHRoZW5cbiAgICAvLyBjbGFtcCB0aGUgYm94IHRvIHRoZSBhbW91bnQgb2Ygc3RlcHMgaXQgd291bGQgdGFrZSBmb3IgdGhlIGJveCB0b1xuICAgIC8vIHJlYWNoIHRoZSBtYXggcG9zaXRpb24uXG4gICAgaWYgKE1hdGguYWJzKHBvc2l0aW9uKSA+IG1heFBvc2l0aW9uKSB7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIDwgMCA/IC0xIDogMTtcbiAgICAgIHBvc2l0aW9uICo9IE1hdGguY2VpbChtYXhQb3NpdGlvbiAvIHN0ZXApICogc3RlcDtcbiAgICB9XG5cbiAgICAvLyBJZiBjb21wdXRlZCBsaW5lIHBvc2l0aW9uIHJldHVybnMgbmVnYXRpdmUgdGhlbiBsaW5lIG51bWJlcnMgYXJlXG4gICAgLy8gcmVsYXRpdmUgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdmlkZW8gaW5zdGVhZCBvZiB0aGUgdG9wLiBUaGVyZWZvcmUsIHdlXG4gICAgLy8gbmVlZCB0byBpbmNyZWFzZSBvdXIgaW5pdGlhbCBwb3NpdGlvbiBieSB0aGUgbGVuZ3RoIG9yIHdpZHRoIG9mIHRoZVxuICAgIC8vIHZpZGVvLCBkZXBlbmRpbmcgb24gdGhlIHdyaXRpbmcgZGlyZWN0aW9uLCBhbmQgcmV2ZXJzZSBvdXIgYXhpcyBkaXJlY3Rpb25zLlxuICAgIGlmIChsaW5lUG9zIDwgMCkge1xuICAgICAgcG9zaXRpb24gKz0gY3VlLnZlcnRpY2FsID09PSBcIlwiID8gY29udGFpbmVyQm94LmhlaWdodCA6IGNvbnRhaW5lckJveC53aWR0aDtcbiAgICAgIGF4aXMgPSBheGlzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIHRoZSBib3ggdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gVGhpcyBtYXkgbm90IGJlIGl0cyBiZXN0XG4gICAgLy8gcG9zaXRpb24uXG4gICAgYm94UG9zaXRpb24ubW92ZShpbml0aWFsQXhpcywgcG9zaXRpb24pO1xuXG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhIHBlcmNlbnRhZ2UgbGluZSB2YWx1ZSBmb3IgdGhlIGN1ZS5cbiAgICB2YXIgY2FsY3VsYXRlZFBlcmNlbnRhZ2UgPSAoYm94UG9zaXRpb24ubGluZUhlaWdodCAvIGNvbnRhaW5lckJveC5oZWlnaHQpICogMTAwO1xuXG4gICAgc3dpdGNoIChjdWUubGluZUFsaWduKSB7XG4gICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgbGluZVBvcyAtPSAoY2FsY3VsYXRlZFBlcmNlbnRhZ2UgLyAyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgIGxpbmVQb3MgLT0gY2FsY3VsYXRlZFBlcmNlbnRhZ2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBBcHBseSBpbml0aWFsIGxpbmUgcG9zaXRpb24gdG8gdGhlIGN1ZSBib3guXG4gICAgc3dpdGNoIChjdWUudmVydGljYWwpIHtcbiAgICBjYXNlIFwiXCI6XG4gICAgICBzdHlsZUJveC5hcHBseVN0eWxlcyh7XG4gICAgICAgIHRvcDogc3R5bGVCb3guZm9ybWF0U3R5bGUobGluZVBvcywgXCIlXCIpXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJybFwiOlxuICAgICAgc3R5bGVCb3guYXBwbHlTdHlsZXMoe1xuICAgICAgICBsZWZ0OiBzdHlsZUJveC5mb3JtYXRTdHlsZShsaW5lUG9zLCBcIiVcIilcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImxyXCI6XG4gICAgICBzdHlsZUJveC5hcHBseVN0eWxlcyh7XG4gICAgICAgIHJpZ2h0OiBzdHlsZUJveC5mb3JtYXRTdHlsZShsaW5lUG9zLCBcIiVcIilcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXhpcyA9IFsgXCIreVwiLCBcIi14XCIsIFwiK3hcIiwgXCIteVwiIF07XG5cbiAgICAvLyBHZXQgdGhlIGJveCBwb3NpdGlvbiBhZ2FpbiBhZnRlciB3ZSd2ZSBhcHBsaWVkIHRoZSBzcGVjaWZpZWQgcG9zaXRpb25pbmdcbiAgICAvLyB0byBpdC5cbiAgICBib3hQb3NpdGlvbiA9IG5ldyBCb3hQb3NpdGlvbihzdHlsZUJveCk7XG4gIH1cblxuICB2YXIgYmVzdFBvc2l0aW9uID0gZmluZEJlc3RQb3NpdGlvbihib3hQb3NpdGlvbiwgYXhpcyk7XG4gIHN0eWxlQm94Lm1vdmUoYmVzdFBvc2l0aW9uLnRvQ1NTQ29tcGF0VmFsdWVzKGNvbnRhaW5lckJveCkpO1xufVxuXG5mdW5jdGlvbiBXZWJWVFQoKSB7XG4gIC8vIE5vdGhpbmdcbn1cblxuLy8gSGVscGVyIHRvIGFsbG93IHN0cmluZ3MgdG8gYmUgZGVjb2RlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJpbmFyeSB1dGY4IGRhdGEuXG5XZWJWVFQuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGRlY29kZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIC0gZXhwZWN0ZWQgc3RyaW5nIGRhdGEuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xuICAgIH1cbiAgfTtcbn07XG5cbldlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlID0gZnVuY3Rpb24od2luZG93LCBjdWV0ZXh0KSB7XG4gIGlmICghd2luZG93IHx8ICFjdWV0ZXh0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhcnNlQ29udGVudCh3aW5kb3csIGN1ZXRleHQpO1xufTtcblxudmFyIEZPTlRfU0laRV9QRVJDRU5UID0gMC4wNTtcbnZhciBGT05UX1NUWUxFID0gXCJzYW5zLXNlcmlmXCI7XG52YXIgQ1VFX0JBQ0tHUk9VTkRfUEFERElORyA9IFwiMS41JVwiO1xuXG4vLyBSdW5zIHRoZSBwcm9jZXNzaW5nIG1vZGVsIG92ZXIgdGhlIGN1ZXMgYW5kIHJlZ2lvbnMgcGFzc2VkIHRvIGl0LlxuLy8gQHBhcmFtIG92ZXJsYXkgQSBibG9jayBsZXZlbCBlbGVtZW50ICh1c3VhbGx5IGEgZGl2KSB0aGF0IHRoZSBjb21wdXRlZCBjdWVzXG4vLyAgICAgICAgICAgICAgICBhbmQgcmVnaW9ucyB3aWxsIGJlIHBsYWNlZCBpbnRvLlxuV2ViVlRULnByb2Nlc3NDdWVzID0gZnVuY3Rpb24od2luZG93LCBjdWVzLCBvdmVybGF5KSB7XG4gIGlmICghd2luZG93IHx8ICFjdWVzIHx8ICFvdmVybGF5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIHByZXZpb3VzIGNoaWxkcmVuLlxuICB3aGlsZSAob3ZlcmxheS5maXJzdENoaWxkKSB7XG4gICAgb3ZlcmxheS5yZW1vdmVDaGlsZChvdmVybGF5LmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgdmFyIHBhZGRlZE92ZXJsYXkgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUucmlnaHQgPSBcIjBcIjtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS50b3AgPSBcIjBcIjtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5ib3R0b20gPSBcIjBcIjtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5tYXJnaW4gPSBDVUVfQkFDS0dST1VORF9QQURESU5HO1xuICBvdmVybGF5LmFwcGVuZENoaWxkKHBhZGRlZE92ZXJsYXkpO1xuXG4gIC8vIERldGVybWluZSBpZiB3ZSBuZWVkIHRvIGNvbXB1dGUgdGhlIGRpc3BsYXkgc3RhdGVzIG9mIHRoZSBjdWVzLiBUaGlzIGNvdWxkXG4gIC8vIGJlIHRoZSBjYXNlIGlmIGEgY3VlJ3Mgc3RhdGUgaGFzIGJlZW4gY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBjb21wdXRhdGlvbiBvclxuICAvLyBpZiBpdCBoYXMgbm90IGJlZW4gY29tcHV0ZWQgeWV0LlxuICBmdW5jdGlvbiBzaG91bGRDb21wdXRlKGN1ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjdWVzW2ldLmhhc0JlZW5SZXNldCB8fCAhY3Vlc1tpXS5kaXNwbGF5U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFdlIGRvbid0IG5lZWQgdG8gcmVjb21wdXRlIHRoZSBjdWVzJyBkaXNwbGF5IHN0YXRlcy4gSnVzdCByZXVzZSB0aGVtLlxuICBpZiAoIXNob3VsZENvbXB1dGUoY3VlcykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhZGRlZE92ZXJsYXkuYXBwZW5kQ2hpbGQoY3Vlc1tpXS5kaXNwbGF5U3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYm94UG9zaXRpb25zID0gW10sXG4gICAgICBjb250YWluZXJCb3ggPSBCb3hQb3NpdGlvbi5nZXRTaW1wbGVCb3hQb3NpdGlvbihwYWRkZWRPdmVybGF5KSxcbiAgICAgIGZvbnRTaXplID0gTWF0aC5yb3VuZChjb250YWluZXJCb3guaGVpZ2h0ICogRk9OVF9TSVpFX1BFUkNFTlQgKiAxMDApIC8gMTAwO1xuICB2YXIgc3R5bGVPcHRpb25zID0ge1xuICAgIGZvbnQ6IGZvbnRTaXplICsgXCJweCBcIiArIEZPTlRfU1RZTEVcbiAgfTtcblxuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0eWxlQm94LCBjdWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1ZSA9IGN1ZXNbaV07XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIGludGlhbCBwb3NpdGlvbiBhbmQgc3R5bGVzIG9mIHRoZSBjdWUgZGl2LlxuICAgICAgc3R5bGVCb3ggPSBuZXcgQ3VlU3R5bGVCb3god2luZG93LCBjdWUsIHN0eWxlT3B0aW9ucyk7XG4gICAgICBwYWRkZWRPdmVybGF5LmFwcGVuZENoaWxkKHN0eWxlQm94LmRpdik7XG5cbiAgICAgIC8vIE1vdmUgdGhlIGN1ZSBkaXYgdG8gaXQncyBjb3JyZWN0IGxpbmUgcG9zaXRpb24uXG4gICAgICBtb3ZlQm94VG9MaW5lUG9zaXRpb24od2luZG93LCBzdHlsZUJveCwgY29udGFpbmVyQm94LCBib3hQb3NpdGlvbnMpO1xuXG4gICAgICAvLyBSZW1lbWJlciB0aGUgY29tcHV0ZWQgZGl2IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byByZWNvbXB1dGUgaXQgbGF0ZXJcbiAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgdG9vLlxuICAgICAgY3VlLmRpc3BsYXlTdGF0ZSA9IHN0eWxlQm94LmRpdjtcblxuICAgICAgYm94UG9zaXRpb25zLnB1c2goQm94UG9zaXRpb24uZ2V0U2ltcGxlQm94UG9zaXRpb24oc3R5bGVCb3gpKTtcbiAgICB9XG4gIH0pKCk7XG59O1xuXG5XZWJWVFQuUGFyc2VyID0gZnVuY3Rpb24od2luZG93LCB2dHRqcywgZGVjb2Rlcikge1xuICBpZiAoIWRlY29kZXIpIHtcbiAgICBkZWNvZGVyID0gdnR0anM7XG4gICAgdnR0anMgPSB7fTtcbiAgfVxuICBpZiAoIXZ0dGpzKSB7XG4gICAgdnR0anMgPSB7fTtcbiAgfVxuXG4gIHRoaXMud2luZG93ID0gd2luZG93O1xuICB0aGlzLnZ0dGpzID0gdnR0anM7XG4gIHRoaXMuc3RhdGUgPSBcIklOSVRJQUxcIjtcbiAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICB0aGlzLmRlY29kZXIgPSBkZWNvZGVyIHx8IG5ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik7XG4gIHRoaXMucmVnaW9uTGlzdCA9IFtdO1xufTtcblxuV2ViVlRULlBhcnNlci5wcm90b3R5cGUgPSB7XG4gIC8vIElmIHRoZSBlcnJvciBpcyBhIFBhcnNpbmdFcnJvciB0aGVuIHJlcG9ydCBpdCB0byB0aGUgY29uc3VtZXIgaWZcbiAgLy8gcG9zc2libGUuIElmIGl0J3Mgbm90IGEgUGFyc2luZ0Vycm9yIHRoZW4gdGhyb3cgaXQgbGlrZSBub3JtYWwuXG4gIHJlcG9ydE9yVGhyb3dFcnJvcjogZnVuY3Rpb24oZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yKSB7XG4gICAgICB0aGlzLm9ucGFyc2luZ2Vycm9yICYmIHRoaXMub25wYXJzaW5nZXJyb3IoZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBkYXRhIHRoZW4gd2Ugd29uJ3QgZGVjb2RlIGl0LCBidXQgd2lsbCBqdXN0IHRyeSB0byBwYXJzZVxuICAgIC8vIHdoYXRldmVyIGlzIGluIGJ1ZmZlciBhbHJlYWR5LiBUaGlzIG1heSBvY2N1ciBpbiBjaXJjdW1zdGFuY2VzLCBmb3JcbiAgICAvLyBleGFtcGxlIHdoZW4gZmx1c2goKSBpcyBjYWxsZWQuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGRhdGEgdGhhdCB3ZSByZWNlaXZlZC5cbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoZGF0YSwge3N0cmVhbTogdHJ1ZX0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3ROZXh0TGluZSgpIHtcbiAgICAgIHZhciBidWZmZXIgPSBzZWxmLmJ1ZmZlcjtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gYnVmZmVyLnN1YnN0cigwLCBwb3MpO1xuICAgICAgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIGVhcmx5IGluIGNhc2Ugd2UgZmFpbCBiZWxvdy5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xccicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXG4nKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgc2VsZi5idWZmZXIgPSBidWZmZXIuc3Vic3RyKHBvcyk7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICAvLyAzLjQgV2ViVlRUIHJlZ2lvbiBhbmQgV2ViVlRUIHJlZ2lvbiBzZXR0aW5ncyBzeW50YXhcbiAgICBmdW5jdGlvbiBwYXJzZVJlZ2lvbihpbnB1dCkge1xuICAgICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG5cbiAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIHNldHRpbmdzLnNldChrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxpbmVzXCI6XG4gICAgICAgICAgc2V0dGluZ3MuaW50ZWdlcihrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlZ2lvbmFuY2hvclwiOlxuICAgICAgICBjYXNlIFwidmlld3BvcnRhbmNob3JcIjpcbiAgICAgICAgICB2YXIgeHkgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgICAgaWYgKHh5Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbWFrZSBzdXJlIGJvdGggeCBhbmQgeSBwYXJzZSwgc28gdXNlIGEgdGVtcG9yYXJ5XG4gICAgICAgICAgLy8gc2V0dGluZ3Mgb2JqZWN0IGhlcmUuXG4gICAgICAgICAgdmFyIGFuY2hvciA9IG5ldyBTZXR0aW5ncygpO1xuICAgICAgICAgIGFuY2hvci5wZXJjZW50KFwieFwiLCB4eVswXSk7XG4gICAgICAgICAgYW5jaG9yLnBlcmNlbnQoXCJ5XCIsIHh5WzFdKTtcbiAgICAgICAgICBpZiAoIWFuY2hvci5oYXMoXCJ4XCIpIHx8ICFhbmNob3IuaGFzKFwieVwiKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldHRpbmdzLnNldChrICsgXCJYXCIsIGFuY2hvci5nZXQoXCJ4XCIpKTtcbiAgICAgICAgICBzZXR0aW5ncy5zZXQoayArIFwiWVwiLCBhbmNob3IuZ2V0KFwieVwiKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzY3JvbGxcIjpcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgW1widXBcIl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LCAvPS8sIC9cXHMvKTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSByZWdpb24sIHVzaW5nIGRlZmF1bHQgdmFsdWVzIGZvciBhbnkgdmFsdWVzIHRoYXQgd2VyZSBub3RcbiAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgIGlmIChzZXR0aW5ncy5oYXMoXCJpZFwiKSkge1xuICAgICAgICB2YXIgcmVnaW9uID0gbmV3IChzZWxmLnZ0dGpzLlZUVFJlZ2lvbiB8fCBzZWxmLndpbmRvdy5WVFRSZWdpb24pKCk7XG4gICAgICAgIHJlZ2lvbi53aWR0aCA9IHNldHRpbmdzLmdldChcIndpZHRoXCIsIDEwMCk7XG4gICAgICAgIHJlZ2lvbi5saW5lcyA9IHNldHRpbmdzLmdldChcImxpbmVzXCIsIDMpO1xuICAgICAgICByZWdpb24ucmVnaW9uQW5jaG9yWCA9IHNldHRpbmdzLmdldChcInJlZ2lvbmFuY2hvclhcIiwgMCk7XG4gICAgICAgIHJlZ2lvbi5yZWdpb25BbmNob3JZID0gc2V0dGluZ3MuZ2V0KFwicmVnaW9uYW5jaG9yWVwiLCAxMDApO1xuICAgICAgICByZWdpb24udmlld3BvcnRBbmNob3JYID0gc2V0dGluZ3MuZ2V0KFwidmlld3BvcnRhbmNob3JYXCIsIDApO1xuICAgICAgICByZWdpb24udmlld3BvcnRBbmNob3JZID0gc2V0dGluZ3MuZ2V0KFwidmlld3BvcnRhbmNob3JZXCIsIDEwMCk7XG4gICAgICAgIHJlZ2lvbi5zY3JvbGwgPSBzZXR0aW5ncy5nZXQoXCJzY3JvbGxcIiwgXCJcIik7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSByZWdpb24uXG4gICAgICAgIHNlbGYub25yZWdpb24gJiYgc2VsZi5vbnJlZ2lvbihyZWdpb24pO1xuICAgICAgICAvLyBSZW1lbWJlciB0aGUgVlRUUmVnaW9uIGZvciBsYXRlciBpbiBjYXNlIHdlIHBhcnNlIGFueSBWVFRDdWVzIHRoYXRcbiAgICAgICAgLy8gcmVmZXJlbmNlIGl0LlxuICAgICAgICBzZWxmLnJlZ2lvbkxpc3QucHVzaCh7XG4gICAgICAgICAgaWQ6IHNldHRpbmdzLmdldChcImlkXCIpLFxuICAgICAgICAgIHJlZ2lvbjogcmVnaW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRyYWZ0LXBhbnRvcy1odHRwLWxpdmUtc3RyZWFtaW5nLTIwXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXBhbnRvcy1odHRwLWxpdmUtc3RyZWFtaW5nLTIwI3NlY3Rpb24tMy41XG4gICAgLy8gMy41IFdlYlZUVFxuICAgIGZ1bmN0aW9uIHBhcnNlVGltZXN0YW1wTWFwKGlucHV0KSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcblxuICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgIHN3aXRjaChrKSB7XG4gICAgICAgIGNhc2UgXCJNUEVHVFwiOlxuICAgICAgICAgIHNldHRpbmdzLmludGVnZXIoayArICdTJywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMT0NBXCI6XG4gICAgICAgICAgc2V0dGluZ3Muc2V0KGsgKyAnTCcsIHBhcnNlVGltZVN0YW1wKHYpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSwgL1teXFxkXTovLCAvLC8pO1xuXG4gICAgICBzZWxmLm9udGltZXN0YW1wbWFwICYmIHNlbGYub250aW1lc3RhbXBtYXAoe1xuICAgICAgICBcIk1QRUdUU1wiOiBzZXR0aW5ncy5nZXQoXCJNUEVHVFNcIiksXG4gICAgICAgIFwiTE9DQUxcIjogc2V0dGluZ3MuZ2V0KFwiTE9DQUxcIilcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIDMuMiBXZWJWVFQgbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQubWF0Y2goL1gtVElNRVNUQU1QLU1BUC8pKSB7XG4gICAgICAgIC8vIFRoaXMgbGluZSBjb250YWlucyBITFMgWC1USU1FU1RBTVAtTUFQIG1ldGFkYXRhXG4gICAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgIHN3aXRjaChrKSB7XG4gICAgICAgICAgY2FzZSBcIlgtVElNRVNUQU1QLU1BUFwiOlxuICAgICAgICAgICAgcGFyc2VUaW1lc3RhbXBNYXAodik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIC89Lyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgICAgY2FzZSBcIlJlZ2lvblwiOlxuICAgICAgICAgICAgLy8gMy4zIFdlYlZUVCByZWdpb24gbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgICAgICAgICAgcGFyc2VSZWdpb24odik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIC86Lyk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyA1LjEgV2ViVlRUIGZpbGUgcGFyc2luZy5cbiAgICB0cnkge1xuICAgICAgdmFyIGxpbmU7XG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gXCJJTklUSUFMXCIpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuXG4gICAgICAgIHZhciBtID0gbGluZS5tYXRjaCgvXldFQlZUVChbIFxcdF0uKik/JC8pO1xuICAgICAgICBpZiAoIW0gfHwgIW1bMF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvci5FcnJvcnMuQmFkU2lnbmF0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc3RhdGUgPSBcIkhFQURFUlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChzZWxmLmJ1ZmZlcikge1xuICAgICAgICAvLyBXZSBjYW4ndCBwYXJzZSBhIGxpbmUgdW50aWwgd2UgaGF2ZSB0aGUgZnVsbCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbHJlYWR5Q29sbGVjdGVkTGluZSkge1xuICAgICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChzZWxmLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgXCJIRUFERVJcIjpcbiAgICAgICAgICAvLyAxMy0xOCAtIEFsbG93IGEgaGVhZGVyIChtZXRhZGF0YSkgdW5kZXIgdGhlIFdFQlZUVCBsaW5lLlxuICAgICAgICAgIGlmICgvOi8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghbGluZSkge1xuICAgICAgICAgICAgLy8gQW4gZW1wdHkgbGluZSB0ZXJtaW5hdGVzIHRoZSBoZWFkZXIgYW5kIHN0YXJ0cyB0aGUgYm9keSAoY3VlcykuXG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJJRFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSBcIk5PVEVcIjpcbiAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJJRFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSBcIklEXCI6XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICBpZiAoL15OT1RFKCR8WyBcXHRdKS8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiTk9URVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIDE5LTI5IC0gQWxsb3cgYW55IG51bWJlciBvZiBsaW5lIHRlcm1pbmF0b3JzLCB0aGVuIGluaXRpYWxpemUgbmV3IGN1ZSB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5jdWUgPSBuZXcgKHNlbGYudnR0anMuVlRUQ3VlIHx8IHNlbGYud2luZG93LlZUVEN1ZSkoMCwgMCwgXCJcIik7XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiQ1VFXCI7XG4gICAgICAgICAgLy8gMzAtMzkgLSBDaGVjayBpZiBzZWxmIGxpbmUgY29udGFpbnMgYW4gb3B0aW9uYWwgaWRlbnRpZmllciBvciB0aW1pbmcgZGF0YS5cbiAgICAgICAgICBpZiAobGluZS5pbmRleE9mKFwiLS0+XCIpID09PSAtMSkge1xuICAgICAgICAgICAgc2VsZi5jdWUuaWQgPSBsaW5lO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFByb2Nlc3MgbGluZSBhcyBzdGFydCBvZiBhIGN1ZS5cbiAgICAgICAgICAvKmZhbGxzIHRocm91Z2gqL1xuICAgICAgICBjYXNlIFwiQ1VFXCI6XG4gICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VDdWUobGluZSwgc2VsZi5jdWUsIHNlbGYucmVnaW9uTGlzdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgc2VsZi5yZXBvcnRPclRocm93RXJyb3IoZSk7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJCQURDVUVcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLnN0YXRlID0gXCJDVUVURVhUXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgXCJDVUVURVhUXCI6XG4gICAgICAgICAgdmFyIGhhc1N1YnN0cmluZyA9IGxpbmUuaW5kZXhPZihcIi0tPlwiKSAhPT0gLTE7XG4gICAgICAgICAgLy8gMzQgLSBJZiB3ZSBoYXZlIGFuIGVtcHR5IGxpbmUgdGhlbiByZXBvcnQgdGhlIGN1ZS5cbiAgICAgICAgICAvLyAzNSAtIElmIHdlIGhhdmUgdGhlIHNwZWNpYWwgc3Vic3RyaW5nICctLT4nIHRoZW4gcmVwb3J0IHRoZSBjdWUsXG4gICAgICAgICAgLy8gYnV0IGRvIG5vdCBjb2xsZWN0IHRoZSBsaW5lIGFzIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgY3VycmVudFxuICAgICAgICAgIC8vIG9uZSBhcyBhIG5ldyBjdWUuXG4gICAgICAgICAgaWYgKCFsaW5lIHx8IGhhc1N1YnN0cmluZyAmJiAoYWxyZWFkeUNvbGxlY3RlZExpbmUgPSB0cnVlKSkge1xuICAgICAgICAgICAgLy8gV2UgYXJlIGRvbmUgcGFyc2luZyBzZWxmIGN1ZS5cbiAgICAgICAgICAgIHNlbGYub25jdWUgJiYgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XG4gICAgICAgICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJJRFwiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWxmLmN1ZS50ZXh0KSB7XG4gICAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuY3VlLnRleHQgKz0gbGluZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSBcIkJBRENVRVwiOiAvLyBCQURDVUVcbiAgICAgICAgICAvLyA1NC02MiAtIENvbGxlY3QgYW5kIGRpc2NhcmQgdGhlIHJlbWFpbmluZyBjdWUuXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJJRFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHNlbGYucmVwb3J0T3JUaHJvd0Vycm9yKGUpO1xuXG4gICAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IHBhcnNpbmcgYSBjdWUsIHJlcG9ydCB3aGF0IHdlIGhhdmUuXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gXCJDVUVURVhUXCIgJiYgc2VsZi5jdWUgJiYgc2VsZi5vbmN1ZSkge1xuICAgICAgICBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgIC8vIEVudGVyIEJBRFdFQlZUVCBzdGF0ZSBpZiBoZWFkZXIgd2FzIG5vdCBwYXJzZWQgY29ycmVjdGx5IG90aGVyd2lzZVxuICAgICAgLy8gYW5vdGhlciBleGNlcHRpb24gb2NjdXJyZWQgc28gZW50ZXIgQkFEQ1VFIHN0YXRlLlxuICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuc3RhdGUgPT09IFwiSU5JVElBTFwiID8gXCJCQURXRUJWVFRcIiA6IFwiQkFEQ1VFXCI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBmbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgLy8gRmluaXNoIGRlY29kaW5nIHRoZSBzdHJlYW0uXG4gICAgICBzZWxmLmJ1ZmZlciArPSBzZWxmLmRlY29kZXIuZGVjb2RlKCk7XG4gICAgICAvLyBTeW50aGVzaXplIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgY3VlIG9yIHJlZ2lvbi5cbiAgICAgIGlmIChzZWxmLmN1ZSB8fCBzZWxmLnN0YXRlID09PSBcIkhFQURFUlwiKSB7XG4gICAgICAgIHNlbGYuYnVmZmVyICs9IFwiXFxuXFxuXCI7XG4gICAgICAgIHNlbGYucGFyc2UoKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlJ3ZlIGZsdXNoZWQsIHBhcnNlZCwgYW5kIHdlJ3JlIHN0aWxsIG9uIHRoZSBJTklUSUFMIHN0YXRlIHRoZW5cbiAgICAgIC8vIHRoYXQgbWVhbnMgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggb2YgdGhlIHN0cmVhbSB0byBwYXJzZSB0aGUgZmlyc3RcbiAgICAgIC8vIGxpbmUuXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gXCJJTklUSUFMXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3IuRXJyb3JzLkJhZFNpZ25hdHVyZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBzZWxmLnJlcG9ydE9yVGhyb3dFcnJvcihlKTtcbiAgICB9XG4gICAgc2VsZi5vbmZsdXNoICYmIHNlbGYub25mbHVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlZUVDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIGF1dG9LZXl3b3JkID0gXCJhdXRvXCI7XG52YXIgZGlyZWN0aW9uU2V0dGluZyA9IHtcbiAgXCJcIjogdHJ1ZSxcbiAgXCJsclwiOiB0cnVlLFxuICBcInJsXCI6IHRydWVcbn07XG52YXIgYWxpZ25TZXR0aW5nID0ge1xuICBcInN0YXJ0XCI6IHRydWUsXG4gIFwibWlkZGxlXCI6IHRydWUsXG4gIFwiZW5kXCI6IHRydWUsXG4gIFwibGVmdFwiOiB0cnVlLFxuICBcInJpZ2h0XCI6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGRpciA9IGRpcmVjdGlvblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiBkaXIgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRBbGlnblNldHRpbmcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgYWxpZ24gPSBhbGlnblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiBhbGlnbiA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuICB2YXIgaSA9IDE7XG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvYmogPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIgcCBpbiBjb2JqKSB7XG4gICAgICBvYmpbcF0gPSBjb2JqW3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgdmFyIGN1ZSA9IHRoaXM7XG4gIHZhciBpc0lFOCA9ICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIGJhc2VPYmogPSB7fTtcblxuICBpZiAoaXNJRTgpIHtcbiAgICBjdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgfSBlbHNlIHtcbiAgICBiYXNlT2JqLmVudW1lcmFibGUgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoaW0gaW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGluXG4gICAqIHRoZSBzcGVjLlxuICAgKi9cblxuICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxuICAvLyB0byByZWNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGUuIFRoaXMgbGV0cyB1cyBjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlXG4gIC8vIGxhemlseS5cbiAgY3VlLmhhc0JlZW5SZXNldCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBWVFRDdWUgYW5kIFRleHRUcmFja0N1ZSBwcm9wZXJ0aWVzXG4gICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxuICAgKi9cblxuICB2YXIgX2lkID0gXCJcIjtcbiAgdmFyIF9wYXVzZU9uRXhpdCA9IGZhbHNlO1xuICB2YXIgX3N0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgdmFyIF9lbmRUaW1lID0gZW5kVGltZTtcbiAgdmFyIF90ZXh0ID0gdGV4dDtcbiAgdmFyIF9yZWdpb24gPSBudWxsO1xuICB2YXIgX3ZlcnRpY2FsID0gXCJcIjtcbiAgdmFyIF9zbmFwVG9MaW5lcyA9IHRydWU7XG4gIHZhciBfbGluZSA9IFwiYXV0b1wiO1xuICB2YXIgX2xpbmVBbGlnbiA9IFwic3RhcnRcIjtcbiAgdmFyIF9wb3NpdGlvbiA9IDUwO1xuICB2YXIgX3Bvc2l0aW9uQWxpZ24gPSBcIm1pZGRsZVwiO1xuICB2YXIgX3NpemUgPSA1MDtcbiAgdmFyIF9hbGlnbiA9IFwibWlkZGxlXCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcImlkXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9pZCA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInBhdXNlT25FeGl0XCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9wYXVzZU9uRXhpdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9wYXVzZU9uRXhpdCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJzdGFydFRpbWVcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N0YXJ0VGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3RhcnQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3N0YXJ0VGltZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJlbmRUaW1lXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9lbmRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX2VuZFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwidGV4dFwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdGV4dDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF90ZXh0ID0gXCJcIiArIHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJyZWdpb25cIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2lvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9yZWdpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwidmVydGljYWxcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF92ZXJ0aWNhbCA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInNuYXBUb0xpbmVzXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9zbmFwVG9MaW5lcyA9ICEhdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcImxpbmVcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2xpbmU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiICYmIHZhbHVlICE9PSBhdXRvS2V5d29yZCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgbnVtYmVyIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9saW5lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcImxpbmVBbGlnblwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbGluZUFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZUFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwicG9zaXRpb25cIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJwb3NpdGlvbkFsaWduXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbkFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfcG9zaXRpb25BbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInNpemVcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJhbGlnblwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfYWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9hbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgLyoqXG4gICAqIE90aGVyIDx0cmFjaz4gc3BlYyBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICovXG5cbiAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLXZpZGVvLWVsZW1lbnQuaHRtbCN0ZXh0LXRyYWNrLWN1ZS1kaXNwbGF5LXN0YXRlXG4gIGN1ZS5kaXNwbGF5U3RhdGUgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzSUU4KSB7XG4gICAgcmV0dXJuIGN1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFZUVEN1ZSBtZXRob2RzXG4gKi9cblxuVlRUQ3VlLnByb3RvdHlwZS5nZXRDdWVBc0hUTUwgPSBmdW5jdGlvbigpIHtcbiAgLy8gQXNzdW1lIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlIGlzIG9uIHRoZSBnbG9iYWwuXG4gIHJldHVybiBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSh3aW5kb3csIHRoaXMudGV4dCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZUVEN1ZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIHNjcm9sbFNldHRpbmcgPSB7XG4gIFwiXCI6IHRydWUsXG4gIFwidXBcIjogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZmluZFNjcm9sbFNldHRpbmcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc2Nyb2xsID0gc2Nyb2xsU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgcmV0dXJuIHNjcm9sbCA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDEwMCk7XG59XG5cbi8vIFZUVFJlZ2lvbiBzaGltIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0cmVnaW9uLWludGVyZmFjZVxuZnVuY3Rpb24gVlRUUmVnaW9uKCkge1xuICB2YXIgX3dpZHRoID0gMTAwO1xuICB2YXIgX2xpbmVzID0gMztcbiAgdmFyIF9yZWdpb25BbmNob3JYID0gMDtcbiAgdmFyIF9yZWdpb25BbmNob3JZID0gMTAwO1xuICB2YXIgX3ZpZXdwb3J0QW5jaG9yWCA9IDA7XG4gIHZhciBfdmlld3BvcnRBbmNob3JZID0gMTAwO1xuICB2YXIgX3Njcm9sbCA9IFwiXCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIFwid2lkdGhcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfd2lkdGg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzVmFsaWRQZXJjZW50VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3dpZHRoID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcImxpbmVzXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2xpbmVzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJMaW5lcyBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmVzID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlZ2lvbkFuY2hvcllcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uQW5jaG9yWTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWdpb25BbmNob3JYIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9yZWdpb25BbmNob3JZID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlZ2lvbkFuY2hvclhcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uQW5jaG9yWDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZ2lvbkFuY2hvclkgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3JlZ2lvbkFuY2hvclggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwidmlld3BvcnRBbmNob3JZXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3ZpZXdwb3J0QW5jaG9yWTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWaWV3cG9ydEFuY2hvclkgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3ZpZXdwb3J0QW5jaG9yWSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJ2aWV3cG9ydEFuY2hvclhcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdmlld3BvcnRBbmNob3JYO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZpZXdwb3J0QW5jaG9yWCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfdmlld3BvcnRBbmNob3JYID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInNjcm9sbFwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zY3JvbGw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRTY3JvbGxTZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgLy8gSGF2ZSB0byBjaGVjayBmb3IgZmFsc2UgYXMgYW4gZW1wdHkgc3RyaW5nIGlzIGEgbGVnYWwgdmFsdWUuXG4gICAgICAgIGlmIChzZXR0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3Njcm9sbCA9IHNldHRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWVFRSZWdpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB3aW5kb3cgPSByZXF1aXJlKFwiZ2xvYmFsL3dpbmRvd1wiKVxudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKFwiaXMtZnVuY3Rpb25cIilcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKFwicGFyc2UtaGVhZGVyc1wiKVxudmFyIHh0ZW5kID0gcmVxdWlyZShcInh0ZW5kXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlWEhSXG5jcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgbm9vcFxuY3JlYXRlWEhSLlhEb21haW5SZXF1ZXN0ID0gXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiAobmV3IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCgpKSA/IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCA6IHdpbmRvdy5YRG9tYWluUmVxdWVzdFxuXG5mb3JFYWNoQXJyYXkoW1wiZ2V0XCIsIFwicHV0XCIsIFwicG9zdFwiLCBcInBhdGNoXCIsIFwiaGVhZFwiLCBcImRlbGV0ZVwiXSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgY3JlYXRlWEhSW21ldGhvZCA9PT0gXCJkZWxldGVcIiA/IFwiZGVsXCIgOiBtZXRob2RdID0gZnVuY3Rpb24odXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBvcHRpb25zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgICAgIHJldHVybiBfY3JlYXRlWEhSKG9wdGlvbnMpXG4gICAgfVxufSlcblxuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0pXG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0VtcHR5KG9iail7XG4gICAgZm9yKHZhciBpIGluIG9iail7XG4gICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXJhbXMgPSB1cmlcblxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcGFyYW1zID0ge3VyaTp1cml9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMgPSB4dGVuZChvcHRpb25zLCB7dXJpOiB1cml9KVxuICAgIH1cblxuICAgIHBhcmFtcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgcmV0dXJuIHBhcmFtc1xufVxuXG5mdW5jdGlvbiBjcmVhdGVYSFIodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIG9wdGlvbnMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgcmV0dXJuIF9jcmVhdGVYSFIob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVhIUihvcHRpb25zKSB7XG4gICAgaWYodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxsYmFjayBhcmd1bWVudCBtaXNzaW5nXCIpXG4gICAgfVxuXG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2JPbmNlKGVyciwgcmVzcG9uc2UsIGJvZHkpe1xuICAgICAgICBpZighY2FsbGVkKXtcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWVcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soZXJyLCByZXNwb25zZSwgYm9keSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChsb2FkRnVuYywgMClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgICAgIC8vIENocm9tZSB3aXRoIHJlcXVlc3RUeXBlPWJsb2IgdGhyb3dzIGVycm9ycyBhcnJvdW5kIHdoZW4gZXZlbiB0ZXN0aW5nIGFjY2VzcyB0byByZXNwb25zZVRleHRcbiAgICAgICAgdmFyIGJvZHkgPSB1bmRlZmluZWRcblxuICAgICAgICBpZiAoeGhyLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlVGV4dCB8fCBnZXRYbWwoeGhyKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSnNvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib2R5XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3JGdW5jKGV2dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKVxuICAgICAgICBpZighKGV2dCBpbnN0YW5jZW9mIEVycm9yKSl7XG4gICAgICAgICAgICBldnQgPSBuZXcgRXJyb3IoXCJcIiArIChldnQgfHwgXCJVbmtub3duIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIpIClcbiAgICAgICAgfVxuICAgICAgICBldnQuc3RhdHVzQ29kZSA9IDBcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGV2dCwgZmFpbHVyZVJlc3BvbnNlKVxuICAgIH1cblxuICAgIC8vIHdpbGwgbG9hZCB0aGUgZGF0YSAmIHByb2Nlc3MgdGhlIHJlc3BvbnNlIGluIGEgc3BlY2lhbCByZXNwb25zZSBvYmplY3RcbiAgICBmdW5jdGlvbiBsb2FkRnVuYygpIHtcbiAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVyblxuICAgICAgICB2YXIgc3RhdHVzXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpXG4gICAgICAgIGlmKG9wdGlvbnMudXNlWERSICYmIHhoci5zdGF0dXM9PT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vSUU4IENPUlMgR0VUIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZG9lc24ndCBoYXZlIGEgc3RhdHVzIGZpZWxkLCBidXQgYm9keSBpcyBmaW5lXG4gICAgICAgICAgICBzdGF0dXMgPSAyMDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICh4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cylcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzcG9uc2UgPSBmYWlsdXJlUmVzcG9uc2VcbiAgICAgICAgdmFyIGVyciA9IG51bGxcblxuICAgICAgICBpZiAoc3RhdHVzICE9PSAwKXtcbiAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGdldEJvZHkoKSxcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgdXJsOiB1cmksXG4gICAgICAgICAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKXsgLy9yZW1lbWJlciB4aHIgY2FuIGluIGZhY3QgYmUgWERSIGZvciBDT1JTIGluIElFXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXCJJbnRlcm5hbCBYTUxIdHRwUmVxdWVzdCBFcnJvclwiKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCByZXNwb25zZS5ib2R5KVxuICAgIH1cblxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociB8fCBudWxsXG5cbiAgICBpZiAoIXhocikge1xuICAgICAgICBpZiAob3B0aW9ucy5jb3JzIHx8IG9wdGlvbnMudXNlWERSKSB7XG4gICAgICAgICAgICB4aHIgPSBuZXcgY3JlYXRlWEhSLlhEb21haW5SZXF1ZXN0KClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB4aHIgPSBuZXcgY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlcbiAgICB2YXIgYWJvcnRlZFxuICAgIHZhciB1cmkgPSB4aHIudXJsID0gb3B0aW9ucy51cmkgfHwgb3B0aW9ucy51cmxcbiAgICB2YXIgbWV0aG9kID0geGhyLm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCJcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBvcHRpb25zLmRhdGFcbiAgICB2YXIgaGVhZGVycyA9IHhoci5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9XG4gICAgdmFyIHN5bmMgPSAhIW9wdGlvbnMuc3luY1xuICAgIHZhciBpc0pzb24gPSBmYWxzZVxuICAgIHZhciB0aW1lb3V0VGltZXJcbiAgICB2YXIgZmFpbHVyZVJlc3BvbnNlID0ge1xuICAgICAgICBib2R5OiB1bmRlZmluZWQsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICBzdGF0dXNDb2RlOiAwLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgdXJsOiB1cmksXG4gICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgIH1cblxuICAgIGlmIChcImpzb25cIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuanNvbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgaXNKc29uID0gdHJ1ZVxuICAgICAgICBoZWFkZXJzW1wiYWNjZXB0XCJdIHx8IGhlYWRlcnNbXCJBY2NlcHRcIl0gfHwgKGhlYWRlcnNbXCJBY2NlcHRcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIikgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gfHwgKGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIikgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24gPT09IHRydWUgPyBib2R5IDogb3B0aW9ucy5qc29uKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHJlYWR5c3RhdGVjaGFuZ2VcbiAgICB4aHIub25sb2FkID0gbG9hZEZ1bmNcbiAgICB4aHIub25lcnJvciA9IGVycm9yRnVuY1xuICAgIC8vIElFOSBtdXN0IGhhdmUgb25wcm9ncmVzcyBiZSBzZXQgdG8gYSB1bmlxdWUgZnVuY3Rpb24uXG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElFIG11c3QgZGllXG4gICAgfVxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHhoci5vbnRpbWVvdXQgPSBlcnJvckZ1bmNcbiAgICB4aHIub3BlbihtZXRob2QsIHVyaSwgIXN5bmMsIG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQpXG4gICAgLy9oYXMgdG8gYmUgYWZ0ZXIgb3BlblxuICAgIGlmKCFzeW5jKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdGlvbnMud2l0aENyZWRlbnRpYWxzXG4gICAgfVxuICAgIC8vIENhbm5vdCBzZXQgdGltZW91dCB3aXRoIHN5bmMgcmVxdWVzdFxuICAgIC8vIG5vdCBzZXR0aW5nIHRpbWVvdXQgb24gdGhlIHhociBvYmplY3QsIGJlY2F1c2Ugb2Ygb2xkIHdlYmtpdHMgZXRjLiBub3QgaGFuZGxpbmcgdGhhdCBjb3JyZWN0bHlcbiAgICAvLyBib3RoIG5wbSdzIHJlcXVlc3QgYW5kIGpxdWVyeSAxLnggdXNlIHRoaXMga2luZCBvZiB0aW1lb3V0LCBzbyB0aGlzIGlzIGJlaW5nIGNvbnNpc3RlbnRcbiAgICBpZiAoIXN5bmMgJiYgb3B0aW9ucy50aW1lb3V0ID4gMCApIHtcbiAgICAgICAgdGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVyblxuICAgICAgICAgICAgYWJvcnRlZCA9IHRydWUvL0lFOSBtYXkgc3RpbGwgY2FsbCByZWFkeXN0YXRlY2hhbmdlXG4gICAgICAgICAgICB4aHIuYWJvcnQoXCJ0aW1lb3V0XCIpXG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcihcIlhNTEh0dHBSZXF1ZXN0IHRpbWVvdXRcIilcbiAgICAgICAgICAgIGUuY29kZSA9IFwiRVRJTUVET1VUXCJcbiAgICAgICAgICAgIGVycm9yRnVuYyhlKVxuICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQgKVxuICAgIH1cblxuICAgIGlmICh4aHIuc2V0UmVxdWVzdEhlYWRlcikge1xuICAgICAgICBmb3Ioa2V5IGluIGhlYWRlcnMpe1xuICAgICAgICAgICAgaWYoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWFkZXJzICYmICFpc0VtcHR5KG9wdGlvbnMuaGVhZGVycykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIGFuIFhEb21haW5SZXF1ZXN0IG9iamVjdFwiKVxuICAgIH1cblxuICAgIGlmIChcInJlc3BvbnNlVHlwZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlXG4gICAgfVxuXG4gICAgaWYgKFwiYmVmb3JlU2VuZFwiIGluIG9wdGlvbnMgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuYmVmb3JlU2VuZCA9PT0gXCJmdW5jdGlvblwiXG4gICAgKSB7XG4gICAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCh4aHIpXG4gICAgfVxuXG4gICAgLy8gTWljcm9zb2Z0IEVkZ2UgYnJvd3NlciBzZW5kcyBcInVuZGVmaW5lZFwiIHdoZW4gc2VuZCBpcyBjYWxsZWQgd2l0aCB1bmRlZmluZWQgdmFsdWUuXG4gICAgLy8gWE1MSHR0cFJlcXVlc3Qgc3BlYyBzYXlzIHRvIHBhc3MgbnVsbCBhcyBib2R5IHRvIGluZGljYXRlIG5vIGJvZHlcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25hdWd0dXIveGhyL2lzc3Vlcy8xMDAuXG4gICAgeGhyLnNlbmQoYm9keSB8fCBudWxsKVxuXG4gICAgcmV0dXJuIHhoclxuXG5cbn1cblxuZnVuY3Rpb24gZ2V0WG1sKHhocikge1xuICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVhNTFxuICAgIH1cbiAgICB2YXIgZmlyZWZveEJ1Z1Rha2VuRWZmZWN0ID0geGhyLnJlc3BvbnNlWE1MICYmIHhoci5yZXNwb25zZVhNTC5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT09IFwicGFyc2VyZXJyb3JcIlxuICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcIlwiICYmICFmaXJlZm94QnVnVGFrZW5FZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVhNTFxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbicpO1xuXG52YXIgX2Fzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NpZ24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG53aW5kb3cudmlkZW9qcyA9IHJlcXVpcmUoJ3ZpZGVvLmpzJyk7XG52aWRlb2pzID0gdmlkZW9qcy5kZWZhdWx0IHx8IHZpZGVvanM7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICd2aWRlby1wbGF5ZXInLFxuICBwcm9wczoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBzdGFydDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGxheXNpbmxpbmU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3VzdG9tRXZlbnROYW1lOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICdzdGF0ZWNoYW5nZWQnO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICBpZiAoIXRoaXMucGxheWVyKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucGxheWVyKSB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuXG4gICAgICAvLyBpbml0XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLnBsYXllciA9IG51bGw7XG5cbiAgICAgIC8vIHZpZGVvanMgb3B0aW9uc1xuICAgICAgdmFyIHZpZGVvT3B0aW9ucyA9ICgwLCBfYXNzaWduMi5kZWZhdWx0KSh7XG4gICAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgICAgY29udHJvbHM6IHRydWUsXG4gICAgICAgIHByZWxvYWQ6ICdhdXRvJyxcbiAgICAgICAgZmx1aWQ6IGZhbHNlLFxuICAgICAgICBtdXRlZDogZmFsc2UsXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgIGhlaWdodDogJzM2MCcsXG4gICAgICAgIGxhbmd1YWdlOiAnZW4nLFxuICAgICAgICBjb250cm9sQmFyOiB7XG4gICAgICAgICAgcmVtYWluaW5nVGltZURpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgIHBsYXlUb2dnbGU6IHt9LFxuICAgICAgICAgIHByb2dyZXNzQ29udHJvbDoge30sXG4gICAgICAgICAgZnVsbHNjcmVlblRvZ2dsZToge30sXG4gICAgICAgICAgdm9sdW1lTWVudUJ1dHRvbjoge1xuICAgICAgICAgICAgaW5saW5lOiBmYWxzZSxcbiAgICAgICAgICAgIHZlcnRpY2FsOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0ZWNoT3JkZXI6IFsnaHRtbDUnXSxcbiAgICAgICAgcGx1Z2luczoge31cbiAgICAgIH0sIHRoaXMub3B0aW9ucyk7XG5cbiAgICAgIC8vIGNoZWNrIHNvdXJjZXNcbiAgICAgIC8qXG4gICAgICBpZiAoIXZpZGVvT3B0aW9ucy5zb3VyY2VzIHx8ICF2aWRlb09wdGlvbnMuc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdNaXNzaW5nIHJlcXVpcmVkIG9wdGlvbjogXCJzb3VyY2VzXCIuJylcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAqL1xuXG4gICAgICAvLyBpb3MgZnVsbHNjcmVlblxuICAgICAgdmFyIHBsYXlzaW5saW5lID0gdGhpcy5wbGF5c2lubGluZTtcbiAgICAgIGlmIChwbGF5c2lubGluZSkge1xuICAgICAgICB0aGlzLiRlbC5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJywgcGxheXNpbmxpbmUpO1xuICAgICAgICB0aGlzLiRlbC5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoJ3dlYmtpdC1wbGF5c2lubGluZScsIHBsYXlzaW5saW5lKTtcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCBldmVudFxuICAgICAgdmFyIGVtaXRQbGF5ZXJTdGF0ZSA9IGZ1bmN0aW9uIGVtaXRQbGF5ZXJTdGF0ZShldmVudCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgc2VsZi4kZW1pdChldmVudCwgc2VsZi5wbGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSB7fTtcbiAgICAgICAgICB2YWx1ZXNbZXZlbnRdID0gdmFsdWU7XG4gICAgICAgICAgc2VsZi4kZW1pdChzZWxmLmN1c3RvbUV2ZW50TmFtZSwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gdmlkZW9PcHRpb25zXG4gICAgICAvLyBjb25zb2xlLmxvZyh2aWRlb09wdGlvbnMpXG5cbiAgICAgIC8vIGF2b2lkIGVycm9yIFwiVklERU9KUzogRVJST1I6IFVuYWJsZSB0byBmaW5kIHBsdWdpbjogX19vYl9fXCJcbiAgICAgIGlmICh2aWRlb09wdGlvbnMucGx1Z2lucykge1xuICAgICAgICBkZWxldGUgdmlkZW9PcHRpb25zLnBsdWdpbnMuX19vYl9fO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBsYXllciA9IHZpZGVvanModGhpcy4kZWwuY2hpbGRyZW5bMF0sIHZpZGVvT3B0aW9ucywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8vIHBsYXllciByZWFkaWVkXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHNlbGYuJGVtaXQoJ3JlYWR5Jywgc2VsZi5wbGF5ZXIpO1xuXG4gICAgICAgIC8vIGV2ZW50c1xuICAgICAgICB2YXIgZXZlbnRzID0gWydsb2FkZWRkYXRhJywgJ2NhbnBsYXknLCAnY2FucGxheXRocm91Z2gnLCAncGxheScsICdwYXVzZScsICd3YWl0aW5nJywgJ3BsYXlpbmcnLCAnZW5kZWQnLCAnZXJyb3InXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5vbihldmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBlbWl0UGxheWVyU3RhdGUoZXZlbnQsIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkoZXZlbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub24oJ3RpbWV1cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZW1pdFBsYXllclN0YXRlKCd0aW1ldXBkYXRlJywgdGhpcy5jdXJyZW50VGltZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICBpZiAodGhpcy5wbGF5ZXIgJiYgdmlkZW9qcykge1xuICAgICAgICBpZiAodGhpcy5wbGF5ZXIudGVjaE5hbWVfICE9PSAnRmxhc2gnKSB7XG4gICAgICAgICAgdGhpcy5wbGF5ZXIucGF1c2UgJiYgdGhpcy5wbGF5ZXIucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2aWRlb2pzKHRoaXMuJGVsLmNoaWxkcmVuWzBdKS5kaXNwb3NlKCk7XG4gICAgICAgIGlmICghdGhpcy4kZWwuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICB2aWRlby5jbGFzc05hbWUgPSAndmlkZW8tanMnO1xuICAgICAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKHZpZGVvKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBsYXllciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIGRlZXA6IHRydWUsXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKG9wdGlvbnMsIG9sZE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc291cmNlcyAmJiBvcHRpb25zLnNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIjxkaXYgY2xhc3M9dmlkZW8tcGxheWVyPjx2aWRlbyBjbGFzcz12aWRlby1qcz48L3ZpZGVvPjwvZGl2PlwiXG4iXX0=
